function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react$1 = { exports: {} };
var react_production_min = {};
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t2 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
  function A(a) {
    if (null === a || "object" !== typeof a) return null;
    a = z && a[z] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var B = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, D = {};
  function E(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  E.prototype.isReactComponent = {};
  E.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b, "setState");
  };
  E.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E.prototype;
  function G(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  var H = G.prototype = new F();
  H.constructor = G;
  C(H, E.prototype);
  H.isPureReactComponent = true;
  var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
  function M(a, b, e) {
    var d, c = {}, k = null, h2 = null;
    if (null != b) for (d in void 0 !== b.ref && (h2 = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
    var g = arguments.length - 2;
    if (1 === g) c.children = e;
    else if (1 < g) {
      for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
      c.children = f;
    }
    if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
    return { $$typeof: l, type: a, key: k, ref: h2, props: c, _owner: K.current };
  }
  function N(a, b) {
    return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
  }
  function O(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l;
  }
  function escape(a) {
    var b = { "=": "=0", ":": "=2" };
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b[a2];
    });
  }
  var P = /\/+/g;
  function Q(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
  }
  function R(a, b, e, d, c) {
    var k = typeof a;
    if ("undefined" === k || "boolean" === k) a = null;
    var h2 = false;
    if (null === a) h2 = true;
    else switch (k) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l:
          case n:
            h2 = true;
        }
    }
    if (h2) return h2 = a, c = c(h2), a = "" === d ? "." + Q(h2, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
      return a2;
    })) : null != c && (O(c) && (c = N(c, e + (!c.key || h2 && h2.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
    h2 = 0;
    d = "" === d ? "." : d + ":";
    if (I(a)) for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = d + Q(k, g);
      h2 += R(k, b, e, f, c);
    }
    else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h2 += R(k, b, e, f, c);
    else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return h2;
  }
  function S(a, b, e) {
    if (null == a) return a;
    var d = [], c = 0;
    R(a, d, "", "", function(a2) {
      return b.call(e, a2, c++);
    });
    return d;
  }
  function T(a) {
    if (-1 === a._status) {
      var b = a._result;
      b = b();
      b.then(function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
      }, function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
      });
      -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
  }
  var U = { current: null }, V2 = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V2, ReactCurrentOwner: K };
  function X() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S, forEach: function(a, b, e) {
    S(a, function() {
      b.apply(this, arguments);
    }, e);
  }, count: function(a) {
    var b = 0;
    S(a, function() {
      b++;
    });
    return b;
  }, toArray: function(a) {
    return S(a, function(a2) {
      return a2;
    }) || [];
  }, only: function(a) {
    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  } };
  react_production_min.Component = E;
  react_production_min.Fragment = p;
  react_production_min.Profiler = r;
  react_production_min.PureComponent = G;
  react_production_min.StrictMode = q;
  react_production_min.Suspense = w;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.act = X;
  react_production_min.cloneElement = function(a, b, e) {
    if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var d = C({}, a.props), c = a.key, k = a.ref, h2 = a._owner;
    if (null != b) {
      void 0 !== b.ref && (k = b.ref, h2 = K.current);
      void 0 !== b.key && (c = "" + b.key);
      if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
      for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
    var f = arguments.length - 2;
    if (1 === f) d.children = e;
    else if (1 < f) {
      g = Array(f);
      for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
      d.children = g;
    }
    return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h2 };
  };
  react_production_min.createContext = function(a) {
    a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a.Provider = { $$typeof: t2, _context: a };
    return a.Consumer = a;
  };
  react_production_min.createElement = M;
  react_production_min.createFactory = function(a) {
    var b = M.bind(null, a);
    b.type = a;
    return b;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a) {
    return { $$typeof: v, render: a };
  };
  react_production_min.isValidElement = O;
  react_production_min.lazy = function(a) {
    return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
  };
  react_production_min.memo = function(a, b) {
    return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
  };
  react_production_min.startTransition = function(a) {
    var b = V2.transition;
    V2.transition = {};
    try {
      a();
    } finally {
      V2.transition = b;
    }
  };
  react_production_min.unstable_act = X;
  react_production_min.useCallback = function(a, b) {
    return U.current.useCallback(a, b);
  };
  react_production_min.useContext = function(a) {
    return U.current.useContext(a);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a) {
    return U.current.useDeferredValue(a);
  };
  react_production_min.useEffect = function(a, b) {
    return U.current.useEffect(a, b);
  };
  react_production_min.useId = function() {
    return U.current.useId();
  };
  react_production_min.useImperativeHandle = function(a, b, e) {
    return U.current.useImperativeHandle(a, b, e);
  };
  react_production_min.useInsertionEffect = function(a, b) {
    return U.current.useInsertionEffect(a, b);
  };
  react_production_min.useLayoutEffect = function(a, b) {
    return U.current.useLayoutEffect(a, b);
  };
  react_production_min.useMemo = function(a, b) {
    return U.current.useMemo(a, b);
  };
  react_production_min.useReducer = function(a, b, e) {
    return U.current.useReducer(a, b, e);
  };
  react_production_min.useRef = function(a) {
    return U.current.useRef(a);
  };
  react_production_min.useState = function(a) {
    return U.current.useState(a);
  };
  react_production_min.useSyncExternalStore = function(a, b, e) {
    return U.current.useSyncExternalStore(a, b, e);
  };
  react_production_min.useTransition = function() {
    return U.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react$1.exports;
  hasRequiredReact = 1;
  {
    react$1.exports = requireReact_production_min();
  }
  return react$1.exports;
}
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = requireReact(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h2 = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h2 = a.ref);
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h2, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports$1) {
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
        else break a;
      }
    }
    function h2(a) {
      return 0 === a.length ? null : a[0];
    }
    function k(a) {
      if (0 === a.length) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
          var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
          if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
          else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
          else break a;
        }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l = performance;
      exports$1.unstable_now = function() {
        return l.now();
      };
    } else {
      var p = Date, q = p.now();
      exports$1.unstable_now = function() {
        return p.now() - q;
      };
    }
    var r = [], t2 = [], u = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h2(t2); null !== b; ) {
        if (null === b.callback) k(t2);
        else if (b.startTime <= a) k(t2), b.sortIndex = b.expirationTime, f(r, b);
        else break;
        b = h2(t2);
      }
    }
    function H(a) {
      B = false;
      G(a);
      if (!A) if (null !== h2(r)) A = true, I(J);
      else {
        var b = h2(t2);
        null !== b && K(H, b.startTime - a);
      }
    }
    function J(a, b) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c = y;
      try {
        G(b);
        for (v = h2(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
          var d = v.callback;
          if ("function" === typeof d) {
            v.callback = null;
            y = v.priorityLevel;
            var e = d(v.expirationTime <= b);
            b = exports$1.unstable_now();
            "function" === typeof e ? v.callback = e : v === h2(r) && k(r);
            G(b);
          } else k(r);
          v = h2(r);
        }
        if (null !== v) var w = true;
        else {
          var m = h2(t2);
          null !== m && K(H, m.startTime - b);
          w = false;
        }
        return w;
      } finally {
        v = null, y = c, z = false;
      }
    }
    var N = false, O = null, L = -1, P = 5, Q = -1;
    function M() {
      return exports$1.unstable_now() - Q < P ? false : true;
    }
    function R() {
      if (null !== O) {
        var a = exports$1.unstable_now();
        Q = a;
        var b = true;
        try {
          b = O(true, a);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else N = false;
    }
    var S;
    if ("function" === typeof F) S = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S = function() {
        U.postMessage(null);
      };
    } else S = function() {
      D(R, 0);
    };
    function I(a) {
      O = a;
      N || (N = true, S());
    }
    function K(a, b) {
      L = D(function() {
        a(exports$1.unstable_now());
      }, b);
    }
    exports$1.unstable_IdlePriority = 5;
    exports$1.unstable_ImmediatePriority = 1;
    exports$1.unstable_LowPriority = 4;
    exports$1.unstable_NormalPriority = 3;
    exports$1.unstable_Profiling = null;
    exports$1.unstable_UserBlockingPriority = 2;
    exports$1.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports$1.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports$1.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports$1.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports$1.unstable_getFirstCallbackNode = function() {
      return h2(r);
    };
    exports$1.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports$1.unstable_pauseExecution = function() {
    };
    exports$1.unstable_requestPaint = function() {
    };
    exports$1.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports$1.unstable_scheduleCallback = function(a, b, c) {
      var d = exports$1.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
      c > d ? (a.sortIndex = c, f(t2, a), null === h2(r) && a === h2(t2) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
      return a;
    };
    exports$1.unstable_shouldYield = M;
    exports$1.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = requireReact(), ca = requireScheduler();
  function p(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a, b) {
    ha(a, b);
    ha(a + "Capture", b);
  }
  function ha(a, b) {
    ea[a] = b;
    for (a = 0; a < b.length; a++) da.add(b[a]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a) {
    if (ja.call(ma, a)) return true;
    if (ja.call(la, a)) return false;
    if (ka.test(a)) return ma[a] = true;
    la[a] = true;
    return false;
  }
  function pa(a, b, c, d) {
    if (null !== c && 0 === c.type) return false;
    switch (typeof b) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d) return false;
        if (null !== c) return !c.acceptsBooleans;
        a = a.toLowerCase().slice(0, 5);
        return "data-" !== a && "aria-" !== a;
      default:
        return false;
    }
  }
  function qa(a, b, c, d) {
    if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
    if (d) return false;
    if (null !== c) switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
    return false;
  }
  function v(a, b, c, d, e, f, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d;
    this.attributeNamespace = e;
    this.mustUseProperty = c;
    this.propertyName = a;
    this.type = b;
    this.sanitizeURL = f;
    this.removeEmptyString = g;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    z[a] = new v(a, 0, false, a, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b = a[0];
    z[b] = new v(b, 1, false, a[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    z[a] = new v(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    z[a] = new v(a, 3, true, a, null, false, false);
  });
  ["capture", "download"].forEach(function(a) {
    z[a] = new v(a, 4, false, a, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a) {
    z[a] = new v(a, 6, false, a, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a) {
    z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b = a.replace(
      ra,
      sa
    );
    z[b] = new v(b, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
  });
  z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
  });
  function ta2(a, b, c, d) {
    var e = z.hasOwnProperty(b) ? z[b] : null;
    if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a) {
    if (null === a || "object" !== typeof a) return null;
    a = Ja && a[Ja] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var A = Object.assign, La;
  function Ma(a) {
    if (void 0 === La) try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
    return "\n" + La + a;
  }
  var Na = false;
  function Oa(a, b) {
    if (!a || Na) return "";
    Na = true;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b) if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l) {
          var d = l;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l) {
          d = l;
        }
        a.call(b.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l) {
          d = l;
        }
        a();
      }
    } catch (l) {
      if (l && d && "string" === typeof l.stack) {
        for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h2 = f.length - 1; 1 <= g && 0 <= h2 && e[g] !== f[h2]; ) h2--;
        for (; 1 <= g && 0 <= h2; g--, h2--) if (e[g] !== f[h2]) {
          if (1 !== g || 1 !== h2) {
            do
              if (g--, h2--, 0 > h2 || e[g] !== f[h2]) {
                var k = "\n" + e[g].replace(" at new ", " at ");
                a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                return k;
              }
            while (1 <= g && 0 <= h2);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c;
    }
    return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
  }
  function Pa(a) {
    switch (a.tag) {
      case 5:
        return Ma(a.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Oa(a.type, false), a;
      case 11:
        return a = Oa(a.type.render, false), a;
      case 1:
        return a = Oa(a.type, true), a;
      default:
        return "";
    }
  }
  function Qa(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch (a) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a) switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a.render;
        a = a.displayName;
        a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
      case Ha:
        b = a._payload;
        a = a._init;
        try {
          return Qa(a(b));
        } catch (c) {
        }
    }
    return null;
  }
  function Ra(a) {
    var b = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b) return b.displayName || b.name || null;
        if ("string" === typeof b) return b;
    }
    return null;
  }
  function Sa(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ta(a) {
    var b = a.type;
    return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
  }
  function Ua(a) {
    var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
    if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
      var e = c.get, f = c.set;
      Object.defineProperty(a, b, { configurable: true, get: function() {
        return e.call(this);
      }, set: function(a2) {
        d = "" + a2;
        f.call(this, a2);
      } });
      Object.defineProperty(a, b, { enumerable: c.enumerable });
      return { getValue: function() {
        return d;
      }, setValue: function(a2) {
        d = "" + a2;
      }, stopTracking: function() {
        a._valueTracker = null;
        delete a[b];
      } };
    }
  }
  function Va(a) {
    a._valueTracker || (a._valueTracker = Ua(a));
  }
  function Wa(a) {
    if (!a) return false;
    var b = a._valueTracker;
    if (!b) return true;
    var c = b.getValue();
    var d = "";
    a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
    a = d;
    return a !== c ? (b.setValue(a), true) : false;
  }
  function Xa(a) {
    a = a || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a) return null;
    try {
      return a.activeElement || a.body;
    } catch (b) {
      return a.body;
    }
  }
  function Ya(a, b) {
    var c = b.checked;
    return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
  }
  function Za(a, b) {
    var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
    c = Sa(null != b.value ? b.value : c);
    a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
  }
  function ab(a, b) {
    b = b.checked;
    null != b && ta2(a, "checked", b, false);
  }
  function bb(a, b) {
    ab(a, b);
    var c = Sa(b.value), d = b.type;
    if (null != c) if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
    else if ("submit" === d || "reset" === d) {
      a.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
    null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
  }
  function db(a, b, c) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d = b.type;
      if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
      b = "" + a._wrapperState.initialValue;
      c || b === a.value || (a.value = b);
      a.defaultValue = b;
    }
    c = a.name;
    "" !== c && (a.name = "");
    a.defaultChecked = !!a._wrapperState.initialChecked;
    "" !== c && (a.name = c);
  }
  function cb(a, b, c) {
    if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
  }
  var eb = Array.isArray;
  function fb(a, b, c, d) {
    a = a.options;
    if (b) {
      b = {};
      for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
      for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
    } else {
      c = "" + Sa(c);
      b = null;
      for (e = 0; e < a.length; e++) {
        if (a[e].value === c) {
          a[e].selected = true;
          d && (a[e].defaultSelected = true);
          return;
        }
        null !== b || a[e].disabled || (b = a[e]);
      }
      null !== b && (b.selected = true);
    }
  }
  function gb(a, b) {
    if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
    return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function hb(a, b) {
    var c = b.value;
    if (null == c) {
      c = b.children;
      b = b.defaultValue;
      if (null != c) {
        if (null != b) throw Error(p(92));
        if (eb(c)) {
          if (1 < c.length) throw Error(p(93));
          c = c[0];
        }
        b = c;
      }
      null == b && (b = "");
      c = b;
    }
    a._wrapperState = { initialValue: Sa(c) };
  }
  function ib(a, b) {
    var c = Sa(b.value), d = Sa(b.defaultValue);
    null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
    null != d && (a.defaultValue = "" + d);
  }
  function jb(a) {
    var b = a.textContent;
    b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
  }
  function kb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a, b) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
  }
  var mb, nb = (function(a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(b, c, d, e);
      });
    } : a;
  })(function(a, b) {
    if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
      for (; b.firstChild; ) a.appendChild(b.firstChild);
    }
  });
  function ob(a, b) {
    if (b) {
      var c = a.firstChild;
      if (c && c === a.lastChild && 3 === c.nodeType) {
        c.nodeValue = b;
        return;
      }
    }
    a.textContent = b;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a) {
    qb.forEach(function(b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1);
      pb[b] = pb[a];
    });
  });
  function rb(a, b, c) {
    return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
  }
  function sb(a, b) {
    a = a.style;
    for (var c in b) if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
  }
  var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a, b) {
    if (b) {
      if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children) throw Error(p(60));
        if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
      }
      if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
    }
  }
  function vb(a, b) {
    if (-1 === a.indexOf("-")) return "string" === typeof b.is;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a) {
    a = a.target || a.srcElement || window;
    a.correspondingUseElement && (a = a.correspondingUseElement);
    return 3 === a.nodeType ? a.parentNode : a;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a) {
    if (a = Cb(a)) {
      if ("function" !== typeof yb) throw Error(p(280));
      var b = a.stateNode;
      b && (b = Db(b), yb(a.stateNode, a.type, b));
    }
  }
  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
  }
  function Fb() {
    if (zb) {
      var a = zb, b = Ab;
      Ab = zb = null;
      Bb(a);
      if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
    }
  }
  function Gb(a, b) {
    return a(b);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a, b, c) {
    if (Ib) return a(b, c);
    Ib = true;
    try {
      return Gb(a, b, c);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a, b) {
    var c = a.stateNode;
    if (null === c) return null;
    var d = Db(c);
    if (null === d) return null;
    c = d[b];
    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
    if (a) return null;
    if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
    return c;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
  function Nb(a, b, c, d, e, f, g, h2, k) {
    var l = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c, l);
    } catch (m) {
      this.onError(m);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
    Ob = true;
    Pb = a;
  } };
  function Tb(a, b, c, d, e, f, g, h2, k) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a, b, c, d, e, f, g, h2, k) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p(198));
      Qb || (Qb = true, Rb = l);
    }
  }
  function Vb(a) {
    var b = a, c = a;
    if (a.alternate) for (; b.return; ) b = b.return;
    else {
      a = b;
      do
        b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
      while (a);
    }
    return 3 === b.tag ? c : null;
  }
  function Wb(a) {
    if (13 === a.tag) {
      var b = a.memoizedState;
      null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
      if (null !== b) return b.dehydrated;
    }
    return null;
  }
  function Xb(a) {
    if (Vb(a) !== a) throw Error(p(188));
  }
  function Yb(a) {
    var b = a.alternate;
    if (!b) {
      b = Vb(a);
      if (null === b) throw Error(p(188));
      return b !== a ? null : a;
    }
    for (var c = a, d = b; ; ) {
      var e = c.return;
      if (null === e) break;
      var f = e.alternate;
      if (null === f) {
        d = e.return;
        if (null !== d) {
          c = d;
          continue;
        }
        break;
      }
      if (e.child === f.child) {
        for (f = e.child; f; ) {
          if (f === c) return Xb(e), a;
          if (f === d) return Xb(e), b;
          f = f.sibling;
        }
        throw Error(p(188));
      }
      if (c.return !== d.return) c = e, d = f;
      else {
        for (var g = false, h2 = e.child; h2; ) {
          if (h2 === c) {
            g = true;
            c = e;
            d = f;
            break;
          }
          if (h2 === d) {
            g = true;
            d = e;
            c = f;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g) {
          for (h2 = f.child; h2; ) {
            if (h2 === c) {
              g = true;
              c = f;
              d = e;
              break;
            }
            if (h2 === d) {
              g = true;
              d = f;
              c = e;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g) throw Error(p(189));
        }
      }
      if (c.alternate !== d) throw Error(p(190));
    }
    if (3 !== c.tag) throw Error(p(188));
    return c.stateNode.current === c ? a : b;
  }
  function Zb(a) {
    a = Yb(a);
    return null !== a ? $b(a) : null;
  }
  function $b(a) {
    if (5 === a.tag || 6 === a.tag) return a;
    for (a = a.child; null !== a; ) {
      var b = $b(a);
      if (null !== b) return b;
      a = a.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b) {
    }
  }
  var oc2 = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function uc(a, b) {
    var c = a.pendingLanes;
    if (0 === c) return 0;
    var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
    if (0 !== g) {
      var h2 = g & ~e;
      0 !== h2 ? d = tc(h2) : (f &= g, 0 !== f && (d = tc(f)));
    } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
    if (0 === d) return 0;
    if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
    0 !== (d & 4) && (d |= c & 16);
    b = a.entangledLanes;
    if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc2(b), e = 1 << c, d |= a[c], b &= ~e;
    return d;
  }
  function vc(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a, b) {
    for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
      var g = 31 - oc2(f), h2 = 1 << g, k = e[g];
      if (-1 === k) {
        if (0 === (h2 & c) || 0 !== (h2 & d)) e[g] = vc(h2, b);
      } else k <= b && (a.expiredLanes |= h2);
      f &= ~h2;
    }
  }
  function xc(a) {
    a = a.pendingLanes & -1073741825;
    return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a;
  }
  function zc(a) {
    for (var b = [], c = 0; 31 > c; c++) b.push(a);
    return b;
  }
  function Ac(a, b, c) {
    a.pendingLanes |= b;
    536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
    a = a.eventTimes;
    b = 31 - oc2(b);
    a[b] = c;
  }
  function Bc(a, b) {
    var c = a.pendingLanes & ~b;
    a.pendingLanes = b;
    a.suspendedLanes = 0;
    a.pingedLanes = 0;
    a.expiredLanes &= b;
    a.mutableReadLanes &= b;
    a.entangledLanes &= b;
    b = a.entanglements;
    var d = a.eventTimes;
    for (a = a.expirationTimes; 0 < c; ) {
      var e = 31 - oc2(c), f = 1 << e;
      b[e] = 0;
      d[e] = -1;
      a[e] = -1;
      c &= ~f;
    }
  }
  function Cc(a, b) {
    var c = a.entangledLanes |= b;
    for (a = a.entanglements; c; ) {
      var d = 31 - oc2(c), e = 1 << d;
      e & b | a[d] & b && (a[d] |= b);
      c &= ~e;
    }
  }
  var C = 0;
  function Dc(a) {
    a &= -a;
    return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a, b) {
    switch (a) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b.pointerId);
    }
  }
  function Tc(a, b, c, d, e, f) {
    if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
    a.eventSystemFlags |= d;
    b = a.targetContainers;
    null !== e && -1 === b.indexOf(e) && b.push(e);
    return a;
  }
  function Uc(a, b, c, d, e) {
    switch (b) {
      case "focusin":
        return Lc = Tc(Lc, a, b, c, d, e), true;
      case "dragenter":
        return Mc = Tc(Mc, a, b, c, d, e), true;
      case "mouseover":
        return Nc = Tc(Nc, a, b, c, d, e), true;
      case "pointerover":
        var f = e.pointerId;
        Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
        return true;
      case "gotpointercapture":
        return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
    }
    return false;
  }
  function Vc(a) {
    var b = Wc(a.target);
    if (null !== b) {
      var c = Vb(b);
      if (null !== c) {
        if (b = c.tag, 13 === b) {
          if (b = Wb(c), null !== b) {
            a.blockedOn = b;
            Ic(a.priority, function() {
              Gc(c);
            });
            return;
          }
        } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Xc(a) {
    if (null !== a.blockedOn) return false;
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (null === c) {
        c = a.nativeEvent;
        var d = new c.constructor(c.type, c);
        wb = d;
        c.target.dispatchEvent(d);
        wb = null;
      } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
      b.shift();
    }
    return true;
  }
  function Zc(a, b, c) {
    Xc(a) && c.delete(b);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a, b) {
    a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a) {
    function b(b2) {
      return ad(b2, a);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a);
      for (var c = 1; c < Kc.length; c++) {
        var d = Kc[c];
        d.blockedOn === a && (d.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a);
    null !== Mc && ad(Mc, a);
    null !== Nc && ad(Nc, a);
    Oc.forEach(b);
    Pc.forEach(b);
    for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
    for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a, b, c, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a, b, c, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function gd(a, b, c, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a, b, c, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function fd(a, b, c, d) {
    if (dd) {
      var e = Yc(a, b, c, d);
      if (null === e) hd(a, b, d, id, c), Sc(a, d);
      else if (Uc(e, a, b, c, d)) d.stopPropagation();
      else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
        for (; null !== e; ) {
          var f = Cb(e);
          null !== f && Ec(f);
          f = Yc(a, b, c, d);
          null === f && hd(a, b, d, id, c);
          if (f === e) break;
          e = f;
        }
        null !== e && d.stopPropagation();
      } else hd(a, b, d, null, c);
    }
  }
  var id = null;
  function Yc(a, b, c, d) {
    id = null;
    a = xb(d);
    a = Wc(a);
    if (null !== a) if (b = Vb(a), null === b) a = null;
    else if (c = b.tag, 13 === c) {
      a = Wb(b);
      if (null !== a) return a;
      a = null;
    } else if (3 === c) {
      if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
      a = null;
    } else b !== a && (a = null);
    id = a;
    return null;
  }
  function jd(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
    for (a = 0; a < c && b[a] === e[a]; a++) ;
    var g = c - a;
    for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
    return md = e.slice(a, 1 < d ? 1 - d : void 0);
  }
  function od(a) {
    var b = a.keyCode;
    "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
    10 === a && (a = 13);
    return 32 <= a || 13 === a ? a : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a) {
    function b(b2, d, e, f, g) {
      this._reactName = b2;
      this._targetInst = e;
      this.type = d;
      this.nativeEvent = f;
      this.target = g;
      this.currentTarget = null;
      for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
      this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A(b.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a2 = this.nativeEvent;
      a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a2 = this.nativeEvent;
      a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    if ("movementX" in a) return a.movementX;
    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
    return wd;
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : xd;
  } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A({}, ud, { key: function(a) {
    if (a.key) {
      var b = Md[a.key] || a.key;
      if ("Unidentified" !== b) return b;
    }
    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
    return "keypress" === a.type ? od(a) : 0;
  }, keyCode: function(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a, b) {
    switch (a) {
      case "keyup":
        return -1 !== $d.indexOf(b.keyCode);
      case "keydown":
        return 229 !== b.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a) {
    a = a.detail;
    return "object" === typeof a && "data" in a ? a.data : null;
  }
  var ie2 = false;
  function je(a, b) {
    switch (a) {
      case "compositionend":
        return he(b);
      case "keypress":
        if (32 !== b.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a = b.data, a === ee && fe ? null : a;
      default:
        return null;
    }
  }
  function ke(a, b) {
    if (ie2) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie2 = false, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b.locale ? null : b.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
  }
  function ne(a, b, c, d) {
    Eb(d);
    b = oe(b, "onChange");
    0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
  }
  var pe = null, qe = null;
  function re(a) {
    se(a, 0);
  }
  function te(a) {
    var b = ue(a);
    if (Wa(b)) return a;
  }
  function ve(a, b) {
    if ("change" === a) return b;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a) {
    if ("value" === a.propertyName && te(qe)) {
      var b = [];
      ne(b, qe, a, xb(a));
      Jb(re, b);
    }
  }
  function Ce(a, b, c) {
    "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
  }
  function De(a) {
    if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
  }
  function Ee(a, b) {
    if ("click" === a) return te(b);
  }
  function Fe(a, b) {
    if ("input" === a || "change" === a) return te(b);
  }
  function Ge(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a, b) {
    if (He(a, b)) return true;
    if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
    var c = Object.keys(a), d = Object.keys(b);
    if (c.length !== d.length) return false;
    for (d = 0; d < c.length; d++) {
      var e = c[d];
      if (!ja.call(b, e) || !He(a[e], b[e])) return false;
    }
    return true;
  }
  function Je(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function Ke(a, b) {
    var c = Je(a);
    a = 0;
    for (var d; c; ) {
      if (3 === c.nodeType) {
        d = a + c.textContent.length;
        if (a <= b && d >= b) return { node: c, offset: b - a };
        a = d;
      }
      a: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break a;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Je(c);
    }
  }
  function Le(a, b) {
    return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
  }
  function Me() {
    for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
      try {
        var c = "string" === typeof b.contentWindow.location.href;
      } catch (d) {
        c = false;
      }
      if (c) a = b.contentWindow;
      else break;
      b = Xa(a.document);
    }
    return b;
  }
  function Ne(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
  }
  function Oe(a) {
    var b = Me(), c = a.focusedElem, d = a.selectionRange;
    if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
      if (null !== d && Ne(c)) {
        if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
        else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var e = c.textContent.length, f = Math.min(d.start, e);
          d = void 0 === d.end ? f : Math.min(d.end, e);
          !a.extend && f > d && (e = d, d = f, f = e);
          e = Ke(c, f);
          var g = Ke(
            c,
            d
          );
          e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
        }
      }
      b = [];
      for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      "function" === typeof c.focus && c.focus();
      for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a, b, c) {
    var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
    Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
  }
  function Ve(a, b) {
    var c = {};
    c[a.toLowerCase()] = b.toLowerCase();
    c["Webkit" + a] = "webkit" + b;
    c["Moz" + a] = "moz" + b;
    return c;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a) {
    if (Xe[a]) return Xe[a];
    if (!We[a]) return a;
    var b = We[a], c;
    for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
    return a;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a, b) {
    df.set(a, b);
    fa(b, [a]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a, b, c) {
    var d = a.type || "unknown-event";
    a.currentTarget = c;
    Ub(d, b, void 0, a);
    a.currentTarget = null;
  }
  function se(a, b) {
    b = 0 !== (b & 4);
    for (var c = 0; c < a.length; c++) {
      var d = a[c], e = d.event;
      d = d.listeners;
      a: {
        var f = void 0;
        if (b) for (var g = d.length - 1; 0 <= g; g--) {
          var h2 = d[g], k = h2.instance, l = h2.currentTarget;
          h2 = h2.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h2, l);
          f = k;
        }
        else for (g = 0; g < d.length; g++) {
          h2 = d[g];
          k = h2.instance;
          l = h2.currentTarget;
          h2 = h2.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h2, l);
          f = k;
        }
      }
    }
    if (Qb) throw a = Rb, Qb = false, Rb = null, a;
  }
  function D(a, b) {
    var c = b[of];
    void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
    var d = a + "__bubble";
    c.has(d) || (pf(b, a, 2, false), c.add(d));
  }
  function qf(a, b, c) {
    var d = 0;
    b && (d |= 4);
    pf(c, a, d, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a) {
    if (!a[rf]) {
      a[rf] = true;
      da.forEach(function(b2) {
        "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
      });
      var b = 9 === a.nodeType ? a : a.ownerDocument;
      null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
    }
  }
  function pf(a, b, c, d) {
    switch (jd(b)) {
      case 1:
        var e = ed;
        break;
      case 4:
        e = gd;
        break;
      default:
        e = fd;
    }
    c = e.bind(null, b, c, a);
    e = void 0;
    !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
    d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
  }
  function hd(a, b, c, d, e) {
    var f = d;
    if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
      if (null === d) return;
      var g = d.tag;
      if (3 === g || 4 === g) {
        var h2 = d.stateNode.containerInfo;
        if (h2 === e || 8 === h2.nodeType && h2.parentNode === e) break;
        if (4 === g) for (g = d.return; null !== g; ) {
          var k = g.tag;
          if (3 === k || 4 === k) {
            if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
          }
          g = g.return;
        }
        for (; null !== h2; ) {
          g = Wc(h2);
          if (null === g) return;
          k = g.tag;
          if (5 === k || 6 === k) {
            d = f = g;
            continue a;
          }
          h2 = h2.parentNode;
        }
      }
      d = d.return;
    }
    Jb(function() {
      var d2 = f, e2 = xb(c), g2 = [];
      a: {
        var h3 = df.get(a);
        if (void 0 !== h3) {
          var k2 = td, n = a;
          switch (a) {
            case "keypress":
              if (0 === od(c)) break a;
            case "keydown":
            case "keyup":
              k2 = Rd;
              break;
            case "focusin":
              n = "focus";
              k2 = Fd;
              break;
            case "focusout":
              n = "blur";
              k2 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k2 = Fd;
              break;
            case "click":
              if (2 === c.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k2 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k2 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k2 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k2 = Hd;
              break;
            case cf:
              k2 = Xd;
              break;
            case "scroll":
              k2 = vd;
              break;
            case "wheel":
              k2 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k2 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k2 = Td;
          }
          var t2 = 0 !== (b & 4), J = !t2 && "scroll" === a, x = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
          t2 = [];
          for (var w = d2, u; null !== w; ) {
            u = w;
            var F = u.stateNode;
            5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t2.push(tf(w, F, u))));
            if (J) break;
            w = w.return;
          }
          0 < t2.length && (h3 = new k2(h3, n, null, c, e2), g2.push({ event: h3, listeners: t2 }));
        }
      }
      if (0 === (b & 7)) {
        a: {
          h3 = "mouseover" === a || "pointerover" === a;
          k2 = "mouseout" === a || "pointerout" === a;
          if (h3 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
          if (k2 || h3) {
            h3 = e2.window === e2 ? e2 : (h3 = e2.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k2) {
              if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
            } else k2 = null, n = d2;
            if (k2 !== n) {
              t2 = Bd;
              F = "onMouseLeave";
              x = "onMouseEnter";
              w = "mouse";
              if ("pointerout" === a || "pointerover" === a) t2 = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
              J = null == k2 ? h3 : ue(k2);
              u = null == n ? h3 : ue(n);
              h3 = new t2(F, w + "leave", k2, c, e2);
              h3.target = J;
              h3.relatedTarget = u;
              F = null;
              Wc(e2) === d2 && (t2 = new t2(x, w + "enter", n, c, e2), t2.target = u, t2.relatedTarget = J, F = t2);
              J = F;
              if (k2 && n) b: {
                t2 = k2;
                x = n;
                w = 0;
                for (u = t2; u; u = vf(u)) w++;
                u = 0;
                for (F = x; F; F = vf(F)) u++;
                for (; 0 < w - u; ) t2 = vf(t2), w--;
                for (; 0 < u - w; ) x = vf(x), u--;
                for (; w--; ) {
                  if (t2 === x || null !== x && t2 === x.alternate) break b;
                  t2 = vf(t2);
                  x = vf(x);
                }
                t2 = null;
              }
              else t2 = null;
              null !== k2 && wf(g2, h3, k2, t2, false);
              null !== n && null !== J && wf(g2, J, n, t2, true);
            }
          }
        }
        a: {
          h3 = d2 ? ue(d2) : window;
          k2 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k2 || "input" === k2 && "file" === h3.type) var na = ve;
          else if (me(h3)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k2 = h3.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
          if (na && (na = na(a, d2))) {
            ne(g2, na, c, e2);
            break a;
          }
          xa && xa(a, h3, d2);
          "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
        }
        xa = d2 ? ue(d2) : window;
        switch (a) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g2, c, e2);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g2, c, e2);
        }
        var $a;
        if (ae) b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie2 ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c.locale && (ie2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie2 && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie2 = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
      }
      se(g2, b);
    });
  }
  function tf(a, b, c) {
    return { instance: a, listener: b, currentTarget: c };
  }
  function oe(a, b) {
    for (var c = b + "Capture", d = []; null !== a; ) {
      var e = a, f = e.stateNode;
      5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
      a = a.return;
    }
    return d;
  }
  function vf(a) {
    if (null === a) return null;
    do
      a = a.return;
    while (a && 5 !== a.tag);
    return a ? a : null;
  }
  function wf(a, b, c, d, e) {
    for (var f = b._reactName, g = []; null !== c && c !== d; ) {
      var h2 = c, k = h2.alternate, l = h2.stateNode;
      if (null !== k && k === d) break;
      5 === h2.tag && null !== l && (h2 = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h2))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h2))));
      c = c.return;
    }
    0 !== g.length && a.push({ event: b, listeners: g });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a) {
    return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
  }
  function Af(a, b, c) {
    b = zf(b);
    if (zf(a) !== b && c) throw Error(p(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a, b) {
    return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
  function If(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Kf(a, b) {
    var c = b, d = 0;
    do {
      var e = c.nextSibling;
      a.removeChild(c);
      if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
        if (0 === d) {
          a.removeChild(e);
          bd(b);
          return;
        }
        d--;
      } else "$" !== c && "$?" !== c && "$!" !== c || d++;
      c = e;
    } while (c);
    bd(b);
  }
  function Lf(a) {
    for (; null != a; a = a.nextSibling) {
      var b = a.nodeType;
      if (1 === b || 3 === b) break;
      if (8 === b) {
        b = a.data;
        if ("$" === b || "$!" === b || "$?" === b) break;
        if ("/$" === b) return null;
      }
    }
    return a;
  }
  function Mf(a) {
    a = a.previousSibling;
    for (var b = 0; a; ) {
      if (8 === a.nodeType) {
        var c = a.data;
        if ("$" === c || "$!" === c || "$?" === c) {
          if (0 === b) return a;
          b--;
        } else "/$" === c && b++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a) {
    var b = a[Of];
    if (b) return b;
    for (var c = a.parentNode; c; ) {
      if (b = c[uf] || c[Of]) {
        c = b.alternate;
        if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
          if (c = a[Of]) return c;
          a = Mf(a);
        }
        return b;
      }
      a = c;
      c = a.parentNode;
    }
    return null;
  }
  function Cb(a) {
    a = a[Of] || a[uf];
    return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
  }
  function ue(a) {
    if (5 === a.tag || 6 === a.tag) return a.stateNode;
    throw Error(p(33));
  }
  function Db(a) {
    return a[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a) {
    return { current: a };
  }
  function E(a) {
    0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a, b) {
    Tf++;
    Sf[Tf] = a.current;
    a.current = b;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a, b) {
    var c = a.type.contextTypes;
    if (!c) return Vf;
    var d = a.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e = {}, f;
    for (f in c) e[f] = b[f];
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }
  function Zf(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }
  function $f() {
    E(Wf);
    E(H);
  }
  function ag(a, b, c) {
    if (H.current !== Vf) throw Error(p(168));
    G(H, b);
    G(Wf, c);
  }
  function bg(a, b, c) {
    var d = a.stateNode;
    b = b.childContextTypes;
    if ("function" !== typeof d.getChildContext) return c;
    d = d.getChildContext();
    for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
    return A({}, c, d);
  }
  function cg(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H.current;
    G(H, a);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a, b, c) {
    var d = a.stateNode;
    if (!d) throw Error(p(169));
    c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
    G(Wf, c);
  }
  var eg = null, fg = false, gg = false;
  function hg(a) {
    null === eg ? eg = [a] : eg.push(a);
  }
  function ig(a) {
    fg = true;
    hg(a);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a = 0, b = C;
      try {
        var c = eg;
        for (C = 1; a < c.length; a++) {
          var d = c[a];
          do
            d = d(true);
          while (null !== d);
        }
        eg = null;
        fg = false;
      } catch (e) {
        throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
      } finally {
        C = b, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a, b) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a;
    ng = b;
  }
  function ug(a, b, c) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a;
    var d = rg;
    a = sg;
    var e = 32 - oc2(d) - 1;
    d &= ~(1 << e);
    c += 1;
    var f = 32 - oc2(b) + e;
    if (30 < f) {
      var g = e - e % 5;
      f = (d & (1 << g) - 1).toString(32);
      d >>= g;
      e -= g;
      rg = 1 << 32 - oc2(b) + e | c << e | d;
      sg = f + a;
    } else rg = 1 << f | c << e | d, sg = a;
  }
  function vg(a) {
    null !== a.return && (tg(a, 1), ug(a, 1, 0));
  }
  function wg(a) {
    for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a, b) {
    var c = Bg(5, null, null, 0);
    c.elementType = "DELETED";
    c.stateNode = b;
    c.return = a;
    b = a.deletions;
    null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
  }
  function Cg(a, b) {
    switch (a.tag) {
      case 5:
        var c = a.type;
        b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
        return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
      case 6:
        return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
      case 13:
        return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a) {
    return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
  }
  function Eg(a) {
    if (I) {
      var b = yg;
      if (b) {
        var c = b;
        if (!Cg(a, b)) {
          if (Dg(a)) throw Error(p(418));
          b = Lf(c.nextSibling);
          var d = xg;
          b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
        }
      } else {
        if (Dg(a)) throw Error(p(418));
        a.flags = a.flags & -4097 | 2;
        I = false;
        xg = a;
      }
    }
  }
  function Fg(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
    xg = a;
  }
  function Gg(a) {
    if (a !== xg) return false;
    if (!I) return Fg(a), I = true, false;
    var b;
    (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
    if (b && (b = yg)) {
      if (Dg(a)) throw Hg(), Error(p(418));
      for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
    }
    Fg(a);
    if (13 === a.tag) {
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a) throw Error(p(317));
      a: {
        a = a.nextSibling;
        for (b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("/$" === c) {
              if (0 === b) {
                yg = Lf(a.nextSibling);
                break a;
              }
              b--;
            } else "$" !== c && "$!" !== c && "$?" !== c || b++;
          }
          a = a.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a = yg; a; ) a = Lf(a.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a) {
    null === zg ? zg = [a] : zg.push(a);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a, b, c) {
    a = c.ref;
    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c._owner) {
        c = c._owner;
        if (c) {
          if (1 !== c.tag) throw Error(p(309));
          var d = c.stateNode;
        }
        if (!d) throw Error(p(147, a));
        var e = d, f = "" + a;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
        b = function(a2) {
          var b2 = e.refs;
          null === a2 ? delete b2[f] : b2[f] = a2;
        };
        b._stringRef = f;
        return b;
      }
      if ("string" !== typeof a) throw Error(p(284));
      if (!c._owner) throw Error(p(290, a));
    }
    return a;
  }
  function Mg(a, b) {
    a = Object.prototype.toString.call(b);
    throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
  }
  function Ng(a) {
    var b = a._init;
    return b(a._payload);
  }
  function Og(a) {
    function b(b2, c2) {
      if (a) {
        var d2 = b2.deletions;
        null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
      }
    }
    function c(c2, d2) {
      if (!a) return null;
      for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
      return null;
    }
    function d(a2, b2) {
      for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
      return a2;
    }
    function e(a2, b2) {
      a2 = Pg(a2, b2);
      a2.index = 0;
      a2.sibling = null;
      return a2;
    }
    function f(b2, c2, d2) {
      b2.index = d2;
      if (!a) return b2.flags |= 1048576, c2;
      d2 = b2.alternate;
      if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
      b2.flags |= 2;
      return c2;
    }
    function g(b2) {
      a && null === b2.alternate && (b2.flags |= 2);
      return b2;
    }
    function h2(a2, b2, c2, d2) {
      if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function k(a2, b2, c2, d2) {
      var f2 = c2.type;
      if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
      if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
      d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
      d2.ref = Lg(a2, b2, c2);
      d2.return = a2;
      return d2;
    }
    function l(a2, b2, c2, d2) {
      if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c2.children || []);
      b2.return = a2;
      return b2;
    }
    function m(a2, b2, c2, d2, f2) {
      if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function q(a2, b2, c2) {
      if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
      if ("object" === typeof b2 && null !== b2) {
        switch (b2.$$typeof) {
          case va:
            return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
          case wa:
            return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
          case Ha:
            var d2 = b2._init;
            return q(a2, d2(b2._payload), c2);
        }
        if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
        Mg(a2, b2);
      }
      return null;
    }
    function r(a2, b2, c2, d2) {
      var e2 = null !== b2 ? b2.key : null;
      if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h2(a2, b2, "" + c2, d2);
      if ("object" === typeof c2 && null !== c2) {
        switch (c2.$$typeof) {
          case va:
            return c2.key === e2 ? k(a2, b2, c2, d2) : null;
          case wa:
            return c2.key === e2 ? l(a2, b2, c2, d2) : null;
          case Ha:
            return e2 = c2._init, r(
              a2,
              b2,
              e2(c2._payload),
              d2
            );
        }
        if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
        Mg(a2, c2);
      }
      return null;
    }
    function y(a2, b2, c2, d2, e2) {
      if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h2(b2, a2, "" + d2, e2);
      if ("object" === typeof d2 && null !== d2) {
        switch (d2.$$typeof) {
          case va:
            return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
          case wa:
            return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
          case Ha:
            var f2 = d2._init;
            return y(a2, b2, c2, f2(d2._payload), e2);
        }
        if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
        Mg(b2, d2);
      }
      return null;
    }
    function n(e2, g2, h3, k2) {
      for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h3.length; w++) {
        u.index > w ? (x = u, u = null) : x = u.sibling;
        var n2 = r(e2, u, h3[w], k2);
        if (null === n2) {
          null === u && (u = x);
          break;
        }
        a && u && null === n2.alternate && b(e2, u);
        g2 = f(n2, g2, w);
        null === m2 ? l2 = n2 : m2.sibling = n2;
        m2 = n2;
        u = x;
      }
      if (w === h3.length) return c(e2, u), I && tg(e2, w), l2;
      if (null === u) {
        for (; w < h3.length; w++) u = q(e2, h3[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
        I && tg(e2, w);
        return l2;
      }
      for (u = d(e2, u); w < h3.length; w++) x = y(u, e2, w, h3[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
      a && u.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function t2(e2, g2, h3, k2) {
      var l2 = Ka(h3);
      if ("function" !== typeof l2) throw Error(p(150));
      h3 = l2.call(h3);
      if (null == h3) throw Error(p(151));
      for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h3.next(); null !== m2 && !n2.done; w++, n2 = h3.next()) {
        m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
        var t3 = r(e2, m2, n2.value, k2);
        if (null === t3) {
          null === m2 && (m2 = x);
          break;
        }
        a && m2 && null === t3.alternate && b(e2, m2);
        g2 = f(t3, g2, w);
        null === u ? l2 = t3 : u.sibling = t3;
        u = t3;
        m2 = x;
      }
      if (n2.done) return c(
        e2,
        m2
      ), I && tg(e2, w), l2;
      if (null === m2) {
        for (; !n2.done; w++, n2 = h3.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        I && tg(e2, w);
        return l2;
      }
      for (m2 = d(e2, m2); !n2.done; w++, n2 = h3.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
      a && m2.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function J(a2, d2, f2, h3) {
      "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
      if ("object" === typeof f2 && null !== f2) {
        switch (f2.$$typeof) {
          case va:
            a: {
              for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                if (l2.key === k2) {
                  k2 = f2.type;
                  if (k2 === ya) {
                    if (7 === l2.tag) {
                      c(a2, l2.sibling);
                      d2 = e(l2, f2.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                  } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                    c(a2, l2.sibling);
                    d2 = e(l2, f2.props);
                    d2.ref = Lg(a2, l2, f2);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                  c(a2, l2);
                  break;
                } else b(a2, l2);
                l2 = l2.sibling;
              }
              f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h3, f2.key), d2.return = a2, a2 = d2) : (h3 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h3), h3.ref = Lg(a2, d2, f2), h3.return = a2, a2 = h3);
            }
            return g(a2);
          case wa:
            a: {
              for (l2 = f2.key; null !== d2; ) {
                if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f2.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
                else b(a2, d2);
                d2 = d2.sibling;
              }
              d2 = Sg(f2, a2.mode, h3);
              d2.return = a2;
              a2 = d2;
            }
            return g(a2);
          case Ha:
            return l2 = f2._init, J(a2, d2, l2(f2._payload), h3);
        }
        if (eb(f2)) return n(a2, d2, f2, h3);
        if (Ka(f2)) return t2(a2, d2, f2, h3);
        Mg(a2, f2);
      }
      return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h3), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
    }
    return J;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a) {
    var b = Wg.current;
    E(Wg);
    a._currentValue = b;
  }
  function bh(a, b, c) {
    for (; null !== a; ) {
      var d = a.alternate;
      (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
      if (a === c) break;
      a = a.return;
    }
  }
  function ch(a, b) {
    Xg = a;
    Zg = Yg = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
  }
  function eh(a) {
    var b = a._currentValue;
    if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
      if (null === Xg) throw Error(p(308));
      Yg = a;
      Xg.dependencies = { lanes: 0, firstContext: a };
    } else Yg = Yg.next = a;
    return b;
  }
  var fh = null;
  function gh(a) {
    null === fh ? fh = [a] : fh.push(a);
  }
  function hh(a, b, c, d) {
    var e = b.interleaved;
    null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
    b.interleaved = c;
    return ih(a, d);
  }
  function ih(a, b) {
    a.lanes |= b;
    var c = a.alternate;
    null !== c && (c.lanes |= b);
    c = a;
    for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
    return 3 === c.tag ? c.stateNode : null;
  }
  var jh = false;
  function kh(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a, b) {
    a = a.updateQueue;
    b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function mh(a, b) {
    return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a, b, c) {
    var d = a.updateQueue;
    if (null === d) return null;
    d = d.shared;
    if (0 !== (K & 2)) {
      var e = d.pending;
      null === e ? b.next = b : (b.next = e.next, e.next = b);
      d.pending = b;
      return ih(a, c);
    }
    e = d.interleaved;
    null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
    d.interleaved = b;
    return ih(a, c);
  }
  function oh(a, b, c) {
    b = b.updateQueue;
    if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  function ph(a, b) {
    var c = a.updateQueue, d = a.alternate;
    if (null !== d && (d = d.updateQueue, c === d)) {
      var e = null, f = null;
      c = c.firstBaseUpdate;
      if (null !== c) {
        do {
          var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
          null === f ? e = f = g : f = f.next = g;
          c = c.next;
        } while (null !== c);
        null === f ? e = f = b : f = f.next = b;
      } else e = f = b;
      c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
      a.updateQueue = c;
      return;
    }
    a = c.lastBaseUpdate;
    null === a ? c.firstBaseUpdate = b : a.next = b;
    c.lastBaseUpdate = b;
  }
  function qh(a, b, c, d) {
    var e = a.updateQueue;
    jh = false;
    var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h2 = e.shared.pending;
    if (null !== h2) {
      e.shared.pending = null;
      var k = h2, l = k.next;
      k.next = null;
      null === g ? f = l : g.next = l;
      g = k;
      var m = a.alternate;
      null !== m && (m = m.updateQueue, h2 = m.lastBaseUpdate, h2 !== g && (null === h2 ? m.firstBaseUpdate = l : h2.next = l, m.lastBaseUpdate = k));
    }
    if (null !== f) {
      var q = e.baseState;
      g = 0;
      m = l = k = null;
      h2 = f;
      do {
        var r = h2.lane, y = h2.eventTime;
        if ((d & r) === r) {
          null !== m && (m = m.next = {
            eventTime: y,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n = a, t2 = h2;
            r = b;
            y = c;
            switch (t2.tag) {
              case 1:
                n = t2.payload;
                if ("function" === typeof n) {
                  q = n.call(y, q, r);
                  break a;
                }
                q = n;
                break a;
              case 3:
                n.flags = n.flags & -65537 | 128;
              case 0:
                n = t2.payload;
                r = "function" === typeof n ? n.call(y, q, r) : n;
                if (null === r || void 0 === r) break a;
                q = A({}, q, r);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h2] : r.push(h2));
        } else y = { eventTime: y, lane: r, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
        h2 = h2.next;
        if (null === h2) if (h2 = e.shared.pending, null === h2) break;
        else r = h2, h2 = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
      } while (1);
      null === m && (k = q);
      e.baseState = k;
      e.firstBaseUpdate = l;
      e.lastBaseUpdate = m;
      b = e.shared.interleaved;
      if (null !== b) {
        e = b;
        do
          g |= e.lane, e = e.next;
        while (e !== b);
      } else null === f && (e.shared.lanes = 0);
      rh |= g;
      a.lanes = g;
      a.memoizedState = q;
    }
  }
  function sh(a, b, c) {
    a = b.effects;
    b.effects = null;
    if (null !== a) for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (null !== e) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e) throw Error(p(191, e));
        e.call(d);
      }
    }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a) {
    if (a === th) throw Error(p(174));
    return a;
  }
  function yh(a, b) {
    G(wh, b);
    G(vh, a);
    G(uh, th);
    a = b.nodeType;
    switch (a) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
    }
    E(uh);
    G(uh, b);
  }
  function zh() {
    E(uh);
    E(vh);
    E(wh);
  }
  function Ah(a) {
    xh(wh.current);
    var b = xh(uh.current);
    var c = lb(b, a.type);
    b !== c && (G(vh, a), G(uh, c));
  }
  function Bh(a) {
    vh.current === a && (E(uh), E(vh));
  }
  var L = Uf(0);
  function Ch(a) {
    for (var b = a; null !== b; ) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.flags & 128)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }
      if (b === a) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a) return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P() {
    throw Error(p(321));
  }
  function Mh(a, b) {
    if (null === b) return false;
    for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
    return true;
  }
  function Nh(a, b, c, d, e, f) {
    Hh = f;
    M = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.lanes = 0;
    Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
    a = c(d, e);
    if (Jh) {
      f = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f) throw Error(p(301));
        f += 1;
        O = N = null;
        b.updateQueue = null;
        Fh.current = Qh;
        a = c(d, e);
      } while (Jh);
    }
    Fh.current = Rh;
    b = null !== N && null !== N.next;
    Hh = 0;
    O = N = M = null;
    Ih = false;
    if (b) throw Error(p(300));
    return a;
  }
  function Sh() {
    var a = 0 !== Kh;
    Kh = 0;
    return a;
  }
  function Th() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
    return O;
  }
  function Uh() {
    if (null === N) {
      var a = M.alternate;
      a = null !== a ? a.memoizedState : null;
    } else a = N.next;
    var b = null === O ? M.memoizedState : O.next;
    if (null !== b) O = b, N = a;
    else {
      if (null === a) throw Error(p(310));
      N = a;
      a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
      null === O ? M.memoizedState = O = a : O = O.next = a;
    }
    return O;
  }
  function Vh(a, b) {
    return "function" === typeof b ? b(a) : b;
  }
  function Wh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = N, e = d.baseQueue, f = c.pending;
    if (null !== f) {
      if (null !== e) {
        var g = e.next;
        e.next = f.next;
        f.next = g;
      }
      d.baseQueue = e = f;
      c.pending = null;
    }
    if (null !== e) {
      f = e.next;
      d = d.baseState;
      var h2 = g = null, k = null, l = f;
      do {
        var m = l.lane;
        if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
        else {
          var q = {
            lane: m,
            action: l.action,
            hasEagerState: l.hasEagerState,
            eagerState: l.eagerState,
            next: null
          };
          null === k ? (h2 = k = q, g = d) : k = k.next = q;
          M.lanes |= m;
          rh |= m;
        }
        l = l.next;
      } while (null !== l && l !== f);
      null === k ? g = d : k.next = h2;
      He(d, b.memoizedState) || (dh = true);
      b.memoizedState = d;
      b.baseState = g;
      b.baseQueue = k;
      c.lastRenderedState = d;
    }
    a = c.interleaved;
    if (null !== a) {
      e = a;
      do
        f = e.lane, M.lanes |= f, rh |= f, e = e.next;
      while (e !== a);
    } else null === e && (c.lanes = 0);
    return [b.memoizedState, c.dispatch];
  }
  function Xh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = c.dispatch, e = c.pending, f = b.memoizedState;
    if (null !== e) {
      c.pending = null;
      var g = e = e.next;
      do
        f = a(f, g.action), g = g.next;
      while (g !== e);
      He(f, b.memoizedState) || (dh = true);
      b.memoizedState = f;
      null === b.baseQueue && (b.baseState = f);
      c.lastRenderedState = f;
    }
    return [f, d];
  }
  function Yh() {
  }
  function Zh(a, b) {
    var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
    f && (d.memoizedState = e, dh = true);
    d = d.queue;
    $h(ai.bind(null, c, d, a), [a]);
    if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
      c.flags |= 2048;
      bi(9, ci.bind(null, c, d, e, b), void 0, null);
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(c, b, e);
    }
    return e;
  }
  function di(a, b, c) {
    a.flags |= 16384;
    a = { getSnapshot: b, value: c };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
  }
  function ci(a, b, c, d) {
    b.value = c;
    b.getSnapshot = d;
    ei(b) && fi(a);
  }
  function ai(a, b, c) {
    return c(function() {
      ei(b) && fi(a);
    });
  }
  function ei(a) {
    var b = a.getSnapshot;
    a = a.value;
    try {
      var c = b();
      return !He(a, c);
    } catch (d) {
      return true;
    }
  }
  function fi(a) {
    var b = ih(a, 1);
    null !== b && gi(b, a, 1, -1);
  }
  function hi(a) {
    var b = Th();
    "function" === typeof a && (a = a());
    b.memoizedState = b.baseState = a;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
    b.queue = a;
    a = a.dispatch = ii.bind(null, M, a);
    return [b.memoizedState, a];
  }
  function bi(a, b, c, d) {
    a = { tag: a, create: b, destroy: c, deps: d, next: null };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
    return a;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a, b, c, d) {
    var e = Th();
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
  }
  function li(a, b, c, d) {
    var e = Uh();
    d = void 0 === d ? null : d;
    var f = void 0;
    if (null !== N) {
      var g = N.memoizedState;
      f = g.destroy;
      if (null !== d && Mh(d, g.deps)) {
        e.memoizedState = bi(b, c, f, d);
        return;
      }
    }
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, f, d);
  }
  function mi(a, b) {
    return ki(8390656, 8, a, b);
  }
  function $h(a, b) {
    return li(2048, 8, a, b);
  }
  function ni(a, b) {
    return li(4, 2, a, b);
  }
  function oi(a, b) {
    return li(4, 4, a, b);
  }
  function pi(a, b) {
    if ("function" === typeof b) return a = a(), b(a), function() {
      b(null);
    };
    if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
      b.current = null;
    };
  }
  function qi(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return li(4, 4, pi.bind(null, b, a), c);
  }
  function ri() {
  }
  function si(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    c.memoizedState = [a, b];
    return a;
  }
  function ti(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    a = a();
    c.memoizedState = [a, b];
    return a;
  }
  function ui(a, b, c) {
    if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
    He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
    return b;
  }
  function vi(a, b) {
    var c = C;
    C = 0 !== c && 4 > c ? c : 4;
    a(true);
    var d = Gh.transition;
    Gh.transition = {};
    try {
      a(false), b();
    } finally {
      C = c, Gh.transition = d;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a, b, c) {
    var d = yi(a);
    c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, c);
    else if (c = hh(a, b, c, d), null !== c) {
      var e = R();
      gi(c, a, d, e);
      Bi(c, b, d);
    }
  }
  function ii(a, b, c) {
    var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, e);
    else {
      var f = a.alternate;
      if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
        var g = b.lastRenderedState, h2 = f(g, c);
        e.hasEagerState = true;
        e.eagerState = h2;
        if (He(h2, g)) {
          var k = b.interleaved;
          null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
          b.interleaved = e;
          return;
        }
      } catch (l) {
      } finally {
      }
      c = hh(a, b, e, d);
      null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
    }
  }
  function zi(a) {
    var b = a.alternate;
    return a === M || null !== b && b === M;
  }
  function Ai(a, b) {
    Jh = Ih = true;
    var c = a.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
  function Bi(a, b, c) {
    if (0 !== (c & 4194240)) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
    Th().memoizedState = [a, void 0 === b ? null : b];
    return a;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return ki(
      4194308,
      4,
      pi.bind(null, b, a),
      c
    );
  }, useLayoutEffect: function(a, b) {
    return ki(4194308, 4, a, b);
  }, useInsertionEffect: function(a, b) {
    return ki(4, 2, a, b);
  }, useMemo: function(a, b) {
    var c = Th();
    b = void 0 === b ? null : b;
    a = a();
    c.memoizedState = [a, b];
    return a;
  }, useReducer: function(a, b, c) {
    var d = Th();
    b = void 0 !== c ? c(b) : b;
    d.memoizedState = d.baseState = b;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
    d.queue = a;
    a = a.dispatch = xi.bind(null, M, a);
    return [d.memoizedState, a];
  }, useRef: function(a) {
    var b = Th();
    a = { current: a };
    return b.memoizedState = a;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
    return Th().memoizedState = a;
  }, useTransition: function() {
    var a = hi(false), b = a[0];
    a = vi.bind(null, a[1]);
    Th().memoizedState = a;
    return [b, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, b, c) {
    var d = M, e = Th();
    if (I) {
      if (void 0 === c) throw Error(p(407));
      c = c();
    } else {
      c = b();
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(d, b, c);
    }
    e.memoizedState = c;
    var f = { value: c, getSnapshot: b };
    e.queue = f;
    mi(ai.bind(
      null,
      d,
      f,
      a
    ), [a]);
    d.flags |= 2048;
    bi(9, ci.bind(null, d, f, c, b), void 0, null);
    return c;
  }, useId: function() {
    var a = Th(), b = Q.identifierPrefix;
    if (I) {
      var c = sg;
      var d = rg;
      c = (d & ~(1 << 32 - oc2(d) - 1)).toString(32) + c;
      b = ":" + b + "R" + c;
      c = Kh++;
      0 < c && (b += "H" + c.toString(32));
      b += ":";
    } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
    return a.memoizedState = b;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a) {
      var b = Uh();
      return ui(b, N.memoizedState, a);
    },
    useTransition: function() {
      var a = Wh(Vh)[0], b = Uh().memoizedState;
      return [a, b];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a) {
    var b = Uh();
    return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
  }, useTransition: function() {
    var a = Xh(Vh)[0], b = Uh().memoizedState;
    return [a, b];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a, b) {
    if (a && a.defaultProps) {
      b = A({}, b);
      a = a.defaultProps;
      for (var c in a) void 0 === b[c] && (b[c] = a[c]);
      return b;
    }
    return b;
  }
  function Di(a, b, c, d) {
    b = a.memoizedState;
    c = c(d, b);
    c = null === c || void 0 === c ? b : A({}, b, c);
    a.memoizedState = c;
    0 === a.lanes && (a.updateQueue.baseState = c);
  }
  var Ei = { isMounted: function(a) {
    return (a = a._reactInternals) ? Vb(a) === a : false;
  }, enqueueSetState: function(a, b, c) {
    a = a._reactInternals;
    var d = R(), e = yi(a), f = mh(d, e);
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueReplaceState: function(a, b, c) {
    a = a._reactInternals;
    var d = R(), e = yi(a), f = mh(d, e);
    f.tag = 1;
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueForceUpdate: function(a, b) {
    a = a._reactInternals;
    var c = R(), d = yi(a), e = mh(c, d);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    b = nh(a, e, d);
    null !== b && (gi(b, a, d, c), oh(b, a, d));
  } };
  function Fi(a, b, c, d, e, f, g) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
  }
  function Gi(a, b, c) {
    var d = false, e = Vf;
    var f = b.contextType;
    "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
    b = new b(c, f);
    a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Ei;
    a.stateNode = b;
    b._reactInternals = a;
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
    return b;
  }
  function Hi(a, b, c, d) {
    a = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
    b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
  }
  function Ii(a, b, c, d) {
    var e = a.stateNode;
    e.props = c;
    e.state = a.memoizedState;
    e.refs = {};
    kh(a);
    var f = b.contextType;
    "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
    e.state = a.memoizedState;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
    "function" === typeof e.componentDidMount && (a.flags |= 4194308);
  }
  function Ji(a, b) {
    try {
      var c = "", d = b;
      do
        c += Pa(d), d = d.return;
      while (d);
      var e = c;
    } catch (f) {
      e = "\nError generating stack: " + f.message + "\n" + f.stack;
    }
    return { value: a, source: b, stack: e, digest: null };
  }
  function Ki(a, b, c) {
    return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
  }
  function Li(a, b) {
    try {
      console.error(b.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    c.payload = { element: null };
    var d = b.value;
    c.callback = function() {
      Oi || (Oi = true, Pi = d);
      Li(a, b);
    };
    return c;
  }
  function Qi(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    var d = a.type.getDerivedStateFromError;
    if ("function" === typeof d) {
      var e = b.value;
      c.payload = function() {
        return d(e);
      };
      c.callback = function() {
        Li(a, b);
      };
    }
    var f = a.stateNode;
    null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
      Li(a, b);
      "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c2 = b.stack;
      this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
    });
    return c;
  }
  function Si(a, b, c) {
    var d = a.pingCache;
    if (null === d) {
      d = a.pingCache = new Mi();
      var e = /* @__PURE__ */ new Set();
      d.set(b, e);
    } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
    e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
  }
  function Ui(a) {
    do {
      var b;
      if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
      if (b) return a;
      a = a.return;
    } while (null !== a);
    return null;
  }
  function Vi(a, b, c, d, e) {
    if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
    a.flags |= 65536;
    a.lanes = e;
    return a;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a, b, c, d) {
    b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
  }
  function Yi(a, b, c, d, e) {
    c = c.render;
    var f = b.ref;
    ch(b, e);
    d = Nh(a, b, c, d, f, e);
    c = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && c && vg(b);
    b.flags |= 1;
    Xi(a, b, d, e);
    return b.child;
  }
  function $i(a, b, c, d, e) {
    if (null === a) {
      var f = c.type;
      if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
      a = Rg(c.type, null, d, b, b.mode, e);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    f = a.child;
    if (0 === (a.lanes & e)) {
      var g = f.memoizedProps;
      c = c.compare;
      c = null !== c ? c : Ie;
      if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
    }
    b.flags |= 1;
    a = Pg(f, d);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  function bj(a, b, c, d, e) {
    if (null !== a) {
      var f = a.memoizedProps;
      if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
      else return b.lanes = a.lanes, Zi(a, b, e);
    }
    return cj(a, b, c, d, e);
  }
  function dj(a, b, c) {
    var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
    if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
    else {
      if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d = null !== f ? f.baseLanes : c;
      G(ej, fj);
      fj |= d;
    }
    else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
    Xi(a, b, e, c);
    return b.child;
  }
  function gj(a, b) {
    var c = b.ref;
    if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
  }
  function cj(a, b, c, d, e) {
    var f = Zf(c) ? Xf : H.current;
    f = Yf(b, f);
    ch(b, e);
    c = Nh(a, b, c, d, f, e);
    d = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && d && vg(b);
    b.flags |= 1;
    Xi(a, b, c, e);
    return b.child;
  }
  function hj(a, b, c, d, e) {
    if (Zf(c)) {
      var f = true;
      cg(b);
    } else f = false;
    ch(b, e);
    if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
    else if (null === a) {
      var g = b.stateNode, h2 = b.memoizedProps;
      g.props = h2;
      var k = g.context, l = c.contextType;
      "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
      var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
      q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== d || k !== l) && Hi(b, g, d, l);
      jh = false;
      var r = b.memoizedState;
      g.state = r;
      qh(b, d, g, e);
      k = b.memoizedState;
      h2 !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h2 = jh || Fi(b, c, h2, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h2) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
    } else {
      g = b.stateNode;
      lh(a, b);
      h2 = b.memoizedProps;
      l = b.type === b.elementType ? h2 : Ci(b.type, h2);
      g.props = l;
      q = b.pendingProps;
      r = g.context;
      k = c.contextType;
      "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
      var y = c.getDerivedStateFromProps;
      (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== q || r !== k) && Hi(b, g, d, k);
      jh = false;
      r = b.memoizedState;
      g.state = r;
      qh(b, d, g, e);
      var n = b.memoizedState;
      h2 !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
    }
    return jj(a, b, c, d, f, e);
  }
  function jj(a, b, c, d, e, f) {
    gj(a, b);
    var g = 0 !== (b.flags & 128);
    if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
    d = b.stateNode;
    Wi.current = b;
    var h2 = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
    b.flags |= 1;
    null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h2, f)) : Xi(a, b, h2, f);
    b.memoizedState = d.state;
    e && dg(b, c, true);
    return b.child;
  }
  function kj(a) {
    var b = a.stateNode;
    b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
    yh(a, b.containerInfo);
  }
  function lj(a, b, c, d, e) {
    Ig();
    Jg(e);
    b.flags |= 256;
    Xi(a, b, c, d);
    return b.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function oj(a, b, c) {
    var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h2;
    (h2 = g) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
    if (h2) f = true, b.flags &= -129;
    else if (null === a || null !== a.memoizedState) e |= 1;
    G(L, e & 1);
    if (null === a) {
      Eg(b);
      a = b.memoizedState;
      if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
      g = d.children;
      a = d.fallback;
      return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
    }
    e = a.memoizedState;
    if (null !== e && (h2 = e.dehydrated, null !== h2)) return rj(a, b, g, d, h2, e, c);
    if (f) {
      f = d.fallback;
      g = b.mode;
      e = a.child;
      h2 = e.sibling;
      var k = { mode: "hidden", children: d.children };
      0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
      null !== h2 ? f = Pg(h2, f) : (f = Tg(f, g, c, null), f.flags |= 2);
      f.return = b;
      d.return = b;
      d.sibling = f;
      b.child = d;
      d = f;
      f = b.child;
      g = a.child.memoizedState;
      g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
      f.memoizedState = g;
      f.childLanes = a.childLanes & ~c;
      b.memoizedState = mj;
      return d;
    }
    f = a.child;
    a = f.sibling;
    d = Pg(f, { mode: "visible", children: d.children });
    0 === (b.mode & 1) && (d.lanes = c);
    d.return = b;
    d.sibling = null;
    null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
    b.child = d;
    b.memoizedState = null;
    return d;
  }
  function qj(a, b) {
    b = pj({ mode: "visible", children: b }, a.mode, 0, null);
    b.return = a;
    return a.child = b;
  }
  function sj(a, b, c, d) {
    null !== d && Jg(d);
    Ug(b, a.child, null, c);
    a = qj(b, b.pendingProps.children);
    a.flags |= 2;
    b.memoizedState = null;
    return a;
  }
  function rj(a, b, c, d, e, f, g) {
    if (c) {
      if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
      if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
      f = d.fallback;
      e = b.mode;
      d = pj({ mode: "visible", children: d.children }, e, 0, null);
      f = Tg(f, e, g, null);
      f.flags |= 2;
      d.return = b;
      f.return = b;
      d.sibling = f;
      b.child = d;
      0 !== (b.mode & 1) && Ug(b, a.child, null, g);
      b.child.memoizedState = nj(g);
      b.memoizedState = mj;
      return f;
    }
    if (0 === (b.mode & 1)) return sj(a, b, g, null);
    if ("$!" === e.data) {
      d = e.nextSibling && e.nextSibling.dataset;
      if (d) var h2 = d.dgst;
      d = h2;
      f = Error(p(419));
      d = Ki(f, d, void 0);
      return sj(a, b, g, d);
    }
    h2 = 0 !== (g & a.childLanes);
    if (dh || h2) {
      d = Q;
      if (null !== d) {
        switch (g & -g) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
        0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
      }
      tj();
      d = Ki(Error(p(421)));
      return sj(a, b, g, d);
    }
    if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
    a = f.treeContext;
    yg = Lf(e.nextSibling);
    xg = b;
    I = true;
    zg = null;
    null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
    b = qj(b, d.children);
    b.flags |= 4096;
    return b;
  }
  function vj(a, b, c) {
    a.lanes |= b;
    var d = a.alternate;
    null !== d && (d.lanes |= b);
    bh(a.return, b, c);
  }
  function wj(a, b, c, d, e) {
    var f = a.memoizedState;
    null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
  }
  function xj(a, b, c) {
    var d = b.pendingProps, e = d.revealOrder, f = d.tail;
    Xi(a, b, d.children, c);
    d = L.current;
    if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
    else {
      if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
        if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
        else if (19 === a.tag) vj(a, c, b);
        else if (null !== a.child) {
          a.child.return = a;
          a = a.child;
          continue;
        }
        if (a === b) break a;
        for (; null === a.sibling; ) {
          if (null === a.return || a.return === b) break a;
          a = a.return;
        }
        a.sibling.return = a.return;
        a = a.sibling;
      }
      d &= 1;
    }
    G(L, d);
    if (0 === (b.mode & 1)) b.memoizedState = null;
    else switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        wj(b, false, e, c, f);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a = e.alternate;
          if (null !== a && null === Ch(a)) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        wj(b, true, c, null, f);
        break;
      case "together":
        wj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
    return b.child;
  }
  function ij(a, b) {
    0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function Zi(a, b, c) {
    null !== a && (b.dependencies = a.dependencies);
    rh |= b.lanes;
    if (0 === (c & b.childLanes)) return null;
    if (null !== a && b.child !== a.child) throw Error(p(153));
    if (null !== b.child) {
      a = b.child;
      c = Pg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  function yj(a, b, c) {
    switch (b.tag) {
      case 3:
        kj(b);
        Ig();
        break;
      case 5:
        Ah(b);
        break;
      case 1:
        Zf(b.type) && cg(b);
        break;
      case 4:
        yh(b, b.stateNode.containerInfo);
        break;
      case 10:
        var d = b.type._context, e = b.memoizedProps.value;
        G(Wg, d._currentValue);
        d._currentValue = e;
        break;
      case 13:
        d = b.memoizedState;
        if (null !== d) {
          if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
          if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
          G(L, L.current & 1);
          a = Zi(a, b, c);
          return null !== a ? a.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d = 0 !== (c & b.childLanes);
        if (0 !== (a.flags & 128)) {
          if (d) return xj(a, b, c);
          b.flags |= 128;
        }
        e = b.memoizedState;
        null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
        G(L, L.current);
        if (d) break;
        else return null;
      case 22:
      case 23:
        return b.lanes = 0, dj(a, b, c);
    }
    return Zi(a, b, c);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a, b) {
    for (var c = b.child; null !== c; ) {
      if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
      else if (4 !== c.tag && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }
      if (c === b) break;
      for (; null === c.sibling; ) {
        if (null === c.return || c.return === b) return;
        c = c.return;
      }
      c.sibling.return = c.return;
      c = c.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a, b, c, d) {
    var e = a.memoizedProps;
    if (e !== d) {
      a = b.stateNode;
      xh(uh.current);
      var f = null;
      switch (c) {
        case "input":
          e = Ya(a, e);
          d = Ya(a, d);
          f = [];
          break;
        case "select":
          e = A({}, e, { value: void 0 });
          d = A({}, d, { value: void 0 });
          f = [];
          break;
        case "textarea":
          e = gb(a, e);
          d = gb(a, d);
          f = [];
          break;
        default:
          "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
      }
      ub(c, d);
      var g;
      c = null;
      for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h2 = e[l];
        for (g in h2) h2.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
      for (l in d) {
        var k = d[l];
        h2 = null != e ? e[l] : void 0;
        if (d.hasOwnProperty(l) && k !== h2 && (null != k || null != h2)) if ("style" === l) if (h2) {
          for (g in h2) !h2.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          for (g in k) k.hasOwnProperty(g) && h2[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
        } else c || (f || (f = []), f.push(
          l,
          c
        )), c = k;
        else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k && h2 !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h2 === k || (f = [])) : (f = f || []).push(l, k));
      }
      c && (f = f || []).push("style", c);
      var l = f;
      if (b.updateQueue = l) b.flags |= 4;
    }
  };
  Cj = function(a, b, c, d) {
    c !== d && (b.flags |= 4);
  };
  function Dj(a, b) {
    if (!I) switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
  }
  function S(a) {
    var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
    if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
    else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
    a.subtreeFlags |= d;
    a.childLanes = c;
    return b;
  }
  function Ej(a, b, c) {
    var d = b.pendingProps;
    wg(b);
    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b), null;
      case 1:
        return Zf(b.type) && $f(), S(b), null;
      case 3:
        d = b.stateNode;
        zh();
        E(Wf);
        E(H);
        Eh();
        d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
        if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a, b);
        S(b);
        return null;
      case 5:
        Bh(b);
        var e = xh(wh.current);
        c = b.type;
        if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d) {
            if (null === b.stateNode) throw Error(p(166));
            S(b);
            return null;
          }
          a = xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.type;
            var f = b.memoizedProps;
            d[Of] = b;
            d[Pf] = f;
            a = 0 !== (b.mode & 1);
            switch (c) {
              case "dialog":
                D("cancel", d);
                D("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], d);
                break;
              case "source":
                D("error", d);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d
                );
                D("load", d);
                break;
              case "details":
                D("toggle", d);
                break;
              case "input":
                Za(d, f);
                D("invalid", d);
                break;
              case "select":
                d._wrapperState = { wasMultiple: !!f.multiple };
                D("invalid", d);
                break;
              case "textarea":
                hb(d, f), D("invalid", d);
            }
            ub(c, f);
            e = null;
            for (var g in f) if (f.hasOwnProperty(g)) {
              var h2 = f[g];
              "children" === g ? "string" === typeof h2 ? d.textContent !== h2 && (true !== f.suppressHydrationWarning && Af(d.textContent, h2, a), e = ["children", h2]) : "number" === typeof h2 && d.textContent !== "" + h2 && (true !== f.suppressHydrationWarning && Af(
                d.textContent,
                h2,
                a
              ), e = ["children", "" + h2]) : ea.hasOwnProperty(g) && null != h2 && "onScroll" === g && D("scroll", d);
            }
            switch (c) {
              case "input":
                Va(d);
                db(d, f, true);
                break;
              case "textarea":
                Va(d);
                jb(d);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f.onClick && (d.onclick = Bf);
            }
            d = e;
            b.updateQueue = d;
            null !== d && (b.flags |= 4);
          } else {
            g = 9 === e.nodeType ? e : e.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
            "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
            a[Of] = b;
            a[Pf] = d;
            zj(a, b, false, false);
            b.stateNode = a;
            a: {
              g = vb(c, d);
              switch (c) {
                case "dialog":
                  D("cancel", a);
                  D("close", a);
                  e = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a);
                  e = d;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], a);
                  e = d;
                  break;
                case "source":
                  D("error", a);
                  e = d;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a
                  );
                  D("load", a);
                  e = d;
                  break;
                case "details":
                  D("toggle", a);
                  e = d;
                  break;
                case "input":
                  Za(a, d);
                  e = Ya(a, d);
                  D("invalid", a);
                  break;
                case "option":
                  e = d;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!d.multiple };
                  e = A({}, d, { value: void 0 });
                  D("invalid", a);
                  break;
                case "textarea":
                  hb(a, d);
                  e = gb(a, d);
                  D("invalid", a);
                  break;
                default:
                  e = d;
              }
              ub(c, e);
              h2 = e;
              for (f in h2) if (h2.hasOwnProperty(f)) {
                var k = h2[f];
                "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta2(a, f, k, g));
              }
              switch (c) {
                case "input":
                  Va(a);
                  db(a, d, false);
                  break;
                case "textarea":
                  Va(a);
                  jb(a);
                  break;
                case "option":
                  null != d.value && a.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a.multiple = !!d.multiple;
                  f = d.value;
                  null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                    a,
                    !!d.multiple,
                    d.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e.onClick && (a.onclick = Bf);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break a;
                case "img":
                  d = true;
                  break a;
                default:
                  d = false;
              }
            }
            d && (b.flags |= 4);
          }
          null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        }
        S(b);
        return null;
      case 6:
        if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
        else {
          if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
          c = xh(wh.current);
          xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.memoizedProps;
            d[Of] = b;
            if (f = d.nodeValue !== c) {
              if (a = xg, null !== a) switch (a.tag) {
                case 3:
                  Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
              }
            }
            f && (b.flags |= 4);
          } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
        }
        S(b);
        return null;
      case 13:
        E(L);
        d = b.memoizedState;
        if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
          else if (f = Gg(b), null !== d && null !== d.dehydrated) {
            if (null === a) {
              if (!f) throw Error(p(318));
              f = b.memoizedState;
              f = null !== f ? f.dehydrated : null;
              if (!f) throw Error(p(317));
              f[Of] = b;
            } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
            S(b);
            f = false;
          } else null !== zg && (Fj(zg), zg = null), f = true;
          if (!f) return b.flags & 65536 ? b : null;
        }
        if (0 !== (b.flags & 128)) return b.lanes = c, b;
        d = null !== d;
        d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b.updateQueue && (b.flags |= 4);
        S(b);
        return null;
      case 4:
        return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
      case 10:
        return ah(b.type._context), S(b), null;
      case 17:
        return Zf(b.type) && $f(), S(b), null;
      case 19:
        E(L);
        f = b.memoizedState;
        if (null === f) return S(b), null;
        d = 0 !== (b.flags & 128);
        g = f.rendering;
        if (null === g) if (d) Dj(f, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
            g = Ch(a);
            if (null !== g) {
              b.flags |= 128;
              Dj(f, false);
              d = g.updateQueue;
              null !== d && (b.updateQueue = d, b.flags |= 4);
              b.subtreeFlags = 0;
              d = c;
              for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
              G(L, L.current & 1 | 2);
              return b.child;
            }
            a = a.sibling;
          }
          null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
        }
        else {
          if (!d) if (a = Ch(g), null !== a) {
            if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
          } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
          f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
        }
        if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
        S(b);
        return null;
      case 22:
      case 23:
        return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p(156, b.tag));
  }
  function Ij(a, b) {
    wg(b);
    switch (b.tag) {
      case 1:
        return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 3:
        return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
      case 5:
        return Bh(b), null;
      case 13:
        E(L);
        a = b.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          if (null === b.alternate) throw Error(p(340));
          Ig();
        }
        a = b.flags;
        return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V2 = null;
  function Lj(a, b) {
    var c = a.ref;
    if (null !== c) if ("function" === typeof c) try {
      c(null);
    } catch (d) {
      W(a, b, d);
    }
    else c.current = null;
  }
  function Mj(a, b, c) {
    try {
      c();
    } catch (d) {
      W(a, b, d);
    }
  }
  var Nj = false;
  function Oj(a, b) {
    Cf = dd;
    a = Me();
    if (Ne(a)) {
      if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
      else a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d = c.getSelection && c.getSelection();
        if (d && 0 !== d.rangeCount) {
          c = d.anchorNode;
          var e = d.anchorOffset, f = d.focusNode;
          d = d.focusOffset;
          try {
            c.nodeType, f.nodeType;
          } catch (F) {
            c = null;
            break a;
          }
          var g = 0, h2 = -1, k = -1, l = 0, m = 0, q = a, r = null;
          b: for (; ; ) {
            for (var y; ; ) {
              q !== c || 0 !== e && 3 !== q.nodeType || (h2 = g + e);
              q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
              3 === q.nodeType && (g += q.nodeValue.length);
              if (null === (y = q.firstChild)) break;
              r = q;
              q = y;
            }
            for (; ; ) {
              if (q === a) break b;
              r === c && ++l === e && (h2 = g);
              r === f && ++m === d && (k = g);
              if (null !== (y = q.nextSibling)) break;
              q = r;
              r = q.parentNode;
            }
            q = y;
          }
          c = -1 === h2 || -1 === k ? null : { start: h2, end: k };
        } else c = null;
      }
      c = c || { start: 0, end: 0 };
    } else c = null;
    Df = { focusedElem: a, selectionRange: c };
    dd = false;
    for (V2 = b; null !== V2; ) if (b = V2, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V2 = a;
    else for (; null !== V2; ) {
      b = V2;
      try {
        var n = b.alternate;
        if (0 !== (b.flags & 1024)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n) {
              var t2 = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Ci(b.type, t2), J);
              x.__reactInternalSnapshotBeforeUpdate = w;
            }
            break;
          case 3:
            var u = b.stateNode.containerInfo;
            1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p(163));
        }
      } catch (F) {
        W(b, b.return, F);
      }
      a = b.sibling;
      if (null !== a) {
        a.return = b.return;
        V2 = a;
        break;
      }
      V2 = b.return;
    }
    n = Nj;
    Nj = false;
    return n;
  }
  function Pj(a, b, c) {
    var d = b.updateQueue;
    d = null !== d ? d.lastEffect : null;
    if (null !== d) {
      var e = d = d.next;
      do {
        if ((e.tag & a) === a) {
          var f = e.destroy;
          e.destroy = void 0;
          void 0 !== f && Mj(b, c, f);
        }
        e = e.next;
      } while (e !== d);
    }
  }
  function Qj(a, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;
    if (null !== b) {
      var c = b = b.next;
      do {
        if ((c.tag & a) === a) {
          var d = c.create;
          c.destroy = d();
        }
        c = c.next;
      } while (c !== b);
    }
  }
  function Rj(a) {
    var b = a.ref;
    if (null !== b) {
      var c = a.stateNode;
      switch (a.tag) {
        case 5:
          a = c;
          break;
        default:
          a = c;
      }
      "function" === typeof b ? b(a) : b.current = a;
    }
  }
  function Sj(a) {
    var b = a.alternate;
    null !== b && (a.alternate = null, Sj(b));
    a.child = null;
    a.deletions = null;
    a.sibling = null;
    5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
    a.stateNode = null;
    a.return = null;
    a.dependencies = null;
    a.memoizedProps = null;
    a.memoizedState = null;
    a.pendingProps = null;
    a.stateNode = null;
    a.updateQueue = null;
  }
  function Tj(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }
  function Uj(a) {
    a: for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Tj(a.return)) return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2) continue a;
        if (null === a.child || 4 === a.tag) continue a;
        else a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function Vj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
    else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
  }
  function Wj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
    else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
  }
  var X = null, Xj = false;
  function Yj(a, b, c) {
    for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
  }
  function Zj(a, b, c) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c);
    } catch (h2) {
    }
    switch (c.tag) {
      case 5:
        U || Lj(c, b);
      case 6:
        var d = X, e = Xj;
        X = null;
        Yj(a, b, c);
        X = d;
        Xj = e;
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
        break;
      case 4:
        d = X;
        e = Xj;
        X = c.stateNode.containerInfo;
        Xj = true;
        Yj(a, b, c);
        X = d;
        Xj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
          e = d = d.next;
          do {
            var f = e, g = f.destroy;
            f = f.tag;
            void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
            e = e.next;
          } while (e !== d);
        }
        Yj(a, b, c);
        break;
      case 1:
        if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
          d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
        } catch (h2) {
          W(c, b, h2);
        }
        Yj(a, b, c);
        break;
      case 21:
        Yj(a, b, c);
        break;
      case 22:
        c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
        break;
      default:
        Yj(a, b, c);
    }
  }
  function ak(a) {
    var b = a.updateQueue;
    if (null !== b) {
      a.updateQueue = null;
      var c = a.stateNode;
      null === c && (c = a.stateNode = new Kj());
      b.forEach(function(b2) {
        var d = bk.bind(null, a, b2);
        c.has(b2) || (c.add(b2), b2.then(d, d));
      });
    }
  }
  function ck(a, b) {
    var c = b.deletions;
    if (null !== c) for (var d = 0; d < c.length; d++) {
      var e = c[d];
      try {
        var f = a, g = b, h2 = g;
        a: for (; null !== h2; ) {
          switch (h2.tag) {
            case 5:
              X = h2.stateNode;
              Xj = false;
              break a;
            case 3:
              X = h2.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X = h2.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h2 = h2.return;
        }
        if (null === X) throw Error(p(160));
        Zj(f, g, e);
        X = null;
        Xj = false;
        var k = e.alternate;
        null !== k && (k.return = null);
        e.return = null;
      } catch (l) {
        W(e, b, l);
      }
    }
    if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
  }
  function dk(a, b) {
    var c = a.alternate, d = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b, a);
        ek(a);
        if (d & 4) {
          try {
            Pj(3, a, a.return), Qj(3, a);
          } catch (t2) {
            W(a, a.return, t2);
          }
          try {
            Pj(5, a, a.return);
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 1:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        break;
      case 5:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        if (a.flags & 32) {
          var e = a.stateNode;
          try {
            ob(e, "");
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        if (d & 4 && (e = a.stateNode, null != e)) {
          var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h2 = a.type, k = a.updateQueue;
          a.updateQueue = null;
          if (null !== k) try {
            "input" === h2 && "radio" === f.type && null != f.name && ab(e, f);
            vb(h2, g);
            var l = vb(h2, f);
            for (g = 0; g < k.length; g += 2) {
              var m = k[g], q = k[g + 1];
              "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta2(e, m, q, l);
            }
            switch (h2) {
              case "input":
                bb(e, f);
                break;
              case "textarea":
                ib(e, f);
                break;
              case "select":
                var r = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f.multiple;
                var y = f.value;
                null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                  e,
                  !!f.multiple,
                  f.defaultValue,
                  true
                ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
            }
            e[Pf] = f;
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 6:
        ck(b, a);
        ek(a);
        if (d & 4) {
          if (null === a.stateNode) throw Error(p(162));
          e = a.stateNode;
          f = a.memoizedProps;
          try {
            e.nodeValue = f;
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 3:
        ck(b, a);
        ek(a);
        if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
          bd(b.containerInfo);
        } catch (t2) {
          W(a, a.return, t2);
        }
        break;
      case 4:
        ck(b, a);
        ek(a);
        break;
      case 13:
        ck(b, a);
        ek(a);
        e = a.child;
        e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
        d & 4 && ak(a);
        break;
      case 22:
        m = null !== c && null !== c.memoizedState;
        a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
        ek(a);
        if (d & 8192) {
          l = null !== a.memoizedState;
          if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V2 = a, m = a.child; null !== m; ) {
            for (q = V2 = m; null !== V2; ) {
              r = V2;
              y = r.child;
              switch (r.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r, r.return);
                  break;
                case 1:
                  Lj(r, r.return);
                  var n = r.stateNode;
                  if ("function" === typeof n.componentWillUnmount) {
                    d = r;
                    c = r.return;
                    try {
                      b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                    } catch (t2) {
                      W(d, c, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r, r.return);
                  break;
                case 22:
                  if (null !== r.memoizedState) {
                    gk(q);
                    continue;
                  }
              }
              null !== y ? (y.return = r, V2 = y) : gk(q);
            }
            m = m.sibling;
          }
          a: for (m = null, q = a; ; ) {
            if (5 === q.tag) {
              if (null === m) {
                m = q;
                try {
                  e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h2 = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h2.style.display = rb("display", g));
                } catch (t2) {
                  W(a, a.return, t2);
                }
              }
            } else if (6 === q.tag) {
              if (null === m) try {
                q.stateNode.nodeValue = l ? "" : q.memoizedProps;
              } catch (t2) {
                W(a, a.return, t2);
              }
            } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
              q.child.return = q;
              q = q.child;
              continue;
            }
            if (q === a) break a;
            for (; null === q.sibling; ) {
              if (null === q.return || q.return === a) break a;
              m === q && (m = null);
              q = q.return;
            }
            m === q && (m = null);
            q.sibling.return = q.return;
            q = q.sibling;
          }
        }
        break;
      case 19:
        ck(b, a);
        ek(a);
        d & 4 && ak(a);
        break;
      case 21:
        break;
      default:
        ck(
          b,
          a
        ), ek(a);
    }
  }
  function ek(a) {
    var b = a.flags;
    if (b & 2) {
      try {
        a: {
          for (var c = a.return; null !== c; ) {
            if (Tj(c)) {
              var d = c;
              break a;
            }
            c = c.return;
          }
          throw Error(p(160));
        }
        switch (d.tag) {
          case 5:
            var e = d.stateNode;
            d.flags & 32 && (ob(e, ""), d.flags &= -33);
            var f = Uj(a);
            Wj(a, f, e);
            break;
          case 3:
          case 4:
            var g = d.stateNode.containerInfo, h2 = Uj(a);
            Vj(a, h2, g);
            break;
          default:
            throw Error(p(161));
        }
      } catch (k) {
        W(a, a.return, k);
      }
      a.flags &= -3;
    }
    b & 4096 && (a.flags &= -4097);
  }
  function hk(a, b, c) {
    V2 = a;
    ik(a);
  }
  function ik(a, b, c) {
    for (var d = 0 !== (a.mode & 1); null !== V2; ) {
      var e = V2, f = e.child;
      if (22 === e.tag && d) {
        var g = null !== e.memoizedState || Jj;
        if (!g) {
          var h2 = e.alternate, k = null !== h2 && null !== h2.memoizedState || U;
          h2 = Jj;
          var l = U;
          Jj = g;
          if ((U = k) && !l) for (V2 = e; null !== V2; ) g = V2, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V2 = k) : jk(e);
          for (; null !== f; ) V2 = f, ik(f), f = f.sibling;
          V2 = e;
          Jj = h2;
          U = l;
        }
        kk(a);
      } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V2 = f) : kk(a);
    }
  }
  function kk(a) {
    for (; null !== V2; ) {
      var b = V2;
      if (0 !== (b.flags & 8772)) {
        var c = b.alternate;
        try {
          if (0 !== (b.flags & 8772)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b);
              break;
            case 1:
              var d = b.stateNode;
              if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
              else {
                var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
              }
              var f = b.updateQueue;
              null !== f && sh(b, f, d);
              break;
            case 3:
              var g = b.updateQueue;
              if (null !== g) {
                c = null;
                if (null !== b.child) switch (b.child.tag) {
                  case 5:
                    c = b.child.stateNode;
                    break;
                  case 1:
                    c = b.child.stateNode;
                }
                sh(b, g, c);
              }
              break;
            case 5:
              var h2 = b.stateNode;
              if (null === c && b.flags & 4) {
                c = h2;
                var k = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k.autoFocus && c.focus();
                    break;
                  case "img":
                    k.src && (c.src = k.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l = b.alternate;
                if (null !== l) {
                  var m = l.memoizedState;
                  if (null !== m) {
                    var q = m.dehydrated;
                    null !== q && bd(q);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p(163));
          }
          U || b.flags & 512 && Rj(b);
        } catch (r) {
          W(b, b.return, r);
        }
      }
      if (b === a) {
        V2 = null;
        break;
      }
      c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V2 = c;
        break;
      }
      V2 = b.return;
    }
  }
  function gk(a) {
    for (; null !== V2; ) {
      var b = V2;
      if (b === a) {
        V2 = null;
        break;
      }
      var c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V2 = c;
        break;
      }
      V2 = b.return;
    }
  }
  function jk(a) {
    for (; null !== V2; ) {
      var b = V2;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c = b.return;
            try {
              Qj(4, b);
            } catch (k) {
              W(b, c, k);
            }
            break;
          case 1:
            var d = b.stateNode;
            if ("function" === typeof d.componentDidMount) {
              var e = b.return;
              try {
                d.componentDidMount();
              } catch (k) {
                W(b, e, k);
              }
            }
            var f = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, f, k);
            }
            break;
          case 5:
            var g = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, g, k);
            }
        }
      } catch (k) {
        W(b, b.return, k);
      }
      if (b === a) {
        V2 = null;
        break;
      }
      var h2 = b.sibling;
      if (null !== h2) {
        h2.return = b.return;
        V2 = h2;
        break;
      }
      V2 = b.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk2 = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a) {
    if (0 === (a.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a = C;
    if (0 !== a) return a;
    a = window.event;
    a = void 0 === a ? 16 : jd(a.type);
    return a;
  }
  function gi(a, b, c, d) {
    if (50 < yk) throw yk = 0, zk = null, Error(p(185));
    Ac(a, c, d);
    if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a, b) {
    var c = a.callbackNode;
    wc(a, b);
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
    else if (b = d & -d, a.callbackPriority !== b) {
      null != c && bc(c);
      if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c = null;
      else {
        switch (Dc(d)) {
          case 1:
            c = fc;
            break;
          case 4:
            c = gc;
            break;
          case 16:
            c = hc;
            break;
          case 536870912:
            c = jc;
            break;
          default:
            c = hc;
        }
        c = Fk(c, Gk.bind(null, a));
      }
      a.callbackPriority = b;
      a.callbackNode = c;
    }
  }
  function Gk(a, b) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p(327));
    var c = a.callbackNode;
    if (Hk() && a.callbackNode !== c) return null;
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) return null;
    if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
    else {
      b = d;
      var e = K;
      K |= 2;
      var f = Jk();
      if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
      do
        try {
          Lk();
          break;
        } catch (h2) {
          Mk(a, h2);
        }
      while (1);
      $g();
      mk.current = f;
      K = e;
      null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
    }
    if (0 !== b) {
      2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
      if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
      if (6 === b) Ck(a, d);
      else {
        e = a.current.alternate;
        if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
        a.finishedWork = e;
        a.finishedLanes = d;
        switch (b) {
          case 0:
          case 1:
            throw Error(p(345));
          case 2:
            Pk(a, tk2, uk);
            break;
          case 3:
            Ck(a, d);
            if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
              if (0 !== uc(a, 0)) break;
              e = a.suspendedLanes;
              if ((e & d) !== d) {
                R();
                a.pingedLanes |= a.suspendedLanes & e;
                break;
              }
              a.timeoutHandle = Ff(Pk.bind(null, a, tk2, uk), b);
              break;
            }
            Pk(a, tk2, uk);
            break;
          case 4:
            Ck(a, d);
            if ((d & 4194240) === d) break;
            b = a.eventTimes;
            for (e = -1; 0 < d; ) {
              var g = 31 - oc2(d);
              f = 1 << g;
              g = b[g];
              g > e && (e = g);
              d &= ~f;
            }
            d = e;
            d = B() - d;
            d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
            if (10 < d) {
              a.timeoutHandle = Ff(Pk.bind(null, a, tk2, uk), d);
              break;
            }
            Pk(a, tk2, uk);
            break;
          case 5:
            Pk(a, tk2, uk);
            break;
          default:
            throw Error(p(329));
        }
      }
    }
    Dk(a, B());
    return a.callbackNode === c ? Gk.bind(null, a) : null;
  }
  function Nk(a, b) {
    var c = sk;
    a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
    a = Ik(a, b);
    2 !== a && (b = tk2, tk2 = c, null !== b && Fj(b));
    return a;
  }
  function Fj(a) {
    null === tk2 ? tk2 = a : tk2.push.apply(tk2, a);
  }
  function Ok(a) {
    for (var b = a; ; ) {
      if (b.flags & 16384) {
        var c = b.updateQueue;
        if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
          var e = c[d], f = e.getSnapshot;
          e = e.value;
          try {
            if (!He(f(), e)) return false;
          } catch (g) {
            return false;
          }
        }
      }
      c = b.child;
      if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
      else {
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return true;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
    }
    return true;
  }
  function Ck(a, b) {
    b &= ~rk;
    b &= ~qk;
    a.suspendedLanes |= b;
    a.pingedLanes &= ~b;
    for (a = a.expirationTimes; 0 < b; ) {
      var c = 31 - oc2(b), d = 1 << c;
      a[c] = -1;
      b &= ~d;
    }
  }
  function Ek(a) {
    if (0 !== (K & 6)) throw Error(p(327));
    Hk();
    var b = uc(a, 0);
    if (0 === (b & 1)) return Dk(a, B()), null;
    var c = Ik(a, b);
    if (0 !== a.tag && 2 === c) {
      var d = xc(a);
      0 !== d && (b = d, c = Nk(a, d));
    }
    if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
    if (6 === c) throw Error(p(345));
    a.finishedWork = a.current.alternate;
    a.finishedLanes = b;
    Pk(a, tk2, uk);
    Dk(a, B());
    return null;
  }
  function Qk(a, b) {
    var c = K;
    K |= 1;
    try {
      return a(b);
    } finally {
      K = c, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b = K;
    K |= 1;
    var c = ok.transition, d = C;
    try {
      if (ok.transition = null, C = 1, a) return a();
    } finally {
      C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a, b) {
    a.finishedWork = null;
    a.finishedLanes = 0;
    var c = a.timeoutHandle;
    -1 !== c && (a.timeoutHandle = -1, Gf(c));
    if (null !== Y) for (c = Y.return; null !== c; ) {
      var d = c;
      wg(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c = c.return;
    }
    Q = a;
    Y = a = Pg(a.current, null);
    Z = fj = b;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk2 = sk = null;
    if (null !== fh) {
      for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
        c.interleaved = null;
        var e = d.next, f = c.pending;
        if (null !== f) {
          var g = f.next;
          f.next = e;
          d.next = g;
        }
        c.pending = d;
      }
      fh = null;
    }
    return a;
  }
  function Mk(a, b) {
    do {
      var c = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d = M.memoizedState; null !== d; ) {
            var e = d.queue;
            null !== e && (e.pending = null);
            d = d.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N = M = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c || null === c.return) {
          T = 1;
          pk = b;
          Y = null;
          break;
        }
        a: {
          var f = a, g = c.return, h2 = c, k = b;
          b = Z;
          h2.flags |= 32768;
          if (null !== k && "object" === typeof k && "function" === typeof k.then) {
            var l = k, m = h2, q = m.tag;
            if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
              var r = m.alternate;
              r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
            }
            var y = Ui(g);
            if (null !== y) {
              y.flags &= -257;
              Vi(y, g, h2, f, b);
              y.mode & 1 && Si(f, l, b);
              b = y;
              k = l;
              var n = b.updateQueue;
              if (null === n) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k);
                b.updateQueue = t2;
              } else n.add(k);
              break a;
            } else {
              if (0 === (b & 1)) {
                Si(f, l, b);
                tj();
                break a;
              }
              k = Error(p(426));
            }
          } else if (I && h2.mode & 1) {
            var J = Ui(g);
            if (null !== J) {
              0 === (J.flags & 65536) && (J.flags |= 256);
              Vi(J, g, h2, f, b);
              Jg(Ji(k, h2));
              break a;
            }
          }
          f = k = Ji(k, h2);
          4 !== T && (T = 2);
          null === sk ? sk = [f] : sk.push(f);
          f = g;
          do {
            switch (f.tag) {
              case 3:
                f.flags |= 65536;
                b &= -b;
                f.lanes |= b;
                var x = Ni(f, k, b);
                ph(f, x);
                break a;
              case 1:
                h2 = k;
                var w = f.type, u = f.stateNode;
                if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var F = Qi(f, h2, b);
                  ph(f, F);
                  break a;
                }
            }
            f = f.return;
          } while (null !== f);
        }
        Sk(c);
      } catch (na) {
        b = na;
        Y === c && null !== c && (Y = c = c.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a = mk.current;
    mk.current = Rh;
    return null === a ? Rh : a;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a, b) {
    var c = K;
    K |= 2;
    var d = Jk();
    if (Q !== a || Z !== b) uk = null, Kk(a, b);
    do
      try {
        Tk();
        break;
      } catch (e) {
        Mk(a, e);
      }
    while (1);
    $g();
    K = c;
    mk.current = d;
    if (null !== Y) throw Error(p(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a) {
    var b = Vk(a.alternate, a, fj);
    a.memoizedProps = a.pendingProps;
    null === b ? Sk(a) : Y = b;
    nk.current = null;
  }
  function Sk(a) {
    var b = a;
    do {
      var c = b.alternate;
      a = b.return;
      if (0 === (b.flags & 32768)) {
        if (c = Ej(c, b, fj), null !== c) {
          Y = c;
          return;
        }
      } else {
        c = Ij(c, b);
        if (null !== c) {
          c.flags &= 32767;
          Y = c;
          return;
        }
        if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b = b.sibling;
      if (null !== b) {
        Y = b;
        return;
      }
      Y = b = a;
    } while (null !== b);
    0 === T && (T = 5);
  }
  function Pk(a, b, c) {
    var d = C, e = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a, b, c, d);
    } finally {
      ok.transition = e, C = d;
    }
    return null;
  }
  function Wk(a, b, c, d) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p(327));
    c = a.finishedWork;
    var e = a.finishedLanes;
    if (null === c) return null;
    a.finishedWork = null;
    a.finishedLanes = 0;
    if (c === a.current) throw Error(p(177));
    a.callbackNode = null;
    a.callbackPriority = 0;
    var f = c.lanes | c.childLanes;
    Bc(a, f);
    a === Q && (Y = Q = null, Z = 0);
    0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f = 0 !== (c.flags & 15990);
    if (0 !== (c.subtreeFlags & 15990) || f) {
      f = ok.transition;
      ok.transition = null;
      var g = C;
      C = 1;
      var h2 = K;
      K |= 4;
      nk.current = null;
      Oj(a, c);
      dk(c, a);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a.current = c;
      hk(c);
      dc();
      K = h2;
      C = g;
      ok.transition = f;
    } else a.current = c;
    vk && (vk = false, wk = a, xk = e);
    f = a.pendingLanes;
    0 === f && (Ri = null);
    mc(c.stateNode);
    Dk(a, B());
    if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
    if (Oi) throw Oi = false, a = Pi, Pi = null, a;
    0 !== (xk & 1) && 0 !== a.tag && Hk();
    f = a.pendingLanes;
    0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a = Dc(xk), b = ok.transition, c = C;
      try {
        ok.transition = null;
        C = 16 > a ? 16 : a;
        if (null === wk) var d = false;
        else {
          a = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p(331));
          var e = K;
          K |= 4;
          for (V2 = a.current; null !== V2; ) {
            var f = V2, g = f.child;
            if (0 !== (V2.flags & 16)) {
              var h2 = f.deletions;
              if (null !== h2) {
                for (var k = 0; k < h2.length; k++) {
                  var l = h2[k];
                  for (V2 = l; null !== V2; ) {
                    var m = V2;
                    switch (m.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m, f);
                    }
                    var q = m.child;
                    if (null !== q) q.return = m, V2 = q;
                    else for (; null !== V2; ) {
                      m = V2;
                      var r = m.sibling, y = m.return;
                      Sj(m);
                      if (m === l) {
                        V2 = null;
                        break;
                      }
                      if (null !== r) {
                        r.return = y;
                        V2 = r;
                        break;
                      }
                      V2 = y;
                    }
                  }
                }
                var n = f.alternate;
                if (null !== n) {
                  var t2 = n.child;
                  if (null !== t2) {
                    n.child = null;
                    do {
                      var J = t2.sibling;
                      t2.sibling = null;
                      t2 = J;
                    } while (null !== t2);
                  }
                }
                V2 = f;
              }
            }
            if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V2 = g;
            else b: for (; null !== V2; ) {
              f = V2;
              if (0 !== (f.flags & 2048)) switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f, f.return);
              }
              var x = f.sibling;
              if (null !== x) {
                x.return = f.return;
                V2 = x;
                break b;
              }
              V2 = f.return;
            }
          }
          var w = a.current;
          for (V2 = w; null !== V2; ) {
            g = V2;
            var u = g.child;
            if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V2 = u;
            else b: for (g = w; null !== V2; ) {
              h2 = V2;
              if (0 !== (h2.flags & 2048)) try {
                switch (h2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h2);
                }
              } catch (na) {
                W(h2, h2.return, na);
              }
              if (h2 === g) {
                V2 = null;
                break b;
              }
              var F = h2.sibling;
              if (null !== F) {
                F.return = h2.return;
                V2 = F;
                break b;
              }
              V2 = h2.return;
            }
          }
          K = e;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
          d = true;
        }
        return d;
      } finally {
        C = c, ok.transition = b;
      }
    }
    return false;
  }
  function Xk(a, b, c) {
    b = Ji(c, b);
    b = Ni(a, b, 1);
    a = nh(a, b, 1);
    b = R();
    null !== a && (Ac(a, 1, b), Dk(a, b));
  }
  function W(a, b, c) {
    if (3 === a.tag) Xk(a, a, c);
    else for (; null !== b; ) {
      if (3 === b.tag) {
        Xk(b, a, c);
        break;
      } else if (1 === b.tag) {
        var d = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
          a = Ji(c, a);
          a = Qi(b, a, 1);
          b = nh(b, a, 1);
          a = R();
          null !== b && (Ac(b, 1, a), Dk(b, a));
          break;
        }
      }
      b = b.return;
    }
  }
  function Ti(a, b, c) {
    var d = a.pingCache;
    null !== d && d.delete(b);
    b = R();
    a.pingedLanes |= a.suspendedLanes & c;
    Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
    Dk(a, b);
  }
  function Yk(a, b) {
    0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c = R();
    a = ih(a, b);
    null !== a && (Ac(a, b, c), Dk(a, c));
  }
  function uj(a) {
    var b = a.memoizedState, c = 0;
    null !== b && (c = b.retryLane);
    Yk(a, c);
  }
  function bk(a, b) {
    var c = 0;
    switch (a.tag) {
      case 13:
        var d = a.stateNode;
        var e = a.memoizedState;
        null !== e && (c = e.retryLane);
        break;
      case 19:
        d = a.stateNode;
        break;
      default:
        throw Error(p(314));
    }
    null !== d && d.delete(b);
    Yk(a, c);
  }
  var Vk;
  Vk = function(a, b, c) {
    if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
      dh = 0 !== (a.flags & 131072) ? true : false;
    }
    else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
    b.lanes = 0;
    switch (b.tag) {
      case 2:
        var d = b.type;
        ij(a, b);
        a = b.pendingProps;
        var e = Yf(b, H.current);
        ch(b, c);
        e = Nh(null, b, d, a, e, c);
        var f = Sh();
        b.flags |= 1;
        "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
        return b;
      case 16:
        d = b.elementType;
        a: {
          ij(a, b);
          a = b.pendingProps;
          e = d._init;
          d = e(d._payload);
          b.type = d;
          e = b.tag = Zk(d);
          a = Ci(d, a);
          switch (e) {
            case 0:
              b = cj(null, b, d, a, c);
              break a;
            case 1:
              b = hj(null, b, d, a, c);
              break a;
            case 11:
              b = Yi(null, b, d, a, c);
              break a;
            case 14:
              b = $i(null, b, d, Ci(d.type, a), c);
              break a;
          }
          throw Error(p(
            306,
            d,
            ""
          ));
        }
        return b;
      case 0:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
      case 1:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
      case 3:
        a: {
          kj(b);
          if (null === a) throw Error(p(387));
          d = b.pendingProps;
          f = b.memoizedState;
          e = f.element;
          lh(a, b);
          qh(b, d, null, c);
          var g = b.memoizedState;
          d = g.element;
          if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
            e = Ji(Error(p(423)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else if (d !== e) {
            e = Ji(Error(p(424)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            Ig();
            if (d === e) {
              b = Zi(a, b, c);
              break a;
            }
            Xi(a, b, d, c);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
      case 6:
        return null === a && Eg(b), null;
      case 13:
        return oj(a, b, c);
      case 4:
        return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
      case 11:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
      case 7:
        return Xi(a, b, b.pendingProps, c), b.child;
      case 8:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 12:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 10:
        a: {
          d = b.type._context;
          e = b.pendingProps;
          f = b.memoizedProps;
          g = e.value;
          G(Wg, d._currentValue);
          d._currentValue = g;
          if (null !== f) if (He(f.value, g)) {
            if (f.children === e.children && !Wf.current) {
              b = Zi(a, b, c);
              break a;
            }
          } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
            var h2 = f.dependencies;
            if (null !== h2) {
              g = f.child;
              for (var k = h2.firstContext; null !== k; ) {
                if (k.context === d) {
                  if (1 === f.tag) {
                    k = mh(-1, c & -c);
                    k.tag = 2;
                    var l = f.updateQueue;
                    if (null !== l) {
                      l = l.shared;
                      var m = l.pending;
                      null === m ? k.next = k : (k.next = m.next, m.next = k);
                      l.pending = k;
                    }
                  }
                  f.lanes |= c;
                  k = f.alternate;
                  null !== k && (k.lanes |= c);
                  bh(
                    f.return,
                    c,
                    b
                  );
                  h2.lanes |= c;
                  break;
                }
                k = k.next;
              }
            } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
            else if (18 === f.tag) {
              g = f.return;
              if (null === g) throw Error(p(341));
              g.lanes |= c;
              h2 = g.alternate;
              null !== h2 && (h2.lanes |= c);
              bh(g, c, b);
              g = f.sibling;
            } else g = f.child;
            if (null !== g) g.return = f;
            else for (g = f; null !== g; ) {
              if (g === b) {
                g = null;
                break;
              }
              f = g.sibling;
              if (null !== f) {
                f.return = g.return;
                g = f;
                break;
              }
              g = g.return;
            }
            f = g;
          }
          Xi(a, b, e.children, c);
          b = b.child;
        }
        return b;
      case 9:
        return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
      case 14:
        return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
      case 15:
        return bj(a, b, b.type, b.pendingProps, c);
      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
      case 19:
        return xj(a, b, c);
      case 22:
        return dj(a, b, c);
    }
    throw Error(p(156, b.tag));
  };
  function Fk(a, b) {
    return ac(a, b);
  }
  function $k(a, b, c, d) {
    this.tag = a;
    this.key = c;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a, b, c, d) {
    return new $k(a, b, c, d);
  }
  function aj(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }
  function Zk(a) {
    if ("function" === typeof a) return aj(a) ? 1 : 0;
    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === Da) return 11;
      if (a === Ga) return 14;
    }
    return 2;
  }
  function Pg(a, b) {
    var c = a.alternate;
    null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
    c.flags = a.flags & 14680064;
    c.childLanes = a.childLanes;
    c.lanes = a.lanes;
    c.child = a.child;
    c.memoizedProps = a.memoizedProps;
    c.memoizedState = a.memoizedState;
    c.updateQueue = a.updateQueue;
    b = a.dependencies;
    c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
    c.sibling = a.sibling;
    c.index = a.index;
    c.ref = a.ref;
    return c;
  }
  function Rg(a, b, c, d, e, f) {
    var g = 2;
    d = a;
    if ("function" === typeof a) aj(a) && (g = 1);
    else if ("string" === typeof a) g = 5;
    else a: switch (a) {
      case ya:
        return Tg(c.children, e, f, b);
      case za:
        g = 8;
        e |= 8;
        break;
      case Aa:
        return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
      case Ea:
        return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
      case Fa:
        return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
      case Ia:
        return pj(c, e, f, b);
      default:
        if ("object" === typeof a && null !== a) switch (a.$$typeof) {
          case Ba:
            g = 10;
            break a;
          case Ca:
            g = 9;
            break a;
          case Da:
            g = 11;
            break a;
          case Ga:
            g = 14;
            break a;
          case Ha:
            g = 16;
            d = null;
            break a;
        }
        throw Error(p(130, null == a ? a : typeof a, ""));
    }
    b = Bg(g, c, b, e);
    b.elementType = a;
    b.type = d;
    b.lanes = f;
    return b;
  }
  function Tg(a, b, c, d) {
    a = Bg(7, a, d, b);
    a.lanes = c;
    return a;
  }
  function pj(a, b, c, d) {
    a = Bg(22, a, d, b);
    a.elementType = Ia;
    a.lanes = c;
    a.stateNode = { isHidden: false };
    return a;
  }
  function Qg(a, b, c) {
    a = Bg(6, a, null, b);
    a.lanes = c;
    return a;
  }
  function Sg(a, b, c) {
    b = Bg(4, null !== a.children ? a.children : [], a.key, b);
    b.lanes = c;
    b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
    return b;
  }
  function al(a, b, c, d, e) {
    this.tag = b;
    this.containerInfo = a;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d;
    this.onRecoverableError = e;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a, b, c, d, e, f, g, h2, k) {
    a = new al(a, b, c, h2, k);
    1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
    f = Bg(3, null, null, b);
    a.current = f;
    f.stateNode = a;
    f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f);
    return a;
  }
  function cl(a, b, c) {
    var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
  }
  function dl(a) {
    if (!a) return Vf;
    a = a._reactInternals;
    a: {
      if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
      var b = a;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (null !== b);
      throw Error(p(171));
    }
    if (1 === a.tag) {
      var c = a.type;
      if (Zf(c)) return bg(a, c, b);
    }
    return b;
  }
  function el(a, b, c, d, e, f, g, h2, k) {
    a = bl(c, d, true, a, e, f, g, h2, k);
    a.context = dl(null);
    c = a.current;
    d = R();
    e = yi(c);
    f = mh(d, e);
    f.callback = void 0 !== b && null !== b ? b : null;
    nh(c, f, e);
    a.current.lanes = e;
    Ac(a, e, d);
    Dk(a, d);
    return a;
  }
  function fl(a, b, c, d) {
    var e = b.current, f = R(), g = yi(e);
    c = dl(c);
    null === b.context ? b.context = c : b.pendingContext = c;
    b = mh(f, g);
    b.payload = { element: a };
    d = void 0 === d ? null : d;
    null !== d && (b.callback = d);
    a = nh(e, b, g);
    null !== a && (gi(a, e, g, f), oh(a, e, g));
    return g;
  }
  function gl(a) {
    a = a.current;
    if (!a.child) return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function hl(a, b) {
    a = a.memoizedState;
    if (null !== a && null !== a.dehydrated) {
      var c = a.retryLane;
      a.retryLane = 0 !== c && c < b ? c : b;
    }
  }
  function il(a, b) {
    hl(a, b);
    (a = a.alternate) && hl(a, b);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a) {
    console.error(a);
  };
  function ll(a) {
    this._internalRoot = a;
  }
  ml.prototype.render = ll.prototype.render = function(a) {
    var b = this._internalRoot;
    if (null === b) throw Error(p(409));
    fl(a, b, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a = this._internalRoot;
    if (null !== a) {
      this._internalRoot = null;
      var b = a.containerInfo;
      Rk(function() {
        fl(null, a, null, null);
      });
      b[uf] = null;
    }
  };
  function ml(a) {
    this._internalRoot = a;
  }
  ml.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var b = Hc();
      a = { blockedOn: null, target: a, priority: b };
      for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
      Qc.splice(c, 0, a);
      0 === c && Vc(a);
    }
  };
  function nl(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
  }
  function ol(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
  }
  function pl() {
  }
  function ql(a, b, c, d, e) {
    if (e) {
      if ("function" === typeof d) {
        var f = d;
        d = function() {
          var a2 = gl(g);
          f.call(a2);
        };
      }
      var g = el(b, d, a, 0, null, false, false, "", pl);
      a._reactRootContainer = g;
      a[uf] = g.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Rk();
      return g;
    }
    for (; e = a.lastChild; ) a.removeChild(e);
    if ("function" === typeof d) {
      var h2 = d;
      d = function() {
        var a2 = gl(k);
        h2.call(a2);
      };
    }
    var k = bl(a, 0, false, null, null, false, false, "", pl);
    a._reactRootContainer = k;
    a[uf] = k.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk(function() {
      fl(b, k, c, d);
    });
    return k;
  }
  function rl(a, b, c, d, e) {
    var f = c._reactRootContainer;
    if (f) {
      var g = f;
      if ("function" === typeof e) {
        var h2 = e;
        e = function() {
          var a2 = gl(g);
          h2.call(a2);
        };
      }
      fl(b, g, a, e);
    } else g = ql(c, b, a, e, d);
    return gl(g);
  }
  Ec = function(a) {
    switch (a.tag) {
      case 3:
        var b = a.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c = tc(b.pendingLanes);
          0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b2 = ih(a, 1);
          if (null !== b2) {
            var c2 = R();
            gi(b2, a, 1, c2);
          }
        }), il(a, 1);
    }
  };
  Fc = function(a) {
    if (13 === a.tag) {
      var b = ih(a, 134217728);
      if (null !== b) {
        var c = R();
        gi(b, a, 134217728, c);
      }
      il(a, 134217728);
    }
  };
  Gc = function(a) {
    if (13 === a.tag) {
      var b = yi(a), c = ih(a, b);
      if (null !== c) {
        var d = R();
        gi(c, a, b, d);
      }
      il(a, b);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a, b) {
    var c = C;
    try {
      return C = a, b();
    } finally {
      C = c;
    }
  };
  yb = function(a, b, c) {
    switch (b) {
      case "input":
        bb(a, c);
        b = c.name;
        if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode; ) c = c.parentNode;
          c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
          for (b = 0; b < c.length; b++) {
            var d = c[b];
            if (d !== a && d.form === a.form) {
              var e = Db(d);
              if (!e) throw Error(p(90));
              Wa(d);
              bb(d, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a, c);
        break;
      case "select":
        b = c.value, null != b && fb(a, !!c.multiple, b, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    a = Zb(a);
    return null === a ? null : a.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a, b) {
    var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b)) throw Error(p(200));
    return cl(a, b, null, c);
  };
  reactDom_production_min.createRoot = function(a, b) {
    if (!nl(a)) throw Error(p(299));
    var c = false, d = "", e = kl;
    null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
    b = bl(a, 1, false, null, null, c, false, d, e);
    a[uf] = b.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    return new ll(b);
  };
  reactDom_production_min.findDOMNode = function(a) {
    if (null == a) return null;
    if (1 === a.nodeType) return a;
    var b = a._reactInternals;
    if (void 0 === b) {
      if ("function" === typeof a.render) throw Error(p(188));
      a = Object.keys(a).join(",");
      throw Error(p(268, a));
    }
    a = Zb(b);
    a = null === a ? null : a.stateNode;
    return a;
  };
  reactDom_production_min.flushSync = function(a) {
    return Rk(a);
  };
  reactDom_production_min.hydrate = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, true, c);
  };
  reactDom_production_min.hydrateRoot = function(a, b, c) {
    if (!nl(a)) throw Error(p(405));
    var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
    null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
    b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
    a[uf] = b.current;
    sf(a);
    if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
      c,
      e
    );
    return new ml(b);
  };
  reactDom_production_min.render = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, false, c);
  };
  reactDom_production_min.unmountComponentAtNode = function(a) {
    if (!ol(a)) throw Error(p(40));
    return a._reactRootContainer ? (Rk(function() {
      rl(null, null, a, false, function() {
        a._reactRootContainer = null;
        a[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
    if (!ol(c)) throw Error(p(200));
    if (null == a || void 0 === a._reactInternals) throw Error(p(38));
    return rl(a, b, c, false, d);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m = requireReactDom();
  {
    client.createRoot = m.createRoot;
    client.hydrateRoot = m.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
const ReactDOM$1 = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
const TLDRAW_LIBRARY_VERSION_KEY = "__TLDRAW_LIBRARY_VERSIONS__";
function getLibraryVersions() {
  if (globalThis[TLDRAW_LIBRARY_VERSION_KEY]) {
    return globalThis[TLDRAW_LIBRARY_VERSION_KEY];
  }
  const info = {
    versions: [],
    didWarn: false,
    scheduledNotice: null
  };
  Object.defineProperty(globalThis, TLDRAW_LIBRARY_VERSION_KEY, {
    value: info,
    writable: false,
    configurable: false,
    enumerable: false
  });
  return info;
}
function registerTldrawLibraryVersion(name, version2, modules) {
  if (!name || !version2 || !modules) {
    {
      throw new Error("Missing name/version/module system in built version of tldraw library");
    }
  }
  const info = getLibraryVersions();
  info.versions.push({ name, version: version2, modules });
  if (!info.scheduledNotice) {
    try {
      info.scheduledNotice = setTimeout(() => {
        info.scheduledNotice = null;
        checkLibraryVersions(info);
      }, 100);
    } catch {
      checkLibraryVersions(info);
    }
  }
}
function checkLibraryVersions(info) {
  if (!info.versions.length) return;
  if (info.didWarn) return;
  const sorted = info.versions.sort((a, b) => compareVersions(a.version, b.version));
  const latestVersion = sorted[sorted.length - 1].version;
  const matchingVersions = /* @__PURE__ */ new Set();
  const nonMatchingVersions = /* @__PURE__ */ new Map();
  for (const lib of sorted) {
    if (nonMatchingVersions.has(lib.name)) {
      matchingVersions.delete(lib.name);
      entry(nonMatchingVersions, lib.name, /* @__PURE__ */ new Set()).add(lib.version);
      continue;
    }
    if (lib.version === latestVersion) {
      matchingVersions.add(lib.name);
    } else {
      matchingVersions.delete(lib.name);
      entry(nonMatchingVersions, lib.name, /* @__PURE__ */ new Set()).add(lib.version);
    }
  }
  if (nonMatchingVersions.size > 0) {
    const message = [
      `${format("[tldraw]", ["bold", "bgRed", "textWhite"])} ${format("You have multiple versions of tldraw libraries installed. This can lead to bugs and unexpected behavior.", ["textRed", "bold"])}`,
      "",
      `The latest version you have installed is ${format(`v${latestVersion}`, ["bold", "textBlue"])}. The following libraries are on the latest version:`,
      ...Array.from(matchingVersions, (name) => `    ${format(name, ["bold"])}`),
      "",
      `The following libraries are not on the latest version, or have multiple versions installed:`,
      ...Array.from(nonMatchingVersions, ([name, versions]) => {
        const sortedVersions = Array.from(versions).sort(compareVersions).map((v) => format(`v${v}`, v === latestVersion ? ["textGreen"] : ["textRed"]));
        return `    ${format(name, ["bold"])} (${sortedVersions.join(", ")})`;
      })
    ];
    console.log(message.join("\n"));
    info.didWarn = true;
    return;
  }
  const potentialDuplicates = /* @__PURE__ */ new Map();
  for (const lib of sorted) {
    entry(potentialDuplicates, lib.name, { version: lib.version, modules: [] }).modules.push(
      lib.modules
    );
  }
  const duplicates = /* @__PURE__ */ new Map();
  for (const [name, lib] of potentialDuplicates) {
    if (lib.modules.length > 1) duplicates.set(name, lib);
  }
  if (duplicates.size > 0) {
    const message = [
      `${format("[tldraw]", ["bold", "bgRed", "textWhite"])} ${format("You have multiple instances of some tldraw libraries active. This can lead to bugs and unexpected behavior. ", ["textRed", "bold"])}`,
      "",
      "This usually means that your bundler is misconfigured, and is importing the same library multiple times - usually once as an ES Module, and once as a CommonJS module.",
      "",
      "The following libraries have been imported multiple times:",
      ...Array.from(duplicates, ([name, lib]) => {
        const modules = lib.modules.map((m, i) => m === "esm" ? `      ${i + 1}. ES Modules` : `      ${i + 1}. CommonJS`).join("\n");
        return `    ${format(name, ["bold"])} v${lib.version}: 
${modules}`;
      }),
      "",
      "You should configure your bundler to only import one version of each library."
    ];
    console.log(message.join("\n"));
    info.didWarn = true;
    return;
  }
}
function compareVersions(a, b) {
  const aMatch = a.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/);
  const bMatch = b.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/);
  if (!aMatch || !bMatch) return a.localeCompare(b);
  if (aMatch[1] !== bMatch[1]) return Number(aMatch[1]) - Number(bMatch[1]);
  if (aMatch[2] !== bMatch[2]) return Number(aMatch[2]) - Number(bMatch[2]);
  if (aMatch[3] !== bMatch[3]) return Number(aMatch[3]) - Number(bMatch[3]);
  if (aMatch[4] && bMatch[4]) return aMatch[4].localeCompare(bMatch[4]);
  if (aMatch[4]) return 1;
  if (bMatch[4]) return -1;
  return 0;
}
const formats = {
  bold: "1",
  textBlue: "94",
  textRed: "31",
  textGreen: "32",
  bgRed: "41",
  textWhite: "97"
};
function format(value, formatters = []) {
  return `\x1B[${formatters.map((f) => formats[f]).join(";")}m${value}\x1B[m`;
}
function entry(map2, key, defaultValue) {
  if (map2.has(key)) {
    return map2.get(key);
  }
  map2.set(key, defaultValue);
  return defaultValue;
}
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
var hasRequiredLodash_isequal;
function requireLodash_isequal() {
  if (hasRequiredLodash_isequal) return lodash_isequal.exports;
  hasRequiredLodash_isequal = 1;
  (function(module, exports$1) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports$1 && !exports$1.nodeType && exports$1;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    })();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array2, values) {
      var index2 = -1, length = values.length, offset2 = array2.length;
      while (++index2 < length) {
        array2[offset2 + index2] = values[index2];
      }
      return array2;
    }
    function arraySome(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var maskSrcKey = (function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    })();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry2 = entries[index2];
        this.set(entry2[0], entry2[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry2 = entries[index2];
        this.set(entry2[0], entry2[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry2 = entries[index2];
        this.set(entry2[0], entry2[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index2 = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if (hasOwnProperty2.call(value, key) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray2(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
    }
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack2.get(array2);
      if (stacked && stack2.get(other)) {
        return stacked == other;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack2.set(array2, other);
      stack2.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array2);
      stack2["delete"](other);
      return result;
    }
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack2.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack2.get(object2);
      if (stacked && stack2.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack2.set(object2, other);
      stack2.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object2);
      stack2["delete"](other);
      return result;
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys2, getSymbols);
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
      return arguments;
    })()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual2(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual2;
  })(lodash_isequal, lodash_isequal.exports);
  return lodash_isequal.exports;
}
var lodash_isequalExports = requireLodash_isequal();
const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isequalExports);
var lodash_isequalwith = { exports: {} };
lodash_isequalwith.exports;
var hasRequiredLodash_isequalwith;
function requireLodash_isequalwith() {
  if (hasRequiredLodash_isequalwith) return lodash_isequalwith.exports;
  hasRequiredLodash_isequalwith = 1;
  (function(module, exports$1) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports$1 && !exports$1.nodeType && exports$1;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    })();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arraySome(array2, predicate) {
      var index2 = -1, length = array2 ? array2.length : 0;
      while (++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = (function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    })();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry2 = entries[index2];
        this.set(entry2[0], entry2[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry2 = entries[index2];
        this.set(entry2[0], entry2[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry2 = entries[index2];
        this.set(entry2[0], entry2[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index2 = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if (hasOwnProperty2.call(value, key) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject2(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack2);
    }
    function baseIsEqualDeep(object2, other, equalFunc, customizer, bitmask, stack2) {
      var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object2);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object2), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, equalFunc, customizer, bitmask, stack2) : equalByTag(object2, other, objTag, equalFunc, customizer, bitmask, stack2);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack());
      return equalObjects(object2, other, equalFunc, customizer, bitmask, stack2);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array2, other, equalFunc, customizer, bitmask, stack2) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack2.get(array2);
      if (stacked && stack2.get(other)) {
        return stacked == other;
      }
      var index2 = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack2.set(array2, other);
      stack2.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack2))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array2);
      stack2["delete"](other);
      return result;
    }
    function equalByTag(object2, other, tag, equalFunc, customizer, bitmask, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack2.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), equalFunc, customizer, bitmask, stack2);
          stack2["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object2, other, equalFunc, customizer, bitmask, stack2) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys2(object2), objLength = objProps.length, othProps = keys2(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack2.get(object2);
      if (stacked && stack2.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack2.set(object2, other);
      stack2.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object2);
      stack2["delete"](other);
      return result;
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isEqualWith2(value, other, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      var result = customizer ? customizer(value, other) : void 0;
      return result === void 0 ? baseIsEqual(value, other, customizer) : !!result;
    }
    function isFunction2(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    module.exports = isEqualWith2;
  })(lodash_isequalwith, lodash_isequalwith.exports);
  return lodash_isequalwith.exports;
}
var lodash_isequalwithExports = requireLodash_isequalwith();
const isEqualWith = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isequalwithExports);
var lodash_throttle;
var hasRequiredLodash_throttle;
function requireLodash_throttle() {
  if (hasRequiredLodash_throttle) return lodash_throttle;
  hasRequiredLodash_throttle = 1;
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max, nativeMin = Math.min;
  var now = function() {
    return root.Date.now();
  };
  function debounce2(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject2(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush2() {
      return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush2;
    return debounced;
  }
  function throttle2(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject2(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce2(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol2(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol2(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  lodash_throttle = throttle2;
  return lodash_throttle;
}
var lodash_throttleExports = requireLodash_throttle();
const throttle = /* @__PURE__ */ getDefaultExportFromCjs(lodash_throttleExports);
var lodash_uniq;
var hasRequiredLodash_uniq;
function requireLodash_uniq() {
  if (hasRequiredLodash_uniq) return lodash_uniq;
  hasRequiredLodash_uniq = 1;
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var INFINITY = 1 / 0;
  var funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayIncludes2(array2, value) {
    var length = array2 ? array2.length : 0;
    return !!length && baseIndexOf(array2, value, 0) > -1;
  }
  function baseFindIndex(array2, predicate, fromIndex, fromRight) {
    var length = array2.length, index2 = fromIndex + -1;
    while (++index2 < length) {
      if (predicate(array2[index2], index2, array2)) {
        return index2;
      }
    }
    return -1;
  }
  function baseIndexOf(array2, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    var index2 = fromIndex - 1, length = array2.length;
    while (++index2 < length) {
      if (array2[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function setToArray(set) {
    var index2 = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = (function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  })();
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var splice = arrayProto.splice;
  var Map2 = getNative(root, "Map"), Set2 = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry2 = entries[index2];
      this.set(entry2[0], entry2[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry2 = entries[index2];
      this.set(entry2[0], entry2[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry2 = entries[index2];
      this.set(entry2[0], entry2[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index2 = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array2, key) {
    var length = array2.length;
    while (length--) {
      if (eq(array2[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseUniq(array2, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes2, length = array2.length, isCommon = true, result = [], seen = result;
    if (length >= LARGE_ARRAY_SIZE) {
      var set = createSet(array2);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = result;
    }
    outer:
      while (++index2 < length) {
        var value = array2[index2], computed2 = value;
        value = value !== 0 ? value : 0;
        if (isCommon && computed2 === computed2) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed2) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(seen, computed2, comparator)) {
          if (seen !== result) {
            seen.push(computed2);
          }
          result.push(value);
        }
      }
    return result;
  }
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values) {
    return new Set2(values);
  };
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object2, key) {
    var value = getValue(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function uniq2(array2) {
    return array2 && array2.length ? baseUniq(array2) : [];
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function noop3() {
  }
  lodash_uniq = uniq2;
  return lodash_uniq;
}
var lodash_uniqExports = requireLodash_uniq();
const _uniq = /* @__PURE__ */ getDefaultExportFromCjs(lodash_uniqExports);
function dedupe(input, equals2) {
  const result = [];
  mainLoop: for (const item of input) {
    for (const existing of result) {
      if (equals2 ? equals2(item, existing) : item === existing) {
        continue mainLoop;
      }
    }
    result.push(item);
  }
  return result;
}
function compact(arr) {
  return arr.filter((i) => i !== void 0 && i !== null);
}
function last(arr) {
  return arr[arr.length - 1];
}
function minBy(arr, fn) {
  let min2;
  let minVal = Infinity;
  for (const item of arr) {
    const val = fn(item);
    if (val < minVal) {
      min2 = item;
      minVal = val;
    }
  }
  return min2;
}
function maxBy(arr, fn) {
  let max2;
  let maxVal = -Infinity;
  for (const item of arr) {
    const val = fn(item);
    if (val > maxVal) {
      max2 = item;
      maxVal = val;
    }
  }
  return max2;
}
function areArraysShallowEqual(arr1, arr2) {
  if (arr1 === arr2) return true;
  if (arr1.length !== arr2.length) return false;
  for (let i = 0; i < arr1.length; i++) {
    if (!Object.is(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
}
function mergeArraysAndReplaceDefaults(key, customEntries, defaults2) {
  const overrideTypes = new Set(customEntries.map((entry2) => entry2[key]));
  const result = [];
  for (const defaultEntry of defaults2) {
    if (overrideTypes.has(defaultEntry[key])) continue;
    result.push(defaultEntry);
  }
  for (const customEntry of customEntries) {
    result.push(customEntry);
  }
  return result;
}
function omitFromStackTrace(fn) {
  const wrappedFn = (...args) => {
    try {
      return fn(...args);
    } catch (error) {
      if (error instanceof Error && Error.captureStackTrace) {
        Error.captureStackTrace(error, wrappedFn);
      }
      throw error;
    }
  };
  return wrappedFn;
}
const noop$3 = () => {
};
const Result = {
  /**
   * Create a successful result containing a value.
   *
   * @param value - The success value to wrap
   * @returns An OkResult containing the value
   */
  ok(value) {
    return { ok: true, value };
  },
  /**
   * Create a failed result containing an error.
   *
   * @param error - The error value to wrap
   * @returns An ErrorResult containing the error
   */
  err(error) {
    return { ok: false, error };
  }
};
function exhaustiveSwitchError(value, property) {
  const debugValue = property && value && typeof value === "object" && property in value ? value[property] : value;
  throw new Error(`Unknown switch case ${debugValue}`);
}
const assert = omitFromStackTrace(
  (value, message) => {
    if (!value) {
      throw new Error(message || "Assertion Error");
    }
  }
);
const assertExists = omitFromStackTrace((value, message) => {
  if (value == null) {
    throw new Error(message ?? "value must be defined");
  }
  return value;
});
function promiseWithResolve() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return Object.assign(promise, {
    resolve,
    reject
  });
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function bind$1(...args) {
  if (args.length === 2) {
    const [originalMethod, context] = args;
    context.addInitializer(function initializeMethod() {
      assert(Reflect.isExtensible(this), "Cannot bind to a non-extensible class.");
      const value = originalMethod.bind(this);
      const ok = Reflect.defineProperty(this, context.name, {
        value,
        writable: true,
        configurable: true
      });
      assert(ok, "Cannot bind a non-configurable class method.");
    });
  } else {
    const [_target, propertyKey, descriptor] = args;
    if (!descriptor || typeof descriptor.value !== "function") {
      throw new TypeError(
        `Only methods can be decorated with @bind. <${propertyKey}> is not a method!`
      );
    }
    return {
      configurable: true,
      get() {
        const bound = descriptor.value.bind(this);
        Object.defineProperty(this, propertyKey, {
          value: bound,
          configurable: true,
          writable: true
        });
        return bound;
      }
    };
  }
}
class WeakCache {
  /**
   * The internal WeakMap storage for cached key-value pairs.
   *
   * @public
   */
  items = /* @__PURE__ */ new WeakMap();
  /**
   * Get the cached value for a given key, computing it if not already cached.
   *
   * Retrieves the cached value associated with the given key. If no cached
   * value exists, calls the provided callback function to compute the value, stores it
   * in the cache, and returns it. Subsequent calls with the same key will return the
   * cached value without recomputation.
   *
   * @param item - The object key to retrieve the cached value for
   * @param cb - Callback function that computes the value when not already cached
   * @returns The cached value if it exists, otherwise the newly computed value from the callback
   *
   * @example
   * ```ts
   * const cache = new WeakCache<HTMLElement, DOMRect>()
   * const element = document.getElementById('my-element')!
   *
   * // First call computes and caches the bounding rect
   * const rect1 = cache.get(element, (el) => el.getBoundingClientRect())
   *
   * // Second call returns cached value
   * const rect2 = cache.get(element, (el) => el.getBoundingClientRect())
   * // rect1 and rect2 are the same object
   * ```
   */
  get(item, cb) {
    if (!this.items.has(item)) {
      this.items.set(item, cb(item));
    }
    return this.items.get(item);
  }
}
function debounce(callback, wait) {
  let state = void 0;
  const fn = (...args) => {
    if (!state) {
      state = {};
      state.promise = new Promise((resolve, reject) => {
        state.resolve = resolve;
        state.reject = reject;
      });
    }
    clearTimeout(state.timeout);
    state.latestArgs = args;
    state.timeout = setTimeout(() => {
      const s = state;
      state = void 0;
      try {
        s.resolve(callback(...s.latestArgs));
      } catch (e) {
        s.reject(e);
      }
    }, wait);
    return state.promise;
  };
  fn.cancel = () => {
    if (!state) return;
    clearTimeout(state.timeout);
  };
  return fn;
}
const annotationsByError = /* @__PURE__ */ new WeakMap();
function annotateError(error, annotations) {
  if (typeof error !== "object" || error === null) return;
  let currentAnnotations = annotationsByError.get(error);
  if (!currentAnnotations) {
    currentAnnotations = { tags: {}, extras: {} };
    annotationsByError.set(error, currentAnnotations);
  }
  if (annotations.tags) {
    currentAnnotations.tags = {
      ...currentAnnotations.tags,
      ...annotations.tags
    };
  }
  if (annotations.extras) {
    currentAnnotations.extras = {
      ...currentAnnotations.extras,
      ...annotations.extras
    };
  }
}
async function fetch$1(input, init2) {
  return window.fetch(input, {
    // We want to make sure that the referrer is not sent to other domains.
    referrerPolicy: "strict-origin-when-cross-origin",
    ...init2
  });
}
const Image = (width, height) => {
  const img = new window.Image(width, height);
  img.referrerPolicy = "strict-origin-when-cross-origin";
  return img;
};
class FileHelpers {
  /**
   * Converts a URL to an ArrayBuffer by fetching the resource.
   *
   * Fetches the resource at the given URL and returns its content as an ArrayBuffer.
   * This is useful for loading binary data like images, videos, or other file types.
   *
   * @param url - The URL of the file to fetch
   * @returns Promise that resolves to the file content as an ArrayBuffer
   * @example
   * ```ts
   * const buffer = await FileHelpers.urlToArrayBuffer('https://example.com/image.png')
   * console.log(buffer.byteLength) // Size of the file in bytes
   * ```
   * @public
   */
  static async urlToArrayBuffer(url) {
    const response = await fetch$1(url);
    return await response.arrayBuffer();
  }
  /**
   * Converts a URL to a Blob by fetching the resource.
   *
   * Fetches the resource at the given URL and returns its content as a Blob object.
   * Blobs are useful for handling file data in web applications.
   *
   * @param url - The URL of the file to fetch
   * @returns Promise that resolves to the file content as a Blob
   * @example
   * ```ts
   * const blob = await FileHelpers.urlToBlob('https://example.com/document.pdf')
   * console.log(blob.type) // 'application/pdf'
   * console.log(blob.size) // Size in bytes
   * ```
   * @public
   */
  static async urlToBlob(url) {
    const response = await fetch$1(url);
    return await response.blob();
  }
  /**
   * Converts a URL to a data URL by fetching the resource.
   *
   * Fetches the resource at the given URL and converts it to a base64-encoded data URL.
   * If the URL is already a data URL, it returns the URL unchanged. This is useful for embedding
   * resources directly in HTML or CSS.
   *
   * @param url - The URL of the file to convert, or an existing data URL
   * @returns Promise that resolves to a data URL string
   * @example
   * ```ts
   * const dataUrl = await FileHelpers.urlToDataUrl('https://example.com/image.jpg')
   * // Returns: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEA...'
   *
   * const existing = await FileHelpers.urlToDataUrl('data:text/plain;base64,SGVsbG8=')
   * // Returns the same data URL unchanged
   * ```
   * @public
   */
  static async urlToDataUrl(url) {
    if (url.startsWith("data:")) return url;
    const blob = await FileHelpers.urlToBlob(url);
    return await FileHelpers.blobToDataUrl(blob);
  }
  /**
   * Convert a Blob to a base64 encoded data URL.
   *
   * Converts a Blob object to a base64-encoded data URL using the FileReader API.
   * This is useful for displaying images or embedding file content directly in HTML.
   *
   * @param file - The Blob object to convert
   * @returns Promise that resolves to a base64-encoded data URL string
   * @example
   * ```ts
   * const blob = new Blob(['Hello World'], { type: 'text/plain' })
   * const dataUrl = await FileHelpers.blobToDataUrl(blob)
   * // Returns: 'data:text/plain;base64,SGVsbG8gV29ybGQ='
   *
   * // With an image file
   * const imageDataUrl = await FileHelpers.blobToDataUrl(myImageFile)
   * // Can be used directly in img src attribute
   * ```
   * @public
   */
  static async blobToDataUrl(file) {
    return await new Promise((resolve, reject) => {
      if (file) {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = (error) => reject(error);
        reader.onabort = (error) => reject(error);
        reader.readAsDataURL(file);
      }
    });
  }
  /**
   * Convert a Blob to a unicode text string.
   *
   * Reads the content of a Blob object as a UTF-8 text string using the FileReader API.
   * This is useful for reading text files or extracting text content from blobs.
   *
   * @param file - The Blob object to convert to text
   * @returns Promise that resolves to the text content as a string
   * @example
   * ```ts
   * const textBlob = new Blob(['Hello World'], { type: 'text/plain' })
   * const text = await FileHelpers.blobToText(textBlob)
   * console.log(text) // 'Hello World'
   *
   * // With a text file from user input
   * const content = await FileHelpers.blobToText(myTextFile)
   * console.log(content) // File content as string
   * ```
   * @public
   */
  static async blobToText(file) {
    return await new Promise((resolve, reject) => {
      if (file) {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = (error) => reject(error);
        reader.onabort = (error) => reject(error);
        reader.readAsText(file);
      }
    });
  }
  static rewriteMimeType(blob, newMimeType) {
    if (blob.type === newMimeType) return blob;
    if (blob instanceof File) {
      return new File([blob], blob.name, { type: newMimeType });
    }
    return new Blob([blob], { type: newMimeType });
  }
}
function getHashForString(string2) {
  let hash2 = 0;
  for (let i = 0; i < string2.length; i++) {
    hash2 = (hash2 << 5) - hash2 + string2.charCodeAt(i);
    hash2 |= 0;
  }
  return hash2 + "";
}
function getHashForBuffer(buffer) {
  const view = new DataView(buffer);
  let hash2 = 0;
  for (let i = 0; i < view.byteLength; i++) {
    hash2 = (hash2 << 5) - hash2 + view.getUint8(i);
    hash2 |= 0;
  }
  return hash2 + "";
}
const crypto$1 = globalThis.crypto;
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
const POOL_SIZE_MULTIPLIER = 128;
let pool, poolOffset;
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = new Uint8Array(bytes * POOL_SIZE_MULTIPLIER);
    crypto$1.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto$1.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function nanoid(size2 = 21) {
  fillPool(size2 -= 0);
  let id = "";
  for (let i = poolOffset - size2; i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63];
  }
  return id;
}
let impl = nanoid;
function uniqueId(size2) {
  return impl(size2);
}
function isApngAnimated(buffer) {
  const view = new Uint8Array(buffer);
  if (!view || !(typeof Buffer !== "undefined" && Buffer.isBuffer(view) || view instanceof Uint8Array) || view.length < 16) {
    return false;
  }
  const isPNG = view[0] === 137 && view[1] === 80 && view[2] === 78 && view[3] === 71 && view[4] === 13 && view[5] === 10 && view[6] === 26 && view[7] === 10;
  if (!isPNG) {
    return false;
  }
  function indexOfSubstring(haystack, needle, fromIndex, upToIndex, chunksize = 1024) {
    if (!needle) {
      return -1;
    }
    needle = new RegExp(needle, "g");
    const needle_length = needle.source.length;
    const decoder = new TextDecoder();
    const full_haystack_length = haystack.length;
    if (typeof upToIndex === "undefined") {
      upToIndex = full_haystack_length;
    }
    if (fromIndex >= full_haystack_length || upToIndex <= 0 || fromIndex >= upToIndex) {
      return -1;
    }
    haystack = haystack.subarray(fromIndex, upToIndex);
    let position = -1;
    let current_index = 0;
    let full_length = 0;
    let needle_buffer = "";
    outer: while (current_index < haystack.length) {
      const next_index = current_index + chunksize;
      const chunk = haystack.subarray(current_index, next_index);
      const decoded = decoder.decode(chunk, { stream: true });
      const text = needle_buffer + decoded;
      let match;
      let last_index = -1;
      while ((match = needle.exec(text)) !== null) {
        last_index = match.index - needle_buffer.length;
        position = full_length + last_index;
        break outer;
      }
      current_index = next_index;
      full_length += decoded.length;
      const needle_index = last_index > -1 ? last_index + needle_length : decoded.length - needle_length;
      needle_buffer = decoded.slice(needle_index);
    }
    if (position >= 0) {
      position += fromIndex >= 0 ? fromIndex : full_haystack_length + fromIndex;
    }
    return position;
  }
  const idatIdx = indexOfSubstring(view, "IDAT", 12);
  if (idatIdx >= 12) {
    const actlIdx = indexOfSubstring(view, "acTL", 8, idatIdx);
    return actlIdx >= 8;
  }
  return false;
}
const isAvifAnimated = (buffer) => {
  const view = new Uint8Array(buffer);
  return view[3] === 44;
};
function getDataBlocksLength(buffer, offset2) {
  let length = 0;
  while (buffer[offset2 + length]) {
    length += buffer[offset2 + length] + 1;
  }
  return length + 1;
}
function isGIF(buffer) {
  const enc = new TextDecoder("ascii");
  const header = enc.decode(buffer.slice(0, 3));
  return header === "GIF";
}
function isGifAnimated(buffer) {
  const view = new Uint8Array(buffer);
  let hasColorTable, colorTableSize;
  let offset2 = 0;
  let imagesCount = 0;
  if (!isGIF(buffer)) {
    return false;
  }
  hasColorTable = view[10] & 128;
  colorTableSize = view[10] & 7;
  offset2 += 6;
  offset2 += 7;
  offset2 += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0;
  while (imagesCount < 2 && offset2 < view.length) {
    switch (view[offset2]) {
      // Image descriptor block. According to specification there could be any
      // number of these blocks (even zero). When there is more than one image
      // descriptor browsers will display animation (they shouldn't when there
      // is no delays defined, but they do it anyway).
      case 44:
        imagesCount += 1;
        hasColorTable = view[offset2 + 9] & 128;
        colorTableSize = view[offset2 + 9] & 7;
        offset2 += 10;
        offset2 += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0;
        offset2 += getDataBlocksLength(view, offset2 + 1) + 1;
        break;
      // Skip all extension blocks. In theory this "plain text extension" blocks
      // could be frames of animation, but no browser renders them.
      case 33:
        offset2 += 2;
        offset2 += getDataBlocksLength(view, offset2);
        break;
      // Stop processing on trailer block,
      // all data after this point will is ignored by decoders
      case 59:
        offset2 = view.length;
        break;
      // Oops! This GIF seems to be invalid
      default:
        offset2 = view.length;
        break;
    }
  }
  return imagesCount > 1;
}
let TABLE = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
if (typeof Int32Array !== "undefined") {
  TABLE = new Int32Array(TABLE);
}
const crc = (current, previous) => {
  let crc2 = 0 ^ -1;
  for (let index2 = 0; index2 < current.length; index2++) {
    crc2 = TABLE[(crc2 ^ current[index2]) & 255] ^ crc2 >>> 8;
  }
  return crc2 ^ -1;
};
const LEN_SIZE = 4;
const CRC_SIZE = 4;
class PngHelpers {
  /**
   * Checks if binary data at the specified offset contains a valid PNG file signature.
   * Validates the 8-byte PNG signature: 89 50 4E 47 0D 0A 1A 0A.
   *
   * @param view - DataView containing the binary data to check
   * @param offset - Byte offset where the PNG signature should start
   * @returns True if the data contains a valid PNG signature, false otherwise
   *
   * @example
   * ```ts
   * // Validate PNG from file upload
   * const file = event.target.files[0]
   * const buffer = await file.arrayBuffer()
   * const view = new DataView(buffer)
   *
   * if (PngHelpers.isPng(view, 0)) {
   *   console.log('Valid PNG file detected')
   *   // Process PNG file...
   * } else {
   *   console.error('Not a valid PNG file')
   * }
   * ```
   */
  static isPng(view, offset2) {
    if (view.getUint8(offset2 + 0) === 137 && view.getUint8(offset2 + 1) === 80 && view.getUint8(offset2 + 2) === 78 && view.getUint8(offset2 + 3) === 71 && view.getUint8(offset2 + 4) === 13 && view.getUint8(offset2 + 5) === 10 && view.getUint8(offset2 + 6) === 26 && view.getUint8(offset2 + 7) === 10) {
      return true;
    }
    return false;
  }
  /**
   * Reads the 4-character chunk type identifier from a PNG chunk header.
   *
   * @param view - DataView containing the PNG data
   * @param offset - Byte offset of the chunk type field (after length field)
   * @returns 4-character string representing the chunk type (e.g., 'IHDR', 'IDAT', 'IEND')
   *
   * @example
   * ```ts
   * // Read chunk type from PNG header (after 8-byte signature)
   * const chunkType = PngHelpers.getChunkType(dataView, 8)
   * console.log(chunkType) // 'IHDR' (Image Header)
   *
   * // Read chunk type at a specific position during parsing
   * let offset = 8 // Skip PNG signature
   * const chunkLength = dataView.getUint32(offset)
   * const type = PngHelpers.getChunkType(dataView, offset + 4)
   * ```
   */
  static getChunkType(view, offset2) {
    return [
      String.fromCharCode(view.getUint8(offset2)),
      String.fromCharCode(view.getUint8(offset2 + 1)),
      String.fromCharCode(view.getUint8(offset2 + 2)),
      String.fromCharCode(view.getUint8(offset2 + 3))
    ].join("");
  }
  /**
   * Parses all chunks in a PNG file and returns their metadata.
   * Skips duplicate IDAT chunks but includes all other chunk types.
   *
   * @param view - DataView containing the complete PNG file data
   * @param offset - Starting byte offset (defaults to 0)
   * @returns Record mapping chunk types to their metadata (start position, data offset, and size)
   * @throws Error if the data is not a valid PNG file
   *
   * @example
   * ```ts
   * // Parse PNG structure for metadata extraction
   * const view = new DataView(await blob.arrayBuffer())
   * const chunks = PngHelpers.readChunks(view)
   *
   * // Check for specific chunks
   * const ihdrChunk = chunks['IHDR']
   * const physChunk = chunks['pHYs']
   *
   * if (physChunk) {
   *   console.log(`Found pixel density info at byte ${physChunk.start}`)
   * } else {
   *   console.log('No pixel density information found')
   * }
   * ```
   */
  static readChunks(view, offset2 = 0) {
    const chunks = {};
    if (!PngHelpers.isPng(view, offset2)) {
      throw new Error("Not a PNG");
    }
    offset2 += 8;
    while (offset2 <= view.buffer.byteLength) {
      const start = offset2;
      const len = view.getInt32(offset2);
      offset2 += 4;
      const chunkType = PngHelpers.getChunkType(view, offset2);
      if (chunkType === "IDAT" && chunks[chunkType]) {
        offset2 += len + LEN_SIZE + CRC_SIZE;
        continue;
      }
      if (chunkType === "IEND") {
        break;
      }
      chunks[chunkType] = {
        start,
        dataOffset: offset2 + 4,
        size: len
      };
      offset2 += len + LEN_SIZE + CRC_SIZE;
    }
    return chunks;
  }
  /**
   * Parses the pHYs (physical pixel dimensions) chunk data.
   * Reads pixels per unit for X and Y axes, and the unit specifier.
   *
   * @param view - DataView containing the PNG data
   * @param offset - Byte offset of the pHYs chunk data
   * @returns Object with ppux (pixels per unit X), ppuy (pixels per unit Y), and unit specifier
   *
   * @example
   * ```ts
   * // Extract pixel density information for DPI calculation
   * const physChunk = PngHelpers.findChunk(dataView, 'pHYs')
   * if (physChunk) {
   *   const physData = PngHelpers.parsePhys(dataView, physChunk.dataOffset)
   *
   *   if (physData.unit === 1) { // meters
   *     const dpiX = Math.round(physData.ppux * 0.0254)
   *     const dpiY = Math.round(physData.ppuy * 0.0254)
   *     console.log(`DPI: ${dpiX} x ${dpiY}`)
   *   }
   * }
   * ```
   */
  static parsePhys(view, offset2) {
    return {
      ppux: view.getUint32(offset2),
      ppuy: view.getUint32(offset2 + 4),
      unit: view.getUint8(offset2 + 8)
    };
  }
  /**
   * Finds a specific chunk type in the PNG file and returns its metadata.
   *
   * @param view - DataView containing the PNG file data
   * @param type - 4-character chunk type to search for (e.g., 'pHYs', 'IDAT')
   * @returns Chunk metadata object if found, undefined otherwise
   *
   * @example
   * ```ts
   * // Look for pixel density information in PNG
   * const physChunk = PngHelpers.findChunk(dataView, 'pHYs')
   * if (physChunk) {
   *   const physData = PngHelpers.parsePhys(dataView, physChunk.dataOffset)
   *   console.log(`Found pHYs chunk with ${physData.ppux} x ${physData.ppuy} pixels per unit`)
   * }
   *
   * // Check for text metadata
   * const textChunk = PngHelpers.findChunk(dataView, 'tEXt')
   * if (textChunk) {
   *   console.log(`Found text metadata at byte ${textChunk.start}`)
   * }
   * ```
   */
  static findChunk(view, type) {
    const chunks = PngHelpers.readChunks(view);
    return chunks[type];
  }
  /**
   * Adds or replaces a pHYs chunk in a PNG file to set pixel density for high-DPI displays.
   * The method determines insertion point by prioritizing IDAT chunk position over existing pHYs,
   * creates a properly formatted pHYs chunk with CRC validation, and returns a new Blob.
   *
   * @param view - DataView containing the original PNG file data
   * @param dpr - Device pixel ratio multiplier (defaults to 1)
   * @param options - Optional Blob constructor options for MIME type and other properties
   * @returns New Blob containing the PNG with updated pixel density information
   *
   * @example
   * ```ts
   * // Export PNG with proper pixel density for high-DPI displays
   * const canvas = document.createElement('canvas')
   * const ctx = canvas.getContext('2d')
   * // ... draw content to canvas ...
   *
   * canvas.toBlob(async (blob) => {
   *   if (blob) {
   *     const view = new DataView(await blob.arrayBuffer())
   *     // Create 2x DPI version for Retina displays
   *     const highDpiBlob = PngHelpers.setPhysChunk(view, 2, { type: 'image/png' })
   *     // Download or use the blob...
   *   }
   * }, 'image/png')
   * ```
   */
  static setPhysChunk(view, dpr = 1, options) {
    let offset2 = 46;
    let size2 = 0;
    const res1 = PngHelpers.findChunk(view, "pHYs");
    if (res1) {
      offset2 = res1.start;
      size2 = res1.size;
    }
    const res2 = PngHelpers.findChunk(view, "IDAT");
    if (res2) {
      offset2 = res2.start;
      size2 = 0;
    }
    const pHYsData = new ArrayBuffer(21);
    const pHYsDataView = new DataView(pHYsData);
    pHYsDataView.setUint32(0, 9);
    pHYsDataView.setUint8(4, "p".charCodeAt(0));
    pHYsDataView.setUint8(5, "H".charCodeAt(0));
    pHYsDataView.setUint8(6, "Y".charCodeAt(0));
    pHYsDataView.setUint8(7, "s".charCodeAt(0));
    const DPI_72 = 2835.5;
    pHYsDataView.setInt32(8, DPI_72 * dpr);
    pHYsDataView.setInt32(12, DPI_72 * dpr);
    pHYsDataView.setInt8(16, 1);
    const crcBit = new Uint8Array(pHYsData.slice(4, 17));
    pHYsDataView.setInt32(17, crc(crcBit));
    const startBuf = view.buffer.slice(0, offset2);
    const endBuf = view.buffer.slice(offset2 + size2);
    return new Blob([startBuf, pHYsData, endBuf], options);
  }
}
function isWebp(view) {
  if (!view || view.length < 12) {
    return false;
  }
  return view[8] === 87 && view[9] === 69 && view[10] === 66 && view[11] === 80;
}
function isWebpAnimated(buffer) {
  const view = new Uint8Array(buffer);
  if (!isWebp(view)) {
    return false;
  }
  if (!view || view.length < 21) {
    return false;
  }
  return (view[20] >> 1 & 1) === 1;
}
const DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES = Object.freeze(["image/svg+xml"]);
const DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES = Object.freeze([
  "image/jpeg",
  "image/png",
  "image/webp"
]);
const DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES = Object.freeze([
  "image/gif",
  "image/apng",
  "image/avif"
]);
const DEFAULT_SUPPORTED_IMAGE_TYPES = Object.freeze([
  ...DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES,
  ...DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES,
  ...DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES
]);
const DEFAULT_SUPPORT_VIDEO_TYPES = Object.freeze([
  "video/mp4",
  "video/webm",
  "video/quicktime"
]);
const DEFAULT_SUPPORTED_MEDIA_TYPES = Object.freeze([
  ...DEFAULT_SUPPORTED_IMAGE_TYPES,
  ...DEFAULT_SUPPORT_VIDEO_TYPES
]);
DEFAULT_SUPPORTED_MEDIA_TYPES.join(",");
class MediaHelpers {
  /**
   * Load a video element from a URL with cross-origin support.
   *
   * @param src - The URL of the video to load
   * @returns Promise that resolves to the loaded HTMLVideoElement
   * @example
   * ```ts
   * const video = await MediaHelpers.loadVideo('https://example.com/video.mp4')
   * console.log(`Video dimensions: ${video.videoWidth}x${video.videoHeight}`)
   * ```
   * @public
   */
  static loadVideo(src) {
    return new Promise((resolve, reject) => {
      const video = document.createElement("video");
      video.onloadeddata = () => resolve(video);
      video.onerror = (e) => {
        console.error(e);
        reject(new Error("Could not load video"));
      };
      video.crossOrigin = "anonymous";
      video.src = src;
    });
  }
  /**
   * Extract a frame from a video element as a data URL.
   *
   * @param video - The HTMLVideoElement to extract frame from
   * @param time - The time in seconds to extract the frame from (default: 0)
   * @returns Promise that resolves to a data URL of the video frame
   * @example
   * ```ts
   * const video = await MediaHelpers.loadVideo('https://example.com/video.mp4')
   * const frameDataUrl = await MediaHelpers.getVideoFrameAsDataUrl(video, 5.0)
   * // Use frameDataUrl as image thumbnail
   * const img = document.createElement('img')
   * img.src = frameDataUrl
   * ```
   * @public
   */
  static async getVideoFrameAsDataUrl(video, time = 0) {
    const promise = promiseWithResolve();
    let didSetTime = false;
    const onReadyStateChanged = () => {
      if (!didSetTime) {
        if (video.readyState >= video.HAVE_METADATA) {
          didSetTime = true;
          video.currentTime = time;
        } else {
          return;
        }
      }
      if (video.readyState >= video.HAVE_CURRENT_DATA) {
        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          throw new Error("Could not get 2d context");
        }
        ctx.drawImage(video, 0, 0);
        promise.resolve(canvas.toDataURL());
      }
    };
    const onError = (e) => {
      console.error(e);
      promise.reject(new Error("Could not get video frame"));
    };
    video.addEventListener("loadedmetadata", onReadyStateChanged);
    video.addEventListener("loadeddata", onReadyStateChanged);
    video.addEventListener("canplay", onReadyStateChanged);
    video.addEventListener("seeked", onReadyStateChanged);
    video.addEventListener("error", onError);
    video.addEventListener("stalled", onError);
    onReadyStateChanged();
    try {
      return await promise;
    } finally {
      video.removeEventListener("loadedmetadata", onReadyStateChanged);
      video.removeEventListener("loadeddata", onReadyStateChanged);
      video.removeEventListener("canplay", onReadyStateChanged);
      video.removeEventListener("seeked", onReadyStateChanged);
      video.removeEventListener("error", onError);
      video.removeEventListener("stalled", onError);
    }
  }
  /**
   * Load an image from a URL and get its dimensions along with the image element.
   *
   * @param src - The URL of the image to load
   * @returns Promise that resolves to an object with width, height, and the image element
   * @example
   * ```ts
   * const { w, h, image } = await MediaHelpers.getImageAndDimensions('https://example.com/image.png')
   * console.log(`Image size: ${w}x${h}`)
   * // Image is ready to use
   * document.body.appendChild(image)
   * ```
   * @public
   */
  static getImageAndDimensions(src) {
    return new Promise((resolve, reject) => {
      const img = Image();
      img.onload = () => {
        let dimensions;
        if (img.naturalWidth) {
          dimensions = {
            w: img.naturalWidth,
            h: img.naturalHeight
          };
        } else {
          document.body.appendChild(img);
          dimensions = {
            w: img.clientWidth,
            h: img.clientHeight
          };
          document.body.removeChild(img);
        }
        resolve({ ...dimensions, image: img });
      };
      img.onerror = (e) => {
        console.error(e);
        reject(new Error("Could not load image"));
      };
      img.crossOrigin = "anonymous";
      img.referrerPolicy = "strict-origin-when-cross-origin";
      img.style.visibility = "hidden";
      img.style.position = "absolute";
      img.style.opacity = "0";
      img.style.zIndex = "-9999";
      img.src = src;
    });
  }
  /**
   * Get the size of a video blob
   *
   * @param blob - A Blob containing the video
   * @returns Promise that resolves to an object with width and height properties
   * @example
   * ```ts
   * const file = new File([...], 'video.mp4', { type: 'video/mp4' })
   * const { w, h } = await MediaHelpers.getVideoSize(file)
   * console.log(`Video dimensions: ${w}x${h}`)
   * ```
   * @public
   */
  static async getVideoSize(blob) {
    return MediaHelpers.usingObjectURL(blob, async (url) => {
      const video = await MediaHelpers.loadVideo(url);
      return { w: video.videoWidth, h: video.videoHeight };
    });
  }
  /**
   * Get the size of an image blob
   *
   * @param blob - A Blob containing the image
   * @returns Promise that resolves to an object with width and height properties
   * @example
   * ```ts
   * const file = new File([...], 'image.png', { type: 'image/png' })
   * const { w, h } = await MediaHelpers.getImageSize(file)
   * console.log(`Image dimensions: ${w}x${h}`)
   * ```
   * @public
   */
  static async getImageSize(blob) {
    const { w, h: h2 } = await MediaHelpers.usingObjectURL(blob, MediaHelpers.getImageAndDimensions);
    try {
      if (blob.type === "image/png") {
        const view = new DataView(await blob.arrayBuffer());
        if (PngHelpers.isPng(view, 0)) {
          const physChunk = PngHelpers.findChunk(view, "pHYs");
          if (physChunk) {
            const physData = PngHelpers.parsePhys(view, physChunk.dataOffset);
            if (physData.unit === 1 && physData.ppux === physData.ppuy) {
              const pixelsPerMeter = 72 / 0.0254;
              const pixelRatio = Math.max(physData.ppux / pixelsPerMeter, 1);
              return {
                w: Math.round(w / pixelRatio),
                h: Math.round(h2 / pixelRatio)
              };
            }
          }
        }
      }
    } catch (err) {
      console.error(err);
      return { w, h: h2 };
    }
    return { w, h: h2 };
  }
  /**
   * Check if a media file blob contains animation data.
   *
   * @param file - The Blob to check for animation
   * @returns Promise that resolves to true if the file is animated, false otherwise
   * @example
   * ```ts
   * const file = new File([...], 'animation.gif', { type: 'image/gif' })
   * const animated = await MediaHelpers.isAnimated(file)
   * console.log(animated ? 'Animated' : 'Static')
   * ```
   * @public
   */
  static async isAnimated(file) {
    if (file.type === "image/gif") {
      return isGifAnimated(await file.arrayBuffer());
    }
    if (file.type === "image/avif") {
      return isAvifAnimated(await file.arrayBuffer());
    }
    if (file.type === "image/webp") {
      return isWebpAnimated(await file.arrayBuffer());
    }
    if (file.type === "image/apng") {
      return isApngAnimated(await file.arrayBuffer());
    }
    return false;
  }
  /**
   * Check if a MIME type represents an animated image format.
   *
   * @param mimeType - The MIME type to check
   * @returns True if the MIME type is an animated image format, false otherwise
   * @example
   * ```ts
   * const isAnimated = MediaHelpers.isAnimatedImageType('image/gif')
   * console.log(isAnimated) // true
   * ```
   * @public
   */
  static isAnimatedImageType(mimeType) {
    return DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES.includes(mimeType || "");
  }
  /**
   * Check if a MIME type represents a static (non-animated) image format.
   *
   * @param mimeType - The MIME type to check
   * @returns True if the MIME type is a static image format, false otherwise
   * @example
   * ```ts
   * const isStatic = MediaHelpers.isStaticImageType('image/jpeg')
   * console.log(isStatic) // true
   * ```
   * @public
   */
  static isStaticImageType(mimeType) {
    return DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES.includes(mimeType || "");
  }
  /**
   * Check if a MIME type represents a vector image format.
   *
   * @param mimeType - The MIME type to check
   * @returns True if the MIME type is a vector image format, false otherwise
   * @example
   * ```ts
   * const isVector = MediaHelpers.isVectorImageType('image/svg+xml')
   * console.log(isVector) // true
   * ```
   * @public
   */
  static isVectorImageType(mimeType) {
    return DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES.includes(mimeType || "");
  }
  /**
   * Check if a MIME type represents any supported image format (static, animated, or vector).
   *
   * @param mimeType - The MIME type to check
   * @returns True if the MIME type is a supported image format, false otherwise
   * @example
   * ```ts
   * const isImage = MediaHelpers.isImageType('image/png')
   * console.log(isImage) // true
   * ```
   * @public
   */
  static isImageType(mimeType) {
    return DEFAULT_SUPPORTED_IMAGE_TYPES.includes(mimeType || "");
  }
  /**
   * Utility function to create an object URL from a blob, execute a function with it, and automatically clean it up.
   *
   * @param blob - The Blob to create an object URL for
   * @param fn - Function to execute with the object URL
   * @returns Promise that resolves to the result of the function
   * @example
   * ```ts
   * const result = await MediaHelpers.usingObjectURL(imageBlob, async (url) => {
   *   const { w, h } = await MediaHelpers.getImageAndDimensions(url)
   *   return { width: w, height: h }
   * })
   * // Object URL is automatically revoked after function completes
   * console.log(`Image dimensions: ${result.width}x${result.height}`)
   * ```
   * @public
   */
  static async usingObjectURL(blob, fn) {
    const url = URL.createObjectURL(blob);
    try {
      return await fn(url);
    } finally {
      URL.revokeObjectURL(url);
    }
  }
}
function lerp(a, b, t2) {
  return a + (b - a) * t2;
}
function invLerp(a, b, t2) {
  return (t2 - a) / (b - a);
}
function rng(seed = "") {
  let x = 0;
  let y = 0;
  let z = 0;
  let w = 0;
  function next() {
    const t2 = x ^ x << 11;
    x = y;
    y = z;
    z = w;
    w ^= (w >>> 19 ^ t2 ^ t2 >>> 8) >>> 0;
    return w / 4294967296 * 2;
  }
  for (let k = 0; k < seed.length + 64; k++) {
    x ^= seed.charCodeAt(k) | 0;
    next();
  }
  return next;
}
function modulate(value, rangeA, rangeB, clamp2 = false) {
  const [fromLow, fromHigh] = rangeA;
  const [v0, v1] = rangeB;
  const result = v0 + (value - fromLow) / (fromHigh - fromLow) * (v1 - v0);
  return clamp2 ? v0 < v1 ? Math.max(Math.min(result, v1), v0) : Math.max(Math.min(result, v0), v1) : result;
}
function hasOwnProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function getOwnProperty(obj, key) {
  if (!hasOwnProperty(obj, key)) {
    return void 0;
  }
  return obj[key];
}
function objectMapKeys(object2) {
  return Object.keys(object2);
}
function objectMapValues(object2) {
  return Object.values(object2);
}
function objectMapEntries(object2) {
  return Object.entries(object2);
}
function objectMapFromEntries(entries) {
  return Object.fromEntries(entries);
}
function filterEntries(object2, predicate) {
  const result = {};
  let didChange = false;
  for (const [key, value] of objectMapEntries(object2)) {
    if (predicate(key, value)) {
      result[key] = value;
    } else {
      didChange = true;
    }
  }
  return didChange ? result : object2;
}
function mapObjectMapValues(object2, mapper) {
  const result = {};
  for (const key in object2) {
    if (!Object.prototype.hasOwnProperty.call(object2, key)) continue;
    result[key] = mapper(key, object2[key]);
  }
  return result;
}
function areObjectsShallowEqual(obj1, obj2) {
  if (obj1 === obj2) return true;
  const keys1 = new Set(Object.keys(obj1));
  const keys2 = new Set(Object.keys(obj2));
  if (keys1.size !== keys2.size) return false;
  for (const key of keys1) {
    if (!keys2.has(key)) return false;
    if (!Object.is(obj1[key], obj2[key])) return false;
  }
  return true;
}
function getChangedKeys(obj1, obj2) {
  const result = [];
  for (const key in obj1) {
    if (!Object.is(obj1[key], obj2[key])) {
      result.push(key);
    }
  }
  return result;
}
function isEqualAllowingForFloatingPointErrors(obj1, obj2, threshold = 1e-6) {
  return isEqualWith(obj1, obj2, (value1, value2) => {
    if (typeof value1 === "number" && typeof value2 === "number") {
      return Math.abs(value1 - value2) < threshold;
    }
    return void 0;
  });
}
const PERFORMANCE_COLORS = {
  Good: "#40C057",
  Mid: "#FFC078",
  Poor: "#E03131"
};
const PERFORMANCE_PREFIX_COLOR = PERFORMANCE_COLORS.Good;
class PerformanceTracker {
  startTime = 0;
  name = "";
  frames = 0;
  started = false;
  frame = null;
  /**
   * Records animation frames to calculate frame rate.
   * Called automatically during performance tracking.
   */
  // eslint-disable-next-line local/prefer-class-methods
  recordFrame = () => {
    this.frames++;
    if (!this.started) return;
    this.frame = requestAnimationFrame(this.recordFrame);
  };
  /**
   * Starts performance tracking for a named operation.
   *
   * @param name - A descriptive name for the operation being tracked
   *
   * @example
   * ```ts
   * tracker.start('canvas-render')
   * // ... perform rendering operations
   * tracker.stop()
   * ```
   */
  start(name) {
    this.name = name;
    this.frames = 0;
    this.started = true;
    if (this.frame !== null) cancelAnimationFrame(this.frame);
    this.frame = requestAnimationFrame(this.recordFrame);
    this.startTime = performance.now();
  }
  /**
   * Stops performance tracking and logs results to the console.
   *
   * Displays the operation name, frame rate, and uses color coding:
   * - Green background: \> 55 FPS (good performance)
   * - Yellow background: 30-55 FPS (moderate performance)
   * - Red background: \< 30 FPS (poor performance)
   *
   * @example
   * ```ts
   * tracker.start('interaction')
   * handleUserInteraction()
   * tracker.stop() // Logs: "Perf Interaction 60 fps"
   * ```
   */
  stop() {
    this.started = false;
    if (this.frame !== null) cancelAnimationFrame(this.frame);
    const duration = (performance.now() - this.startTime) / 1e3;
    const fps = duration === 0 ? 0 : Math.floor(this.frames / duration);
    const background = fps > 55 ? PERFORMANCE_COLORS.Good : fps > 30 ? PERFORMANCE_COLORS.Mid : PERFORMANCE_COLORS.Poor;
    const color = background === PERFORMANCE_COLORS.Mid ? "black" : "white";
    const capitalized = this.name[0].toUpperCase() + this.name.slice(1);
    console.debug(
      `%cPerf%c ${capitalized} %c${fps}%c fps`,
      `color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,
      "font-weight: normal",
      `font-weight: bold; padding: 2px; background: ${background};color: ${color};`,
      "font-weight: normal"
    );
  }
  /**
   * Checks whether performance tracking is currently active.
   *
   * @returns True if tracking is in progress, false otherwise
   *
   * @example
   * ```ts
   * if (!tracker.isStarted()) {
   *   tracker.start('new-operation')
   * }
   * ```
   */
  isStarted() {
    return this.started;
  }
}
const BASE_62_DIGITS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
function midpoint(a, b, digits) {
  const zero = digits[0];
  if (b != null && a >= b) {
    throw new Error(a + " >= " + b);
  }
  if (a.slice(-1) === zero || b && b.slice(-1) === zero) {
    throw new Error("trailing zero");
  }
  if (b) {
    let n = 0;
    while ((a[n] || zero) === b[n]) {
      n++;
    }
    if (n > 0) {
      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits);
    }
  }
  const digitA = a ? digits.indexOf(a[0]) : 0;
  const digitB = b != null ? digits.indexOf(b[0]) : digits.length;
  if (digitB - digitA > 1) {
    const midDigit = Math.round(0.5 * (digitA + digitB));
    return digits[midDigit];
  } else {
    if (b && b.length > 1) {
      return b.slice(0, 1);
    } else {
      return digits[digitA] + midpoint(a.slice(1), null, digits);
    }
  }
}
function validateInteger(int) {
  if (int.length !== getIntegerLength(int[0])) {
    throw new Error("invalid integer part of order key: " + int);
  }
}
function getIntegerLength(head) {
  if (head >= "a" && head <= "z") {
    return head.charCodeAt(0) - "a".charCodeAt(0) + 2;
  } else if (head >= "A" && head <= "Z") {
    return "Z".charCodeAt(0) - head.charCodeAt(0) + 2;
  } else {
    throw new Error("invalid order key head: " + head);
  }
}
function getIntegerPart(key) {
  const integerPartLength = getIntegerLength(key[0]);
  if (integerPartLength > key.length) {
    throw new Error("invalid order key: " + key);
  }
  return key.slice(0, integerPartLength);
}
function validateOrderKey(key, digits) {
  if (key === "A" + digits[0].repeat(26)) {
    throw new Error("invalid order key: " + key);
  }
  const i = getIntegerPart(key);
  const f = key.slice(i.length);
  if (f.slice(-1) === digits[0]) {
    throw new Error("invalid order key: " + key);
  }
}
function incrementInteger(x, digits) {
  validateInteger(x);
  const [head, ...digs] = x.split("");
  let carry = true;
  for (let i = digs.length - 1; carry && i >= 0; i--) {
    const d = digits.indexOf(digs[i]) + 1;
    if (d === digits.length) {
      digs[i] = digits[0];
    } else {
      digs[i] = digits[d];
      carry = false;
    }
  }
  if (carry) {
    if (head === "Z") {
      return "a" + digits[0];
    }
    if (head === "z") {
      return null;
    }
    const h2 = String.fromCharCode(head.charCodeAt(0) + 1);
    if (h2 > "a") {
      digs.push(digits[0]);
    } else {
      digs.pop();
    }
    return h2 + digs.join("");
  } else {
    return head + digs.join("");
  }
}
function decrementInteger(x, digits) {
  validateInteger(x);
  const [head, ...digs] = x.split("");
  let borrow = true;
  for (let i = digs.length - 1; borrow && i >= 0; i--) {
    const d = digits.indexOf(digs[i]) - 1;
    if (d === -1) {
      digs[i] = digits.slice(-1);
    } else {
      digs[i] = digits[d];
      borrow = false;
    }
  }
  if (borrow) {
    if (head === "a") {
      return "Z" + digits.slice(-1);
    }
    if (head === "A") {
      return null;
    }
    const h2 = String.fromCharCode(head.charCodeAt(0) - 1);
    if (h2 < "Z") {
      digs.push(digits.slice(-1));
    } else {
      digs.pop();
    }
    return h2 + digs.join("");
  } else {
    return head + digs.join("");
  }
}
function generateKeyBetween$1(a, b, digits = BASE_62_DIGITS) {
  if (a != null) {
    validateOrderKey(a, digits);
  }
  if (b != null) {
    validateOrderKey(b, digits);
  }
  if (a != null && b != null && a >= b) {
    throw new Error(a + " >= " + b);
  }
  if (a == null) {
    if (b == null) {
      return "a" + digits[0];
    }
    const ib2 = getIntegerPart(b);
    const fb2 = b.slice(ib2.length);
    if (ib2 === "A" + digits[0].repeat(26)) {
      return ib2 + midpoint("", fb2, digits);
    }
    if (ib2 < b) {
      return ib2;
    }
    const res = decrementInteger(ib2, digits);
    if (res == null) {
      throw new Error("cannot decrement any more");
    }
    return res;
  }
  if (b == null) {
    const ia2 = getIntegerPart(a);
    const fa2 = a.slice(ia2.length);
    const i2 = incrementInteger(ia2, digits);
    return i2 == null ? ia2 + midpoint(fa2, null, digits) : i2;
  }
  const ia = getIntegerPart(a);
  const fa = a.slice(ia.length);
  const ib = getIntegerPart(b);
  const fb = b.slice(ib.length);
  if (ia === ib) {
    return ia + midpoint(fa, fb, digits);
  }
  const i = incrementInteger(ia, digits);
  if (i == null) {
    throw new Error("cannot increment any more");
  }
  if (i < b) {
    return i;
  }
  return ia + midpoint(fa, null, digits);
}
function generateNKeysBetween$1(a, b, n, digits = BASE_62_DIGITS) {
  if (n === 0) {
    return [];
  }
  if (n === 1) {
    return [generateKeyBetween$1(a, b, digits)];
  }
  if (b == null) {
    let c2 = generateKeyBetween$1(a, b, digits);
    const result = [c2];
    for (let i = 0; i < n - 1; i++) {
      c2 = generateKeyBetween$1(c2, b, digits);
      result.push(c2);
    }
    return result;
  }
  if (a == null) {
    let c2 = generateKeyBetween$1(a, b, digits);
    const result = [c2];
    for (let i = 0; i < n - 1; i++) {
      c2 = generateKeyBetween$1(a, c2, digits);
      result.push(c2);
    }
    result.reverse();
    return result;
  }
  const mid = Math.floor(n / 2);
  const c = generateKeyBetween$1(a, b, digits);
  return [
    ...generateNKeysBetween$1(a, c, mid, digits),
    c,
    ...generateNKeysBetween$1(c, b, n - mid - 1, digits)
  ];
}
const DEFAULT_JITTER_BITS = 30;
const DEFAULT_GET_RANDOM_BIT = () => Math.random() < 0.5;
function assertIsNonnegativeInteger(paramName, n) {
  if (!Number.isInteger(n)) {
    throw new Error(`"${paramName}" must be an integer, got '${n}'`);
  }
  if (n < 0) {
    throw new Error(
      `"${paramName}" must be greater than or equal to 0, got '${n}'`
    );
  }
}
function generateKeyBetween(a, b, opts) {
  const {
    digits,
    jitterBits = DEFAULT_JITTER_BITS,
    getRandomBit = DEFAULT_GET_RANDOM_BIT
  } = opts ?? {};
  assertIsNonnegativeInteger("jitterBits", jitterBits);
  let remainingJitterBits = jitterBits;
  let low = a;
  let high = b;
  let midpoint2 = generateKeyBetween$1(a, b, digits);
  while (remainingJitterBits > 0) {
    const randomBit = getRandomBit() ? 1 : 0;
    if (randomBit === 1) {
      low = midpoint2;
    } else {
      high = midpoint2;
    }
    midpoint2 = generateKeyBetween$1(low, high, digits);
    remainingJitterBits--;
  }
  return midpoint2;
}
function generateNKeysBetween(a, b, n, opts) {
  const { digits, jitterBits } = opts ?? {};
  assertIsNonnegativeInteger("n", n);
  if (n === 0) {
    return [];
  }
  if (jitterBits === 0) {
    return generateNKeysBetween$1(a, b, n, digits);
  }
  const keys2 = generateNKeysBetween$1(a, b, n + 1, digits);
  const jitteredKeys = [];
  for (let i = 0; i < n; i++) {
    const currentKey = keys2[i];
    const nextKey = keys2[i + 1];
    jitteredKeys.push(generateKeyBetween(currentKey, nextKey, opts));
  }
  return jitteredKeys;
}
const generateKeysFn = generateNKeysBetween;
const ZERO_INDEX_KEY = "a0";
function validateIndexKey(index2) {
  try {
    generateKeyBetween(index2, null);
  } catch {
    throw new Error("invalid index: " + index2);
  }
}
function getIndicesBetween(below, above, n) {
  return generateKeysFn(below ?? null, above ?? null, n);
}
function getIndicesAbove(below, n) {
  return generateKeysFn(below ?? null, null, n);
}
function getIndexBetween(below, above) {
  return generateKeysFn(below ?? null, above ?? null, 1)[0];
}
function getIndexAbove(below = null) {
  return generateKeysFn(below, null, 1)[0];
}
function getIndexBelow(above = null) {
  return generateKeysFn(null, above, 1)[0];
}
function getIndices(n, start = "a1") {
  return [start, ...generateKeysFn(start, null, n)];
}
function sortByIndex(a, b) {
  if (a.index < b.index) {
    return -1;
  } else if (a.index > b.index) {
    return 1;
  }
  return 0;
}
function sortById(a, b) {
  return a.id > b.id ? 1 : -1;
}
function getFromLocalStorage(key) {
  try {
    return localStorage.getItem(key);
  } catch {
    return null;
  }
}
function setInLocalStorage(key, value) {
  try {
    localStorage.setItem(key, value);
  } catch {
  }
}
function clearLocalStorage() {
  try {
    localStorage.clear();
  } catch {
  }
}
function getFromSessionStorage(key) {
  try {
    return sessionStorage.getItem(key);
  } catch {
    return null;
  }
}
function setInSessionStorage(key, value) {
  try {
    sessionStorage.setItem(key, value);
  } catch {
  }
}
function deleteFromSessionStorage(key) {
  try {
    sessionStorage.removeItem(key);
  } catch {
  }
}
function clearSessionStorage() {
  try {
    sessionStorage.clear();
  } catch {
  }
}
const fpsQueue = [];
const targetFps = 60;
const targetTimePerFrame = Math.floor(1e3 / targetFps) * 0.9;
let frameRaf;
let flushRaf;
let lastFlushTime = -targetTimePerFrame;
const flush = () => {
  const queue = fpsQueue.splice(0, fpsQueue.length);
  for (const fn of queue) {
    fn();
  }
};
function tick(isOnNextFrame = false) {
  if (frameRaf) return;
  const now = Date.now();
  const elapsed = now - lastFlushTime;
  if (elapsed < targetTimePerFrame) {
    frameRaf = requestAnimationFrame(() => {
      frameRaf = void 0;
      tick(true);
    });
    return;
  }
  if (isOnNextFrame) {
    if (flushRaf) return;
    lastFlushTime = now;
    flush();
  } else {
    if (flushRaf) return;
    flushRaf = requestAnimationFrame(() => {
      flushRaf = void 0;
      lastFlushTime = now;
      flush();
    });
  }
}
function throttleToNextFrame$1(fn) {
  if (!fpsQueue.includes(fn)) {
    fpsQueue.push(fn);
    tick();
  }
  return () => {
    const index2 = fpsQueue.indexOf(fn);
    if (index2 > -1) {
      fpsQueue.splice(index2, 1);
    }
  };
}
class Timers {
  timeouts = /* @__PURE__ */ new Map();
  intervals = /* @__PURE__ */ new Map();
  rafs = /* @__PURE__ */ new Map();
  /**
   * Creates a new Timers instance with bound methods for safe callback usage.
   * @example
   * ```ts
   * const timers = new Timers()
   * // Methods are pre-bound, safe to use as callbacks
   * element.addEventListener('click', timers.dispose)
   * ```
   */
  constructor() {
    this.setTimeout = this.setTimeout.bind(this);
    this.setInterval = this.setInterval.bind(this);
    this.requestAnimationFrame = this.requestAnimationFrame.bind(this);
    this.dispose = this.dispose.bind(this);
  }
  /**
   * Creates a timeout that will be tracked under the specified context.
   * @param contextId - The context identifier to group this timer under.
   * @param handler - The function to execute when the timeout expires.
   * @param timeout - The delay in milliseconds (default: 0).
   * @param args - Additional arguments to pass to the handler.
   * @returns The timer ID that can be used with clearTimeout.
   * @example
   * ```ts
   * const timers = new Timers()
   * const id = timers.setTimeout('autosave', () => save(), 5000)
   * // Timer will be automatically cleared when 'autosave' context is disposed
   * ```
   * @public
   */
  setTimeout(contextId, handler, timeout, ...args) {
    const id = window.setTimeout(handler, timeout, args);
    const current = this.timeouts.get(contextId) ?? [];
    this.timeouts.set(contextId, [...current, id]);
    return id;
  }
  /**
   * Creates an interval that will be tracked under the specified context.
   * @param contextId - The context identifier to group this timer under.
   * @param handler - The function to execute repeatedly.
   * @param timeout - The delay in milliseconds between executions (default: 0).
   * @param args - Additional arguments to pass to the handler.
   * @returns The interval ID that can be used with clearInterval.
   * @example
   * ```ts
   * const timers = new Timers()
   * const id = timers.setInterval('refresh', () => updateData(), 1000)
   * // Interval will be automatically cleared when 'refresh' context is disposed
   * ```
   * @public
   */
  setInterval(contextId, handler, timeout, ...args) {
    const id = window.setInterval(handler, timeout, args);
    const current = this.intervals.get(contextId) ?? [];
    this.intervals.set(contextId, [...current, id]);
    return id;
  }
  /**
   * Requests an animation frame that will be tracked under the specified context.
   * @param contextId - The context identifier to group this animation frame under.
   * @param callback - The function to execute on the next animation frame.
   * @returns The request ID that can be used with cancelAnimationFrame.
   * @example
   * ```ts
   * const timers = new Timers()
   * const id = timers.requestAnimationFrame('render', () => draw())
   * // Animation frame will be automatically cancelled when 'render' context is disposed
   * ```
   * @public
   */
  requestAnimationFrame(contextId, callback) {
    const id = window.requestAnimationFrame(callback);
    const current = this.rafs.get(contextId) ?? [];
    this.rafs.set(contextId, [...current, id]);
    return id;
  }
  /**
   * Disposes of all timers associated with the specified context.
   * Clears all timeouts, intervals, and animation frames for the given context ID.
   * @param contextId - The context identifier whose timers should be cleared.
   * @returns void
   * @example
   * ```ts
   * const timers = new Timers()
   * timers.setTimeout('ui', () => console.log('timeout'), 1000)
   * timers.setInterval('ui', () => console.log('interval'), 500)
   *
   * // Clear all 'ui' context timers
   * timers.dispose('ui')
   * ```
   * @public
   */
  dispose(contextId) {
    this.timeouts.get(contextId)?.forEach((id) => clearTimeout(id));
    this.intervals.get(contextId)?.forEach((id) => clearInterval(id));
    this.rafs.get(contextId)?.forEach((id) => cancelAnimationFrame(id));
    this.timeouts.delete(contextId);
    this.intervals.delete(contextId);
    this.rafs.delete(contextId);
  }
  /**
   * Disposes of all timers across all contexts.
   * Clears every timeout, interval, and animation frame managed by this instance.
   * @returns void
   * @example
   * ```ts
   * const timers = new Timers()
   * timers.setTimeout('ui', () => console.log('ui'), 1000)
   * timers.setTimeout('background', () => console.log('bg'), 2000)
   *
   * // Clear everything
   * timers.disposeAll()
   * ```
   * @public
   */
  disposeAll() {
    for (const contextId of this.timeouts.keys()) {
      this.dispose(contextId);
    }
  }
  /**
   * Returns an object with timer methods bound to a specific context.
   * Convenient for getting context-specific timer functions without repeatedly passing the contextId.
   * @param contextId - The context identifier to bind the returned methods to.
   * @returns An object with setTimeout, setInterval, requestAnimationFrame, and dispose methods bound to the context.
   * @example
   * ```ts
   * const timers = new Timers()
   * const uiTimers = timers.forContext('ui')
   *
   * // These are equivalent to calling timers.setTimeout('ui', ...)
   * uiTimers.setTimeout(() => console.log('timeout'), 1000)
   * uiTimers.setInterval(() => console.log('interval'), 500)
   * uiTimers.requestAnimationFrame(() => console.log('frame'))
   *
   * // Dispose only this context
   * uiTimers.dispose()
   * ```
   * @public
   */
  forContext(contextId) {
    return {
      setTimeout: (handler, timeout, ...args) => this.setTimeout(contextId, handler, timeout, args),
      setInterval: (handler, timeout, ...args) => this.setInterval(contextId, handler, timeout, args),
      requestAnimationFrame: (callback) => this.requestAnimationFrame(contextId, callback),
      dispose: () => this.dispose(contextId)
    };
  }
}
const safeParseUrl = (url, baseUrl) => {
  try {
    return new URL(url, baseUrl);
  } catch {
    return;
  }
};
function isDefined(value) {
  return value !== void 0;
}
function getStructuredClone() {
  if (typeof globalThis !== "undefined" && globalThis.structuredClone) {
    return [globalThis.structuredClone, true];
  }
  if (typeof global !== "undefined" && global.structuredClone) {
    return [global.structuredClone, true];
  }
  if (typeof window !== "undefined" && window.structuredClone) {
    return [window.structuredClone, true];
  }
  return [(i) => i ? JSON.parse(JSON.stringify(i)) : i, false];
}
const _structuredClone = getStructuredClone();
const structuredClone = _structuredClone[0];
_structuredClone[1];
const STRUCTURED_CLONE_OBJECT_PROTOTYPE = Object.getPrototypeOf(structuredClone({}));
const usedWarnings = /* @__PURE__ */ new Set();
function warnOnce(message) {
  if (usedWarnings.has(message)) return;
  usedWarnings.add(message);
  console.warn(`[tldraw] ${message}`);
}
registerTldrawLibraryVersion(
  "@tldraw/utils",
  "4.2.0",
  "esm"
);
var es_array_at = {};
var globalThis_1;
var hasRequiredGlobalThis;
function requireGlobalThis() {
  if (hasRequiredGlobalThis) return globalThis_1;
  hasRequiredGlobalThis = 1;
  var check = function(it) {
    return it && it.Math === Math && it;
  };
  globalThis_1 = // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof globalThis_1 == "object" && globalThis_1) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ (function() {
    return this;
  })() || Function("return this")();
  return globalThis_1;
}
var objectGetOwnPropertyDescriptor = {};
var fails;
var hasRequiredFails;
function requireFails() {
  if (hasRequiredFails) return fails;
  hasRequiredFails = 1;
  fails = function(exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };
  return fails;
}
var descriptors;
var hasRequiredDescriptors;
function requireDescriptors() {
  if (hasRequiredDescriptors) return descriptors;
  hasRequiredDescriptors = 1;
  var fails2 = requireFails();
  descriptors = !fails2(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] !== 7;
  });
  return descriptors;
}
var functionBindNative;
var hasRequiredFunctionBindNative;
function requireFunctionBindNative() {
  if (hasRequiredFunctionBindNative) return functionBindNative;
  hasRequiredFunctionBindNative = 1;
  var fails2 = requireFails();
  functionBindNative = !fails2(function() {
    var test = (function() {
    }).bind();
    return typeof test != "function" || test.hasOwnProperty("prototype");
  });
  return functionBindNative;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var call2 = Function.prototype.call;
  functionCall = NATIVE_BIND ? call2.bind(call2) : function() {
    return call2.apply(call2, arguments);
  };
  return functionCall;
}
var objectPropertyIsEnumerable = {};
var hasRequiredObjectPropertyIsEnumerable;
function requireObjectPropertyIsEnumerable() {
  if (hasRequiredObjectPropertyIsEnumerable) return objectPropertyIsEnumerable;
  hasRequiredObjectPropertyIsEnumerable = 1;
  var $propertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
    var descriptor = getOwnPropertyDescriptor(this, V2);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;
  return objectPropertyIsEnumerable;
}
var createPropertyDescriptor;
var hasRequiredCreatePropertyDescriptor;
function requireCreatePropertyDescriptor() {
  if (hasRequiredCreatePropertyDescriptor) return createPropertyDescriptor;
  hasRequiredCreatePropertyDescriptor = 1;
  createPropertyDescriptor = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  return createPropertyDescriptor;
}
var functionUncurryThis;
var hasRequiredFunctionUncurryThis;
function requireFunctionUncurryThis() {
  if (hasRequiredFunctionUncurryThis) return functionUncurryThis;
  hasRequiredFunctionUncurryThis = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var FunctionPrototype = Function.prototype;
  var call2 = FunctionPrototype.call;
  var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call2, call2);
  functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
    return function() {
      return call2.apply(fn, arguments);
    };
  };
  return functionUncurryThis;
}
var classofRaw;
var hasRequiredClassofRaw;
function requireClassofRaw() {
  if (hasRequiredClassofRaw) return classofRaw;
  hasRequiredClassofRaw = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toString2 = uncurryThis({}.toString);
  var stringSlice = uncurryThis("".slice);
  classofRaw = function(it) {
    return stringSlice(toString2(it), 8, -1);
  };
  return classofRaw;
}
var indexedObject;
var hasRequiredIndexedObject;
function requireIndexedObject() {
  if (hasRequiredIndexedObject) return indexedObject;
  hasRequiredIndexedObject = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var classof2 = requireClassofRaw();
  var $Object = Object;
  var split2 = uncurryThis("".split);
  indexedObject = fails2(function() {
    return !$Object("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof2(it) === "String" ? split2(it, "") : $Object(it);
  } : $Object;
  return indexedObject;
}
var isNullOrUndefined;
var hasRequiredIsNullOrUndefined;
function requireIsNullOrUndefined() {
  if (hasRequiredIsNullOrUndefined) return isNullOrUndefined;
  hasRequiredIsNullOrUndefined = 1;
  isNullOrUndefined = function(it) {
    return it === null || it === void 0;
  };
  return isNullOrUndefined;
}
var requireObjectCoercible;
var hasRequiredRequireObjectCoercible;
function requireRequireObjectCoercible() {
  if (hasRequiredRequireObjectCoercible) return requireObjectCoercible;
  hasRequiredRequireObjectCoercible = 1;
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  var $TypeError = TypeError;
  requireObjectCoercible = function(it) {
    if (isNullOrUndefined2(it)) throw new $TypeError("Can't call method on " + it);
    return it;
  };
  return requireObjectCoercible;
}
var toIndexedObject;
var hasRequiredToIndexedObject;
function requireToIndexedObject() {
  if (hasRequiredToIndexedObject) return toIndexedObject;
  hasRequiredToIndexedObject = 1;
  var IndexedObject = requireIndexedObject();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  toIndexedObject = function(it) {
    return IndexedObject(requireObjectCoercible2(it));
  };
  return toIndexedObject;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var documentAll = typeof document == "object" && document.all;
  isCallable = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
    return typeof argument == "function" || argument === documentAll;
  } : function(argument) {
    return typeof argument == "function";
  };
  return isCallable;
}
var isObject;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject;
  hasRequiredIsObject = 1;
  var isCallable2 = requireIsCallable();
  isObject = function(it) {
    return typeof it == "object" ? it !== null : isCallable2(it);
  };
  return isObject;
}
var getBuiltIn;
var hasRequiredGetBuiltIn;
function requireGetBuiltIn() {
  if (hasRequiredGetBuiltIn) return getBuiltIn;
  hasRequiredGetBuiltIn = 1;
  var globalThis2 = requireGlobalThis();
  var isCallable2 = requireIsCallable();
  var aFunction = function(argument) {
    return isCallable2(argument) ? argument : void 0;
  };
  getBuiltIn = function(namespace, method) {
    return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
  };
  return getBuiltIn;
}
var objectIsPrototypeOf;
var hasRequiredObjectIsPrototypeOf;
function requireObjectIsPrototypeOf() {
  if (hasRequiredObjectIsPrototypeOf) return objectIsPrototypeOf;
  hasRequiredObjectIsPrototypeOf = 1;
  var uncurryThis = requireFunctionUncurryThis();
  objectIsPrototypeOf = uncurryThis({}.isPrototypeOf);
  return objectIsPrototypeOf;
}
var environmentUserAgent;
var hasRequiredEnvironmentUserAgent;
function requireEnvironmentUserAgent() {
  if (hasRequiredEnvironmentUserAgent) return environmentUserAgent;
  hasRequiredEnvironmentUserAgent = 1;
  var globalThis2 = requireGlobalThis();
  var navigator2 = globalThis2.navigator;
  var userAgent = navigator2 && navigator2.userAgent;
  environmentUserAgent = userAgent ? String(userAgent) : "";
  return environmentUserAgent;
}
var environmentV8Version;
var hasRequiredEnvironmentV8Version;
function requireEnvironmentV8Version() {
  if (hasRequiredEnvironmentV8Version) return environmentV8Version;
  hasRequiredEnvironmentV8Version = 1;
  var globalThis2 = requireGlobalThis();
  var userAgent = requireEnvironmentUserAgent();
  var process = globalThis2.process;
  var Deno = globalThis2.Deno;
  var versions = process && process.versions || Deno && Deno.version;
  var v8 = versions && versions.v8;
  var match, version2;
  if (v8) {
    match = v8.split(".");
    version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }
  if (!version2 && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent.match(/Chrome\/(\d+)/);
      if (match) version2 = +match[1];
    }
  }
  environmentV8Version = version2;
  return environmentV8Version;
}
var symbolConstructorDetection;
var hasRequiredSymbolConstructorDetection;
function requireSymbolConstructorDetection() {
  if (hasRequiredSymbolConstructorDetection) return symbolConstructorDetection;
  hasRequiredSymbolConstructorDetection = 1;
  var V8_VERSION = requireEnvironmentV8Version();
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $String = globalThis2.String;
  symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails2(function() {
    var symbol = Symbol("symbol detection");
    return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
  });
  return symbolConstructorDetection;
}
var useSymbolAsUid;
var hasRequiredUseSymbolAsUid;
function requireUseSymbolAsUid() {
  if (hasRequiredUseSymbolAsUid) return useSymbolAsUid;
  hasRequiredUseSymbolAsUid = 1;
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  useSymbolAsUid = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  return useSymbolAsUid;
}
var isSymbol;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol;
  hasRequiredIsSymbol = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var isCallable2 = requireIsCallable();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
  var $Object = Object;
  isSymbol = USE_SYMBOL_AS_UID ? function(it) {
    return typeof it == "symbol";
  } : function(it) {
    var $Symbol = getBuiltIn2("Symbol");
    return isCallable2($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
  };
  return isSymbol;
}
var tryToString;
var hasRequiredTryToString;
function requireTryToString() {
  if (hasRequiredTryToString) return tryToString;
  hasRequiredTryToString = 1;
  var $String = String;
  tryToString = function(argument) {
    try {
      return $String(argument);
    } catch (error) {
      return "Object";
    }
  };
  return tryToString;
}
var aCallable;
var hasRequiredACallable;
function requireACallable() {
  if (hasRequiredACallable) return aCallable;
  hasRequiredACallable = 1;
  var isCallable2 = requireIsCallable();
  var tryToString2 = requireTryToString();
  var $TypeError = TypeError;
  aCallable = function(argument) {
    if (isCallable2(argument)) return argument;
    throw new $TypeError(tryToString2(argument) + " is not a function");
  };
  return aCallable;
}
var getMethod$1;
var hasRequiredGetMethod;
function requireGetMethod() {
  if (hasRequiredGetMethod) return getMethod$1;
  hasRequiredGetMethod = 1;
  var aCallable2 = requireACallable();
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  getMethod$1 = function(V2, P) {
    var func = V2[P];
    return isNullOrUndefined2(func) ? void 0 : aCallable2(func);
  };
  return getMethod$1;
}
var ordinaryToPrimitive;
var hasRequiredOrdinaryToPrimitive;
function requireOrdinaryToPrimitive() {
  if (hasRequiredOrdinaryToPrimitive) return ordinaryToPrimitive;
  hasRequiredOrdinaryToPrimitive = 1;
  var call2 = requireFunctionCall();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var $TypeError = TypeError;
  ordinaryToPrimitive = function(input, pref) {
    var fn, val;
    if (pref === "string" && isCallable2(fn = input.toString) && !isObject2(val = call2(fn, input))) return val;
    if (isCallable2(fn = input.valueOf) && !isObject2(val = call2(fn, input))) return val;
    if (pref !== "string" && isCallable2(fn = input.toString) && !isObject2(val = call2(fn, input))) return val;
    throw new $TypeError("Can't convert object to primitive value");
  };
  return ordinaryToPrimitive;
}
var sharedStore = { exports: {} };
var isPure;
var hasRequiredIsPure;
function requireIsPure() {
  if (hasRequiredIsPure) return isPure;
  hasRequiredIsPure = 1;
  isPure = false;
  return isPure;
}
var defineGlobalProperty;
var hasRequiredDefineGlobalProperty;
function requireDefineGlobalProperty() {
  if (hasRequiredDefineGlobalProperty) return defineGlobalProperty;
  hasRequiredDefineGlobalProperty = 1;
  var globalThis2 = requireGlobalThis();
  var defineProperty = Object.defineProperty;
  defineGlobalProperty = function(key, value) {
    try {
      defineProperty(globalThis2, key, { value, configurable: true, writable: true });
    } catch (error) {
      globalThis2[key] = value;
    }
    return value;
  };
  return defineGlobalProperty;
}
var hasRequiredSharedStore;
function requireSharedStore() {
  if (hasRequiredSharedStore) return sharedStore.exports;
  hasRequiredSharedStore = 1;
  var IS_PURE = requireIsPure();
  var globalThis2 = requireGlobalThis();
  var defineGlobalProperty2 = requireDefineGlobalProperty();
  var SHARED = "__core-js_shared__";
  var store = sharedStore.exports = globalThis2[SHARED] || defineGlobalProperty2(SHARED, {});
  (store.versions || (store.versions = [])).push({
    version: "3.47.0",
    mode: IS_PURE ? "pure" : "global",
    copyright: " 2014-2025 Denis Pushkarev (zloirock.ru), 2025 CoreJS Company (core-js.io)",
    license: "https://github.com/zloirock/core-js/blob/v3.47.0/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
  return sharedStore.exports;
}
var shared;
var hasRequiredShared;
function requireShared() {
  if (hasRequiredShared) return shared;
  hasRequiredShared = 1;
  var store = requireSharedStore();
  shared = function(key, value) {
    return store[key] || (store[key] = value || {});
  };
  return shared;
}
var toObject;
var hasRequiredToObject;
function requireToObject() {
  if (hasRequiredToObject) return toObject;
  hasRequiredToObject = 1;
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var $Object = Object;
  toObject = function(argument) {
    return $Object(requireObjectCoercible2(argument));
  };
  return toObject;
}
var hasOwnProperty_1;
var hasRequiredHasOwnProperty;
function requireHasOwnProperty() {
  if (hasRequiredHasOwnProperty) return hasOwnProperty_1;
  hasRequiredHasOwnProperty = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toObject2 = requireToObject();
  var hasOwnProperty2 = uncurryThis({}.hasOwnProperty);
  hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty2(toObject2(it), key);
  };
  return hasOwnProperty_1;
}
var uid;
var hasRequiredUid;
function requireUid() {
  if (hasRequiredUid) return uid;
  hasRequiredUid = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var id = 0;
  var postfix = Math.random();
  var toString2 = uncurryThis(1.1.toString);
  uid = function(key) {
    return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
  };
  return uid;
}
var wellKnownSymbol;
var hasRequiredWellKnownSymbol;
function requireWellKnownSymbol() {
  if (hasRequiredWellKnownSymbol) return wellKnownSymbol;
  hasRequiredWellKnownSymbol = 1;
  var globalThis2 = requireGlobalThis();
  var shared2 = requireShared();
  var hasOwn = requireHasOwnProperty();
  var uid2 = requireUid();
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
  var Symbol2 = globalThis2.Symbol;
  var WellKnownSymbolsStore = shared2("wks");
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
  wellKnownSymbol = function(name) {
    if (!hasOwn(WellKnownSymbolsStore, name)) {
      WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
    }
    return WellKnownSymbolsStore[name];
  };
  return wellKnownSymbol;
}
var toPrimitive;
var hasRequiredToPrimitive;
function requireToPrimitive() {
  if (hasRequiredToPrimitive) return toPrimitive;
  hasRequiredToPrimitive = 1;
  var call2 = requireFunctionCall();
  var isObject2 = requireIsObject();
  var isSymbol2 = requireIsSymbol();
  var getMethod2 = requireGetMethod();
  var ordinaryToPrimitive2 = requireOrdinaryToPrimitive();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var $TypeError = TypeError;
  var TO_PRIMITIVE = wellKnownSymbol2("toPrimitive");
  toPrimitive = function(input, pref) {
    if (!isObject2(input) || isSymbol2(input)) return input;
    var exoticToPrim = getMethod2(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === void 0) pref = "default";
      result = call2(exoticToPrim, input, pref);
      if (!isObject2(result) || isSymbol2(result)) return result;
      throw new $TypeError("Can't convert object to primitive value");
    }
    if (pref === void 0) pref = "number";
    return ordinaryToPrimitive2(input, pref);
  };
  return toPrimitive;
}
var toPropertyKey;
var hasRequiredToPropertyKey;
function requireToPropertyKey() {
  if (hasRequiredToPropertyKey) return toPropertyKey;
  hasRequiredToPropertyKey = 1;
  var toPrimitive2 = requireToPrimitive();
  var isSymbol2 = requireIsSymbol();
  toPropertyKey = function(argument) {
    var key = toPrimitive2(argument, "string");
    return isSymbol2(key) ? key : key + "";
  };
  return toPropertyKey;
}
var documentCreateElement;
var hasRequiredDocumentCreateElement;
function requireDocumentCreateElement() {
  if (hasRequiredDocumentCreateElement) return documentCreateElement;
  hasRequiredDocumentCreateElement = 1;
  var globalThis2 = requireGlobalThis();
  var isObject2 = requireIsObject();
  var document2 = globalThis2.document;
  var EXISTS = isObject2(document2) && isObject2(document2.createElement);
  documentCreateElement = function(it) {
    return EXISTS ? document2.createElement(it) : {};
  };
  return documentCreateElement;
}
var ie8DomDefine;
var hasRequiredIe8DomDefine;
function requireIe8DomDefine() {
  if (hasRequiredIe8DomDefine) return ie8DomDefine;
  hasRequiredIe8DomDefine = 1;
  var DESCRIPTORS = requireDescriptors();
  var fails2 = requireFails();
  var createElement = requireDocumentCreateElement();
  ie8DomDefine = !DESCRIPTORS && !fails2(function() {
    return Object.defineProperty(createElement("div"), "a", {
      get: function() {
        return 7;
      }
    }).a !== 7;
  });
  return ie8DomDefine;
}
var hasRequiredObjectGetOwnPropertyDescriptor;
function requireObjectGetOwnPropertyDescriptor() {
  if (hasRequiredObjectGetOwnPropertyDescriptor) return objectGetOwnPropertyDescriptor;
  hasRequiredObjectGetOwnPropertyDescriptor = 1;
  var DESCRIPTORS = requireDescriptors();
  var call2 = requireFunctionCall();
  var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  var toIndexedObject2 = requireToIndexedObject();
  var toPropertyKey2 = requireToPropertyKey();
  var hasOwn = requireHasOwnProperty();
  var IE8_DOM_DEFINE = requireIe8DomDefine();
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject2(O);
    P = toPropertyKey2(P);
    if (IE8_DOM_DEFINE) try {
      return $getOwnPropertyDescriptor(O, P);
    } catch (error) {
    }
    if (hasOwn(O, P)) return createPropertyDescriptor2(!call2(propertyIsEnumerableModule.f, O, P), O[P]);
  };
  return objectGetOwnPropertyDescriptor;
}
var objectDefineProperty = {};
var v8PrototypeDefineBug;
var hasRequiredV8PrototypeDefineBug;
function requireV8PrototypeDefineBug() {
  if (hasRequiredV8PrototypeDefineBug) return v8PrototypeDefineBug;
  hasRequiredV8PrototypeDefineBug = 1;
  var DESCRIPTORS = requireDescriptors();
  var fails2 = requireFails();
  v8PrototypeDefineBug = DESCRIPTORS && fails2(function() {
    return Object.defineProperty(function() {
    }, "prototype", {
      value: 42,
      writable: false
    }).prototype !== 42;
  });
  return v8PrototypeDefineBug;
}
var anObject;
var hasRequiredAnObject;
function requireAnObject() {
  if (hasRequiredAnObject) return anObject;
  hasRequiredAnObject = 1;
  var isObject2 = requireIsObject();
  var $String = String;
  var $TypeError = TypeError;
  anObject = function(argument) {
    if (isObject2(argument)) return argument;
    throw new $TypeError($String(argument) + " is not an object");
  };
  return anObject;
}
var hasRequiredObjectDefineProperty;
function requireObjectDefineProperty() {
  if (hasRequiredObjectDefineProperty) return objectDefineProperty;
  hasRequiredObjectDefineProperty = 1;
  var DESCRIPTORS = requireDescriptors();
  var IE8_DOM_DEFINE = requireIe8DomDefine();
  var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
  var anObject2 = requireAnObject();
  var toPropertyKey2 = requireToPropertyKey();
  var $TypeError = TypeError;
  var $defineProperty = Object.defineProperty;
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = "enumerable";
  var CONFIGURABLE = "configurable";
  var WRITABLE = "writable";
  objectDefineProperty.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
    anObject2(O);
    P = toPropertyKey2(P);
    anObject2(Attributes);
    if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor(O, P);
      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    }
    return $defineProperty(O, P, Attributes);
  } : $defineProperty : function defineProperty(O, P, Attributes) {
    anObject2(O);
    P = toPropertyKey2(P);
    anObject2(Attributes);
    if (IE8_DOM_DEFINE) try {
      return $defineProperty(O, P, Attributes);
    } catch (error) {
    }
    if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
  };
  return objectDefineProperty;
}
var createNonEnumerableProperty;
var hasRequiredCreateNonEnumerableProperty;
function requireCreateNonEnumerableProperty() {
  if (hasRequiredCreateNonEnumerableProperty) return createNonEnumerableProperty;
  hasRequiredCreateNonEnumerableProperty = 1;
  var DESCRIPTORS = requireDescriptors();
  var definePropertyModule = requireObjectDefineProperty();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  createNonEnumerableProperty = DESCRIPTORS ? function(object2, key, value) {
    return definePropertyModule.f(object2, key, createPropertyDescriptor2(1, value));
  } : function(object2, key, value) {
    object2[key] = value;
    return object2;
  };
  return createNonEnumerableProperty;
}
var makeBuiltIn = { exports: {} };
var functionName;
var hasRequiredFunctionName;
function requireFunctionName() {
  if (hasRequiredFunctionName) return functionName;
  hasRequiredFunctionName = 1;
  var DESCRIPTORS = requireDescriptors();
  var hasOwn = requireHasOwnProperty();
  var FunctionPrototype = Function.prototype;
  var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
  var EXISTS = hasOwn(FunctionPrototype, "name");
  var PROPER = EXISTS && (function something() {
  }).name === "something";
  var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
  functionName = {
    EXISTS,
    PROPER,
    CONFIGURABLE
  };
  return functionName;
}
var inspectSource;
var hasRequiredInspectSource;
function requireInspectSource() {
  if (hasRequiredInspectSource) return inspectSource;
  hasRequiredInspectSource = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var isCallable2 = requireIsCallable();
  var store = requireSharedStore();
  var functionToString = uncurryThis(Function.toString);
  if (!isCallable2(store.inspectSource)) {
    store.inspectSource = function(it) {
      return functionToString(it);
    };
  }
  inspectSource = store.inspectSource;
  return inspectSource;
}
var weakMapBasicDetection;
var hasRequiredWeakMapBasicDetection;
function requireWeakMapBasicDetection() {
  if (hasRequiredWeakMapBasicDetection) return weakMapBasicDetection;
  hasRequiredWeakMapBasicDetection = 1;
  var globalThis2 = requireGlobalThis();
  var isCallable2 = requireIsCallable();
  var WeakMap2 = globalThis2.WeakMap;
  weakMapBasicDetection = isCallable2(WeakMap2) && /native code/.test(String(WeakMap2));
  return weakMapBasicDetection;
}
var sharedKey;
var hasRequiredSharedKey;
function requireSharedKey() {
  if (hasRequiredSharedKey) return sharedKey;
  hasRequiredSharedKey = 1;
  var shared2 = requireShared();
  var uid2 = requireUid();
  var keys2 = shared2("keys");
  sharedKey = function(key) {
    return keys2[key] || (keys2[key] = uid2(key));
  };
  return sharedKey;
}
var hiddenKeys;
var hasRequiredHiddenKeys;
function requireHiddenKeys() {
  if (hasRequiredHiddenKeys) return hiddenKeys;
  hasRequiredHiddenKeys = 1;
  hiddenKeys = {};
  return hiddenKeys;
}
var internalState;
var hasRequiredInternalState;
function requireInternalState() {
  if (hasRequiredInternalState) return internalState;
  hasRequiredInternalState = 1;
  var NATIVE_WEAK_MAP = requireWeakMapBasicDetection();
  var globalThis2 = requireGlobalThis();
  var isObject2 = requireIsObject();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var hasOwn = requireHasOwnProperty();
  var shared2 = requireSharedStore();
  var sharedKey2 = requireSharedKey();
  var hiddenKeys2 = requireHiddenKeys();
  var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
  var TypeError2 = globalThis2.TypeError;
  var WeakMap2 = globalThis2.WeakMap;
  var set, get2, has;
  var enforce = function(it) {
    return has(it) ? get2(it) : set(it, {});
  };
  var getterFor = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject2(it) || (state = get2(it)).type !== TYPE) {
        throw new TypeError2("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP || shared2.state) {
    var store = shared2.state || (shared2.state = new WeakMap2());
    store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    set = function(it, metadata) {
      if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      store.set(it, metadata);
      return metadata;
    };
    get2 = function(it) {
      return store.get(it) || {};
    };
    has = function(it) {
      return store.has(it);
    };
  } else {
    var STATE = sharedKey2("state");
    hiddenKeys2[STATE] = true;
    set = function(it, metadata) {
      if (hasOwn(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty2(it, STATE, metadata);
      return metadata;
    };
    get2 = function(it) {
      return hasOwn(it, STATE) ? it[STATE] : {};
    };
    has = function(it) {
      return hasOwn(it, STATE);
    };
  }
  internalState = {
    set,
    get: get2,
    has,
    enforce,
    getterFor
  };
  return internalState;
}
var hasRequiredMakeBuiltIn;
function requireMakeBuiltIn() {
  if (hasRequiredMakeBuiltIn) return makeBuiltIn.exports;
  hasRequiredMakeBuiltIn = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var hasOwn = requireHasOwnProperty();
  var DESCRIPTORS = requireDescriptors();
  var CONFIGURABLE_FUNCTION_NAME = requireFunctionName().CONFIGURABLE;
  var inspectSource2 = requireInspectSource();
  var InternalStateModule = requireInternalState();
  var enforceInternalState = InternalStateModule.enforce;
  var getInternalState = InternalStateModule.get;
  var $String = String;
  var defineProperty = Object.defineProperty;
  var stringSlice = uncurryThis("".slice);
  var replace2 = uncurryThis("".replace);
  var join2 = uncurryThis([].join);
  var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails2(function() {
    return defineProperty(function() {
    }, "length", { value: 8 }).length !== 8;
  });
  var TEMPLATE = String(String).split("String");
  var makeBuiltIn$1 = makeBuiltIn.exports = function(value, name, options) {
    if (stringSlice($String(name), 0, 7) === "Symbol(") {
      name = "[" + replace2($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
    }
    if (options && options.getter) name = "get " + name;
    if (options && options.setter) name = "set " + name;
    if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
      if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
      else value.name = name;
    }
    if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
      defineProperty(value, "length", { value: options.arity });
    }
    try {
      if (options && hasOwn(options, "constructor") && options.constructor) {
        if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
      } else if (value.prototype) value.prototype = void 0;
    } catch (error) {
    }
    var state = enforceInternalState(value);
    if (!hasOwn(state, "source")) {
      state.source = join2(TEMPLATE, typeof name == "string" ? name : "");
    }
    return value;
  };
  Function.prototype.toString = makeBuiltIn$1(function toString2() {
    return isCallable2(this) && getInternalState(this).source || inspectSource2(this);
  }, "toString");
  return makeBuiltIn.exports;
}
var defineBuiltIn;
var hasRequiredDefineBuiltIn;
function requireDefineBuiltIn() {
  if (hasRequiredDefineBuiltIn) return defineBuiltIn;
  hasRequiredDefineBuiltIn = 1;
  var isCallable2 = requireIsCallable();
  var definePropertyModule = requireObjectDefineProperty();
  var makeBuiltIn2 = requireMakeBuiltIn();
  var defineGlobalProperty2 = requireDefineGlobalProperty();
  defineBuiltIn = function(O, key, value, options) {
    if (!options) options = {};
    var simple = options.enumerable;
    var name = options.name !== void 0 ? options.name : key;
    if (isCallable2(value)) makeBuiltIn2(value, name, options);
    if (options.global) {
      if (simple) O[key] = value;
      else defineGlobalProperty2(key, value);
    } else {
      try {
        if (!options.unsafe) delete O[key];
        else if (O[key]) simple = true;
      } catch (error) {
      }
      if (simple) O[key] = value;
      else definePropertyModule.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
    }
    return O;
  };
  return defineBuiltIn;
}
var objectGetOwnPropertyNames = {};
var mathTrunc;
var hasRequiredMathTrunc;
function requireMathTrunc() {
  if (hasRequiredMathTrunc) return mathTrunc;
  hasRequiredMathTrunc = 1;
  var ceil = Math.ceil;
  var floor2 = Math.floor;
  mathTrunc = Math.trunc || function trunc(x) {
    var n = +x;
    return (n > 0 ? floor2 : ceil)(n);
  };
  return mathTrunc;
}
var toIntegerOrInfinity;
var hasRequiredToIntegerOrInfinity;
function requireToIntegerOrInfinity() {
  if (hasRequiredToIntegerOrInfinity) return toIntegerOrInfinity;
  hasRequiredToIntegerOrInfinity = 1;
  var trunc = requireMathTrunc();
  toIntegerOrInfinity = function(argument) {
    var number2 = +argument;
    return number2 !== number2 || number2 === 0 ? 0 : trunc(number2);
  };
  return toIntegerOrInfinity;
}
var toAbsoluteIndex;
var hasRequiredToAbsoluteIndex;
function requireToAbsoluteIndex() {
  if (hasRequiredToAbsoluteIndex) return toAbsoluteIndex;
  hasRequiredToAbsoluteIndex = 1;
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var max2 = Math.max;
  var min2 = Math.min;
  toAbsoluteIndex = function(index2, length) {
    var integer2 = toIntegerOrInfinity2(index2);
    return integer2 < 0 ? max2(integer2 + length, 0) : min2(integer2, length);
  };
  return toAbsoluteIndex;
}
var toLength;
var hasRequiredToLength;
function requireToLength() {
  if (hasRequiredToLength) return toLength;
  hasRequiredToLength = 1;
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var min2 = Math.min;
  toLength = function(argument) {
    var len = toIntegerOrInfinity2(argument);
    return len > 0 ? min2(len, 9007199254740991) : 0;
  };
  return toLength;
}
var lengthOfArrayLike;
var hasRequiredLengthOfArrayLike;
function requireLengthOfArrayLike() {
  if (hasRequiredLengthOfArrayLike) return lengthOfArrayLike;
  hasRequiredLengthOfArrayLike = 1;
  var toLength2 = requireToLength();
  lengthOfArrayLike = function(obj) {
    return toLength2(obj.length);
  };
  return lengthOfArrayLike;
}
var arrayIncludes;
var hasRequiredArrayIncludes;
function requireArrayIncludes() {
  if (hasRequiredArrayIncludes) return arrayIncludes;
  hasRequiredArrayIncludes = 1;
  var toIndexedObject2 = requireToIndexedObject();
  var toAbsoluteIndex2 = requireToAbsoluteIndex();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject2($this);
      var length = lengthOfArrayLike2(O);
      if (length === 0) return !IS_INCLUDES && -1;
      var index2 = toAbsoluteIndex2(fromIndex, length);
      var value;
      if (IS_INCLUDES && el !== el) while (length > index2) {
        value = O[index2++];
        if (value !== value) return true;
      }
      else for (; length > index2; index2++) {
        if ((IS_INCLUDES || index2 in O) && O[index2] === el) return IS_INCLUDES || index2 || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };
  arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };
  return arrayIncludes;
}
var objectKeysInternal;
var hasRequiredObjectKeysInternal;
function requireObjectKeysInternal() {
  if (hasRequiredObjectKeysInternal) return objectKeysInternal;
  hasRequiredObjectKeysInternal = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var hasOwn = requireHasOwnProperty();
  var toIndexedObject2 = requireToIndexedObject();
  var indexOf = requireArrayIncludes().indexOf;
  var hiddenKeys2 = requireHiddenKeys();
  var push = uncurryThis([].push);
  objectKeysInternal = function(object2, names) {
    var O = toIndexedObject2(object2);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !hasOwn(hiddenKeys2, key) && hasOwn(O, key) && push(result, key);
    while (names.length > i) if (hasOwn(O, key = names[i++])) {
      ~indexOf(result, key) || push(result, key);
    }
    return result;
  };
  return objectKeysInternal;
}
var enumBugKeys;
var hasRequiredEnumBugKeys;
function requireEnumBugKeys() {
  if (hasRequiredEnumBugKeys) return enumBugKeys;
  hasRequiredEnumBugKeys = 1;
  enumBugKeys = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  return enumBugKeys;
}
var hasRequiredObjectGetOwnPropertyNames;
function requireObjectGetOwnPropertyNames() {
  if (hasRequiredObjectGetOwnPropertyNames) return objectGetOwnPropertyNames;
  hasRequiredObjectGetOwnPropertyNames = 1;
  var internalObjectKeys = requireObjectKeysInternal();
  var enumBugKeys2 = requireEnumBugKeys();
  var hiddenKeys2 = enumBugKeys2.concat("length", "prototype");
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys2);
  };
  return objectGetOwnPropertyNames;
}
var objectGetOwnPropertySymbols = {};
var hasRequiredObjectGetOwnPropertySymbols;
function requireObjectGetOwnPropertySymbols() {
  if (hasRequiredObjectGetOwnPropertySymbols) return objectGetOwnPropertySymbols;
  hasRequiredObjectGetOwnPropertySymbols = 1;
  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
  return objectGetOwnPropertySymbols;
}
var ownKeys$2;
var hasRequiredOwnKeys;
function requireOwnKeys() {
  if (hasRequiredOwnKeys) return ownKeys$2;
  hasRequiredOwnKeys = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var uncurryThis = requireFunctionUncurryThis();
  var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
  var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
  var anObject2 = requireAnObject();
  var concat = uncurryThis([].concat);
  ownKeys$2 = getBuiltIn2("Reflect", "ownKeys") || function ownKeys2(it) {
    var keys2 = getOwnPropertyNamesModule.f(anObject2(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it)) : keys2;
  };
  return ownKeys$2;
}
var copyConstructorProperties;
var hasRequiredCopyConstructorProperties;
function requireCopyConstructorProperties() {
  if (hasRequiredCopyConstructorProperties) return copyConstructorProperties;
  hasRequiredCopyConstructorProperties = 1;
  var hasOwn = requireHasOwnProperty();
  var ownKeys2 = requireOwnKeys();
  var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
  var definePropertyModule = requireObjectDefineProperty();
  copyConstructorProperties = function(target, source, exceptions) {
    var keys2 = ownKeys2(source);
    var defineProperty = definePropertyModule.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
        defineProperty(target, key, getOwnPropertyDescriptor(source, key));
      }
    }
  };
  return copyConstructorProperties;
}
var isForced_1;
var hasRequiredIsForced;
function requireIsForced() {
  if (hasRequiredIsForced) return isForced_1;
  hasRequiredIsForced = 1;
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var replacement = /#|\.prototype\./;
  var isForced = function(feature, detection) {
    var value = data[normalize2(feature)];
    return value === POLYFILL ? true : value === NATIVE ? false : isCallable2(detection) ? fails2(detection) : !!detection;
  };
  var normalize2 = isForced.normalize = function(string2) {
    return String(string2).replace(replacement, ".").toLowerCase();
  };
  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = "N";
  var POLYFILL = isForced.POLYFILL = "P";
  isForced_1 = isForced;
  return isForced_1;
}
var _export;
var hasRequired_export;
function require_export() {
  if (hasRequired_export) return _export;
  hasRequired_export = 1;
  var globalThis2 = requireGlobalThis();
  var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var defineGlobalProperty2 = requireDefineGlobalProperty();
  var copyConstructorProperties2 = requireCopyConstructorProperties();
  var isForced = requireIsForced();
  _export = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = globalThis2;
    } else if (STATIC) {
      target = globalThis2[TARGET] || defineGlobalProperty2(TARGET, {});
    } else {
      target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties2(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty2(sourceProperty, "sham", true);
      }
      defineBuiltIn2(target, key, sourceProperty, options);
    }
  };
  return _export;
}
var objectDefineProperties = {};
var objectKeys;
var hasRequiredObjectKeys;
function requireObjectKeys() {
  if (hasRequiredObjectKeys) return objectKeys;
  hasRequiredObjectKeys = 1;
  var internalObjectKeys = requireObjectKeysInternal();
  var enumBugKeys2 = requireEnumBugKeys();
  objectKeys = Object.keys || function keys2(O) {
    return internalObjectKeys(O, enumBugKeys2);
  };
  return objectKeys;
}
var hasRequiredObjectDefineProperties;
function requireObjectDefineProperties() {
  if (hasRequiredObjectDefineProperties) return objectDefineProperties;
  hasRequiredObjectDefineProperties = 1;
  var DESCRIPTORS = requireDescriptors();
  var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
  var definePropertyModule = requireObjectDefineProperty();
  var anObject2 = requireAnObject();
  var toIndexedObject2 = requireToIndexedObject();
  var objectKeys2 = requireObjectKeys();
  objectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject2(O);
    var props = toIndexedObject2(Properties);
    var keys2 = objectKeys2(Properties);
    var length = keys2.length;
    var index2 = 0;
    var key;
    while (length > index2) definePropertyModule.f(O, key = keys2[index2++], props[key]);
    return O;
  };
  return objectDefineProperties;
}
var html;
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml) return html;
  hasRequiredHtml = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  html = getBuiltIn2("document", "documentElement");
  return html;
}
var objectCreate;
var hasRequiredObjectCreate;
function requireObjectCreate() {
  if (hasRequiredObjectCreate) return objectCreate;
  hasRequiredObjectCreate = 1;
  var anObject2 = requireAnObject();
  var definePropertiesModule = requireObjectDefineProperties();
  var enumBugKeys2 = requireEnumBugKeys();
  var hiddenKeys2 = requireHiddenKeys();
  var html2 = requireHtml();
  var documentCreateElement2 = requireDocumentCreateElement();
  var sharedKey2 = requireSharedKey();
  var GT = ">";
  var LT = "<";
  var PROTOTYPE = "prototype";
  var SCRIPT = "script";
  var IE_PROTO = sharedKey2("IE_PROTO");
  var EmptyConstructor = function() {
  };
  var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
  };
  var NullProtoObjectViaActiveX = function(activeXDocument2) {
    activeXDocument2.write(scriptTag(""));
    activeXDocument2.close();
    var temp = activeXDocument2.parentWindow.Object;
    activeXDocument2 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame = function() {
    var iframe = documentCreateElement2("iframe");
    var JS = "java" + SCRIPT + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html2.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument;
  var NullProtoObject = function() {
    try {
      activeXDocument = new ActiveXObject("htmlfile");
    } catch (error) {
    }
    NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
    var length = enumBugKeys2.length;
    while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys2[length]];
    return NullProtoObject();
  };
  hiddenKeys2[IE_PROTO] = true;
  objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject2(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      result[IE_PROTO] = O;
    } else result = NullProtoObject();
    return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
  };
  return objectCreate;
}
var addToUnscopables;
var hasRequiredAddToUnscopables;
function requireAddToUnscopables() {
  if (hasRequiredAddToUnscopables) return addToUnscopables;
  hasRequiredAddToUnscopables = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var create = requireObjectCreate();
  var defineProperty = requireObjectDefineProperty().f;
  var UNSCOPABLES = wellKnownSymbol2("unscopables");
  var ArrayPrototype = Array.prototype;
  if (ArrayPrototype[UNSCOPABLES] === void 0) {
    defineProperty(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: create(null)
    });
  }
  addToUnscopables = function(key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };
  return addToUnscopables;
}
var hasRequiredEs_array_at;
function requireEs_array_at() {
  if (hasRequiredEs_array_at) return es_array_at;
  hasRequiredEs_array_at = 1;
  var $ = require_export();
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var addToUnscopables2 = requireAddToUnscopables();
  $({ target: "Array", proto: true }, {
    at: function at2(index2) {
      var O = toObject2(this);
      var len = lengthOfArrayLike2(O);
      var relativeIndex = toIntegerOrInfinity2(index2);
      var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
      return k < 0 || k >= len ? void 0 : O[k];
    }
  });
  addToUnscopables2("at");
  return es_array_at;
}
var entryUnbind;
var hasRequiredEntryUnbind;
function requireEntryUnbind() {
  if (hasRequiredEntryUnbind) return entryUnbind;
  hasRequiredEntryUnbind = 1;
  var globalThis2 = requireGlobalThis();
  var uncurryThis = requireFunctionUncurryThis();
  entryUnbind = function(CONSTRUCTOR, METHOD) {
    return uncurryThis(globalThis2[CONSTRUCTOR].prototype[METHOD]);
  };
  return entryUnbind;
}
var at$3;
var hasRequiredAt$3;
function requireAt$3() {
  if (hasRequiredAt$3) return at$3;
  hasRequiredAt$3 = 1;
  requireEs_array_at();
  var entryUnbind2 = requireEntryUnbind();
  at$3 = entryUnbind2("Array", "at");
  return at$3;
}
var at$2;
var hasRequiredAt$2;
function requireAt$2() {
  if (hasRequiredAt$2) return at$2;
  hasRequiredAt$2 = 1;
  var parent = requireAt$3();
  at$2 = parent;
  return at$2;
}
requireAt$2();
var es_array_flatMap = {};
var isArray;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray;
  hasRequiredIsArray = 1;
  var classof2 = requireClassofRaw();
  isArray = Array.isArray || function isArray2(argument) {
    return classof2(argument) === "Array";
  };
  return isArray;
}
var doesNotExceedSafeInteger;
var hasRequiredDoesNotExceedSafeInteger;
function requireDoesNotExceedSafeInteger() {
  if (hasRequiredDoesNotExceedSafeInteger) return doesNotExceedSafeInteger;
  hasRequiredDoesNotExceedSafeInteger = 1;
  var $TypeError = TypeError;
  var MAX_SAFE_INTEGER = 9007199254740991;
  doesNotExceedSafeInteger = function(it) {
    if (it > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
    return it;
  };
  return doesNotExceedSafeInteger;
}
var functionUncurryThisClause;
var hasRequiredFunctionUncurryThisClause;
function requireFunctionUncurryThisClause() {
  if (hasRequiredFunctionUncurryThisClause) return functionUncurryThisClause;
  hasRequiredFunctionUncurryThisClause = 1;
  var classofRaw2 = requireClassofRaw();
  var uncurryThis = requireFunctionUncurryThis();
  functionUncurryThisClause = function(fn) {
    if (classofRaw2(fn) === "Function") return uncurryThis(fn);
  };
  return functionUncurryThisClause;
}
var functionBindContext;
var hasRequiredFunctionBindContext;
function requireFunctionBindContext() {
  if (hasRequiredFunctionBindContext) return functionBindContext;
  hasRequiredFunctionBindContext = 1;
  var uncurryThis = requireFunctionUncurryThisClause();
  var aCallable2 = requireACallable();
  var NATIVE_BIND = requireFunctionBindNative();
  var bind2 = uncurryThis(uncurryThis.bind);
  functionBindContext = function(fn, that) {
    aCallable2(fn);
    return that === void 0 ? fn : NATIVE_BIND ? bind2(fn, that) : function() {
      return fn.apply(that, arguments);
    };
  };
  return functionBindContext;
}
var flattenIntoArray_1;
var hasRequiredFlattenIntoArray;
function requireFlattenIntoArray() {
  if (hasRequiredFlattenIntoArray) return flattenIntoArray_1;
  hasRequiredFlattenIntoArray = 1;
  var isArray2 = requireIsArray();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var doesNotExceedSafeInteger2 = requireDoesNotExceedSafeInteger();
  var bind2 = requireFunctionBindContext();
  var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
    var targetIndex = start;
    var sourceIndex = 0;
    var mapFn = mapper ? bind2(mapper, thisArg) : false;
    var element, elementLen;
    while (sourceIndex < sourceLen) {
      if (sourceIndex in source) {
        element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
        if (depth > 0 && isArray2(element)) {
          elementLen = lengthOfArrayLike2(element);
          targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
        } else {
          doesNotExceedSafeInteger2(targetIndex + 1);
          target[targetIndex] = element;
        }
        targetIndex++;
      }
      sourceIndex++;
    }
    return targetIndex;
  };
  flattenIntoArray_1 = flattenIntoArray;
  return flattenIntoArray_1;
}
var toStringTagSupport;
var hasRequiredToStringTagSupport;
function requireToStringTagSupport() {
  if (hasRequiredToStringTagSupport) return toStringTagSupport;
  hasRequiredToStringTagSupport = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  var test = {};
  test[TO_STRING_TAG] = "z";
  toStringTagSupport = String(test) === "[object z]";
  return toStringTagSupport;
}
var classof;
var hasRequiredClassof;
function requireClassof() {
  if (hasRequiredClassof) return classof;
  hasRequiredClassof = 1;
  var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
  var isCallable2 = requireIsCallable();
  var classofRaw2 = requireClassofRaw();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  var $Object = Object;
  var CORRECT_ARGUMENTS = classofRaw2(/* @__PURE__ */ (function() {
    return arguments;
  })()) === "Arguments";
  var tryGet = function(it, key) {
    try {
      return it[key];
    } catch (error) {
    }
  };
  classof = TO_STRING_TAG_SUPPORT ? classofRaw2 : function(it) {
    var O, tag, result;
    return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw2(O) : (result = classofRaw2(O)) === "Object" && isCallable2(O.callee) ? "Arguments" : result;
  };
  return classof;
}
var isConstructor;
var hasRequiredIsConstructor;
function requireIsConstructor() {
  if (hasRequiredIsConstructor) return isConstructor;
  hasRequiredIsConstructor = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var classof2 = requireClassof();
  var getBuiltIn2 = requireGetBuiltIn();
  var inspectSource2 = requireInspectSource();
  var noop3 = function() {
  };
  var construct = getBuiltIn2("Reflect", "construct");
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec = uncurryThis(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.test(noop3);
  var isConstructorModern = function isConstructor2(argument) {
    if (!isCallable2(argument)) return false;
    try {
      construct(noop3, [], argument);
      return true;
    } catch (error) {
      return false;
    }
  };
  var isConstructorLegacy = function isConstructor2(argument) {
    if (!isCallable2(argument)) return false;
    switch (classof2(argument)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource2(argument));
    } catch (error) {
      return true;
    }
  };
  isConstructorLegacy.sham = true;
  isConstructor = !construct || fails2(function() {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
      called = true;
    }) || called;
  }) ? isConstructorLegacy : isConstructorModern;
  return isConstructor;
}
var arraySpeciesConstructor;
var hasRequiredArraySpeciesConstructor;
function requireArraySpeciesConstructor() {
  if (hasRequiredArraySpeciesConstructor) return arraySpeciesConstructor;
  hasRequiredArraySpeciesConstructor = 1;
  var isArray2 = requireIsArray();
  var isConstructor2 = requireIsConstructor();
  var isObject2 = requireIsObject();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var SPECIES = wellKnownSymbol2("species");
  var $Array = Array;
  arraySpeciesConstructor = function(originalArray) {
    var C;
    if (isArray2(originalArray)) {
      C = originalArray.constructor;
      if (isConstructor2(C) && (C === $Array || isArray2(C.prototype))) C = void 0;
      else if (isObject2(C)) {
        C = C[SPECIES];
        if (C === null) C = void 0;
      }
    }
    return C === void 0 ? $Array : C;
  };
  return arraySpeciesConstructor;
}
var arraySpeciesCreate;
var hasRequiredArraySpeciesCreate;
function requireArraySpeciesCreate() {
  if (hasRequiredArraySpeciesCreate) return arraySpeciesCreate;
  hasRequiredArraySpeciesCreate = 1;
  var arraySpeciesConstructor2 = requireArraySpeciesConstructor();
  arraySpeciesCreate = function(originalArray, length) {
    return new (arraySpeciesConstructor2(originalArray))(length === 0 ? 0 : length);
  };
  return arraySpeciesCreate;
}
var hasRequiredEs_array_flatMap;
function requireEs_array_flatMap() {
  if (hasRequiredEs_array_flatMap) return es_array_flatMap;
  hasRequiredEs_array_flatMap = 1;
  var $ = require_export();
  var flattenIntoArray = requireFlattenIntoArray();
  var aCallable2 = requireACallable();
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var arraySpeciesCreate2 = requireArraySpeciesCreate();
  $({ target: "Array", proto: true }, {
    flatMap: function flatMap2(callbackfn) {
      var O = toObject2(this);
      var sourceLen = lengthOfArrayLike2(O);
      var A;
      aCallable2(callbackfn);
      A = arraySpeciesCreate2(O, 0);
      A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      return A;
    }
  });
  return es_array_flatMap;
}
var es_array_unscopables_flatMap = {};
var hasRequiredEs_array_unscopables_flatMap;
function requireEs_array_unscopables_flatMap() {
  if (hasRequiredEs_array_unscopables_flatMap) return es_array_unscopables_flatMap;
  hasRequiredEs_array_unscopables_flatMap = 1;
  var addToUnscopables2 = requireAddToUnscopables();
  addToUnscopables2("flatMap");
  return es_array_unscopables_flatMap;
}
var flatMap$1;
var hasRequiredFlatMap$1;
function requireFlatMap$1() {
  if (hasRequiredFlatMap$1) return flatMap$1;
  hasRequiredFlatMap$1 = 1;
  requireEs_array_flatMap();
  requireEs_array_unscopables_flatMap();
  var entryUnbind2 = requireEntryUnbind();
  flatMap$1 = entryUnbind2("Array", "flatMap");
  return flatMap$1;
}
var flatMap;
var hasRequiredFlatMap;
function requireFlatMap() {
  if (hasRequiredFlatMap) return flatMap;
  hasRequiredFlatMap = 1;
  var parent = requireFlatMap$1();
  flatMap = parent;
  return flatMap;
}
requireFlatMap();
var es_array_flat = {};
var hasRequiredEs_array_flat;
function requireEs_array_flat() {
  if (hasRequiredEs_array_flat) return es_array_flat;
  hasRequiredEs_array_flat = 1;
  var $ = require_export();
  var flattenIntoArray = requireFlattenIntoArray();
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var arraySpeciesCreate2 = requireArraySpeciesCreate();
  $({ target: "Array", proto: true }, {
    flat: function flat2() {
      var depthArg = arguments.length ? arguments[0] : void 0;
      var O = toObject2(this);
      var sourceLen = lengthOfArrayLike2(O);
      var A = arraySpeciesCreate2(O, 0);
      A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity2(depthArg));
      return A;
    }
  });
  return es_array_flat;
}
var es_array_unscopables_flat = {};
var hasRequiredEs_array_unscopables_flat;
function requireEs_array_unscopables_flat() {
  if (hasRequiredEs_array_unscopables_flat) return es_array_unscopables_flat;
  hasRequiredEs_array_unscopables_flat = 1;
  var addToUnscopables2 = requireAddToUnscopables();
  addToUnscopables2("flat");
  return es_array_unscopables_flat;
}
var flat$1;
var hasRequiredFlat$1;
function requireFlat$1() {
  if (hasRequiredFlat$1) return flat$1;
  hasRequiredFlat$1 = 1;
  requireEs_array_flat();
  requireEs_array_unscopables_flat();
  var entryUnbind2 = requireEntryUnbind();
  flat$1 = entryUnbind2("Array", "flat");
  return flat$1;
}
var flat;
var hasRequiredFlat;
function requireFlat() {
  if (hasRequiredFlat) return flat;
  hasRequiredFlat = 1;
  var parent = requireFlat$1();
  flat = parent;
  return flat;
}
requireFlat();
var es_string_atAlternative = {};
var toString;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString;
  hasRequiredToString = 1;
  var classof2 = requireClassof();
  var $String = String;
  toString = function(argument) {
    if (classof2(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
    return $String(argument);
  };
  return toString;
}
var hasRequiredEs_string_atAlternative;
function requireEs_string_atAlternative() {
  if (hasRequiredEs_string_atAlternative) return es_string_atAlternative;
  hasRequiredEs_string_atAlternative = 1;
  var $ = require_export();
  var uncurryThis = requireFunctionUncurryThis();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var toString2 = requireToString();
  var fails2 = requireFails();
  var charAt = uncurryThis("".charAt);
  var FORCED = fails2(function() {
    return "".at(-2) !== "\uD842";
  });
  $({ target: "String", proto: true, forced: FORCED }, {
    at: function at2(index2) {
      var S = toString2(requireObjectCoercible2(this));
      var len = S.length;
      var relativeIndex = toIntegerOrInfinity2(index2);
      var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
      return k < 0 || k >= len ? void 0 : charAt(S, k);
    }
  });
  return es_string_atAlternative;
}
var at$1;
var hasRequiredAt$1;
function requireAt$1() {
  if (hasRequiredAt$1) return at$1;
  hasRequiredAt$1 = 1;
  requireEs_string_atAlternative();
  var entryUnbind2 = requireEntryUnbind();
  at$1 = entryUnbind2("String", "at");
  return at$1;
}
var at;
var hasRequiredAt;
function requireAt() {
  if (hasRequiredAt) return at;
  hasRequiredAt = 1;
  var parent = requireAt$1();
  at = parent;
  return at;
}
requireAt();
var es_regexp_exec = {};
var regexpFlags;
var hasRequiredRegexpFlags;
function requireRegexpFlags() {
  if (hasRequiredRegexpFlags) return regexpFlags;
  hasRequiredRegexpFlags = 1;
  var anObject2 = requireAnObject();
  regexpFlags = function() {
    var that = anObject2(this);
    var result = "";
    if (that.hasIndices) result += "d";
    if (that.global) result += "g";
    if (that.ignoreCase) result += "i";
    if (that.multiline) result += "m";
    if (that.dotAll) result += "s";
    if (that.unicode) result += "u";
    if (that.unicodeSets) result += "v";
    if (that.sticky) result += "y";
    return result;
  };
  return regexpFlags;
}
var regexpStickyHelpers;
var hasRequiredRegexpStickyHelpers;
function requireRegexpStickyHelpers() {
  if (hasRequiredRegexpStickyHelpers) return regexpStickyHelpers;
  hasRequiredRegexpStickyHelpers = 1;
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $RegExp = globalThis2.RegExp;
  var UNSUPPORTED_Y = fails2(function() {
    var re = $RegExp("a", "y");
    re.lastIndex = 2;
    return re.exec("abcd") !== null;
  });
  var MISSED_STICKY = UNSUPPORTED_Y || fails2(function() {
    return !$RegExp("a", "y").sticky;
  });
  var BROKEN_CARET = UNSUPPORTED_Y || fails2(function() {
    var re = $RegExp("^r", "gy");
    re.lastIndex = 2;
    return re.exec("str") !== null;
  });
  regexpStickyHelpers = {
    BROKEN_CARET,
    MISSED_STICKY,
    UNSUPPORTED_Y
  };
  return regexpStickyHelpers;
}
var regexpUnsupportedDotAll;
var hasRequiredRegexpUnsupportedDotAll;
function requireRegexpUnsupportedDotAll() {
  if (hasRequiredRegexpUnsupportedDotAll) return regexpUnsupportedDotAll;
  hasRequiredRegexpUnsupportedDotAll = 1;
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $RegExp = globalThis2.RegExp;
  regexpUnsupportedDotAll = fails2(function() {
    var re = $RegExp(".", "s");
    return !(re.dotAll && re.test("\n") && re.flags === "s");
  });
  return regexpUnsupportedDotAll;
}
var regexpUnsupportedNcg;
var hasRequiredRegexpUnsupportedNcg;
function requireRegexpUnsupportedNcg() {
  if (hasRequiredRegexpUnsupportedNcg) return regexpUnsupportedNcg;
  hasRequiredRegexpUnsupportedNcg = 1;
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $RegExp = globalThis2.RegExp;
  regexpUnsupportedNcg = fails2(function() {
    var re = $RegExp("(?<a>b)", "g");
    return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
  });
  return regexpUnsupportedNcg;
}
var regexpExec;
var hasRequiredRegexpExec;
function requireRegexpExec() {
  if (hasRequiredRegexpExec) return regexpExec;
  hasRequiredRegexpExec = 1;
  var call2 = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var toString2 = requireToString();
  var regexpFlags2 = requireRegexpFlags();
  var stickyHelpers = requireRegexpStickyHelpers();
  var shared2 = requireShared();
  var create = requireObjectCreate();
  var getInternalState = requireInternalState().get;
  var UNSUPPORTED_DOT_ALL = requireRegexpUnsupportedDotAll();
  var UNSUPPORTED_NCG = requireRegexpUnsupportedNcg();
  var nativeReplace = shared2("native-string-replace", String.prototype.replace);
  var nativeExec = RegExp.prototype.exec;
  var patchedExec = nativeExec;
  var charAt = uncurryThis("".charAt);
  var indexOf = uncurryThis("".indexOf);
  var replace2 = uncurryThis("".replace);
  var stringSlice = uncurryThis("".slice);
  var UPDATES_LAST_INDEX_WRONG = (function() {
    var re1 = /a/;
    var re2 = /b*/g;
    call2(nativeExec, re1, "a");
    call2(nativeExec, re2, "a");
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  })();
  var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
  var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
  if (PATCH) {
    patchedExec = function exec(string2) {
      var re = this;
      var state = getInternalState(re);
      var str = toString2(string2);
      var raw = state.raw;
      var result, reCopy, lastIndex, match, i, object2, group;
      if (raw) {
        raw.lastIndex = re.lastIndex;
        result = call2(patchedExec, raw, str);
        re.lastIndex = raw.lastIndex;
        return result;
      }
      var groups = state.groups;
      var sticky = UNSUPPORTED_Y && re.sticky;
      var flags = call2(regexpFlags2, re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str;
      if (sticky) {
        flags = replace2(flags, "y", "");
        if (indexOf(flags, "g") === -1) {
          flags += "g";
        }
        strCopy = stringSlice(str, re.lastIndex);
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
          source = "(?: " + source + ")";
          strCopy = " " + strCopy;
          charsAdded++;
        }
        reCopy = new RegExp("^(?:" + source + ")", flags);
      }
      if (NPCG_INCLUDED) {
        reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
      }
      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
      match = call2(nativeExec, sticky ? reCopy : re, strCopy);
      if (sticky) {
        if (match) {
          match.input = stringSlice(match.input, charsAdded);
          match[0] = stringSlice(match[0], charsAdded);
          match.index = re.lastIndex;
          re.lastIndex += match[0].length;
        } else re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG && match) {
        re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
      }
      if (NPCG_INCLUDED && match && match.length > 1) {
        call2(nativeReplace, match[0], reCopy, function() {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === void 0) match[i] = void 0;
          }
        });
      }
      if (match && groups) {
        match.groups = object2 = create(null);
        for (i = 0; i < groups.length; i++) {
          group = groups[i];
          object2[group[0]] = match[group[1]];
        }
      }
      return match;
    };
  }
  regexpExec = patchedExec;
  return regexpExec;
}
var hasRequiredEs_regexp_exec;
function requireEs_regexp_exec() {
  if (hasRequiredEs_regexp_exec) return es_regexp_exec;
  hasRequiredEs_regexp_exec = 1;
  var $ = require_export();
  var exec = requireRegexpExec();
  $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
    exec
  });
  return es_regexp_exec;
}
var es_string_replace = {};
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var FunctionPrototype = Function.prototype;
  var apply2 = FunctionPrototype.apply;
  var call2 = FunctionPrototype.call;
  functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call2.bind(apply2) : function() {
    return call2.apply(apply2, arguments);
  });
  return functionApply;
}
var fixRegexpWellKnownSymbolLogic;
var hasRequiredFixRegexpWellKnownSymbolLogic;
function requireFixRegexpWellKnownSymbolLogic() {
  if (hasRequiredFixRegexpWellKnownSymbolLogic) return fixRegexpWellKnownSymbolLogic;
  hasRequiredFixRegexpWellKnownSymbolLogic = 1;
  requireEs_regexp_exec();
  var call2 = requireFunctionCall();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var regexpExec2 = requireRegexpExec();
  var fails2 = requireFails();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var SPECIES = wellKnownSymbol2("species");
  var RegExpPrototype = RegExp.prototype;
  fixRegexpWellKnownSymbolLogic = function(KEY, exec, FORCED, SHAM) {
    var SYMBOL = wellKnownSymbol2(KEY);
    var DELEGATES_TO_SYMBOL = !fails2(function() {
      var O = {};
      O[SYMBOL] = function() {
        return 7;
      };
      return ""[KEY](O) !== 7;
    });
    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails2(function() {
      var execCalled = false;
      var re = /a/;
      if (KEY === "split") {
        var constructor = {};
        constructor[SPECIES] = function() {
          return re;
        };
        re = { constructor, flags: "" };
        re[SYMBOL] = /./[SYMBOL];
      }
      re.exec = function() {
        execCalled = true;
        return null;
      };
      re[SYMBOL]("");
      return !execCalled;
    });
    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
      var nativeRegExpMethod = /./[SYMBOL];
      var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
        var $exec = regexp.exec;
        if ($exec === regexpExec2 || $exec === RegExpPrototype.exec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            return { done: true, value: call2(nativeRegExpMethod, regexp, str, arg2) };
          }
          return { done: true, value: call2(nativeMethod, str, regexp, arg2) };
        }
        return { done: false };
      });
      defineBuiltIn2(String.prototype, KEY, methods[0]);
      defineBuiltIn2(RegExpPrototype, SYMBOL, methods[1]);
    }
    if (SHAM) createNonEnumerableProperty2(RegExpPrototype[SYMBOL], "sham", true);
  };
  return fixRegexpWellKnownSymbolLogic;
}
var stringMultibyte;
var hasRequiredStringMultibyte;
function requireStringMultibyte() {
  if (hasRequiredStringMultibyte) return stringMultibyte;
  hasRequiredStringMultibyte = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var toString2 = requireToString();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var charAt = uncurryThis("".charAt);
  var charCodeAt = uncurryThis("".charCodeAt);
  var stringSlice = uncurryThis("".slice);
  var createMethod = function(CONVERT_TO_STRING) {
    return function($this, pos) {
      var S = toString2(requireObjectCoercible2($this));
      var position = toIntegerOrInfinity2(pos);
      var size2 = S.length;
      var first2, second;
      if (position < 0 || position >= size2) return CONVERT_TO_STRING ? "" : void 0;
      first2 = charCodeAt(S, position);
      return first2 < 55296 || first2 > 56319 || position + 1 === size2 || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first2 : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;
    };
  };
  stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
  };
  return stringMultibyte;
}
var advanceStringIndex;
var hasRequiredAdvanceStringIndex;
function requireAdvanceStringIndex() {
  if (hasRequiredAdvanceStringIndex) return advanceStringIndex;
  hasRequiredAdvanceStringIndex = 1;
  var charAt = requireStringMultibyte().charAt;
  advanceStringIndex = function(S, index2, unicode) {
    return index2 + (unicode ? charAt(S, index2).length : 1);
  };
  return advanceStringIndex;
}
var getSubstitution;
var hasRequiredGetSubstitution;
function requireGetSubstitution() {
  if (hasRequiredGetSubstitution) return getSubstitution;
  hasRequiredGetSubstitution = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toObject2 = requireToObject();
  var floor2 = Math.floor;
  var charAt = uncurryThis("".charAt);
  var replace2 = uncurryThis("".replace);
  var stringSlice = uncurryThis("".slice);
  var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
  getSubstitution = function(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== void 0) {
      namedCaptures = toObject2(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return replace2(replacement, symbols, function(match, ch) {
      var capture;
      switch (charAt(ch, 0)) {
        case "$":
          return "$";
        case "&":
          return matched;
        case "`":
          return stringSlice(str, 0, position);
        case "'":
          return stringSlice(str, tailPos);
        case "<":
          capture = namedCaptures[stringSlice(ch, 1, -1)];
          break;
        default:
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor2(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === void 0 ? "" : capture;
    });
  };
  return getSubstitution;
}
var regexpFlagsDetection;
var hasRequiredRegexpFlagsDetection;
function requireRegexpFlagsDetection() {
  if (hasRequiredRegexpFlagsDetection) return regexpFlagsDetection;
  hasRequiredRegexpFlagsDetection = 1;
  var globalThis2 = requireGlobalThis();
  var fails2 = requireFails();
  var RegExp2 = globalThis2.RegExp;
  var FLAGS_GETTER_IS_CORRECT = !fails2(function() {
    var INDICES_SUPPORT = true;
    try {
      RegExp2(".", "d");
    } catch (error) {
      INDICES_SUPPORT = false;
    }
    var O = {};
    var calls = "";
    var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
    var addGetter = function(key2, chr) {
      Object.defineProperty(O, key2, { get: function() {
        calls += chr;
        return true;
      } });
    };
    var pairs = {
      dotAll: "s",
      global: "g",
      ignoreCase: "i",
      multiline: "m",
      sticky: "y"
    };
    if (INDICES_SUPPORT) pairs.hasIndices = "d";
    for (var key in pairs) addGetter(key, pairs[key]);
    var result = Object.getOwnPropertyDescriptor(RegExp2.prototype, "flags").get.call(O);
    return result !== expected || calls !== expected;
  });
  regexpFlagsDetection = { correct: FLAGS_GETTER_IS_CORRECT };
  return regexpFlagsDetection;
}
var regexpGetFlags;
var hasRequiredRegexpGetFlags;
function requireRegexpGetFlags() {
  if (hasRequiredRegexpGetFlags) return regexpGetFlags;
  hasRequiredRegexpGetFlags = 1;
  var call2 = requireFunctionCall();
  var hasOwn = requireHasOwnProperty();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var regExpFlagsDetection = requireRegexpFlagsDetection();
  var regExpFlagsGetterImplementation = requireRegexpFlags();
  var RegExpPrototype = RegExp.prototype;
  regexpGetFlags = regExpFlagsDetection.correct ? function(it) {
    return it.flags;
  } : function(it) {
    return !regExpFlagsDetection.correct && isPrototypeOf(RegExpPrototype, it) && !hasOwn(it, "flags") ? call2(regExpFlagsGetterImplementation, it) : it.flags;
  };
  return regexpGetFlags;
}
var regexpExecAbstract;
var hasRequiredRegexpExecAbstract;
function requireRegexpExecAbstract() {
  if (hasRequiredRegexpExecAbstract) return regexpExecAbstract;
  hasRequiredRegexpExecAbstract = 1;
  var call2 = requireFunctionCall();
  var anObject2 = requireAnObject();
  var isCallable2 = requireIsCallable();
  var classof2 = requireClassofRaw();
  var regexpExec2 = requireRegexpExec();
  var $TypeError = TypeError;
  regexpExecAbstract = function(R, S) {
    var exec = R.exec;
    if (isCallable2(exec)) {
      var result = call2(exec, R, S);
      if (result !== null) anObject2(result);
      return result;
    }
    if (classof2(R) === "RegExp") return call2(regexpExec2, R, S);
    throw new $TypeError("RegExp#exec called on incompatible receiver");
  };
  return regexpExecAbstract;
}
var hasRequiredEs_string_replace;
function requireEs_string_replace() {
  if (hasRequiredEs_string_replace) return es_string_replace;
  hasRequiredEs_string_replace = 1;
  var apply2 = requireFunctionApply();
  var call2 = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
  var fails2 = requireFails();
  var anObject2 = requireAnObject();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var toLength2 = requireToLength();
  var toString2 = requireToString();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var advanceStringIndex2 = requireAdvanceStringIndex();
  var getMethod2 = requireGetMethod();
  var getSubstitution2 = requireGetSubstitution();
  var getRegExpFlags = requireRegexpGetFlags();
  var regExpExec = requireRegexpExecAbstract();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var REPLACE = wellKnownSymbol2("replace");
  var max2 = Math.max;
  var min2 = Math.min;
  var concat = uncurryThis([].concat);
  var push = uncurryThis([].push);
  var stringIndexOf = uncurryThis("".indexOf);
  var stringSlice = uncurryThis("".slice);
  var maybeToString = function(it) {
    return it === void 0 ? it : String(it);
  };
  var REPLACE_KEEPS_$0 = (function() {
    return "a".replace(/./, "$0") === "$0";
  })();
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function() {
    if (/./[REPLACE]) {
      return /./[REPLACE]("a", "$0") === "";
    }
    return false;
  })();
  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails2(function() {
    var re = /./;
    re.exec = function() {
      var result = [];
      result.groups = { a: "7" };
      return result;
    };
    return "".replace(re, "$<a>") !== "7";
  });
  fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
    return [
      // `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function replace2(searchValue, replaceValue) {
        var O = requireObjectCoercible2(this);
        var replacer = isObject2(searchValue) ? getMethod2(searchValue, REPLACE) : void 0;
        return replacer ? call2(replacer, searchValue, O, replaceValue) : call2(nativeReplace, toString2(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function(string2, replaceValue) {
        var rx = anObject2(this);
        var S = toString2(string2);
        if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
          var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
          if (res.done) return res.value;
        }
        var functionalReplace = isCallable2(replaceValue);
        if (!functionalReplace) replaceValue = toString2(replaceValue);
        var flags = toString2(getRegExpFlags(rx));
        var global2 = stringIndexOf(flags, "g") !== -1;
        var fullUnicode;
        if (global2) {
          fullUnicode = stringIndexOf(flags, "u") !== -1;
          rx.lastIndex = 0;
        }
        var results = [];
        var result;
        while (true) {
          result = regExpExec(rx, S);
          if (result === null) break;
          push(results, result);
          if (!global2) break;
          var matchStr = toString2(result[0]);
          if (matchStr === "") rx.lastIndex = advanceStringIndex2(S, toLength2(rx.lastIndex), fullUnicode);
        }
        var accumulatedResult = "";
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];
          var matched = toString2(result[0]);
          var position = max2(min2(toIntegerOrInfinity2(result.index), S.length), 0);
          var captures = [];
          var replacement;
          for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = concat([matched], captures, position, S);
            if (namedCaptures !== void 0) push(replacerArgs, namedCaptures);
            replacement = toString2(apply2(replaceValue, void 0, replacerArgs));
          } else {
            replacement = getSubstitution2(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + stringSlice(S, nextSourcePosition);
      }
    ];
  }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
  return es_string_replace;
}
var es_string_replaceAll = {};
var isRegexp;
var hasRequiredIsRegexp;
function requireIsRegexp() {
  if (hasRequiredIsRegexp) return isRegexp;
  hasRequiredIsRegexp = 1;
  var isObject2 = requireIsObject();
  var classof2 = requireClassofRaw();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var MATCH = wellKnownSymbol2("match");
  isRegexp = function(it) {
    var isRegExp2;
    return isObject2(it) && ((isRegExp2 = it[MATCH]) !== void 0 ? !!isRegExp2 : classof2(it) === "RegExp");
  };
  return isRegexp;
}
var hasRequiredEs_string_replaceAll;
function requireEs_string_replaceAll() {
  if (hasRequiredEs_string_replaceAll) return es_string_replaceAll;
  hasRequiredEs_string_replaceAll = 1;
  var $ = require_export();
  var call2 = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var isRegExp2 = requireIsRegexp();
  var toString2 = requireToString();
  var getMethod2 = requireGetMethod();
  var getRegExpFlags = requireRegexpGetFlags();
  var getSubstitution2 = requireGetSubstitution();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var IS_PURE = requireIsPure();
  var REPLACE = wellKnownSymbol2("replace");
  var $TypeError = TypeError;
  var indexOf = uncurryThis("".indexOf);
  var replace2 = uncurryThis("".replace);
  var stringSlice = uncurryThis("".slice);
  var max2 = Math.max;
  $({ target: "String", proto: true }, {
    replaceAll: function replaceAll2(searchValue, replaceValue) {
      var O = requireObjectCoercible2(this);
      var IS_REG_EXP, flags, replacer, string2, searchString, functionalReplace, searchLength, advanceBy, position, replacement;
      var endOfLastMatch = 0;
      var result = "";
      if (isObject2(searchValue)) {
        IS_REG_EXP = isRegExp2(searchValue);
        if (IS_REG_EXP) {
          flags = toString2(requireObjectCoercible2(getRegExpFlags(searchValue)));
          if (!~indexOf(flags, "g")) throw new $TypeError("`.replaceAll` does not allow non-global regexes");
        }
        replacer = getMethod2(searchValue, REPLACE);
        if (replacer) return call2(replacer, searchValue, O, replaceValue);
        if (IS_PURE && IS_REG_EXP) return replace2(toString2(O), searchValue, replaceValue);
      }
      string2 = toString2(O);
      searchString = toString2(searchValue);
      functionalReplace = isCallable2(replaceValue);
      if (!functionalReplace) replaceValue = toString2(replaceValue);
      searchLength = searchString.length;
      advanceBy = max2(1, searchLength);
      position = indexOf(string2, searchString);
      while (position !== -1) {
        replacement = functionalReplace ? toString2(replaceValue(searchString, position, string2)) : getSubstitution2(searchString, string2, position, [], void 0, replaceValue);
        result += stringSlice(string2, endOfLastMatch, position) + replacement;
        endOfLastMatch = position + searchLength;
        position = position + advanceBy > string2.length ? -1 : indexOf(string2, searchString, position + advanceBy);
      }
      if (endOfLastMatch < string2.length) {
        result += stringSlice(string2, endOfLastMatch);
      }
      return result;
    }
  });
  return es_string_replaceAll;
}
var replaceAll$1;
var hasRequiredReplaceAll$1;
function requireReplaceAll$1() {
  if (hasRequiredReplaceAll$1) return replaceAll$1;
  hasRequiredReplaceAll$1 = 1;
  requireEs_regexp_exec();
  requireEs_string_replace();
  requireEs_string_replaceAll();
  var entryUnbind2 = requireEntryUnbind();
  replaceAll$1 = entryUnbind2("String", "replaceAll");
  return replaceAll$1;
}
var replaceAll;
var hasRequiredReplaceAll;
function requireReplaceAll() {
  if (hasRequiredReplaceAll) return replaceAll;
  hasRequiredReplaceAll = 1;
  var parent = requireReplaceAll$1();
  replaceAll = parent;
  return replaceAll;
}
requireReplaceAll();
function isChild(x) {
  return x && typeof x === "object" && "parents" in x;
}
function haveParentsChanged(child) {
  for (let i = 0, n = child.parents.length; i < n; i++) {
    child.parents[i].__unsafe__getWithoutCapture(true);
    if (child.parents[i].lastChangedEpoch !== child.parentEpochs[i]) {
      return true;
    }
  }
  return false;
}
function detach(parent, child) {
  if (!parent.children.remove(child)) {
    return;
  }
  if (parent.children.isEmpty && isChild(parent)) {
    for (let i = 0, n = parent.parents.length; i < n; i++) {
      detach(parent.parents[i], parent);
    }
  }
}
function attach(parent, child) {
  if (!parent.children.add(child)) {
    return;
  }
  if (isChild(parent)) {
    for (let i = 0, n = parent.parents.length; i < n; i++) {
      attach(parent.parents[i], parent);
    }
  }
}
function equals(a, b) {
  const shallowEquals = a === b || Object.is(a, b) || Boolean(a && b && typeof a.equals === "function" && a.equals(b));
  return shallowEquals;
}
function singleton(key, init2) {
  const symbol = Symbol.for(`com.tldraw.state/${key}`);
  const global2 = globalThis;
  global2[symbol] ??= init2();
  return global2[symbol];
}
const EMPTY_ARRAY = singleton("empty_array", () => Object.freeze([]));
const ARRAY_SIZE_THRESHOLD = 8;
class ArraySet {
  arraySize = 0;
  array = Array(ARRAY_SIZE_THRESHOLD);
  set = null;
  /**
   * Get whether this ArraySet has any elements.
   *
   * @returns True if this ArraySet has any elements, false otherwise.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isEmpty() {
    if (this.array) {
      return this.arraySize === 0;
    }
    if (this.set) {
      return this.set.size === 0;
    }
    throw new Error("no set or array");
  }
  /**
   * Add an element to the ArraySet if it is not already present.
   *
   * @param elem - The element to add to the set
   * @returns `true` if the element was added, `false` if it was already present
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   *
   * console.log(arraySet.add('hello')) // true
   * console.log(arraySet.add('hello')) // false (already exists)
   * ```
   */
  add(elem) {
    if (this.array) {
      const idx = this.array.indexOf(elem);
      if (idx !== -1) {
        return false;
      }
      if (this.arraySize < ARRAY_SIZE_THRESHOLD) {
        this.array[this.arraySize] = elem;
        this.arraySize++;
        return true;
      } else {
        this.set = new Set(this.array);
        this.array = null;
        this.set.add(elem);
        return true;
      }
    }
    if (this.set) {
      if (this.set.has(elem)) {
        return false;
      }
      this.set.add(elem);
      return true;
    }
    throw new Error("no set or array");
  }
  /**
   * Remove an element from the ArraySet if it is present.
   *
   * @param elem - The element to remove from the set
   * @returns `true` if the element was removed, `false` if it was not present
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   * arraySet.add('hello')
   *
   * console.log(arraySet.remove('hello')) // true
   * console.log(arraySet.remove('hello')) // false (not present)
   * ```
   */
  remove(elem) {
    if (this.array) {
      const idx = this.array.indexOf(elem);
      if (idx === -1) {
        return false;
      }
      this.array[idx] = void 0;
      this.arraySize--;
      if (idx !== this.arraySize) {
        this.array[idx] = this.array[this.arraySize];
        this.array[this.arraySize] = void 0;
      }
      return true;
    }
    if (this.set) {
      if (!this.set.has(elem)) {
        return false;
      }
      this.set.delete(elem);
      return true;
    }
    throw new Error("no set or array");
  }
  /**
   * Execute a callback function for each element in the ArraySet.
   *
   * @param visitor - A function to call for each element in the set
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   * arraySet.add('hello')
   * arraySet.add('world')
   *
   * arraySet.visit((item) => {
   *   console.log(item) // 'hello', 'world'
   * })
   * ```
   */
  visit(visitor) {
    if (this.array) {
      for (let i = 0; i < this.arraySize; i++) {
        const elem = this.array[i];
        if (typeof elem !== "undefined") {
          visitor(elem);
        }
      }
      return;
    }
    if (this.set) {
      this.set.forEach(visitor);
      return;
    }
    throw new Error("no set or array");
  }
  /**
   * Make the ArraySet iterable, allowing it to be used in for...of loops and with spread syntax.
   *
   * @returns An iterator that yields each element in the set
   * @example
   * ```ts
   * const arraySet = new ArraySet<number>()
   * arraySet.add(1)
   * arraySet.add(2)
   *
   * for (const item of arraySet) {
   *   console.log(item) // 1, 2
   * }
   *
   * const items = [...arraySet] // [1, 2]
   * ```
   */
  *[Symbol.iterator]() {
    if (this.array) {
      for (let i = 0; i < this.arraySize; i++) {
        const elem = this.array[i];
        if (typeof elem !== "undefined") {
          yield elem;
        }
      }
    } else if (this.set) {
      yield* this.set;
    } else {
      throw new Error("no set or array");
    }
  }
  /**
   * Check whether an element is present in the ArraySet.
   *
   * @param elem - The element to check for
   * @returns `true` if the element is present, `false` otherwise
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   * arraySet.add('hello')
   *
   * console.log(arraySet.has('hello')) // true
   * console.log(arraySet.has('world')) // false
   * ```
   */
  has(elem) {
    if (this.array) {
      return this.array.indexOf(elem) !== -1;
    } else {
      return this.set.has(elem);
    }
  }
  /**
   * Remove all elements from the ArraySet.
   *
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   * arraySet.add('hello')
   * arraySet.add('world')
   *
   * arraySet.clear()
   * console.log(arraySet.size()) // 0
   * ```
   */
  clear() {
    if (this.set) {
      this.set.clear();
    } else {
      this.arraySize = 0;
      this.array = [];
    }
  }
  /**
   * Get the number of elements in the ArraySet.
   *
   * @returns The number of elements in the set
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   * console.log(arraySet.size()) // 0
   *
   * arraySet.add('hello')
   * console.log(arraySet.size()) // 1
   * ```
   */
  size() {
    if (this.set) {
      return this.set.size;
    } else {
      return this.arraySize;
    }
  }
}
const RESET_VALUE = Symbol.for("com.tldraw.state/RESET_VALUE");
class HistoryBuffer {
  /**
   * Creates a new HistoryBuffer with the specified capacity.
   *
   * capacity - Maximum number of diffs to store in the buffer
   * @example
   * ```ts
   * const buffer = new HistoryBuffer<number>(10) // Store up to 10 diffs
   * ```
   */
  constructor(capacity) {
    this.capacity = capacity;
    this.buffer = new Array(capacity);
  }
  /**
   * Current write position in the circular buffer.
   * @internal
   */
  index = 0;
  /**
   * Circular buffer storing range tuples. Uses undefined to represent empty slots.
   * @internal
   */
  buffer;
  /**
   * Adds a diff entry to the history buffer, representing a change between two epochs.
   *
   * If the diff is undefined, the operation is ignored. If the diff is RESET_VALUE,
   * the entire buffer is cleared to indicate that historical tracking should restart.
   *
   * @param lastComputedEpoch - The epoch when the previous value was computed
   * @param currentEpoch - The epoch when the current value was computed
   * @param diff - The diff representing the change, or RESET_VALUE to clear history
   * @example
   * ```ts
   * const buffer = new HistoryBuffer<string>(5)
   * buffer.pushEntry(0, 1, 'added text')
   * buffer.pushEntry(1, 2, RESET_VALUE) // Clears the buffer
   * ```
   */
  pushEntry(lastComputedEpoch, currentEpoch, diff) {
    if (diff === void 0) {
      return;
    }
    if (diff === RESET_VALUE) {
      this.clear();
      return;
    }
    this.buffer[this.index] = [lastComputedEpoch, currentEpoch, diff];
    this.index = (this.index + 1) % this.capacity;
  }
  /**
   * Clears all entries from the history buffer and resets the write position.
   * This is called when a RESET_VALUE diff is encountered.
   *
   * @example
   * ```ts
   * const buffer = new HistoryBuffer<string>(5)
   * buffer.pushEntry(0, 1, 'change')
   * buffer.clear()
   * console.log(buffer.getChangesSince(0)) // RESET_VALUE
   * ```
   */
  clear() {
    this.index = 0;
    this.buffer.fill(void 0);
  }
  /**
   * Retrieves all diffs that occurred since the specified epoch.
   *
   * The method searches backwards through the circular buffer to find changes
   * that occurred after the given epoch. If insufficient history is available
   * or the requested epoch is too old, returns RESET_VALUE indicating that
   * a complete state rebuild is required.
   *
   * @param sinceEpoch - The epoch from which to retrieve changes
   * @returns Array of diffs since the epoch, or RESET_VALUE if history is insufficient
   * @example
   * ```ts
   * const buffer = new HistoryBuffer<string>(5)
   * buffer.pushEntry(0, 1, 'first')
   * buffer.pushEntry(1, 2, 'second')
   * const changes = buffer.getChangesSince(0) // ['first', 'second']
   * const recentChanges = buffer.getChangesSince(1) // ['second']
   * const tooOld = buffer.getChangesSince(-100) // RESET_VALUE
   * ```
   */
  getChangesSince(sinceEpoch) {
    const { index: index2, capacity, buffer } = this;
    for (let i = 0; i < capacity; i++) {
      const offset2 = (index2 - 1 + capacity - i) % capacity;
      const elem = buffer[offset2];
      if (!elem) {
        return RESET_VALUE;
      }
      const [fromEpoch, toEpoch] = elem;
      if (i === 0 && sinceEpoch >= toEpoch) {
        return [];
      }
      if (fromEpoch <= sinceEpoch && sinceEpoch < toEpoch) {
        const len = i + 1;
        const result = new Array(len);
        for (let j = 0; j < len; j++) {
          result[j] = buffer[(offset2 + j) % capacity][2];
        }
        return result;
      }
    }
    return RESET_VALUE;
  }
}
const GLOBAL_START_EPOCH = -1;
class __EffectScheduler__ {
  constructor(name, runEffect, options) {
    this.name = name;
    this.runEffect = runEffect;
    this._scheduleEffect = options?.scheduleEffect;
  }
  /** @internal */
  _isActivelyListening = false;
  /**
   * Whether this scheduler is attached and actively listening to its parents.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return this._isActivelyListening;
  }
  /** @internal */
  lastTraversedEpoch = GLOBAL_START_EPOCH;
  /** @internal */
  lastReactedEpoch = GLOBAL_START_EPOCH;
  /** @internal */
  _scheduleCount = 0;
  /** @internal */
  __debug_ancestor_epochs__ = null;
  /**
   * The number of times this effect has been scheduled.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get scheduleCount() {
    return this._scheduleCount;
  }
  /** @internal */
  parentSet = new ArraySet();
  /** @internal */
  parentEpochs = [];
  /** @internal */
  parents = [];
  /** @internal */
  _scheduleEffect;
  /** @internal */
  maybeScheduleEffect() {
    if (!this._isActivelyListening) return;
    if (this.lastReactedEpoch === getGlobalEpoch()) return;
    if (this.parents.length && !haveParentsChanged(this)) {
      this.lastReactedEpoch = getGlobalEpoch();
      return;
    }
    this.scheduleEffect();
  }
  /** @internal */
  scheduleEffect() {
    this._scheduleCount++;
    if (this._scheduleEffect) {
      this._scheduleEffect(this.maybeExecute);
    } else {
      this.execute();
    }
  }
  /** @internal */
  // eslint-disable-next-line local/prefer-class-methods
  maybeExecute = () => {
    if (!this._isActivelyListening) return;
    this.execute();
  };
  /**
   * Makes this scheduler become 'actively listening' to its parents.
   * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.
   * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling `EffectScheduler.execute`.
   * @public
   */
  attach() {
    this._isActivelyListening = true;
    for (let i = 0, n = this.parents.length; i < n; i++) {
      attach(this.parents[i], this);
    }
  }
  /**
   * Makes this scheduler stop 'actively listening' to its parents.
   * It will no longer be eligible to receive 'maybeScheduleEffect' calls until `EffectScheduler.attach` is called again.
   * @public
   */
  detach() {
    this._isActivelyListening = false;
    for (let i = 0, n = this.parents.length; i < n; i++) {
      detach(this.parents[i], this);
    }
  }
  /**
   * Executes the effect immediately and returns the result.
   * @returns The result of the effect.
   * @public
   */
  execute() {
    try {
      startCapturingParents(this);
      const currentEpoch = getGlobalEpoch();
      const result = this.runEffect(this.lastReactedEpoch);
      this.lastReactedEpoch = currentEpoch;
      return result;
    } finally {
      stopCapturingParents();
    }
  }
}
const EffectScheduler = singleton(
  "EffectScheduler",
  () => __EffectScheduler__
);
function react(name, fn, options) {
  const scheduler2 = new EffectScheduler(name, fn, options);
  scheduler2.attach();
  scheduler2.scheduleEffect();
  return () => {
    scheduler2.detach();
  };
}
function reactor(name, fn, options) {
  const scheduler2 = new EffectScheduler(name, fn, options);
  return {
    scheduler: scheduler2,
    start: (options2) => {
      const force = options2?.force ?? false;
      scheduler2.attach();
      if (force) {
        scheduler2.scheduleEffect();
      } else {
        scheduler2.maybeScheduleEffect();
      }
    },
    stop: () => {
      scheduler2.detach();
    }
  };
}
let Transaction$1 = class Transaction {
  constructor(parent, isSync) {
    this.parent = parent;
    this.isSync = isSync;
  }
  asyncProcessCount = 0;
  initialAtomValues = /* @__PURE__ */ new Map();
  /**
   * Get whether this transaction is a root (no parents).
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isRoot() {
    return this.parent === null;
  }
  /**
   * Commit the transaction's changes.
   *
   * @public
   */
  commit() {
    if (inst$1.globalIsReacting) {
      for (const atom2 of this.initialAtomValues.keys()) {
        traverseAtomForCleanup(atom2);
      }
    } else if (this.isRoot) {
      flushChanges(this.initialAtomValues.keys());
    } else {
      this.initialAtomValues.forEach((value, atom2) => {
        if (!this.parent.initialAtomValues.has(atom2)) {
          this.parent.initialAtomValues.set(atom2, value);
        }
      });
    }
  }
  /**
   * Abort the transaction.
   *
   * @public
   */
  abort() {
    inst$1.globalEpoch++;
    this.initialAtomValues.forEach((value, atom2) => {
      atom2.set(value);
      atom2.historyBuffer?.clear();
    });
    this.commit();
  }
};
const inst$1 = singleton("transactions", () => ({
  // The current epoch (global to all atoms).
  globalEpoch: GLOBAL_START_EPOCH + 1,
  // Whether any transaction is reacting.
  globalIsReacting: false,
  currentTransaction: null,
  cleanupReactors: null,
  reactionEpoch: GLOBAL_START_EPOCH + 1
}));
function getReactionEpoch() {
  return inst$1.reactionEpoch;
}
function getGlobalEpoch() {
  return inst$1.globalEpoch;
}
function getIsReacting() {
  return inst$1.globalIsReacting;
}
function traverse(reactors, child) {
  if (child.lastTraversedEpoch === inst$1.globalEpoch) {
    return;
  }
  child.lastTraversedEpoch = inst$1.globalEpoch;
  if (child instanceof EffectScheduler) {
    reactors.add(child);
  } else {
    child.children.visit((c) => traverse(reactors, c));
  }
}
function flushChanges(atoms) {
  if (inst$1.globalIsReacting) {
    throw new Error("flushChanges cannot be called during a reaction");
  }
  const outerTxn = inst$1.currentTransaction;
  try {
    inst$1.currentTransaction = null;
    inst$1.globalIsReacting = true;
    inst$1.reactionEpoch = inst$1.globalEpoch;
    const reactors = /* @__PURE__ */ new Set();
    for (const atom2 of atoms) {
      atom2.children.visit((child) => traverse(reactors, child));
    }
    for (const r of reactors) {
      r.maybeScheduleEffect();
    }
    let updateDepth = 0;
    while (inst$1.cleanupReactors?.size) {
      if (updateDepth++ > 1e3) {
        throw new Error("Reaction update depth limit exceeded");
      }
      const reactors2 = inst$1.cleanupReactors;
      inst$1.cleanupReactors = null;
      for (const r of reactors2) {
        r.maybeScheduleEffect();
      }
    }
  } finally {
    inst$1.cleanupReactors = null;
    inst$1.globalIsReacting = false;
    inst$1.currentTransaction = outerTxn;
  }
}
function atomDidChange(atom2, previousValue) {
  if (inst$1.currentTransaction) {
    if (!inst$1.currentTransaction.initialAtomValues.has(atom2)) {
      inst$1.currentTransaction.initialAtomValues.set(atom2, previousValue);
    }
  } else if (inst$1.globalIsReacting) {
    traverseAtomForCleanup(atom2);
  } else {
    flushChanges([atom2]);
  }
}
function traverseAtomForCleanup(atom2) {
  const rs = inst$1.cleanupReactors ??= /* @__PURE__ */ new Set();
  atom2.children.visit((child) => traverse(rs, child));
}
function advanceGlobalEpoch() {
  inst$1.globalEpoch++;
}
function transaction(fn) {
  const txn = new Transaction$1(inst$1.currentTransaction, true);
  inst$1.currentTransaction = txn;
  try {
    let result = void 0;
    let rollback = false;
    try {
      result = fn(() => rollback = true);
    } catch (e) {
      txn.abort();
      throw e;
    }
    if (inst$1.currentTransaction !== txn) {
      throw new Error("Transaction boundaries overlap");
    }
    if (rollback) {
      txn.abort();
    } else {
      txn.commit();
    }
    return result;
  } finally {
    inst$1.currentTransaction = txn.parent;
  }
}
function transact(fn) {
  if (inst$1.currentTransaction) {
    return fn();
  }
  return transaction(fn);
}
let didWarnComputedGetter = false;
function logComputedGetterWarning() {
  if (didWarnComputedGetter) return;
  didWarnComputedGetter = true;
  console.warn(
    `Using \`@computed\` as a decorator for getters is deprecated and will be removed in the near future. Please refactor to use \`@computed\` as a decorator for methods.

// Before
@computed
get foo() {
	return 'foo'
}

// After
@computed
getFoo() {
	return 'foo'
}
`
  );
}
const UNINITIALIZED = Symbol.for("com.tldraw.state/UNINITIALIZED");
function isUninitialized(value) {
  return value === UNINITIALIZED;
}
const WithDiff = singleton(
  "WithDiff",
  () => class WithDiff {
    constructor(value, diff) {
      this.value = value;
      this.diff = diff;
    }
  }
);
function withDiff(value, diff) {
  return new WithDiff(value, diff);
}
class __UNSAFE__Computed {
  constructor(name, derive, options) {
    this.name = name;
    this.derive = derive;
    if (options?.historyLength) {
      this.historyBuffer = new HistoryBuffer(options.historyLength);
    }
    this.computeDiff = options?.computeDiff;
    this.isEqual = options?.isEqual ?? equals;
  }
  lastChangedEpoch = GLOBAL_START_EPOCH;
  lastTraversedEpoch = GLOBAL_START_EPOCH;
  __debug_ancestor_epochs__ = null;
  /**
   * The epoch when the reactor was last checked.
   */
  lastCheckedEpoch = GLOBAL_START_EPOCH;
  parentSet = new ArraySet();
  parents = [];
  parentEpochs = [];
  children = new ArraySet();
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return !this.children.isEmpty;
  }
  historyBuffer;
  // The last-computed value of this signal.
  state = UNINITIALIZED;
  // If the signal throws an error we stash it so we can rethrow it on the next get()
  error = null;
  computeDiff;
  isEqual;
  __unsafe__getWithoutCapture(ignoreErrors) {
    const isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH;
    const globalEpoch = getGlobalEpoch();
    if (!isNew && (this.lastCheckedEpoch === globalEpoch || this.isActivelyListening && getIsReacting() && this.lastTraversedEpoch < getReactionEpoch() || !haveParentsChanged(this))) {
      this.lastCheckedEpoch = globalEpoch;
      if (this.error) {
        if (!ignoreErrors) {
          throw this.error.thrownValue;
        } else {
          return this.state;
        }
      } else {
        return this.state;
      }
    }
    try {
      startCapturingParents(this);
      const result = this.derive(this.state, this.lastCheckedEpoch);
      const newState = result instanceof WithDiff ? result.value : result;
      const isUninitialized2 = this.state === UNINITIALIZED;
      if (isUninitialized2 || !this.isEqual(newState, this.state)) {
        if (this.historyBuffer && !isUninitialized2) {
          const diff = result instanceof WithDiff ? result.diff : void 0;
          this.historyBuffer.pushEntry(
            this.lastChangedEpoch,
            getGlobalEpoch(),
            diff ?? this.computeDiff?.(this.state, newState, this.lastCheckedEpoch, getGlobalEpoch()) ?? RESET_VALUE
          );
        }
        this.lastChangedEpoch = getGlobalEpoch();
        this.state = newState;
      }
      this.error = null;
      this.lastCheckedEpoch = getGlobalEpoch();
      return this.state;
    } catch (e) {
      if (this.state !== UNINITIALIZED) {
        this.state = UNINITIALIZED;
        this.lastChangedEpoch = getGlobalEpoch();
      }
      this.lastCheckedEpoch = getGlobalEpoch();
      if (this.historyBuffer) {
        this.historyBuffer.clear();
      }
      this.error = { thrownValue: e };
      if (!ignoreErrors) throw e;
      return this.state;
    } finally {
      stopCapturingParents();
    }
  }
  get() {
    try {
      return this.__unsafe__getWithoutCapture();
    } finally {
      maybeCaptureParent(this);
    }
  }
  getDiffSince(epoch) {
    this.__unsafe__getWithoutCapture(true);
    maybeCaptureParent(this);
    if (epoch >= this.lastChangedEpoch) {
      return EMPTY_ARRAY;
    }
    return this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE;
  }
}
const _Computed = singleton("Computed", () => __UNSAFE__Computed);
function computedMethodLegacyDecorator(options = {}, _target, key, descriptor) {
  const originalMethod = descriptor.value;
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + key);
  descriptor.value = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(key, originalMethod.bind(this), options);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  descriptor.value[isComputedMethodKey] = true;
  return descriptor;
}
function computedGetterLegacyDecorator(options = {}, _target, key, descriptor) {
  const originalMethod = descriptor.get;
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + key);
  descriptor.get = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(key, originalMethod.bind(this), options);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  return descriptor;
}
function computedMethodTc39Decorator(options, compute, context) {
  assert(context.kind === "method", "@computed can only be used on methods");
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + String(context.name));
  const fn = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(String(context.name), compute.bind(this), options);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  fn[isComputedMethodKey] = true;
  return fn;
}
function computedDecorator(options = {}, args) {
  if (args.length === 2) {
    const [originalMethod, context] = args;
    return computedMethodTc39Decorator(options, originalMethod, context);
  } else {
    const [_target, key, descriptor] = args;
    if (descriptor.get) {
      logComputedGetterWarning();
      return computedGetterLegacyDecorator(options, _target, key, descriptor);
    } else {
      return computedMethodLegacyDecorator(options, _target, key, descriptor);
    }
  }
}
const isComputedMethodKey = "@@__isComputedMethod__@@";
function computed() {
  if (arguments.length === 1) {
    const options = arguments[0];
    return (...args) => computedDecorator(options, args);
  } else if (typeof arguments[0] === "string") {
    return new _Computed(arguments[0], arguments[1], arguments[2]);
  } else {
    return computedDecorator(void 0, arguments);
  }
}
function isComputed(value) {
  return !!(value && value instanceof _Computed);
}
class CaptureStackFrame {
  constructor(below, child) {
    this.below = below;
    this.child = child;
  }
  offset = 0;
  maybeRemoved;
}
const inst = singleton("capture", () => ({ stack: null }));
function unsafe__withoutCapture(fn) {
  const oldStack = inst.stack;
  inst.stack = null;
  try {
    return fn();
  } finally {
    inst.stack = oldStack;
  }
}
function startCapturingParents(child) {
  inst.stack = new CaptureStackFrame(inst.stack, child);
  if (child.__debug_ancestor_epochs__) {
    const previousAncestorEpochs = child.__debug_ancestor_epochs__;
    child.__debug_ancestor_epochs__ = null;
    for (const p of child.parents) {
      p.__unsafe__getWithoutCapture(true);
    }
    logChangedAncestors(child, previousAncestorEpochs);
  }
  child.parentSet.clear();
}
function stopCapturingParents() {
  const frame = inst.stack;
  inst.stack = frame.below;
  if (frame.offset < frame.child.parents.length) {
    for (let i = frame.offset; i < frame.child.parents.length; i++) {
      const maybeRemovedParent = frame.child.parents[i];
      if (!frame.child.parentSet.has(maybeRemovedParent)) {
        detach(maybeRemovedParent, frame.child);
      }
    }
    frame.child.parents.length = frame.offset;
    frame.child.parentEpochs.length = frame.offset;
  }
  if (frame.maybeRemoved) {
    for (let i = 0; i < frame.maybeRemoved.length; i++) {
      const maybeRemovedParent = frame.maybeRemoved[i];
      if (!frame.child.parentSet.has(maybeRemovedParent)) {
        detach(maybeRemovedParent, frame.child);
      }
    }
  }
  if (frame.child.__debug_ancestor_epochs__) {
    captureAncestorEpochs(frame.child, frame.child.__debug_ancestor_epochs__);
  }
}
function maybeCaptureParent(p) {
  if (inst.stack) {
    const wasCapturedAlready = inst.stack.child.parentSet.has(p);
    if (wasCapturedAlready) {
      return;
    }
    inst.stack.child.parentSet.add(p);
    if (inst.stack.child.isActivelyListening) {
      attach(p, inst.stack.child);
    }
    if (inst.stack.offset < inst.stack.child.parents.length) {
      const maybeRemovedParent = inst.stack.child.parents[inst.stack.offset];
      if (maybeRemovedParent !== p) {
        if (!inst.stack.maybeRemoved) {
          inst.stack.maybeRemoved = [maybeRemovedParent];
        } else {
          inst.stack.maybeRemoved.push(maybeRemovedParent);
        }
      }
    }
    inst.stack.child.parents[inst.stack.offset] = p;
    inst.stack.child.parentEpochs[inst.stack.offset] = p.lastChangedEpoch;
    inst.stack.offset++;
  }
}
function captureAncestorEpochs(child, ancestorEpochs) {
  for (let i = 0; i < child.parents.length; i++) {
    const parent = child.parents[i];
    const epoch = child.parentEpochs[i];
    ancestorEpochs.set(parent, epoch);
    if (isComputed(parent)) {
      captureAncestorEpochs(parent, ancestorEpochs);
    }
  }
  return ancestorEpochs;
}
function collectChangedAncestors(child, ancestorEpochs) {
  const changeTree = {};
  for (let i = 0; i < child.parents.length; i++) {
    const parent = child.parents[i];
    if (!ancestorEpochs.has(parent)) {
      continue;
    }
    const prevEpoch = ancestorEpochs.get(parent);
    const currentEpoch = parent.lastChangedEpoch;
    if (currentEpoch !== prevEpoch) {
      if (isComputed(parent)) {
        changeTree[parent.name] = collectChangedAncestors(parent, ancestorEpochs);
      } else {
        changeTree[parent.name] = null;
      }
    }
  }
  return changeTree;
}
function logChangedAncestors(child, ancestorEpochs) {
  const changeTree = collectChangedAncestors(child, ancestorEpochs);
  if (Object.keys(changeTree).length === 0) {
    console.log(`Effect(${child.name}) was executed manually.`);
    return;
  }
  let str = isComputed(child) ? `Computed(${child.name}) is recomputing because:` : `Effect(${child.name}) is executing because:`;
  function logParent(tree, indent) {
    const indentStr = "\n" + " ".repeat(indent) + " ";
    for (const [name, val] of Object.entries(tree)) {
      if (val) {
        str += `${indentStr}Computed(${name}) changed`;
        logParent(val, indent + 2);
      } else {
        str += `${indentStr}Atom(${name}) changed`;
      }
    }
  }
  logParent(changeTree, 1);
  console.log(str);
}
class __Atom__ {
  constructor(name, current, options) {
    this.name = name;
    this.current = current;
    this.isEqual = options?.isEqual ?? null;
    if (!options) return;
    if (options.historyLength) {
      this.historyBuffer = new HistoryBuffer(options.historyLength);
    }
    this.computeDiff = options.computeDiff;
  }
  /**
   * Custom equality function for comparing values, or null to use default equality.
   * @internal
   */
  isEqual;
  /**
   * Optional function to compute diffs between old and new values.
   * @internal
   */
  computeDiff;
  /**
   * The global epoch when this atom was last changed.
   * @internal
   */
  lastChangedEpoch = getGlobalEpoch();
  /**
   * Set of child signals that depend on this atom.
   * @internal
   */
  children = new ArraySet();
  /**
   * Optional history buffer for tracking changes over time.
   * @internal
   */
  historyBuffer;
  /**
   * Gets the current value without capturing it as a dependency in the current reactive context.
   * This is unsafe because it breaks the reactivity chain - use with caution.
   *
   * @param _ignoreErrors - Unused parameter for API compatibility
   * @returns The current value
   * @internal
   */
  __unsafe__getWithoutCapture(_ignoreErrors) {
    return this.current;
  }
  /**
   * Gets the current value of this atom. When called within a computed signal or reaction,
   * this atom will be automatically captured as a dependency.
   *
   * @returns The current value
   * @example
   * ```ts
   * const count = atom('count', 5)
   * console.log(count.get()) // 5
   * ```
   */
  get() {
    maybeCaptureParent(this);
    return this.current;
  }
  /**
   * Sets the value of this atom to the given value. If the value is the same as the current value, this is a no-op.
   *
   * @param value - The new value to set
   * @param diff - The diff to use for the update. If not provided, the diff will be computed using {@link AtomOptions.computeDiff}
   * @returns The new value
   * @example
   * ```ts
   * const count = atom('count', 0)
   * count.set(5) // count.get() is now 5
   * ```
   */
  set(value, diff) {
    if (this.isEqual?.(this.current, value) ?? equals(this.current, value)) {
      return this.current;
    }
    advanceGlobalEpoch();
    if (this.historyBuffer) {
      this.historyBuffer.pushEntry(
        this.lastChangedEpoch,
        getGlobalEpoch(),
        diff ?? this.computeDiff?.(this.current, value, this.lastChangedEpoch, getGlobalEpoch()) ?? RESET_VALUE
      );
    }
    this.lastChangedEpoch = getGlobalEpoch();
    const oldValue = this.current;
    this.current = value;
    atomDidChange(this, oldValue);
    return value;
  }
  /**
   * Updates the value of this atom using the given updater function. If the returned value is the same as the current value, this is a no-op.
   *
   * @param updater - A function that takes the current value and returns the new value
   * @returns The new value
   * @example
   * ```ts
   * const count = atom('count', 5)
   * count.update(n => n + 1) // count.get() is now 6
   * ```
   */
  update(updater) {
    return this.set(updater(this.current));
  }
  /**
   * Gets all the diffs that have occurred since the given epoch. When called within a computed
   * signal or reaction, this atom will be automatically captured as a dependency.
   *
   * @param epoch - The epoch to get changes since
   * @returns An array of diffs, or RESET_VALUE if history is insufficient
   * @internal
   */
  getDiffSince(epoch) {
    maybeCaptureParent(this);
    if (epoch >= this.lastChangedEpoch) {
      return EMPTY_ARRAY;
    }
    return this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE;
  }
}
const _Atom = singleton("Atom", () => __Atom__);
function atom(name, initialValue, options) {
  return new _Atom(name, initialValue, options);
}
const currentApiVersion = 1;
const actualApiVersion = singleton("apiVersion", () => currentApiVersion);
if (actualApiVersion !== currentApiVersion) {
  throw new Error(
    `You have multiple incompatible versions of @tldraw/state in your app. Please deduplicate the package.`
  );
}
registerTldrawLibraryVersion(
  "@tldraw/state",
  "4.2.0",
  "esm"
);
function useStateTracking(name, render, deps = []) {
  const renderRef = React.useRef(render);
  renderRef.current = render;
  const [scheduler2, subscribe, getSnapshot2] = React.useMemo(() => {
    let scheduleUpdate = null;
    const subscribe2 = (cb) => {
      scheduleUpdate = cb;
      return () => {
        scheduleUpdate = null;
      };
    };
    const scheduler22 = new EffectScheduler(
      `useStateTracking(${name})`,
      // this is what `scheduler.execute()` will call
      () => renderRef.current?.(),
      // this is what will be invoked when @tldraw/state detects a change in an upstream reactive value
      {
        scheduleEffect() {
          scheduleUpdate?.();
        }
      }
    );
    const getSnapshot22 = () => scheduler22.scheduleCount;
    return [scheduler22, subscribe2, getSnapshot22];
  }, [name, ...deps]);
  React.useSyncExternalStore(subscribe, getSnapshot2, getSnapshot2);
  React.useEffect(() => {
    scheduler2.attach();
    scheduler2.maybeScheduleEffect();
    return () => {
      scheduler2.detach();
    };
  }, [scheduler2]);
  return scheduler2.execute();
}
const ProxyHandlers = {
  /**
   * This is a function call trap for functional components. When this is called, we know it means
   * React did run 'Component()', that means we can use any hooks here to setup our effect and
   * store.
   *
   * With the native Proxy, all other calls such as access/setting to/of properties will be
   * forwarded to the target Component, so we don't need to copy the Component's own or inherited
   * properties.
   *
   * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460
   */
  apply(Component, thisArg, argumentsList) {
    return useStateTracking(
      Component.displayName ?? Component.name ?? "tracked(???)",
      () => Component.apply(thisArg, argumentsList)
    );
  }
};
const ReactMemoSymbol = Symbol.for("react.memo");
const ReactForwardRefSymbol = Symbol.for("react.forward_ref");
function track(baseComponent) {
  let compare = null;
  const $$typeof = baseComponent["$$typeof"];
  if ($$typeof === ReactMemoSymbol) {
    baseComponent = baseComponent.type;
    compare = baseComponent.compare;
  }
  if ($$typeof === ReactForwardRefSymbol) {
    return reactExports.memo(reactExports.forwardRef(new Proxy(baseComponent.render, ProxyHandlers)));
  }
  return reactExports.memo(new Proxy(baseComponent, ProxyHandlers), compare);
}
function useAtom(name, valueOrInitialiser, options) {
  return reactExports.useState(() => {
    const initialValue = typeof valueOrInitialiser === "function" ? valueOrInitialiser() : valueOrInitialiser;
    return atom(`useAtom(${name})`, initialValue, options);
  })[0];
}
function useComputed() {
  const name = arguments[0];
  const compute = arguments[1];
  const opts = arguments.length === 3 ? void 0 : arguments[2];
  const deps = arguments.length === 3 ? arguments[2] : arguments[3];
  return reactExports.useMemo(() => computed(`useComputed(${name})`, compute, opts), deps);
}
function useQuickReactor(name, reactFn, deps = EMPTY_ARRAY) {
  reactExports.useEffect(() => {
    const scheduler2 = new EffectScheduler(name, reactFn);
    scheduler2.attach();
    scheduler2.execute();
    return () => {
      scheduler2.detach();
    };
  }, deps);
}
function useReactor(name, reactFn, deps = []) {
  reactExports.useEffect(() => {
    let cancelFn;
    const scheduler2 = new EffectScheduler(name, reactFn, {
      scheduleEffect: (cb) => {
        cancelFn = throttleToNextFrame$1(cb);
      }
    });
    scheduler2.attach();
    scheduler2.execute();
    return () => {
      scheduler2.detach();
      cancelFn?.();
    };
  }, deps);
}
function useValue() {
  const args = arguments;
  const deps = args.length === 3 ? args[2] : [args[0]];
  const name = args.length === 3 ? args[0] : `useValue(${args[0].name})`;
  const { $val, subscribe, getSnapshot: getSnapshot2 } = reactExports.useMemo(() => {
    const $val2 = args.length === 1 ? args[0] : computed(name, args[1]);
    return {
      $val: $val2,
      subscribe: (notify) => {
        return react(`useValue(${name})`, () => {
          try {
            $val2.get();
          } catch {
          }
          notify();
        });
      },
      getSnapshot: () => $val2.lastChangedEpoch
    };
  }, deps);
  reactExports.useSyncExternalStore(subscribe, getSnapshot2, getSnapshot2);
  return $val.__unsafe__getWithoutCapture();
}
registerTldrawLibraryVersion(
  "@tldraw/state-react",
  "4.2.0",
  "esm"
);
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
const defaultValueOf = Object.prototype.valueOf;
function hash(o) {
  if (o == null) {
    return hashNullish(o);
  }
  if (typeof o.hashCode === "function") {
    return smi(o.hashCode(o));
  }
  const v = valueOf(o);
  if (v == null) {
    return hashNullish(v);
  }
  switch (typeof v) {
    case "boolean":
      return v ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v);
    case "string":
      return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
    case "object":
    case "function":
      return hashJSObj(v);
    case "symbol":
      return hashSymbol(v);
    default:
      if (typeof v.toString === "function") {
        return hashString(v.toString());
      }
      throw new Error("Value type " + typeof v + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function hashNumber(n) {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let hash2 = n | 0;
  if (hash2 !== n) {
    hash2 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    n /= 4294967295;
    hash2 ^= n;
  }
  return smi(hash2);
}
function cachedHashString(string2) {
  let hashed = stringHashCache[string2];
  if (hashed === void 0) {
    hashed = hashString(string2);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string2] = hashed;
  }
  return hashed;
}
function hashString(string2) {
  let hashed = 0;
  for (let ii = 0; ii < string2.length; ii++) {
    hashed = 31 * hashed + string2.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  let hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  let hashed = weakMap.get(obj);
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  weakMap.set(obj, hashed);
  return hashed;
}
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
  const nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
const weakMap = /* @__PURE__ */ new WeakMap();
const symbolMap = /* @__PURE__ */ Object.create(null);
let _objHashUID = 0;
const STRING_HASH_CACHE_MIN_STRLEN = 16;
const STRING_HASH_CACHE_MAX_SIZE = 255;
let STRING_HASH_CACHE_SIZE = 0;
let stringHashCache = {};
const SHIFT = 5;
const SIZE = 1 << SHIFT;
const MASK = SIZE - 1;
const NOT_SET = {};
function MakeRef() {
  return { value: false };
}
function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}
function arrCopy(arr, offset2) {
  offset2 = offset2 || 0;
  const len = Math.max(0, arr.length - offset2);
  const newArr = new Array(len);
  for (let ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset2];
  }
  return newArr;
}
const is = Object.is;
class OwnerID {
}
class ImmutableMap {
  // @pragma Construction
  // @ts-ignore
  _root;
  // @ts-ignore
  size;
  // @ts-ignore
  __ownerID;
  // @ts-ignore
  __hash;
  // @ts-ignore
  __altered;
  /**
   * Creates a new ImmutableMap instance.
   *
   * @param value - An iterable of key-value pairs to populate the map, or null/undefined for an empty map
   * @example
   * ```ts
   * // Create from array of pairs
   * const map1 = new ImmutableMap([['a', 1], ['b', 2]])
   *
   * // Create empty map
   * const map2 = new ImmutableMap()
   *
   * // Create from another map
   * const map3 = new ImmutableMap(map1)
   * ```
   */
  constructor(value) {
    return value === void 0 || value === null ? emptyMap() : value instanceof ImmutableMap ? value : emptyMap().withMutations((map2) => {
      for (const [k, v] of value) {
        map2.set(k, v);
      }
    });
  }
  /**
   * Gets the value associated with the specified key, with a fallback value.
   *
   * @param k - The key to look up
   * @param notSetValue - The value to return if the key is not found
   * @returns The value associated with the key, or the fallback value if not found
   * @example
   * ```ts
   * const map = new ImmutableMap([['key1', 'value1']])
   * console.log(map.get('key1', 'default')) // 'value1'
   * console.log(map.get('missing', 'default')) // 'default'
   * ```
   */
  get(k, notSetValue) {
    return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
  }
  /**
   * Returns a new ImmutableMap with the specified key-value pair added or updated.
   * If the key already exists, its value is replaced. Otherwise, a new entry is created.
   *
   * @param k - The key to set
   * @param v - The value to associate with the key
   * @returns A new ImmutableMap with the key-value pair set
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1]])
   * const updated = map.set('b', 2) // New map with both 'a' and 'b'
   * const replaced = map.set('a', 10) // New map with 'a' updated to 10
   * ```
   */
  set(k, v) {
    return updateMap(this, k, v);
  }
  /**
   * Returns a new ImmutableMap with the specified key removed.
   * If the key doesn't exist, returns the same map instance.
   *
   * @param k - The key to remove
   * @returns A new ImmutableMap with the key removed, or the same instance if key not found
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2]])
   * const smaller = map.delete('a') // New map with only 'b'
   * const same = map.delete('missing') // Returns original map
   * ```
   */
  delete(k) {
    return updateMap(this, k, NOT_SET);
  }
  /**
   * Returns a new ImmutableMap with all specified keys removed.
   * This is more efficient than calling delete() multiple times.
   *
   * @param keys - An iterable of keys to remove
   * @returns A new ImmutableMap with all specified keys removed
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2], ['c', 3]])
   * const smaller = map.deleteAll(['a', 'c']) // New map with only 'b'
   * ```
   */
  deleteAll(keys2) {
    return this.withMutations((map2) => {
      for (const key of keys2) {
        map2.delete(key);
      }
    });
  }
  __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  }
  /**
   * Applies multiple mutations efficiently by creating a mutable copy,
   * applying all changes, then returning an immutable result.
   * This is more efficient than chaining multiple set/delete operations.
   *
   * @param fn - Function that receives a mutable copy and applies changes
   * @returns A new ImmutableMap with all mutations applied, or the same instance if no changes
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1]])
   * const updated = map.withMutations(mutable => {
   *   mutable.set('b', 2)
   *   mutable.set('c', 3)
   *   mutable.delete('a')
   * }) // Efficiently applies all changes at once
   * ```
   */
  withMutations(fn) {
    const mutable = this.asMutable();
    fn(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  }
  /**
   * Checks if this map instance has been altered during a mutation operation.
   * This is used internally to optimize mutations.
   *
   * @returns True if the map was altered, false otherwise
   * @internal
   */
  wasAltered() {
    return this.__altered;
  }
  /**
   * Returns a mutable copy of this map that can be efficiently modified.
   * Multiple changes to the mutable copy are batched together.
   *
   * @returns A mutable copy of this map
   * @internal
   */
  asMutable() {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  }
  /**
   * Makes the map iterable, yielding key-value pairs.
   *
   * @returns An iterator over [key, value] pairs
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2]])
   * for (const [key, value] of map) {
   *   console.log(key, value) // 'a' 1, then 'b' 2
   * }
   * ```
   */
  [Symbol.iterator]() {
    return this.entries()[Symbol.iterator]();
  }
  /**
   * Returns an iterable of key-value pairs.
   *
   * @returns An iterable over [key, value] pairs
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2]])
   * const entries = Array.from(map.entries()) // [['a', 1], ['b', 2]]
   * ```
   */
  entries() {
    return new MapIterator(this, ITERATE_ENTRIES, false);
  }
  /**
   * Returns an iterable of keys.
   *
   * @returns An iterable over keys
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2]])
   * const keys = Array.from(map.keys()) // ['a', 'b']
   * ```
   */
  keys() {
    return new MapIterator(this, ITERATE_KEYS, false);
  }
  /**
   * Returns an iterable of values.
   *
   * @returns An iterable over values
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2]])
   * const values = Array.from(map.values()) // [1, 2]
   * ```
   */
  values() {
    return new MapIterator(this, ITERATE_VALUES, false);
  }
}
class ArrayMapNode {
  constructor(ownerID, entries) {
    this.ownerID = ownerID;
    this.entries = entries;
  }
  get(_shift, _keyHash, key, notSetValue) {
    const entries = this.entries;
    for (let ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  }
  update(ownerID, _shift, _keyHash, key, value, didChangeSize, didAlter) {
    const removed = value === NOT_SET;
    const entries = this.entries;
    let idx = 0;
    const len = entries.length;
    for (; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    const exists = idx < len;
    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }
    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);
    if (removed && entries.length === 1) {
      return;
    }
    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
      return createNodes(ownerID, entries, key, value);
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }
    if (isEditable) {
      this.entries = newEntries;
      return this;
    }
    return new ArrayMapNode(ownerID, newEntries);
  }
}
class BitmapIndexedNode {
  constructor(ownerID, bitmap, nodes) {
    this.ownerID = ownerID;
    this.bitmap = bitmap;
    this.nodes = nodes;
  }
  get(shift2, keyHash, key, notSetValue) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const bit = 1 << ((shift2 === 0 ? keyHash : keyHash >>> shift2) & MASK);
    const bitmap = this.bitmap;
    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift2 + SHIFT, keyHash, key, notSetValue);
  }
  update(ownerID, shift2, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const keyHashFrag = (shift2 === 0 ? keyHash : keyHash >>> shift2) & MASK;
    const bit = 1 << keyHashFrag;
    const bitmap = this.bitmap;
    const exists = (bitmap & bit) !== 0;
    if (!exists && value === NOT_SET) {
      return this;
    }
    const idx = popCount(bitmap & bit - 1);
    const nodes = this.nodes;
    const node = exists ? nodes[idx] : void 0;
    const newNode = updateNode(
      node,
      ownerID,
      shift2 + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
    if (newNode === node) {
      return this;
    }
    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
    }
    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
      return nodes[idx ^ 1];
    }
    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
      return newNode;
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
    const newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.bitmap = newBitmap;
      this.nodes = newNodes;
      return this;
    }
    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
  }
}
class HashArrayMapNode {
  constructor(ownerID, count2, nodes) {
    this.ownerID = ownerID;
    this.count = count2;
    this.nodes = nodes;
  }
  get(shift2, keyHash, key, notSetValue) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const idx = (shift2 === 0 ? keyHash : keyHash >>> shift2) & MASK;
    const node = this.nodes[idx];
    return node ? node.get(shift2 + SHIFT, keyHash, key, notSetValue) : notSetValue;
  }
  update(ownerID, shift2, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const idx = (shift2 === 0 ? keyHash : keyHash >>> shift2) & MASK;
    const removed = value === NOT_SET;
    const nodes = this.nodes;
    const node = nodes[idx];
    if (removed && !node) {
      return this;
    }
    const newNode = updateNode(
      node,
      ownerID,
      shift2 + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
    if (newNode === node) {
      return this;
    }
    let newCount = this.count;
    if (!node) {
      newCount++;
    } else if (!newNode) {
      newCount--;
      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
        return packNodes(ownerID, nodes, newCount, idx);
      }
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newNodes = setAt(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.count = newCount;
      this.nodes = newNodes;
      return this;
    }
    return new HashArrayMapNode(ownerID, newCount, newNodes);
  }
}
class HashCollisionNode {
  constructor(ownerID, keyHash, entries) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entries = entries;
  }
  get(shift2, keyHash, key, notSetValue) {
    const entries = this.entries;
    for (let ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  }
  update(ownerID, shift2, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const removed = value === NOT_SET;
    if (keyHash !== this.keyHash) {
      if (removed) {
        return this;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift2, keyHash, [key, value]);
    }
    const entries = this.entries;
    let idx = 0;
    const len = entries.length;
    for (; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    const exists = idx < len;
    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }
    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);
    if (removed && len === 2) {
      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }
    if (isEditable) {
      this.entries = newEntries;
      return this;
    }
    return new HashCollisionNode(ownerID, this.keyHash, newEntries);
  }
}
class ValueNode {
  constructor(ownerID, keyHash, entry2) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entry = entry2;
  }
  get(shift2, keyHash, key, notSetValue) {
    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
  }
  update(ownerID, shift2, keyHash, key, value, didChangeSize, didAlter) {
    const removed = value === NOT_SET;
    const keyMatch = is(key, this.entry[0]);
    if (keyMatch ? value === this.entry[1] : removed) {
      return this;
    }
    SetRef(didAlter);
    if (removed) {
      SetRef(didChangeSize);
      return;
    }
    if (keyMatch) {
      if (ownerID && ownerID === this.ownerID) {
        this.entry[1] = value;
        return this;
      }
      return new ValueNode(ownerID, this.keyHash, [key, value]);
    }
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift2, hash(key), [key, value]);
  }
}
class MapIterator {
  constructor(map2, _type, _reverse) {
    this._type = _type;
    this._reverse = _reverse;
    this._stack = map2._root && mapIteratorFrame(map2._root);
  }
  _stack;
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const type = this._type;
    let stack2 = this._stack;
    while (stack2) {
      const node = stack2.node;
      const index2 = stack2.index++;
      let maxIndex;
      if (node.entry) {
        if (index2 === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if ("entries" in node && node.entries) {
        maxIndex = node.entries.length - 1;
        if (index2 <= maxIndex) {
          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index2 : index2]);
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index2 <= maxIndex) {
          const subNode = node.nodes[this._reverse ? maxIndex - index2 : index2];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack2 = this._stack = mapIteratorFrame(subNode, stack2);
          }
          continue;
        }
      }
      stack2 = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  }
}
function mapIteratorValue(type, entry2) {
  return iteratorValue(type, entry2[0], entry2[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
const ITERATE_KEYS = 0;
const ITERATE_VALUES = 1;
const ITERATE_ENTRIES = 2;
function iteratorValue(type, k, v, iteratorResult) {
  const value = type === ITERATE_KEYS ? k : type === ITERATE_VALUES ? v : [k, v];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    value,
    done: false
  };
  return iteratorResult;
}
function iteratorDone() {
  return { value: void 0, done: true };
}
function makeMap(size2, root, ownerID, hash2) {
  const map2 = Object.create(ImmutableMap.prototype);
  map2.size = size2;
  map2._root = root;
  map2.__ownerID = ownerID;
  map2.__hash = hash2;
  map2.__altered = false;
  return map2;
}
let EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map2, k, v) {
  let newRoot;
  let newSize;
  if (!map2._root) {
    if (v === NOT_SET) {
      return map2;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map2.__ownerID, [[k, v]]);
  } else {
    const didChangeSize = MakeRef();
    const didAlter = MakeRef();
    newRoot = updateNode(map2._root, map2.__ownerID, 0, void 0, k, v, didChangeSize, didAlter);
    if (!didAlter.value) {
      return map2;
    }
    newSize = map2.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }
  if (map2.__ownerID) {
    map2.size = newSize;
    map2._root = newRoot;
    map2.__hash = void 0;
    map2.__altered = true;
    return map2;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift2, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(ownerID, shift2, keyHash, key, value, didChangeSize, didAlter);
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift2, keyHash, entry2) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry2]);
  }
  const idx1 = (shift2 === 0 ? node.keyHash : node.keyHash >>> shift2) & MASK;
  const idx2 = (shift2 === 0 ? keyHash : keyHash >>> shift2) & MASK;
  let newNode;
  const nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift2 + SHIFT, keyHash, entry2)] : (newNode = new ValueNode(ownerID, keyHash, entry2), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  let node = new ValueNode(ownerID, hash(key), [key, value]);
  for (let ii = 0; ii < entries.length; ii++) {
    const entry2 = entries[ii];
    node = node.update(ownerID, 0, void 0, entry2[0], entry2[1]);
  }
  return node;
}
function packNodes(ownerID, nodes, count2, excluding) {
  let bitmap = 0;
  let packedII = 0;
  const packedNodes = new Array(count2);
  for (let ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    const node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  let count2 = 0;
  const expandedNodes = new Array(SIZE);
  for (let ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count2 + 1, expandedNodes);
}
function popCount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function setAt(array2, idx, val, canEdit) {
  const newArray = canEdit ? array2 : arrCopy(array2);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array2, idx, val, canEdit) {
  const newLen = array2.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array2[idx] = val;
    return array2;
  }
  const newArray = new Array(newLen);
  let after = 0;
  for (let ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array2[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array2, idx, canEdit) {
  const newLen = array2.length - 1;
  if (canEdit && idx === newLen) {
    array2.pop();
    return array2;
  }
  const newArray = new Array(newLen);
  let after = 0;
  for (let ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array2[ii + after];
  }
  return newArray;
}
const MAX_ARRAY_MAP_SIZE = SIZE / 4;
const MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
const MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
class AtomMap {
  /**
   * Creates a new AtomMap instance.
   *
   * name - A unique name for this map, used for atom identification
   * entries - Optional initial entries to populate the map with
   * @example
   * ```ts
   * // Create an empty map
   * const map = new AtomMap('userMap')
   *
   * // Create a map with initial data
   * const initialData: [string, number][] = [['a', 1], ['b', 2]]
   * const mapWithData = new AtomMap('numbersMap', initialData)
   * ```
   */
  constructor(name, entries) {
    this.name = name;
    let atoms = emptyMap();
    if (entries) {
      atoms = atoms.withMutations((atoms2) => {
        for (const [k, v] of entries) {
          atoms2.set(k, atom(`${name}:${String(k)}`, v));
        }
      });
    }
    this.atoms = atom(`${name}:atoms`, atoms);
  }
  atoms;
  /**
   * Retrieves the underlying atom for a given key.
   *
   * @param key - The key to retrieve the atom for
   * @returns The atom containing the value, or undefined if the key doesn't exist
   * @internal
   */
  getAtom(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      this.atoms.get();
      return void 0;
    }
    return valueAtom;
  }
  /**
   * Gets the value associated with a key. Returns undefined if the key doesn't exist.
   * This method is reactive and will cause reactive contexts to update when the value changes.
   *
   * @param key - The key to retrieve the value for
   * @returns The value associated with the key, or undefined if not found
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('name', 'Alice')
   * console.log(map.get('name')) // 'Alice'
   * console.log(map.get('missing')) // undefined
   * ```
   */
  get(key) {
    const value = this.getAtom(key)?.get();
    assert(value !== UNINITIALIZED);
    return value;
  }
  /**
   * Gets the value associated with a key without creating reactive dependencies.
   * This method will not cause reactive contexts to update when the value changes.
   *
   * @param key - The key to retrieve the value for
   * @returns The value associated with the key, or undefined if not found
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('count', 42)
   * const value = map.__unsafe__getWithoutCapture('count') // No reactive subscription
   * ```
   */
  __unsafe__getWithoutCapture(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) return void 0;
    const value = valueAtom.__unsafe__getWithoutCapture();
    assert(value !== UNINITIALIZED);
    return value;
  }
  /**
   * Checks whether a key exists in the map.
   * This method is reactive and will cause reactive contexts to update when keys are added or removed.
   *
   * @param key - The key to check for
   * @returns True if the key exists in the map, false otherwise
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * console.log(map.has('name')) // false
   * map.set('name', 'Alice')
   * console.log(map.has('name')) // true
   * ```
   */
  has(key) {
    const valueAtom = this.getAtom(key);
    if (!valueAtom) {
      return false;
    }
    return valueAtom.get() !== UNINITIALIZED;
  }
  /**
   * Checks whether a key exists in the map without creating reactive dependencies.
   * This method will not cause reactive contexts to update when keys are added or removed.
   *
   * @param key - The key to check for
   * @returns True if the key exists in the map, false otherwise
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('active', true)
   * const exists = map.__unsafe__hasWithoutCapture('active') // No reactive subscription
   * ```
   */
  __unsafe__hasWithoutCapture(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) return false;
    assert(valueAtom.__unsafe__getWithoutCapture() !== UNINITIALIZED);
    return true;
  }
  /**
   * Sets a value for the given key. If the key already exists, its value is updated.
   * If the key doesn't exist, a new entry is created.
   *
   * @param key - The key to set the value for
   * @param value - The value to associate with the key
   * @returns This AtomMap instance for method chaining
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('name', 'Alice').set('age', 30)
   * ```
   */
  set(key, value) {
    const existingAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (existingAtom) {
      existingAtom.set(value);
    } else {
      this.atoms.update((atoms) => {
        return atoms.set(key, atom(`${this.name}:${String(key)}`, value));
      });
    }
    return this;
  }
  /**
   * Updates an existing value using an updater function.
   *
   * @param key - The key of the value to update
   * @param updater - A function that receives the current value and returns the new value
   * @throws Error if the key doesn't exist in the map
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('count', 5)
   * map.update('count', count => count + 1) // count is now 6
   * ```
   */
  update(key, updater) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      throw new Error(`AtomMap: key ${key} not found`);
    }
    const value = valueAtom.__unsafe__getWithoutCapture();
    assert(value !== UNINITIALIZED);
    valueAtom.set(updater(value));
  }
  /**
   * Removes a key-value pair from the map.
   *
   * @param key - The key to remove
   * @returns True if the key existed and was removed, false if it didn't exist
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('temp', 'value')
   * console.log(map.delete('temp')) // true
   * console.log(map.delete('missing')) // false
   * ```
   */
  delete(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      return false;
    }
    transact(() => {
      valueAtom.set(UNINITIALIZED);
      this.atoms.update((atoms) => {
        return atoms.delete(key);
      });
    });
    return true;
  }
  /**
   * Removes multiple key-value pairs from the map in a single transaction.
   *
   * @param keys - An iterable of keys to remove
   * @returns An array of [key, value] pairs that were actually deleted
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('a', 1).set('b', 2).set('c', 3)
   * const deleted = map.deleteMany(['a', 'c', 'missing'])
   * console.log(deleted) // [['a', 1], ['c', 3]]
   * ```
   */
  deleteMany(keys2) {
    return transact(() => {
      const deleted = [];
      const newAtoms = this.atoms.get().withMutations((atoms) => {
        for (const key of keys2) {
          const valueAtom = atoms.get(key);
          if (!valueAtom) continue;
          const oldValue = valueAtom.get();
          assert(oldValue !== UNINITIALIZED);
          deleted.push([key, oldValue]);
          atoms.delete(key);
          valueAtom.set(UNINITIALIZED);
        }
      });
      if (deleted.length) {
        this.atoms.set(newAtoms);
      }
      return deleted;
    });
  }
  /**
   * Removes all key-value pairs from the map.
   *
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('a', 1).set('b', 2)
   * map.clear()
   * console.log(map.size) // 0
   * ```
   */
  clear() {
    return transact(() => {
      for (const valueAtom of this.atoms.__unsafe__getWithoutCapture().values()) {
        valueAtom.set(UNINITIALIZED);
      }
      this.atoms.set(emptyMap());
    });
  }
  /**
   * Returns an iterator that yields [key, value] pairs for each entry in the map.
   * This method is reactive and will cause reactive contexts to update when entries change.
   *
   * @returns A generator that yields [key, value] tuples
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('a', 1).set('b', 2)
   * for (const [key, value] of map.entries()) {
   *   console.log(`${key}: ${value}`)
   * }
   * ```
   */
  *entries() {
    for (const [key, valueAtom] of this.atoms.get()) {
      const value = valueAtom.get();
      assert(value !== UNINITIALIZED);
      yield [key, value];
    }
  }
  /**
   * Returns an iterator that yields all keys in the map.
   * This method is reactive and will cause reactive contexts to update when keys change.
   *
   * @returns A generator that yields keys
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('name', 'Alice').set('age', 30)
   * for (const key of map.keys()) {
   *   console.log(key) // 'name', 'age'
   * }
   * ```
   */
  *keys() {
    for (const key of this.atoms.get().keys()) {
      yield key;
    }
  }
  /**
   * Returns an iterator that yields all values in the map.
   * This method is reactive and will cause reactive contexts to update when values change.
   *
   * @returns A generator that yields values
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('name', 'Alice').set('age', 30)
   * for (const value of map.values()) {
   *   console.log(value) // 'Alice', 30
   * }
   * ```
   */
  *values() {
    for (const valueAtom of this.atoms.get().values()) {
      const value = valueAtom.get();
      assert(value !== UNINITIALIZED);
      yield value;
    }
  }
  /**
   * The number of key-value pairs in the map.
   * This property is reactive and will cause reactive contexts to update when the size changes.
   *
   * @returns The number of entries in the map
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * console.log(map.size) // 0
   * map.set('a', 1)
   * console.log(map.size) // 1
   * ```
   */
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.atoms.get().size;
  }
  /**
   * Executes a provided function once for each key-value pair in the map.
   * This method is reactive and will cause reactive contexts to update when entries change.
   *
   * @param callbackfn - Function to execute for each entry
   *   - value - The value of the current entry
   *   - key - The key of the current entry
   *   - map - The AtomMap being traversed
   * @param thisArg - Value to use as `this` when executing the callback
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('a', 1).set('b', 2)
   * map.forEach((value, key) => {
   *   console.log(`${key} = ${value}`)
   * })
   * ```
   */
  forEach(callbackfn, thisArg) {
    for (const [key, value] of this.entries()) {
      callbackfn.call(thisArg, value, key, this);
    }
  }
  /**
   * Returns the default iterator for the map, which is the same as entries().
   * This allows the map to be used in for...of loops and other iterable contexts.
   *
   * @returns The same iterator as entries()
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('a', 1).set('b', 2)
   *
   * // These are equivalent:
   * for (const [key, value] of map) {
   *   console.log(`${key}: ${value}`)
   * }
   *
   * for (const [key, value] of map.entries()) {
   *   console.log(`${key}: ${value}`)
   * }
   * ```
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * The string tag used by Object.prototype.toString for this class.
   *
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * console.log(Object.prototype.toString.call(map)) // '[object AtomMap]'
   * ```
   */
  [Symbol.toStringTag] = "AtomMap";
}
function devFreeze(object2) {
  {
    return object2;
  }
}
class IncrementalSetConstructor {
  constructor(previousValue) {
    this.previousValue = previousValue;
  }
  /**
   * The next value of the set.
   *
   * @internal
   */
  nextValue;
  /**
   * The diff of the set.
   *
   * @internal
   */
  diff;
  /**
   * Gets the result of the incremental set construction if any changes were made.
   * Returns undefined if no additions or removals occurred.
   *
   * @returns An object containing the final set value and the diff of changes,
   * or undefined if no changes were made
   *
   * @example
   * ```ts
   * const constructor = new IncrementalSetConstructor(new Set(['a', 'b']))
   * constructor.add('c')
   *
   * const result = constructor.get()
   * // result = {
   * //   value: Set(['a', 'b', 'c']),
   * //   diff: { added: Set(['c']) }
   * // }
   * ```
   *
   * @public
   */
  get() {
    const numRemoved = this.diff?.removed?.size ?? 0;
    const numAdded = this.diff?.added?.size ?? 0;
    if (numRemoved === 0 && numAdded === 0) {
      return void 0;
    }
    return { value: this.nextValue, diff: this.diff };
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _add(item, wasAlreadyPresent) {
    this.nextValue ??= new Set(this.previousValue);
    this.nextValue.add(item);
    this.diff ??= {};
    if (wasAlreadyPresent) {
      this.diff.removed?.delete(item);
    } else {
      this.diff.added ??= /* @__PURE__ */ new Set();
      this.diff.added.add(item);
    }
  }
  /**
   * Adds an item to the set. If the item was already present in the original set
   * and was previously removed during this construction, it will be restored.
   * If the item is already present and wasn't removed, this is a no-op.
   *
   * @param item - The item to add to the set
   *
   * @example
   * ```ts
   * const constructor = new IncrementalSetConstructor(new Set(['a', 'b']))
   * constructor.add('c') // Adds new item
   * constructor.add('a') // No-op, already present
   * constructor.remove('b')
   * constructor.add('b') // Restores previously removed item
   * ```
   *
   * @public
   */
  add(item) {
    const wasAlreadyPresent = this.previousValue.has(item);
    if (wasAlreadyPresent) {
      const wasRemoved = this.diff?.removed?.has(item);
      if (!wasRemoved) return;
      return this._add(item, wasAlreadyPresent);
    }
    const isCurrentlyPresent = this.nextValue?.has(item);
    if (isCurrentlyPresent) return;
    this._add(item, wasAlreadyPresent);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _remove(item, wasAlreadyPresent) {
    this.nextValue ??= new Set(this.previousValue);
    this.nextValue.delete(item);
    this.diff ??= {};
    if (wasAlreadyPresent) {
      this.diff.removed ??= /* @__PURE__ */ new Set();
      this.diff.removed.add(item);
    } else {
      this.diff.added?.delete(item);
    }
  }
  /**
   * Removes an item from the set. If the item wasn't present in the original set
   * and was added during this construction, it will be removed from the added diff.
   * If the item is not present at all, this is a no-op.
   *
   * @param item - The item to remove from the set
   *
   * @example
   * ```ts
   * const constructor = new IncrementalSetConstructor(new Set(['a', 'b']))
   * constructor.remove('a') // Removes existing item
   * constructor.remove('c') // No-op, not present
   * constructor.add('d')
   * constructor.remove('d') // Removes recently added item
   * ```
   *
   * @public
   */
  remove(item) {
    const wasAlreadyPresent = this.previousValue.has(item);
    if (!wasAlreadyPresent) {
      const wasAdded = this.diff?.added?.has(item);
      if (!wasAdded) return;
      return this._remove(item, wasAlreadyPresent);
    }
    const hasAlreadyBeenRemoved = this.diff?.removed?.has(item);
    if (hasAlreadyBeenRemoved) return;
    this._remove(item, wasAlreadyPresent);
  }
}
function squashDependsOn(sequence) {
  const result = [];
  for (let i = sequence.length - 1; i >= 0; i--) {
    const elem = sequence[i];
    if (!("id" in elem)) {
      const dependsOn = elem.dependsOn;
      const prev = result[0];
      if (prev) {
        result[0] = {
          ...prev,
          dependsOn: dependsOn.concat(prev.dependsOn ?? [])
        };
      }
    } else {
      result.unshift(elem);
    }
  }
  return result;
}
function createMigrationSequence({
  sequence,
  sequenceId,
  retroactive = true
}) {
  const migrations = {
    sequenceId,
    retroactive,
    sequence: squashDependsOn(sequence)
  };
  validateMigrations(migrations);
  return migrations;
}
function createMigrationIds(sequenceId, versions) {
  return Object.fromEntries(
    objectMapEntries(versions).map(([key, version2]) => [key, `${sequenceId}/${version2}`])
  );
}
function createRecordMigrationSequence(opts) {
  const sequenceId = opts.sequenceId;
  return createMigrationSequence({
    sequenceId,
    retroactive: opts.retroactive ?? true,
    sequence: opts.sequence.map(
      (m) => "id" in m ? {
        ...m,
        scope: "record",
        filter: (r) => r.typeName === opts.recordType && (m.filter?.(r) ?? true) && (opts.filter?.(r) ?? true)
      } : m
    )
  });
}
function sortMigrations(migrations) {
  if (migrations.length === 0) return [];
  const byId = new Map(migrations.map((m) => [m.id, m]));
  const dependents = /* @__PURE__ */ new Map();
  const inDegree = /* @__PURE__ */ new Map();
  const explicitDeps = /* @__PURE__ */ new Map();
  for (const m of migrations) {
    inDegree.set(m.id, 0);
    dependents.set(m.id, /* @__PURE__ */ new Set());
    explicitDeps.set(m.id, /* @__PURE__ */ new Set());
  }
  for (const m of migrations) {
    const { version: version2, sequenceId } = parseMigrationId(m.id);
    const prevId = `${sequenceId}/${version2 - 1}`;
    if (byId.has(prevId)) {
      dependents.get(prevId).add(m.id);
      inDegree.set(m.id, inDegree.get(m.id) + 1);
    }
    if (m.dependsOn) {
      for (const depId of m.dependsOn) {
        if (byId.has(depId)) {
          dependents.get(depId).add(m.id);
          explicitDeps.get(m.id).add(depId);
          inDegree.set(m.id, inDegree.get(m.id) + 1);
        }
      }
    }
  }
  const ready = migrations.filter((m) => inDegree.get(m.id) === 0);
  const result = [];
  const processed = /* @__PURE__ */ new Set();
  while (ready.length > 0) {
    let bestCandidate;
    let bestCandidateScore = -Infinity;
    for (const m of ready) {
      let urgencyScore = 0;
      for (const depId of dependents.get(m.id) || []) {
        if (!processed.has(depId)) {
          urgencyScore += 1;
          if (explicitDeps.get(depId).has(m.id)) {
            urgencyScore += 100;
          }
        }
      }
      if (urgencyScore > bestCandidateScore || // Tiebreaker: prefer lower sequence/version
      urgencyScore === bestCandidateScore && m.id.localeCompare(bestCandidate?.id ?? "") < 0) {
        bestCandidate = m;
        bestCandidateScore = urgencyScore;
      }
    }
    const nextMigration = bestCandidate;
    ready.splice(ready.indexOf(nextMigration), 1);
    result.push(nextMigration);
    processed.add(nextMigration.id);
    for (const depId of dependents.get(nextMigration.id) || []) {
      if (!processed.has(depId)) {
        inDegree.set(depId, inDegree.get(depId) - 1);
        if (inDegree.get(depId) === 0) {
          ready.push(byId.get(depId));
        }
      }
    }
  }
  if (result.length !== migrations.length) {
    const unprocessed = migrations.filter((m) => !processed.has(m.id));
    assert(false, `Circular dependency in migrations: ${unprocessed[0].id}`);
  }
  return result;
}
function parseMigrationId(id) {
  const [sequenceId, version2] = id.split("/");
  return { sequenceId, version: parseInt(version2) };
}
function validateMigrationId(id, expectedSequenceId) {
  if (expectedSequenceId) {
    assert(
      id.startsWith(expectedSequenceId + "/"),
      `Every migration in sequence '${expectedSequenceId}' must have an id starting with '${expectedSequenceId}/'. Got invalid id: '${id}'`
    );
  }
  assert(id.match(/^(.*?)\/(0|[1-9]\d*)$/), `Invalid migration id: '${id}'`);
}
function validateMigrations(migrations) {
  assert(
    !migrations.sequenceId.includes("/"),
    `sequenceId cannot contain a '/', got ${migrations.sequenceId}`
  );
  assert(migrations.sequenceId.length, "sequenceId must be a non-empty string");
  if (migrations.sequence.length === 0) {
    return;
  }
  validateMigrationId(migrations.sequence[0].id, migrations.sequenceId);
  let n = parseMigrationId(migrations.sequence[0].id).version;
  assert(
    n === 1,
    `Expected the first migrationId to be '${migrations.sequenceId}/1' but got '${migrations.sequence[0].id}'`
  );
  for (let i = 1; i < migrations.sequence.length; i++) {
    const id = migrations.sequence[i].id;
    validateMigrationId(id, migrations.sequenceId);
    const m = parseMigrationId(id).version;
    assert(
      m === n + 1,
      `Migration id numbers must increase in increments of 1, expected ${migrations.sequenceId}/${n + 1} but got '${migrations.sequence[i].id}'`
    );
    n = m;
  }
}
var MigrationFailureReason = /* @__PURE__ */ ((MigrationFailureReason2) => {
  MigrationFailureReason2["IncompatibleSubtype"] = "incompatible-subtype";
  MigrationFailureReason2["UnknownType"] = "unknown-type";
  MigrationFailureReason2["TargetVersionTooNew"] = "target-version-too-new";
  MigrationFailureReason2["TargetVersionTooOld"] = "target-version-too-old";
  MigrationFailureReason2["MigrationError"] = "migration-error";
  MigrationFailureReason2["UnrecognizedSubtype"] = "unrecognized-subtype";
  return MigrationFailureReason2;
})(MigrationFailureReason || {});
function createEmptyRecordsDiff() {
  return { added: {}, updated: {}, removed: {} };
}
function reverseRecordsDiff(diff) {
  const result = { added: diff.removed, removed: diff.added, updated: {} };
  for (const [from2, to] of Object.values(diff.updated)) {
    result.updated[from2.id] = [to, from2];
  }
  return result;
}
function isRecordsDiffEmpty(diff) {
  return Object.keys(diff.added).length === 0 && Object.keys(diff.updated).length === 0 && Object.keys(diff.removed).length === 0;
}
function squashRecordDiffs(diffs, options) {
  const result = options?.mutateFirstDiff ? diffs[0] : { added: {}, removed: {}, updated: {} };
  squashRecordDiffsMutable(result, diffs);
  return result;
}
function squashRecordDiffsMutable(target, diffs) {
  for (const diff of diffs) {
    for (const [id, value] of objectMapEntries(diff.added)) {
      if (target.removed[id]) {
        const original = target.removed[id];
        delete target.removed[id];
        if (original !== value) {
          target.updated[id] = [original, value];
        }
      } else {
        target.added[id] = value;
      }
    }
    for (const [id, [_from, to]] of objectMapEntries(diff.updated)) {
      if (target.added[id]) {
        target.added[id] = to;
        delete target.updated[id];
        delete target.removed[id];
        continue;
      }
      if (target.updated[id]) {
        target.updated[id] = [target.updated[id][0], to];
        delete target.removed[id];
        continue;
      }
      target.updated[id] = diff.updated[id];
      delete target.removed[id];
    }
    for (const [id, value] of objectMapEntries(diff.removed)) {
      if (target.added[id]) {
        delete target.added[id];
      } else if (target.updated[id]) {
        target.removed[id] = target.updated[id][0];
        delete target.updated[id];
      } else {
        target.removed[id] = value;
      }
    }
  }
}
class RecordType {
  /**
   * Creates a new RecordType instance.
   *
   * typeName - The unique type name for records created by this RecordType
   * config - Configuration object for the RecordType
   *   - createDefaultProperties - Function that returns default properties for new records
   *   - validator - Optional validator function for record validation
   *   - scope - Optional scope determining persistence behavior (defaults to 'document')
   *   - ephemeralKeys - Optional mapping of property names to ephemeral status
   * @public
   */
  constructor(typeName, config) {
    this.typeName = typeName;
    this.createDefaultProperties = config.createDefaultProperties;
    this.validator = config.validator ?? { validate: (r) => r };
    this.scope = config.scope ?? "document";
    this.ephemeralKeys = config.ephemeralKeys;
    const ephemeralKeySet = /* @__PURE__ */ new Set();
    if (config.ephemeralKeys) {
      for (const [key, isEphemeral] of objectMapEntries(config.ephemeralKeys)) {
        if (isEphemeral) ephemeralKeySet.add(key);
      }
    }
    this.ephemeralKeySet = ephemeralKeySet;
  }
  /**
   * Factory function that creates default properties for new records.
   * @public
   */
  createDefaultProperties;
  /**
   * Validator function used to validate records of this type.
   * @public
   */
  validator;
  /**
   * Optional configuration specifying which record properties are ephemeral.
   * Ephemeral properties are not included in snapshots or synchronization.
   * @public
   */
  ephemeralKeys;
  /**
   * Set of property names that are marked as ephemeral for efficient lookup.
   * @public
   */
  ephemeralKeySet;
  /**
   * The scope that determines how records of this type are persisted and synchronized.
   * @public
   */
  scope;
  /**
   * Creates a new record of this type with the given properties.
   *
   * Properties are merged with default properties from the RecordType configuration.
   * If no id is provided, a unique id will be generated automatically.
   *
   * @example
   * ```ts
   * const book = Book.create({
   *   title: 'The Great Gatsby',
   *   author: 'F. Scott Fitzgerald'
   * })
   * // Result: { id: 'book:abc123', typeName: 'book', title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', inStock: true }
   * ```
   *
   * @param properties - The properties for the new record, including both required and optional fields
   * @returns The newly created record with generated id and typeName
   * @public
   */
  create(properties) {
    const result = {
      ...this.createDefaultProperties(),
      id: "id" in properties ? properties.id : this.createId()
    };
    for (const [k, v] of Object.entries(properties)) {
      if (v !== void 0) {
        result[k] = v;
      }
    }
    result.typeName = this.typeName;
    return result;
  }
  /**
   * Creates a deep copy of an existing record with a new unique id.
   *
   * This method performs a deep clone of all properties while generating a fresh id,
   * making it useful for duplicating records without id conflicts.
   *
   * @example
   * ```ts
   * const originalBook = Book.create({ title: '1984', author: 'George Orwell' })
   * const duplicatedBook = Book.clone(originalBook)
   * // duplicatedBook has same properties but different id
   * ```
   *
   * @param record - The record to clone
   * @returns A new record with the same properties but a different id
   * @public
   */
  clone(record) {
    return { ...structuredClone(record), id: this.createId() };
  }
  /**
   * Create a new ID for this record type.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createId()
   * ```
   *
   * @returns The new ID.
   * @public
   */
  createId(customUniquePart) {
    return this.typeName + ":" + (customUniquePart ?? uniqueId());
  }
  /**
   * Extracts the unique identifier part from a full record id.
   *
   * Record ids have the format `typeName:uniquePart`. This method returns just the unique part.
   *
   * @example
   * ```ts
   * const bookId = Book.createId() // 'book:abc123'
   * const uniquePart = Book.parseId(bookId) // 'abc123'
   * ```
   *
   * @param id - The full record id to parse
   * @returns The unique identifier portion after the colon
   * @throws Error if the id is not valid for this record type
   * @public
   */
  parseId(id) {
    if (!this.isId(id)) {
      throw new Error(`ID "${id}" is not a valid ID for type "${this.typeName}"`);
    }
    return id.slice(this.typeName.length + 1);
  }
  /**
   * Type guard that checks whether a record belongs to this RecordType.
   *
   * This method performs a runtime check by comparing the record's typeName
   * against this RecordType's typeName.
   *
   * @example
   * ```ts
   * if (Book.isInstance(someRecord)) {
   *   // someRecord is now typed as a book record
   *   console.log(someRecord.title)
   * }
   * ```
   *
   * @param record - The record to check, may be undefined
   * @returns True if the record is an instance of this record type
   * @public
   */
  isInstance(record) {
    return record?.typeName === this.typeName;
  }
  /**
   * Type guard that checks whether an id string belongs to this RecordType.
   *
   * Validates that the id starts with this RecordType's typeName followed by a colon.
   * This is more efficient than parsing the full id when you only need to verify the type.
   *
   * @example
   * ```ts
   * if (Book.isId(someId)) {
   *   // someId is now typed as IdOf<BookRecord>
   *   const book = store.get(someId)
   * }
   * ```
   *
   * @param id - The id string to check, may be undefined
   * @returns True if the id belongs to this record type
   * @public
   */
  isId(id) {
    if (!id) return false;
    for (let i = 0; i < this.typeName.length; i++) {
      if (id[i] !== this.typeName[i]) return false;
    }
    return id[this.typeName.length] === ":";
  }
  /**
   * Create a new RecordType that has the same type name as this RecordType and includes the given
   * default properties.
   *
   * @example
   *
   * ```ts
   * const authorType = createRecordType('author', () => ({ living: true }))
   * const deadAuthorType = authorType.withDefaultProperties({ living: false })
   * ```
   *
   * @param createDefaultProperties - A function that returns the default properties of the new RecordType.
   * @returns The new RecordType.
   */
  withDefaultProperties(createDefaultProperties) {
    return new RecordType(this.typeName, {
      createDefaultProperties,
      validator: this.validator,
      scope: this.scope,
      ephemeralKeys: this.ephemeralKeys
    });
  }
  /**
   * Validates a record against this RecordType's validator and returns it with proper typing.
   *
   * This method runs the configured validator function and throws an error if validation fails.
   * If a previous version of the record is provided, it may use optimized validation.
   *
   * @example
   * ```ts
   * try {
   *   const validBook = Book.validate(untrustedData)
   *   // validBook is now properly typed and validated
   * } catch (error) {
   *   console.log('Validation failed:', error.message)
   * }
   * ```
   *
   * @param record - The unknown record data to validate
   * @param recordBefore - Optional previous version for optimized validation
   * @returns The validated and properly typed record
   * @throws Error if validation fails
   * @public
   */
  validate(record, recordBefore) {
    if (recordBefore && this.validator.validateUsingKnownGoodVersion) {
      return this.validator.validateUsingKnownGoodVersion(recordBefore, record);
    }
    return this.validator.validate(record);
  }
}
function createRecordType(typeName, config) {
  return new RecordType(typeName, {
    createDefaultProperties: () => ({}),
    validator: config.validator,
    scope: config.scope,
    ephemeralKeys: config.ephemeralKeys
  });
}
function intersectSets(sets) {
  if (sets.length === 0) return /* @__PURE__ */ new Set();
  const first2 = sets[0];
  const rest = sets.slice(1);
  const result = /* @__PURE__ */ new Set();
  for (const val of first2) {
    if (rest.every((set) => set.has(val))) {
      result.add(val);
    }
  }
  return result;
}
function diffSets(prev, next) {
  const result = {};
  for (const val of next) {
    if (!prev.has(val)) {
      result.added ??= /* @__PURE__ */ new Set();
      result.added.add(val);
    }
  }
  for (const val of prev) {
    if (!next.has(val)) {
      result.removed ??= /* @__PURE__ */ new Set();
      result.removed.add(val);
    }
  }
  return result.added || result.removed ? result : void 0;
}
function isQueryValueMatcher(value) {
  if (typeof value !== "object" || value === null) return false;
  return "eq" in value || "neq" in value || "gt" in value;
}
function extractMatcherPaths(query, prefix = "") {
  const paths = [];
  for (const [key, value] of Object.entries(query)) {
    const currentPath = prefix ? `${prefix}\\${key}` : key;
    if (isQueryValueMatcher(value)) {
      paths.push({ path: currentPath, matcher: value });
    } else if (typeof value === "object" && value !== null) {
      paths.push(...extractMatcherPaths(value, currentPath));
    }
  }
  return paths;
}
function objectMatchesQuery(query, object2) {
  for (const [key, matcher] of Object.entries(query)) {
    const value = object2[key];
    if (isQueryValueMatcher(matcher)) {
      if ("eq" in matcher && value !== matcher.eq) return false;
      if ("neq" in matcher && value === matcher.neq) return false;
      if ("gt" in matcher && (typeof value !== "number" || value <= matcher.gt)) return false;
      continue;
    }
    if (typeof value !== "object" || value === null) return false;
    if (!objectMatchesQuery(matcher, value)) {
      return false;
    }
  }
  return true;
}
function executeQuery(store, typeName, query) {
  const matcherPaths = extractMatcherPaths(query);
  const matchIds = Object.fromEntries(matcherPaths.map(({ path }) => [path, /* @__PURE__ */ new Set()]));
  for (const { path, matcher } of matcherPaths) {
    const index2 = store.index(typeName, path);
    if ("eq" in matcher) {
      const ids = index2.get().get(matcher.eq);
      if (ids) {
        for (const id of ids) {
          matchIds[path].add(id);
        }
      }
    } else if ("neq" in matcher) {
      for (const [value, ids] of index2.get()) {
        if (value !== matcher.neq) {
          for (const id of ids) {
            matchIds[path].add(id);
          }
        }
      }
    } else if ("gt" in matcher) {
      for (const [value, ids] of index2.get()) {
        if (typeof value === "number" && value > matcher.gt) {
          for (const id of ids) {
            matchIds[path].add(id);
          }
        }
      }
    }
    if (matchIds[path].size === 0) {
      return /* @__PURE__ */ new Set();
    }
  }
  return intersectSets(Object.values(matchIds));
}
class StoreQueries {
  /**
   * Creates a new StoreQueries instance.
   *
   * recordMap - The atom map containing all records in the store
   * history - The atom tracking the store's change history with diffs
   *
   * @internal
   */
  constructor(recordMap, history2) {
    this.recordMap = recordMap;
    this.history = history2;
  }
  /**
   * A cache of derivations (indexes).
   *
   * @internal
   */
  indexCache = /* @__PURE__ */ new Map();
  /**
   * A cache of derivations (filtered histories).
   *
   * @internal
   */
  historyCache = /* @__PURE__ */ new Map();
  /**
   * @internal
   */
  getAllIdsForType(typeName) {
    const ids = /* @__PURE__ */ new Set();
    for (const record of this.recordMap.values()) {
      if (record.typeName === typeName) {
        ids.add(record.id);
      }
    }
    return ids;
  }
  /**
   * @internal
   */
  getRecordById(typeName, id) {
    const record = this.recordMap.get(id);
    if (record && record.typeName === typeName) {
      return record;
    }
    return void 0;
  }
  /**
   * Helper to extract nested property value using pre-split path parts.
   * @internal
   */
  getNestedValue(obj, pathParts) {
    let current = obj;
    for (const part of pathParts) {
      if (current == null || typeof current !== "object") return void 0;
      current = current[part];
    }
    return current;
  }
  /**
   * Creates a reactive computed that tracks the change history for records of a specific type.
   * The returned computed provides incremental diffs showing what records of the given type
   * have been added, updated, or removed.
   *
   * @param typeName - The type name to filter the history by
   * @returns A computed value containing the current epoch and diffs of changes for the specified type
   *
   * @example
   * ```ts
   * // Track changes to book records only
   * const bookHistory = store.query.filterHistory('book')
   *
   * // React to book changes
   * react('book-changes', () => {
   *   const currentEpoch = bookHistory.get()
   *   console.log('Books updated at epoch:', currentEpoch)
   * })
   * ```
   *
   * @public
   */
  filterHistory(typeName) {
    if (this.historyCache.has(typeName)) {
      return this.historyCache.get(typeName);
    }
    const filtered = computed(
      "filterHistory:" + typeName,
      (lastValue, lastComputedEpoch) => {
        if (isUninitialized(lastValue)) {
          return this.history.get();
        }
        const diff = this.history.getDiffSince(lastComputedEpoch);
        if (diff === RESET_VALUE) return this.history.get();
        const res = { added: {}, removed: {}, updated: {} };
        let numAdded = 0;
        let numRemoved = 0;
        let numUpdated = 0;
        for (const changes of diff) {
          for (const added of objectMapValues(changes.added)) {
            if (added.typeName === typeName) {
              if (res.removed[added.id]) {
                const original = res.removed[added.id];
                delete res.removed[added.id];
                numRemoved--;
                if (original !== added) {
                  res.updated[added.id] = [original, added];
                  numUpdated++;
                }
              } else {
                res.added[added.id] = added;
                numAdded++;
              }
            }
          }
          for (const [from2, to] of objectMapValues(changes.updated)) {
            if (to.typeName === typeName) {
              if (res.added[to.id]) {
                res.added[to.id] = to;
              } else if (res.updated[to.id]) {
                res.updated[to.id] = [res.updated[to.id][0], to];
              } else {
                res.updated[to.id] = [from2, to];
                numUpdated++;
              }
            }
          }
          for (const removed of objectMapValues(changes.removed)) {
            if (removed.typeName === typeName) {
              if (res.added[removed.id]) {
                delete res.added[removed.id];
                numAdded--;
              } else if (res.updated[removed.id]) {
                res.removed[removed.id] = res.updated[removed.id][0];
                delete res.updated[removed.id];
                numUpdated--;
                numRemoved++;
              } else {
                res.removed[removed.id] = removed;
                numRemoved++;
              }
            }
          }
        }
        if (numAdded || numRemoved || numUpdated) {
          return withDiff(this.history.get(), res);
        } else {
          return lastValue;
        }
      },
      { historyLength: 100 }
    );
    this.historyCache.set(typeName, filtered);
    return filtered;
  }
  /**
   * Creates a reactive index that maps property values to sets of record IDs for efficient lookups.
   * The index automatically updates when records are added, updated, or removed, and results are cached
   * for performance.
   *
   * Supports nested property paths using backslash separator (e.g., 'metadata\\sessionId').
   *
   * @param typeName - The type name of records to index
   * @param path - The property name or backslash-delimited path to index by
   * @returns A reactive computed containing the index map with change diffs
   *
   * @example
   * ```ts
   * // Create an index of books by author ID
   * const booksByAuthor = store.query.index('book', 'authorId')
   *
   * // Get all books by a specific author
   * const authorBooks = booksByAuthor.get().get('author:leguin')
   * console.log(authorBooks) // Set<RecordId<Book>>
   *
   * // Index by nested property using backslash separator
   * const booksBySession = store.query.index('book', 'metadata\\sessionId')
   * const sessionBooks = booksBySession.get().get('session:alpha')
   * ```
   *
   * @public
   */
  index(typeName, path) {
    const cacheKey = typeName + ":" + path;
    if (this.indexCache.has(cacheKey)) {
      return this.indexCache.get(cacheKey);
    }
    const index2 = this.__uncached_createIndex(typeName, path);
    this.indexCache.set(cacheKey, index2);
    return index2;
  }
  /**
   * Creates a new index without checking the cache. This method performs the actual work
   * of building the reactive index computation that tracks property values to record ID sets.
   *
   * Supports nested property paths using backslash separator.
   *
   * @param typeName - The type name of records to index
   * @param path - The property name or backslash-delimited path to index by
   * @returns A reactive computed containing the index map with change diffs
   *
   * @internal
   */
  __uncached_createIndex(typeName, path) {
    const typeHistory = this.filterHistory(typeName);
    const pathParts = path.split("\\");
    const getPropertyValue = pathParts.length > 1 ? (obj) => this.getNestedValue(obj, pathParts) : (obj) => obj[path];
    const fromScratch2 = () => {
      typeHistory.get();
      const res = /* @__PURE__ */ new Map();
      for (const record of this.recordMap.values()) {
        if (record.typeName === typeName) {
          const value = getPropertyValue(record);
          if (value !== void 0) {
            if (!res.has(value)) {
              res.set(value, /* @__PURE__ */ new Set());
            }
            res.get(value).add(record.id);
          }
        }
      }
      return res;
    };
    return computed(
      "index:" + typeName + ":" + path,
      (prevValue, lastComputedEpoch) => {
        if (isUninitialized(prevValue)) return fromScratch2();
        const history2 = typeHistory.getDiffSince(lastComputedEpoch);
        if (history2 === RESET_VALUE) {
          return fromScratch2();
        }
        const setConstructors = /* @__PURE__ */ new Map();
        const add = (value, id) => {
          let setConstructor = setConstructors.get(value);
          if (!setConstructor)
            setConstructor = new IncrementalSetConstructor(
              prevValue.get(value) ?? /* @__PURE__ */ new Set()
            );
          setConstructor.add(id);
          setConstructors.set(value, setConstructor);
        };
        const remove2 = (value, id) => {
          let set = setConstructors.get(value);
          if (!set) set = new IncrementalSetConstructor(prevValue.get(value) ?? /* @__PURE__ */ new Set());
          set.remove(id);
          setConstructors.set(value, set);
        };
        for (const changes of history2) {
          for (const record of objectMapValues(changes.added)) {
            if (record.typeName === typeName) {
              const value = getPropertyValue(record);
              if (value !== void 0) {
                add(value, record.id);
              }
            }
          }
          for (const [from2, to] of objectMapValues(changes.updated)) {
            if (to.typeName === typeName) {
              const prev = getPropertyValue(from2);
              const next = getPropertyValue(to);
              if (prev !== next) {
                if (prev !== void 0) {
                  remove2(prev, to.id);
                }
                if (next !== void 0) {
                  add(next, to.id);
                }
              }
            }
          }
          for (const record of objectMapValues(changes.removed)) {
            if (record.typeName === typeName) {
              const value = getPropertyValue(record);
              if (value !== void 0) {
                remove2(value, record.id);
              }
            }
          }
        }
        let nextValue = void 0;
        let nextDiff = void 0;
        for (const [value, setConstructor] of setConstructors) {
          const result = setConstructor.get();
          if (!result) continue;
          if (!nextValue) nextValue = new Map(prevValue);
          if (!nextDiff) nextDiff = /* @__PURE__ */ new Map();
          if (result.value.size === 0) {
            nextValue.delete(value);
          } else {
            nextValue.set(value, result.value);
          }
          nextDiff.set(value, result.diff);
        }
        if (nextValue && nextDiff) {
          return withDiff(nextValue, nextDiff);
        }
        return prevValue;
      },
      { historyLength: 100 }
    );
  }
  /**
   * Creates a reactive query that returns the first record matching the given query criteria.
   * Returns undefined if no matching record is found. The query automatically updates
   * when records change.
   *
   * @param typeName - The type name of records to query
   * @param queryCreator - Function that returns the query expression object to match against
   * @param name - Optional name for the query computation (used for debugging)
   * @returns A computed value containing the first matching record or undefined
   *
   * @example
   * ```ts
   * // Find the first book with a specific title
   * const bookLatheOfHeaven = store.query.record('book', () => ({ title: { eq: 'The Lathe of Heaven' } }))
   * console.log(bookLatheOfHeaven.get()?.title) // 'The Lathe of Heaven' or undefined
   *
   * // Find any book in stock
   * const anyInStockBook = store.query.record('book', () => ({ inStock: { eq: true } }))
   * ```
   *
   * @public
   */
  record(typeName, queryCreator = () => ({}), name = "record:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const ids = this.ids(typeName, queryCreator, name);
    return computed(name, () => {
      for (const id of ids.get()) {
        return this.recordMap.get(id);
      }
      return void 0;
    });
  }
  /**
   * Creates a reactive query that returns an array of all records matching the given query criteria.
   * The array automatically updates when records are added, updated, or removed.
   *
   * @param typeName - The type name of records to query
   * @param queryCreator - Function that returns the query expression object to match against
   * @param name - Optional name for the query computation (used for debugging)
   * @returns A computed value containing an array of all matching records
   *
   * @example
   * ```ts
   * // Get all books in stock
   * const inStockBooks = store.query.records('book', () => ({ inStock: { eq: true } }))
   * console.log(inStockBooks.get()) // Book[]
   *
   * // Get all books by a specific author
   * const leguinBooks = store.query.records('book', () => ({ authorId: { eq: 'author:leguin' } }))
   *
   * // Get all books (no filter)
   * const allBooks = store.query.records('book')
   * ```
   *
   * @public
   */
  records(typeName, queryCreator = () => ({}), name = "records:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const ids = this.ids(typeName, queryCreator, "ids:" + name);
    return computed(
      name,
      () => {
        return Array.from(ids.get(), (id) => this.recordMap.get(id));
      },
      {
        isEqual: areArraysShallowEqual
      }
    );
  }
  /**
   * Creates a reactive query that returns a set of record IDs matching the given query criteria.
   * This is more efficient than `records()` when you only need the IDs and not the full record objects.
   * The set automatically updates with collection diffs when records change.
   *
   * @param typeName - The type name of records to query
   * @param queryCreator - Function that returns the query expression object to match against
   * @param name - Optional name for the query computation (used for debugging)
   * @returns A computed value containing a set of matching record IDs with collection diffs
   *
   * @example
   * ```ts
   * // Get IDs of all books in stock
   * const inStockBookIds = store.query.ids('book', () => ({ inStock: { eq: true } }))
   * console.log(inStockBookIds.get()) // Set<RecordId<Book>>
   *
   * // Get all book IDs (no filter)
   * const allBookIds = store.query.ids('book')
   *
   * // Use with other queries for efficient lookups
   * const authorBookIds = store.query.ids('book', () => ({ authorId: { eq: 'author:leguin' } }))
   * ```
   *
   * @public
   */
  ids(typeName, queryCreator = () => ({}), name = "ids:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const typeHistory = this.filterHistory(typeName);
    const fromScratch2 = () => {
      typeHistory.get();
      const query = queryCreator();
      if (Object.keys(query).length === 0) {
        return this.getAllIdsForType(typeName);
      }
      return executeQuery(this, typeName, query);
    };
    const fromScratchWithDiff = (prevValue) => {
      const nextValue = fromScratch2();
      const diff = diffSets(prevValue, nextValue);
      if (diff) {
        return withDiff(nextValue, diff);
      } else {
        return prevValue;
      }
    };
    const cachedQuery = computed("ids_query:" + name, queryCreator, {
      isEqual
    });
    return computed(
      "query:" + name,
      (prevValue, lastComputedEpoch) => {
        const query = cachedQuery.get();
        if (isUninitialized(prevValue)) {
          return fromScratch2();
        }
        if (lastComputedEpoch < cachedQuery.lastChangedEpoch) {
          return fromScratchWithDiff(prevValue);
        }
        const history2 = typeHistory.getDiffSince(lastComputedEpoch);
        if (history2 === RESET_VALUE) {
          return fromScratchWithDiff(prevValue);
        }
        const setConstructor = new IncrementalSetConstructor(
          prevValue
        );
        for (const changes of history2) {
          for (const added of objectMapValues(changes.added)) {
            if (added.typeName === typeName && objectMatchesQuery(query, added)) {
              setConstructor.add(added.id);
            }
          }
          for (const [_, updated] of objectMapValues(changes.updated)) {
            if (updated.typeName === typeName) {
              if (objectMatchesQuery(query, updated)) {
                setConstructor.add(updated.id);
              } else {
                setConstructor.remove(updated.id);
              }
            }
          }
          for (const removed of objectMapValues(changes.removed)) {
            if (removed.typeName === typeName) {
              setConstructor.remove(removed.id);
            }
          }
        }
        const result = setConstructor.get();
        if (!result) {
          return prevValue;
        }
        return withDiff(result.value, result.diff);
      },
      { historyLength: 50 }
    );
  }
  /**
   * Executes a one-time query against the current store state and returns matching records.
   * This is a non-reactive query that returns results immediately without creating a computed value.
   * Use this when you need a snapshot of data at a specific point in time.
   *
   * @param typeName - The type name of records to query
   * @param query - The query expression object to match against
   * @returns An array of records that match the query at the current moment
   *
   * @example
   * ```ts
   * // Get current in-stock books (non-reactive)
   * const currentInStockBooks = store.query.exec('book', { inStock: { eq: true } })
   * console.log(currentInStockBooks) // Book[]
   *
   * // Unlike records(), this won't update when the data changes
   * const staticBookList = store.query.exec('book', { authorId: { eq: 'author:leguin' } })
   * ```
   *
   * @public
   */
  exec(typeName, query) {
    const ids = executeQuery(this, typeName, query);
    if (ids.size === 0) {
      return EMPTY_ARRAY;
    }
    return Array.from(ids, (id) => this.recordMap.get(id));
  }
}
class StoreSideEffects {
  /**
   * Creates a new side effects manager for the given store.
   *
   * store - The store instance to manage side effects for
   */
  constructor(store) {
    this.store = store;
  }
  _beforeCreateHandlers = {};
  _afterCreateHandlers = {};
  _beforeChangeHandlers = {};
  _afterChangeHandlers = {};
  _beforeDeleteHandlers = {};
  _afterDeleteHandlers = {};
  _operationCompleteHandlers = [];
  _isEnabled = true;
  /**
   * Checks whether side effects are currently enabled.
   * When disabled, all side effect handlers are bypassed.
   *
   * @returns `true` if side effects are enabled, `false` otherwise
   * @internal
   */
  isEnabled() {
    return this._isEnabled;
  }
  /**
   * Enables or disables side effects processing.
   * When disabled, no side effect handlers will be called.
   *
   * @param enabled - Whether to enable or disable side effects
   * @internal
   */
  setIsEnabled(enabled) {
    this._isEnabled = enabled;
  }
  /**
   * Processes all registered 'before create' handlers for a record.
   * Handlers are called in registration order and can transform the record.
   *
   * @param record - The record about to be created
   * @param source - Whether the change originated from 'user' or 'remote'
   * @returns The potentially modified record to actually create
   * @internal
   */
  handleBeforeCreate(record, source) {
    if (!this._isEnabled) return record;
    const handlers2 = this._beforeCreateHandlers[record.typeName];
    if (handlers2) {
      let r = record;
      for (const handler of handlers2) {
        r = handler(r, source);
      }
      return r;
    }
    return record;
  }
  /**
   * Processes all registered 'after create' handlers for a record.
   * Handlers are called in registration order after the record is created.
   *
   * @param record - The record that was created
   * @param source - Whether the change originated from 'user' or 'remote'
   * @internal
   */
  handleAfterCreate(record, source) {
    if (!this._isEnabled) return;
    const handlers2 = this._afterCreateHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(record, source);
      }
    }
  }
  /**
   * Processes all registered 'before change' handlers for a record.
   * Handlers are called in registration order and can modify or block the change.
   *
   * @param prev - The current version of the record
   * @param next - The proposed new version of the record
   * @param source - Whether the change originated from 'user' or 'remote'
   * @returns The potentially modified record to actually store
   * @internal
   */
  handleBeforeChange(prev, next, source) {
    if (!this._isEnabled) return next;
    const handlers2 = this._beforeChangeHandlers[next.typeName];
    if (handlers2) {
      let r = next;
      for (const handler of handlers2) {
        r = handler(prev, r, source);
      }
      return r;
    }
    return next;
  }
  /**
   * Processes all registered 'after change' handlers for a record.
   * Handlers are called in registration order after the record is updated.
   *
   * @param prev - The previous version of the record
   * @param next - The new version of the record that was stored
   * @param source - Whether the change originated from 'user' or 'remote'
   * @internal
   */
  handleAfterChange(prev, next, source) {
    if (!this._isEnabled) return;
    const handlers2 = this._afterChangeHandlers[next.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(prev, next, source);
      }
    }
  }
  /**
   * Processes all registered 'before delete' handlers for a record.
   * If any handler returns `false`, the deletion is prevented.
   *
   * @param record - The record about to be deleted
   * @param source - Whether the change originated from 'user' or 'remote'
   * @returns `true` to allow deletion, `false` to prevent it
   * @internal
   */
  handleBeforeDelete(record, source) {
    if (!this._isEnabled) return true;
    const handlers2 = this._beforeDeleteHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        if (handler(record, source) === false) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Processes all registered 'after delete' handlers for a record.
   * Handlers are called in registration order after the record is deleted.
   *
   * @param record - The record that was deleted
   * @param source - Whether the change originated from 'user' or 'remote'
   * @internal
   */
  handleAfterDelete(record, source) {
    if (!this._isEnabled) return;
    const handlers2 = this._afterDeleteHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(record, source);
      }
    }
  }
  /**
   * Processes all registered operation complete handlers.
   * Called after an atomic store operation finishes.
   *
   * @param source - Whether the operation originated from 'user' or 'remote'
   * @internal
   */
  handleOperationComplete(source) {
    if (!this._isEnabled) return;
    for (const handler of this._operationCompleteHandlers) {
      handler(source);
    }
  }
  /**
   * Internal helper for registering multiple side effect handlers at once and keeping them organized.
   * This provides a convenient way to register handlers for multiple record types and lifecycle events
   * in a single call, returning a single cleanup function.
   *
   * @param handlersByType - An object mapping record type names to their respective handlers
   * @returns A function that removes all registered handlers when called
   *
   * @example
   * ```ts
   * const cleanup = sideEffects.register({
   *   shape: {
   *     afterDelete: (shape) => console.log('Shape deleted:', shape.id),
   *     beforeChange: (prev, next) => ({ ...next, lastModified: Date.now() })
   *   },
   *   arrow: {
   *     afterCreate: (arrow) => updateConnectedShapes(arrow)
   *   }
   * })
   *
   * // Later, remove all handlers
   * cleanup()
   * ```
   *
   * @internal
   */
  register(handlersByType) {
    const disposes = [];
    for (const [type, handlers2] of Object.entries(handlersByType)) {
      if (handlers2?.beforeCreate) {
        disposes.push(this.registerBeforeCreateHandler(type, handlers2.beforeCreate));
      }
      if (handlers2?.afterCreate) {
        disposes.push(this.registerAfterCreateHandler(type, handlers2.afterCreate));
      }
      if (handlers2?.beforeChange) {
        disposes.push(this.registerBeforeChangeHandler(type, handlers2.beforeChange));
      }
      if (handlers2?.afterChange) {
        disposes.push(this.registerAfterChangeHandler(type, handlers2.afterChange));
      }
      if (handlers2?.beforeDelete) {
        disposes.push(this.registerBeforeDeleteHandler(type, handlers2.beforeDelete));
      }
      if (handlers2?.afterDelete) {
        disposes.push(this.registerAfterDeleteHandler(type, handlers2.afterDelete));
      }
    }
    return () => {
      for (const dispose of disposes) dispose();
    };
  }
  /**
   * Register a handler to be called before a record of a certain type is created. Return a
   * modified record from the handler to change the record that will be created.
   *
   * Use this handle only to modify the creation of the record itself. If you want to trigger a
   * side-effect on a different record (for example, moving one shape when another is created),
   * use {@link StoreSideEffects.registerAfterCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {
   *     // only modify shapes created by the user
   *     if (source !== 'user') return shape
   *
   *     //by default, arrow shapes have no label. Let's make sure they always have a label.
   *     if (shape.type === 'arrow') {
   *         return {...shape, props: {...shape.props, text: 'an arrow'}}
   *     }
   *
   *     // other shapes get returned unmodified
   *     return shape
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeCreateHandler(typeName, handler) {
    const handlers2 = this._beforeCreateHandlers[typeName];
    if (!handlers2) this._beforeCreateHandlers[typeName] = [];
    this._beforeCreateHandlers[typeName].push(handler);
    return () => remove(this._beforeCreateHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is created. This is useful for side-effects
   * that would update _other_ records. If you want to modify the record being created use
   * {@link StoreSideEffects.registerBeforeCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterCreateHandler('page', (page, source) => {
   *     // Automatically create a shape when a page is created
   *     editor.createShape<TLTextShape>({
   *         id: createShapeId(),
   *         type: 'text',
   *         props: { richText: toRichText(page.name) },
   *     })
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterCreateHandler(typeName, handler) {
    const handlers2 = this._afterCreateHandlers[typeName];
    if (!handlers2) this._afterCreateHandlers[typeName] = [];
    this._afterCreateHandlers[typeName].push(handler);
    return () => remove(this._afterCreateHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called before a record is changed. The handler is given the old and
   * new record - you can return a modified record to apply a different update, or the old record
   * to block the update entirely.
   *
   * Use this handler only for intercepting updates to the record itself. If you want to update
   * other records in response to a change, use
   * {@link StoreSideEffects.registerAfterChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {
   *     if (next.isLocked && !prev.isLocked) {
   *         // prevent shapes from ever being locked:
   *         return prev
   *     }
   *     // other types of change are allowed
   *     return next
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeChangeHandler(typeName, handler) {
    const handlers2 = this._beforeChangeHandlers[typeName];
    if (!handlers2) this._beforeChangeHandlers[typeName] = [];
    this._beforeChangeHandlers[typeName].push(handler);
    return () => remove(this._beforeChangeHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is changed. This is useful for side-effects
   * that would update _other_ records - if you want to modify the record being changed, use
   * {@link StoreSideEffects.registerBeforeChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {
   *     if (next.props.color === 'red') {
   *         // there can only be one red shape at a time:
   *         const otherRedShapes = editor.getCurrentPageShapes().filter(s => s.props.color === 'red' && s.id !== next.id)
   *         editor.updateShapes(otherRedShapes.map(s => ({...s, props: {...s.props, color: 'blue'}})))
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterChangeHandler(typeName, handler) {
    const handlers2 = this._afterChangeHandlers[typeName];
    if (!handlers2) this._afterChangeHandlers[typeName] = [];
    this._afterChangeHandlers[typeName].push(handler);
    return () => remove(this._afterChangeHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called before a record is deleted. The handler can return `false` to
   * prevent the deletion.
   *
   * Use this handler only for intercepting deletions of the record itself. If you want to do
   * something to other records in response to a deletion, use
   * {@link StoreSideEffects.registerAfterDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {
   *     if (shape.props.color === 'red') {
   *         // prevent red shapes from being deleted
   * 	       return false
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeDeleteHandler(typeName, handler) {
    const handlers2 = this._beforeDeleteHandlers[typeName];
    if (!handlers2) this._beforeDeleteHandlers[typeName] = [];
    this._beforeDeleteHandlers[typeName].push(handler);
    return () => remove(this._beforeDeleteHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is deleted. This is useful for side-effects
   * that would update _other_ records - if you want to block the deletion of the record itself,
   * use {@link StoreSideEffects.registerBeforeDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {
   *     // if the last shape in a frame is deleted, delete the frame too:
   *     const parentFrame = editor.getShape(shape.parentId)
   *     if (!parentFrame || parentFrame.type !== 'frame') return
   *
   *     const siblings = editor.getSortedChildIdsForParent(parentFrame)
   *     if (siblings.length === 0) {
   *         editor.deleteShape(parentFrame.id)
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterDeleteHandler(typeName, handler) {
    const handlers2 = this._afterDeleteHandlers[typeName];
    if (!handlers2) this._afterDeleteHandlers[typeName] = [];
    this._afterDeleteHandlers[typeName].push(handler);
    return () => remove(this._afterDeleteHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called when a store completes an atomic operation.
   *
   * @example
   * ```ts
   * let count = 0
   *
   * editor.sideEffects.registerOperationCompleteHandler(() => count++)
   *
   * editor.selectAll()
   * expect(count).toBe(1)
   *
   * editor.store.atomic(() => {
   *	editor.selectNone()
   * 	editor.selectAll()
   * })
   *
   * expect(count).toBe(2)
   * ```
   *
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   *
   * @public
   */
  registerOperationCompleteHandler(handler) {
    this._operationCompleteHandlers.push(handler);
    return () => remove(this._operationCompleteHandlers, handler);
  }
}
function remove(array2, item) {
  const index2 = array2.indexOf(item);
  if (index2 >= 0) {
    array2.splice(index2, 1);
  }
}
class Store {
  /**
   * The unique identifier of the store instance.
   *
   * @public
   */
  id;
  /**
   * An AtomMap containing the stores records.
   *
   * @internal
   * @readonly
   */
  records;
  /**
   * An atom containing the store's history.
   *
   * @public
   * @readonly
   */
  history = atom("history", 0, {
    historyLength: 1e3
  });
  /**
   * Reactive queries and indexes for efficiently accessing store data.
   * Provides methods for filtering, indexing, and subscribing to subsets of records.
   *
   * @example
   * ```ts
   * // Create an index by a property
   * const booksByAuthor = store.query.index('book', 'author')
   *
   * // Get records matching criteria
   * const inStockBooks = store.query.records('book', () => ({
   *   inStock: { eq: true }
   * }))
   * ```
   *
   * @public
   * @readonly
   */
  query;
  /**
   * A set containing listeners that have been added to this store.
   *
   * @internal
   */
  listeners = /* @__PURE__ */ new Set();
  /**
   * An array of history entries that have not yet been flushed.
   *
   * @internal
   */
  historyAccumulator = new HistoryAccumulator();
  /**
   * A reactor that responds to changes to the history by squashing the accumulated history and
   * notifying listeners of the changes.
   *
   * @internal
   */
  historyReactor;
  /**
   * Function to dispose of any in-flight timeouts.
   *
   * @internal
   */
  cancelHistoryReactor() {
  }
  /**
   * The schema that defines the structure and validation rules for records in this store.
   *
   * @public
   */
  schema;
  /**
   * Custom properties associated with this store instance.
   *
   * @public
   */
  props;
  /**
   * A mapping of record scopes to the set of record type names that belong to each scope.
   * Used to filter records by their persistence and synchronization behavior.
   *
   * @public
   */
  scopedTypes;
  /**
   * Side effects manager that handles lifecycle events for record operations.
   * Allows registration of callbacks for create, update, delete, and validation events.
   *
   * @example
   * ```ts
   * store.sideEffects.registerAfterCreateHandler('book', (book) => {
   *   console.log('Book created:', book.title)
   * })
   * ```
   *
   * @public
   */
  sideEffects = new StoreSideEffects(this);
  /**
   * Creates a new Store instance.
   *
   * @example
   * ```ts
   * const store = new Store({
   *   schema: StoreSchema.create({ book: Book }),
   *   props: { appName: 'MyLibrary' },
   *   initialData: savedData
   * })
   * ```
   *
   * @param config - Configuration object for the store
   */
  constructor(config) {
    const { initialData, schema, id } = config;
    this.id = id ?? uniqueId();
    this.schema = schema;
    this.props = config.props;
    if (initialData) {
      this.records = new AtomMap(
        "store",
        objectMapEntries(initialData).map(([id2, record]) => [
          id2,
          devFreeze(this.schema.validateRecord(this, record, "initialize", null))
        ])
      );
    } else {
      this.records = new AtomMap("store");
    }
    this.query = new StoreQueries(this.records, this.history);
    this.historyReactor = reactor(
      "Store.historyReactor",
      () => {
        this.history.get();
        this._flushHistory();
      },
      { scheduleEffect: (cb) => this.cancelHistoryReactor = throttleToNextFrame$1(cb) }
    );
    this.scopedTypes = {
      document: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "document").map((t2) => t2.typeName)
      ),
      session: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "session").map((t2) => t2.typeName)
      ),
      presence: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "presence").map((t2) => t2.typeName)
      )
    };
  }
  _flushHistory() {
    if (this.historyAccumulator.hasChanges()) {
      const entries = this.historyAccumulator.flush();
      for (const { changes, source } of entries) {
        let instanceChanges = null;
        let documentChanges = null;
        let presenceChanges = null;
        for (const { onHistory, filters } of this.listeners) {
          if (filters.source !== "all" && filters.source !== source) {
            continue;
          }
          if (filters.scope !== "all") {
            if (filters.scope === "document") {
              documentChanges ??= this.filterChangesByScope(changes, "document");
              if (!documentChanges) continue;
              onHistory({ changes: documentChanges, source });
            } else if (filters.scope === "session") {
              instanceChanges ??= this.filterChangesByScope(changes, "session");
              if (!instanceChanges) continue;
              onHistory({ changes: instanceChanges, source });
            } else {
              presenceChanges ??= this.filterChangesByScope(changes, "presence");
              if (!presenceChanges) continue;
              onHistory({ changes: presenceChanges, source });
            }
          } else {
            onHistory({ changes, source });
          }
        }
      }
    }
  }
  dispose() {
    this.cancelHistoryReactor();
  }
  /**
   * Filters out non-document changes from a diff. Returns null if there are no changes left.
   * @param change - the records diff
   * @param scope - the records scope
   * @returns
   */
  filterChangesByScope(change, scope) {
    const result = {
      added: filterEntries(change.added, (_, r) => this.scopedTypes[scope].has(r.typeName)),
      updated: filterEntries(change.updated, (_, r) => this.scopedTypes[scope].has(r[1].typeName)),
      removed: filterEntries(change.removed, (_, r) => this.scopedTypes[scope].has(r.typeName))
    };
    if (Object.keys(result.added).length === 0 && Object.keys(result.updated).length === 0 && Object.keys(result.removed).length === 0) {
      return null;
    }
    return result;
  }
  /**
   * Update the history with a diff of changes.
   *
   * @param changes - The changes to add to the history.
   */
  updateHistory(changes) {
    this.historyAccumulator.add({
      changes,
      source: this.isMergingRemoteChanges ? "remote" : "user"
    });
    if (this.listeners.size === 0) {
      this.historyAccumulator.clear();
    }
    this.history.set(this.history.get() + 1, changes);
  }
  validate(phase) {
    this.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null));
  }
  /**
   * Add or update records in the store. If a record with the same ID already exists, it will be updated.
   * Otherwise, a new record will be created.
   *
   * @example
   * ```ts
   * // Add new records
   * const book = Book.create({ title: 'Lathe Of Heaven', author: 'Le Guin' })
   * store.put([book])
   *
   * // Update existing record
   * store.put([{ ...book, title: 'The Lathe of Heaven' }])
   * ```
   *
   * @param records - The records to add or update
   * @param phaseOverride - Override the validation phase (used internally)
   * @public
   */
  put(records, phaseOverride) {
    this.atomic(() => {
      const updates = {};
      const additions = {};
      let record;
      let didChange = false;
      const source = this.isMergingRemoteChanges ? "remote" : "user";
      for (let i = 0, n = records.length; i < n; i++) {
        record = records[i];
        const initialValue = this.records.__unsafe__getWithoutCapture(record.id);
        if (initialValue) {
          record = this.sideEffects.handleBeforeChange(initialValue, record, source);
          const validated = this.schema.validateRecord(
            this,
            record,
            phaseOverride ?? "updateRecord",
            initialValue
          );
          if (validated === initialValue) continue;
          record = devFreeze(record);
          this.records.set(record.id, record);
          didChange = true;
          updates[record.id] = [initialValue, record];
          this.addDiffForAfterEvent(initialValue, record);
        } else {
          record = this.sideEffects.handleBeforeCreate(record, source);
          didChange = true;
          record = this.schema.validateRecord(
            this,
            record,
            phaseOverride ?? "createRecord",
            null
          );
          record = devFreeze(record);
          additions[record.id] = record;
          this.addDiffForAfterEvent(null, record);
          this.records.set(record.id, record);
        }
      }
      if (!didChange) return;
      this.updateHistory({
        added: additions,
        updated: updates,
        removed: {}
      });
    });
  }
  /**
   * Remove records from the store by their IDs.
   *
   * @example
   * ```ts
   * // Remove a single record
   * store.remove([book.id])
   *
   * // Remove multiple records
   * store.remove([book1.id, book2.id, book3.id])
   * ```
   *
   * @param ids - The IDs of the records to remove
   * @public
   */
  remove(ids) {
    this.atomic(() => {
      const toDelete = new Set(ids);
      const source = this.isMergingRemoteChanges ? "remote" : "user";
      if (this.sideEffects.isEnabled()) {
        for (const id of ids) {
          const record = this.records.__unsafe__getWithoutCapture(id);
          if (!record) continue;
          if (this.sideEffects.handleBeforeDelete(record, source) === false) {
            toDelete.delete(id);
          }
        }
      }
      const actuallyDeleted = this.records.deleteMany(toDelete);
      if (actuallyDeleted.length === 0) return;
      const removed = {};
      for (const [id, record] of actuallyDeleted) {
        removed[id] = record;
        this.addDiffForAfterEvent(record, null);
      }
      this.updateHistory({ added: {}, updated: {}, removed });
    });
  }
  /**
   * Get a record by its ID. This creates a reactive subscription to the record.
   *
   * @example
   * ```ts
   * const book = store.get(bookId)
   * if (book) {
   *   console.log(book.title)
   * }
   * ```
   *
   * @param id - The ID of the record to get
   * @returns The record if it exists, undefined otherwise
   * @public
   */
  get(id) {
    return this.records.get(id);
  }
  /**
   * Get a record by its ID without creating a reactive subscription.
   * Use this when you need to access a record but don't want reactive updates.
   *
   * @example
   * ```ts
   * // Won't trigger reactive updates when this record changes
   * const book = store.unsafeGetWithoutCapture(bookId)
   * ```
   *
   * @param id - The ID of the record to get
   * @returns The record if it exists, undefined otherwise
   * @public
   */
  unsafeGetWithoutCapture(id) {
    return this.records.__unsafe__getWithoutCapture(id);
  }
  /**
   * Serialize the store's records to a plain JavaScript object.
   * Only includes records matching the specified scope.
   *
   * @example
   * ```ts
   * // Serialize only document records (default)
   * const documentData = store.serialize('document')
   *
   * // Serialize all records
   * const allData = store.serialize('all')
   * ```
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'
   * @returns The serialized store data
   * @public
   */
  serialize(scope = "document") {
    const result = {};
    for (const [id, record] of this.records) {
      if (scope === "all" || this.scopedTypes[scope].has(record.typeName)) {
        result[id] = record;
      }
    }
    return result;
  }
  /**
   * Get a serialized snapshot of the store and its schema.
   * This includes both the data and schema information needed for proper migration.
   *
   * @example
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * localStorage.setItem('myApp', JSON.stringify(snapshot))
   *
   * // Later...
   * const saved = JSON.parse(localStorage.getItem('myApp'))
   * store.loadStoreSnapshot(saved)
   * ```
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'
   * @returns A snapshot containing both store data and schema information
   * @public
   */
  getStoreSnapshot(scope = "document") {
    return {
      store: this.serialize(scope),
      schema: this.schema.serialize()
    };
  }
  /**
   * Migrate a serialized snapshot to the current schema version.
   * This applies any necessary migrations to bring old data up to date.
   *
   * @example
   * ```ts
   * const oldSnapshot = JSON.parse(localStorage.getItem('myApp'))
   * const migratedSnapshot = store.migrateSnapshot(oldSnapshot)
   * ```
   *
   * @param snapshot - The snapshot to migrate
   * @returns The migrated snapshot with current schema version
   * @throws Error if migration fails
   * @public
   */
  migrateSnapshot(snapshot) {
    const migrationResult = this.schema.migrateStoreSnapshot(snapshot);
    if (migrationResult.type === "error") {
      throw new Error(`Failed to migrate snapshot: ${migrationResult.reason}`);
    }
    return {
      store: migrationResult.value,
      schema: this.schema.serialize()
    };
  }
  /**
   * Load a serialized snapshot into the store, replacing all current data.
   * The snapshot will be automatically migrated to the current schema version if needed.
   *
   * @example
   * ```ts
   * const snapshot = JSON.parse(localStorage.getItem('myApp'))
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load
   * @throws Error if migration fails or snapshot is invalid
   * @public
   */
  loadStoreSnapshot(snapshot) {
    const migrationResult = this.schema.migrateStoreSnapshot(snapshot);
    if (migrationResult.type === "error") {
      throw new Error(`Failed to migrate snapshot: ${migrationResult.reason}`);
    }
    const prevSideEffectsEnabled = this.sideEffects.isEnabled();
    try {
      this.sideEffects.setIsEnabled(false);
      this.atomic(() => {
        this.clear();
        this.put(Object.values(migrationResult.value));
        this.ensureStoreIsUsable();
      });
    } finally {
      this.sideEffects.setIsEnabled(prevSideEffectsEnabled);
    }
  }
  /**
   * Get an array of all records in the store.
   *
   * @example
   * ```ts
   * const allRecords = store.allRecords()
   * const books = allRecords.filter(r => r.typeName === 'book')
   * ```
   *
   * @returns An array containing all records in the store
   * @public
   */
  allRecords() {
    return Array.from(this.records.values());
  }
  /**
   * Remove all records from the store.
   *
   * @example
   * ```ts
   * store.clear()
   * console.log(store.allRecords().length) // 0
   * ```
   *
   * @public
   */
  clear() {
    this.remove(Array.from(this.records.keys()));
  }
  /**
   * Update a single record using an updater function. To update multiple records at once,
   * use the `update` method of the `TypedStore` class.
   *
   * @example
   * ```ts
   * store.update(book.id, (book) => ({
   *   ...book,
   *   title: 'Updated Title'
   * }))
   * ```
   *
   * @param id - The ID of the record to update
   * @param updater - A function that receives the current record and returns the updated record
   * @public
   */
  update(id, updater) {
    const existing = this.unsafeGetWithoutCapture(id);
    if (!existing) {
      console.error(`Record ${id} not found. This is probably an error`);
      return;
    }
    this.put([updater(existing)]);
  }
  /**
   * Check whether a record with the given ID exists in the store.
   *
   * @example
   * ```ts
   * if (store.has(bookId)) {
   *   console.log('Book exists!')
   * }
   * ```
   *
   * @param id - The ID of the record to check
   * @returns True if the record exists, false otherwise
   * @public
   */
  has(id) {
    return this.records.has(id);
  }
  /**
   * Add a listener that will be called when the store changes.
   * Returns a function to remove the listener.
   *
   * @example
   * ```ts
   * const removeListener = store.listen((entry) => {
   *   console.log('Changes:', entry.changes)
   *   console.log('Source:', entry.source)
   * })
   *
   * // Listen only to user changes to document records
   * const removeDocumentListener = store.listen(
   *   (entry) => console.log('Document changed:', entry),
   *   { source: 'user', scope: 'document' }
   * )
   *
   * // Later, remove the listener
   * removeListener()
   * ```
   *
   * @param onHistory - The listener function to call when changes occur
   * @param filters - Optional filters to control when the listener is called
   * @returns A function that removes the listener when called
   * @public
   */
  listen(onHistory, filters) {
    this._flushHistory();
    const listener = {
      onHistory,
      filters: {
        source: filters?.source ?? "all",
        scope: filters?.scope ?? "all"
      }
    };
    if (!this.historyReactor.scheduler.isActivelyListening) {
      this.historyReactor.start();
      this.historyReactor.scheduler.execute();
    }
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
      if (this.listeners.size === 0) {
        this.historyReactor.stop();
      }
    };
  }
  isMergingRemoteChanges = false;
  /**
   * Merge changes from a remote source. Changes made within the provided function
   * will be marked with source 'remote' instead of 'user'.
   *
   * @example
   * ```ts
   * // Changes from sync/collaboration
   * store.mergeRemoteChanges(() => {
   *   store.put(remoteRecords)
   *   store.remove(deletedIds)
   * })
   * ```
   *
   * @param fn - A function that applies the remote changes
   * @public
   */
  mergeRemoteChanges(fn) {
    if (this.isMergingRemoteChanges) {
      return fn();
    }
    if (this._isInAtomicOp) {
      throw new Error("Cannot merge remote changes while in atomic operation");
    }
    try {
      this.atomic(fn, true, true);
    } finally {
      this.ensureStoreIsUsable();
    }
  }
  /**
   * Run `fn` and return a {@link RecordsDiff} of the changes that occurred as a result.
   */
  extractingChanges(fn) {
    const changes = [];
    const dispose = this.historyAccumulator.addInterceptor((entry2) => changes.push(entry2.changes));
    try {
      transact(fn);
      return squashRecordDiffs(changes);
    } finally {
      dispose();
    }
  }
  applyDiff(diff, {
    runCallbacks = true,
    ignoreEphemeralKeys = false
  } = {}) {
    this.atomic(() => {
      const toPut = objectMapValues(diff.added);
      for (const [_from, to] of objectMapValues(diff.updated)) {
        const type = this.schema.getType(to.typeName);
        if (ignoreEphemeralKeys && type.ephemeralKeySet.size) {
          const existing = this.get(to.id);
          if (!existing) {
            toPut.push(to);
            continue;
          }
          let changed = null;
          for (const [key, value] of Object.entries(to)) {
            if (type.ephemeralKeySet.has(key) || Object.is(value, getOwnProperty(existing, key))) {
              continue;
            }
            if (!changed) changed = { ...existing };
            changed[key] = value;
          }
          if (changed) toPut.push(changed);
        } else {
          toPut.push(to);
        }
      }
      const toRemove = objectMapKeys(diff.removed);
      if (toPut.length) {
        this.put(toPut);
      }
      if (toRemove.length) {
        this.remove(toRemove);
      }
    }, runCallbacks);
  }
  /**
   * Create a cache based on values in the store. Pass in a function that takes and ID and a
   * signal for the underlying record. Return a signal (usually a computed) for the cached value.
   * For simple derivations, use {@link Store.createComputedCache}. This function is useful if you
   * need more precise control over intermediate values.
   */
  createCache(create) {
    const cache = new WeakCache();
    return {
      get: (id) => {
        const atom2 = this.records.getAtom(id);
        if (!atom2) return void 0;
        return cache.get(atom2, () => create(id, atom2)).get();
      }
    };
  }
  /**
   * Create a computed cache.
   *
   * @param name - The name of the derivation cache.
   * @param derive - A function used to derive the value of the cache.
   * @param opts - Options for the computed cache.
   * @public
   */
  createComputedCache(name, derive, opts) {
    return this.createCache((id, record) => {
      const recordSignal = opts?.areRecordsEqual ? computed(`${name}:${id}:isEqual`, () => record.get(), { isEqual: opts.areRecordsEqual }) : record;
      return computed(
        name + ":" + id,
        () => {
          return derive(recordSignal.get());
        },
        {
          isEqual: opts?.areResultsEqual
        }
      );
    });
  }
  _integrityChecker;
  /** @internal */
  ensureStoreIsUsable() {
    this.atomic(() => {
      this._integrityChecker ??= this.schema.createIntegrityChecker(this);
      this._integrityChecker?.();
    });
  }
  _isPossiblyCorrupted = false;
  /** @internal */
  markAsPossiblyCorrupted() {
    this._isPossiblyCorrupted = true;
  }
  /** @internal */
  isPossiblyCorrupted() {
    return this._isPossiblyCorrupted;
  }
  pendingAfterEvents = null;
  addDiffForAfterEvent(before, after) {
    assert(this.pendingAfterEvents, "must be in event operation");
    if (before === after) return;
    if (before && after) assert(before.id === after.id);
    if (!before && !after) return;
    const id = (before || after).id;
    const existing = this.pendingAfterEvents.get(id);
    if (existing) {
      existing.after = after;
    } else {
      this.pendingAfterEvents.set(id, { before, after });
    }
  }
  flushAtomicCallbacks(isMergingRemoteChanges) {
    let updateDepth = 0;
    let source = isMergingRemoteChanges ? "remote" : "user";
    while (this.pendingAfterEvents) {
      const events = this.pendingAfterEvents;
      this.pendingAfterEvents = null;
      if (!this.sideEffects.isEnabled()) continue;
      updateDepth++;
      if (updateDepth > 100) {
        throw new Error("Maximum store update depth exceeded, bailing out");
      }
      for (const { before, after } of events.values()) {
        if (before && after && before !== after && !isEqual(before, after)) {
          this.sideEffects.handleAfterChange(before, after, source);
        } else if (before && !after) {
          this.sideEffects.handleAfterDelete(before, source);
        } else if (!before && after) {
          this.sideEffects.handleAfterCreate(after, source);
        }
      }
      if (!this.pendingAfterEvents) {
        this.sideEffects.handleOperationComplete(source);
      } else {
        source = "user";
      }
    }
  }
  _isInAtomicOp = false;
  /** @internal */
  atomic(fn, runCallbacks = true, isMergingRemoteChanges = false) {
    return transact(() => {
      if (this._isInAtomicOp) {
        if (!this.pendingAfterEvents) this.pendingAfterEvents = /* @__PURE__ */ new Map();
        const prevSideEffectsEnabled2 = this.sideEffects.isEnabled();
        assert(!isMergingRemoteChanges, "cannot call mergeRemoteChanges while in atomic operation");
        try {
          if (prevSideEffectsEnabled2 && !runCallbacks) {
            this.sideEffects.setIsEnabled(false);
          }
          return fn();
        } finally {
          this.sideEffects.setIsEnabled(prevSideEffectsEnabled2);
        }
      }
      this.pendingAfterEvents = /* @__PURE__ */ new Map();
      const prevSideEffectsEnabled = this.sideEffects.isEnabled();
      this.sideEffects.setIsEnabled(runCallbacks ?? prevSideEffectsEnabled);
      this._isInAtomicOp = true;
      if (isMergingRemoteChanges) {
        this.isMergingRemoteChanges = true;
      }
      try {
        const result = fn();
        this.isMergingRemoteChanges = false;
        this.flushAtomicCallbacks(isMergingRemoteChanges);
        return result;
      } finally {
        this.pendingAfterEvents = null;
        this.sideEffects.setIsEnabled(prevSideEffectsEnabled);
        this._isInAtomicOp = false;
        this.isMergingRemoteChanges = false;
      }
    });
  }
  /** @internal */
  addHistoryInterceptor(fn) {
    return this.historyAccumulator.addInterceptor(
      (entry2) => fn(entry2, this.isMergingRemoteChanges ? "remote" : "user")
    );
  }
}
function squashHistoryEntries(entries) {
  if (entries.length === 0) return [];
  const chunked = [];
  let chunk = [entries[0]];
  let entry2;
  for (let i = 1, n = entries.length; i < n; i++) {
    entry2 = entries[i];
    if (chunk[0].source !== entry2.source) {
      chunked.push(chunk);
      chunk = [];
    }
    chunk.push(entry2);
  }
  chunked.push(chunk);
  return devFreeze(
    chunked.map((chunk2) => ({
      source: chunk2[0].source,
      changes: squashRecordDiffs(chunk2.map((e) => e.changes))
    }))
  );
}
class HistoryAccumulator {
  _history = [];
  _interceptors = /* @__PURE__ */ new Set();
  /**
   * Add an interceptor that will be called for each history entry.
   * Returns a function to remove the interceptor.
   */
  addInterceptor(fn) {
    this._interceptors.add(fn);
    return () => {
      this._interceptors.delete(fn);
    };
  }
  /**
   * Add a history entry to the accumulator.
   * Calls all registered interceptors with the entry.
   */
  add(entry2) {
    this._history.push(entry2);
    for (const interceptor of this._interceptors) {
      interceptor(entry2);
    }
  }
  /**
   * Flush all accumulated history entries, squashing adjacent entries from the same source.
   * Clears the internal history buffer.
   */
  flush() {
    const history2 = squashHistoryEntries(this._history);
    this._history = [];
    return history2;
  }
  /**
   * Clear all accumulated history entries without flushing.
   */
  clear() {
    this._history = [];
  }
  /**
   * Check if there are any accumulated history entries.
   */
  hasChanges() {
    return this._history.length > 0;
  }
}
function createComputedCache(name, derive, opts) {
  const cache = new WeakCache();
  return {
    get(context, id) {
      const computedCache = cache.get(context, () => {
        const store = context instanceof Store ? context : context.store;
        return store.createComputedCache(name, (record) => derive(context, record), opts);
      });
      return computedCache.get(id);
    }
  };
}
function upgradeSchema(schema) {
  if (schema.schemaVersion > 2 || schema.schemaVersion < 1) return Result.err("Bad schema version");
  if (schema.schemaVersion === 2) return Result.ok(schema);
  const result = {
    schemaVersion: 2,
    sequences: {
      "com.tldraw.store": schema.storeVersion
    }
  };
  for (const [typeName, recordVersion] of Object.entries(schema.recordVersions)) {
    result.sequences[`com.tldraw.${typeName}`] = recordVersion.version;
    if ("subTypeKey" in recordVersion) {
      for (const [subType, version2] of Object.entries(recordVersion.subTypeVersions)) {
        result.sequences[`com.tldraw.${typeName}.${subType}`] = version2;
      }
    }
  }
  return Result.ok(result);
}
class StoreSchema {
  constructor(types, options) {
    this.types = types;
    this.options = options;
    for (const m of options.migrations ?? []) {
      assert(!this.migrations[m.sequenceId], `Duplicate migration sequenceId ${m.sequenceId}`);
      validateMigrations(m);
      this.migrations[m.sequenceId] = m;
    }
    const allMigrations = Object.values(this.migrations).flatMap((m) => m.sequence);
    this.sortedMigrations = sortMigrations(allMigrations);
    for (const migration of this.sortedMigrations) {
      if (!migration.dependsOn?.length) continue;
      for (const dep of migration.dependsOn) {
        const depMigration = allMigrations.find((m) => m.id === dep);
        assert(depMigration, `Migration '${migration.id}' depends on missing migration '${dep}'`);
      }
    }
  }
  /**
   * Creates a new StoreSchema with the given record types and options.
   *
   * This static factory method is the recommended way to create a StoreSchema.
   * It ensures type safety while providing a clean API for schema definition.
   *
   * @param types - Object mapping type names to their RecordType definitions
   * @param options - Optional configuration for migrations, validation, and integrity checking
   * @returns A new StoreSchema instance
   *
   * @example
   * ```ts
   * const Book = createRecordType<Book>('book', { scope: 'document' })
   * const Author = createRecordType<Author>('author', { scope: 'document' })
   *
   * const schema = StoreSchema.create(
   *   {
   *     book: Book,
   *     author: Author
   *   },
   *   {
   *     migrations: [bookMigrations],
   *     onValidationFailure: (failure) => failure.record
   *   }
   * )
   * ```
   *
   * @public
   */
  static create(types, options) {
    return new StoreSchema(types, options ?? {});
  }
  migrations = {};
  sortedMigrations;
  migrationCache = /* @__PURE__ */ new WeakMap();
  /**
   * Validates a record using its corresponding RecordType validator.
   *
   * This method ensures that records conform to their type definitions before
   * being stored. If validation fails and an onValidationFailure handler is
   * provided, it will be called to potentially recover from the error.
   *
   * @param store - The store instance where validation is occurring
   * @param record - The record to validate
   * @param phase - The lifecycle phase where validation is happening
   * @param recordBefore - The previous version of the record (for updates)
   * @returns The validated record, potentially modified by validation failure handler
   *
   * @example
   * ```ts
   * try {
   *   const validatedBook = schema.validateRecord(
   *     store,
   *     { id: 'book:1', typeName: 'book', title: '', author: 'Jane Doe' },
   *     'createRecord',
   *     null
   *   )
   * } catch (error) {
   *   console.error('Record validation failed:', error)
   * }
   * ```
   *
   * @public
   */
  validateRecord(store, record, phase, recordBefore) {
    try {
      const recordType = getOwnProperty(this.types, record.typeName);
      if (!recordType) {
        throw new Error(`Missing definition for record type ${record.typeName}`);
      }
      return recordType.validate(record, recordBefore ?? void 0);
    } catch (error) {
      if (this.options.onValidationFailure) {
        return this.options.onValidationFailure({
          store,
          record,
          phase,
          recordBefore,
          error
        });
      } else {
        throw error;
      }
    }
  }
  /**
   * Gets all migrations that need to be applied to upgrade from a persisted schema
   * to the current schema version.
   *
   * This method compares the persisted schema with the current schema and determines
   * which migrations need to be applied to bring the data up to date. It handles
   * both regular migrations and retroactive migrations, and caches results for
   * performance.
   *
   * @param persistedSchema - The schema version that was previously persisted
   * @returns A Result containing the list of migrations to apply, or an error message
   *
   * @example
   * ```ts
   * const persistedSchema = {
   *   schemaVersion: 2,
   *   sequences: { 'com.tldraw.book': 1, 'com.tldraw.author': 0 }
   * }
   *
   * const migrationsResult = schema.getMigrationsSince(persistedSchema)
   * if (migrationsResult.ok) {
   *   console.log('Migrations to apply:', migrationsResult.value.length)
   *   // Apply each migration to bring data up to date
   * }
   * ```
   *
   * @public
   */
  getMigrationsSince(persistedSchema) {
    const cached = this.migrationCache.get(persistedSchema);
    if (cached) {
      return cached;
    }
    const upgradeResult = upgradeSchema(persistedSchema);
    if (!upgradeResult.ok) {
      this.migrationCache.set(persistedSchema, upgradeResult);
      return upgradeResult;
    }
    const schema = upgradeResult.value;
    const sequenceIdsToInclude = new Set(
      // start with any shared sequences
      Object.keys(schema.sequences).filter((sequenceId) => this.migrations[sequenceId])
    );
    for (const sequenceId in this.migrations) {
      if (schema.sequences[sequenceId] === void 0 && this.migrations[sequenceId].retroactive) {
        sequenceIdsToInclude.add(sequenceId);
      }
    }
    if (sequenceIdsToInclude.size === 0) {
      const result2 = Result.ok([]);
      this.migrationCache.set(persistedSchema, result2);
      return result2;
    }
    const allMigrationsToInclude = /* @__PURE__ */ new Set();
    for (const sequenceId of sequenceIdsToInclude) {
      const theirVersion = schema.sequences[sequenceId];
      if (typeof theirVersion !== "number" && this.migrations[sequenceId].retroactive || theirVersion === 0) {
        for (const migration of this.migrations[sequenceId].sequence) {
          allMigrationsToInclude.add(migration.id);
        }
        continue;
      }
      const theirVersionId = `${sequenceId}/${theirVersion}`;
      const idx = this.migrations[sequenceId].sequence.findIndex((m) => m.id === theirVersionId);
      if (idx === -1) {
        const result2 = Result.err("Incompatible schema?");
        this.migrationCache.set(persistedSchema, result2);
        return result2;
      }
      for (const migration of this.migrations[sequenceId].sequence.slice(idx + 1)) {
        allMigrationsToInclude.add(migration.id);
      }
    }
    const result = Result.ok(
      this.sortedMigrations.filter(({ id }) => allMigrationsToInclude.has(id))
    );
    this.migrationCache.set(persistedSchema, result);
    return result;
  }
  /**
   * Migrates a single persisted record to match the current schema version.
   *
   * This method applies the necessary migrations to transform a record from an
   * older (or newer) schema version to the current version. It supports both
   * forward ('up') and backward ('down') migrations.
   *
   * @param record - The record to migrate
   * @param persistedSchema - The schema version the record was persisted with
   * @param direction - Direction to migrate ('up' for newer, 'down' for older)
   * @returns A MigrationResult containing the migrated record or an error
   *
   * @example
   * ```ts
   * const oldRecord = { id: 'book:1', typeName: 'book', title: 'Old Title', publishDate: '2020-01-01' }
   * const oldSchema = { schemaVersion: 2, sequences: { 'com.tldraw.book': 1 } }
   *
   * const result = schema.migratePersistedRecord(oldRecord, oldSchema, 'up')
   * if (result.type === 'success') {
   *   console.log('Migrated record:', result.value)
   *   // Record now has publishedYear instead of publishDate
   * } else {
   *   console.error('Migration failed:', result.reason)
   * }
   * ```
   *
   * @public
   */
  migratePersistedRecord(record, persistedSchema, direction = "up") {
    const migrations = this.getMigrationsSince(persistedSchema);
    if (!migrations.ok) {
      console.error("Error migrating record", migrations.error);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    let migrationsToApply = migrations.value;
    if (migrationsToApply.length === 0) {
      return { type: "success", value: record };
    }
    if (migrationsToApply.some((m) => m.scope === "store")) {
      return {
        type: "error",
        reason: direction === "down" ? MigrationFailureReason.TargetVersionTooOld : MigrationFailureReason.TargetVersionTooNew
      };
    }
    if (direction === "down") {
      if (!migrationsToApply.every((m) => m.down)) {
        return {
          type: "error",
          reason: MigrationFailureReason.TargetVersionTooOld
        };
      }
      migrationsToApply = migrationsToApply.slice().reverse();
    }
    record = structuredClone(record);
    try {
      for (const migration of migrationsToApply) {
        if (migration.scope === "store") throw new Error(
          /* won't happen, just for TS */
        );
        const shouldApply = migration.filter ? migration.filter(record) : true;
        if (!shouldApply) continue;
        const result = migration[direction](record);
        if (result) {
          record = structuredClone(result);
        }
      }
    } catch (e) {
      console.error("Error migrating record", e);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    return { type: "success", value: record };
  }
  /**
   * Migrates an entire store snapshot to match the current schema version.
   *
   * This method applies all necessary migrations to bring a persisted store
   * snapshot up to the current schema version. It handles both record-level
   * and store-level migrations, and can optionally mutate the input store
   * for performance.
   *
   * @param snapshot - The store snapshot containing data and schema information
   * @param opts - Options controlling migration behavior
   *   - mutateInputStore - Whether to modify the input store directly (default: false)
   * @returns A MigrationResult containing the migrated store or an error
   *
   * @example
   * ```ts
   * const snapshot = {
   *   schema: { schemaVersion: 2, sequences: { 'com.tldraw.book': 1 } },
   *   store: {
   *     'book:1': { id: 'book:1', typeName: 'book', title: 'Old Book', publishDate: '2020-01-01' }
   *   }
   * }
   *
   * const result = schema.migrateStoreSnapshot(snapshot)
   * if (result.type === 'success') {
   *   console.log('Migrated store:', result.value)
   *   // All records are now at current schema version
   * }
   * ```
   *
   * @public
   */
  migrateStoreSnapshot(snapshot, opts) {
    let { store } = snapshot;
    const migrations = this.getMigrationsSince(snapshot.schema);
    if (!migrations.ok) {
      console.error("Error migrating store", migrations.error);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    const migrationsToApply = migrations.value;
    if (migrationsToApply.length === 0) {
      return { type: "success", value: store };
    }
    if (!opts?.mutateInputStore) {
      store = structuredClone(store);
    }
    try {
      for (const migration of migrationsToApply) {
        if (migration.scope === "record") {
          for (const [id, record] of Object.entries(store)) {
            const shouldApply = migration.filter ? migration.filter(record) : true;
            if (!shouldApply) continue;
            const result = migration.up(record);
            if (result) {
              store[id] = result;
            }
          }
        } else if (migration.scope === "store") {
          const result = migration.up(store);
          if (result) {
            store = result;
          }
        } else {
          exhaustiveSwitchError(migration);
        }
      }
    } catch (e) {
      console.error("Error migrating store", e);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    return { type: "success", value: store };
  }
  /**
   * Creates an integrity checker function for the given store.
   *
   * This method calls the createIntegrityChecker option if provided, allowing
   * custom integrity checking logic to be set up for the store. The integrity
   * checker is used to validate store consistency and catch data corruption.
   *
   * @param store - The store instance to create an integrity checker for
   * @returns An integrity checker function, or undefined if none is configured
   *
   * @internal
   */
  createIntegrityChecker(store) {
    return this.options.createIntegrityChecker?.(store) ?? void 0;
  }
  /**
   * Serializes the current schema to a SerializedSchemaV2 format.
   *
   * This method creates a serialized representation of the current schema,
   * capturing the latest version number for each migration sequence.
   * The result can be persisted and later used to determine what migrations
   * need to be applied when loading data.
   *
   * @returns A SerializedSchemaV2 object representing the current schema state
   *
   * @example
   * ```ts
   * const serialized = schema.serialize()
   * console.log(serialized)
   * // {
   * //   schemaVersion: 2,
   * //   sequences: {
   * //     'com.tldraw.book': 3,
   * //     'com.tldraw.author': 2
   * //   }
   * // }
   *
   * // Store this with your data for future migrations
   * localStorage.setItem('schema', JSON.stringify(serialized))
   * ```
   *
   * @public
   */
  serialize() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId, sequence }) => [
          sequenceId,
          sequence.length ? parseMigrationId(sequence.at(-1).id).version : 0
        ])
      )
    };
  }
  /**
   * Serializes a schema representing the earliest possible version.
   *
   * This method creates a serialized schema where all migration sequences
   * are set to version 0, representing the state before any migrations
   * have been applied. This is used in specific legacy scenarios.
   *
   * @returns A SerializedSchema with all sequences set to version 0
   *
   * @deprecated This is only here for legacy reasons, don't use it unless you have david's blessing!
   * @internal
   */
  serializeEarliestVersion() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId }) => [sequenceId, 0])
      )
    };
  }
  /**
   * Gets the RecordType definition for a given type name.
   *
   * This method retrieves the RecordType associated with the specified
   * type name, which contains the record's validation, creation, and
   * other behavioral logic.
   *
   * @param typeName - The name of the record type to retrieve
   * @returns The RecordType definition for the specified type
   *
   * @throws Will throw an error if the record type does not exist
   *
   * @internal
   */
  getType(typeName) {
    const type = getOwnProperty(this.types, typeName);
    assert(type, "record type does not exists");
    return type;
  }
}
registerTldrawLibraryVersion(
  "@tldraw/store",
  "4.2.0",
  "esm"
);
function formatPath(path) {
  if (!path.length) {
    return null;
  }
  let formattedPath = "";
  for (const item of path) {
    if (typeof item === "number") {
      formattedPath += `.${item}`;
    } else if (item.startsWith("(")) {
      if (formattedPath.endsWith(")")) {
        formattedPath = `${formattedPath.slice(0, -1)}, ${item.slice(1)}`;
      } else {
        formattedPath += item;
      }
    } else {
      formattedPath += `.${item}`;
    }
  }
  formattedPath = formattedPath.replace(/id = [^,]+, /, "").replace(/id = [^)]+/, "");
  if (formattedPath.startsWith(".")) {
    return formattedPath.slice(1);
  }
  return formattedPath;
}
class ValidationError extends Error {
  /**
   * Creates a new ValidationError with contextual information about where the error occurred.
   *
   * rawMessage - The raw error message without path information
   * path - Array indicating the location in the data structure where validation failed
   */
  constructor(rawMessage, path = []) {
    const formattedPath = formatPath(path);
    const indentedMessage = rawMessage.split("\n").map((line, i) => i === 0 ? line : `  ${line}`).join("\n");
    super(path ? `At ${formattedPath}: ${indentedMessage}` : indentedMessage);
    this.rawMessage = rawMessage;
    this.path = path;
  }
  name = "ValidationError";
}
function prefixError(path, fn) {
  try {
    return fn();
  } catch (err) {
    if (err instanceof ValidationError) {
      throw new ValidationError(err.rawMessage, [path, ...err.path]);
    }
    throw new ValidationError(err.toString(), [path]);
  }
}
function typeToString(value) {
  if (value === null) return "null";
  if (Array.isArray(value)) return "an array";
  const type = typeof value;
  switch (type) {
    case "bigint":
    case "boolean":
    case "function":
    case "number":
    case "string":
    case "symbol":
      return `a ${type}`;
    case "object":
      return `an ${type}`;
    case "undefined":
      return "undefined";
    default:
      exhaustiveSwitchError(type);
  }
}
class Validator {
  /**
   * Creates a new Validator instance.
   *
   * validationFn - Function that validates and returns a value of type T
   * validateUsingKnownGoodVersionFn - Optional performance-optimized validation function
   */
  constructor(validationFn, validateUsingKnownGoodVersionFn) {
    this.validationFn = validationFn;
    this.validateUsingKnownGoodVersionFn = validateUsingKnownGoodVersionFn;
  }
  /**
   * Validates an unknown value and returns it with the correct type. The returned value is
   * guaranteed to be referentially equal to the passed value.
   *
   * @param value - The unknown value to validate
   * @returns The validated value with type T
   * @throws ValidationError When validation fails
   * @example
   * ```ts
   * import { T } from '@tldraw/validate'
   *
   * const name = T.string.validate("Alice") // Returns "Alice" as string
   * const title = T.string.validate("") // Returns "" (empty strings are valid)
   *
   * // These will throw ValidationError:
   * T.string.validate(123) // Expected string, got a number
   * T.string.validate(null) // Expected string, got null
   * T.string.validate(undefined) // Expected string, got undefined
   * ```
   */
  validate(value) {
    const validated = this.validationFn(value);
    return validated;
  }
  /**
   * Performance-optimized validation using a previously validated value. If the new value
   * is referentially equal to the known good value, returns the known good value immediately.
   *
   * @param knownGoodValue - A previously validated value
   * @param newValue - The new value to validate
   * @returns The validated value, potentially reusing the known good value
   * @throws ValidationError When validation fails
   * @example
   * ```ts
   * import { T } from '@tldraw/validate'
   *
   * const userValidator = T.object({
   *   name: T.string,
   *   settings: T.object({ theme: T.literalEnum('light', 'dark') })
   * })
   *
   * const user = userValidator.validate({ name: "Alice", settings: { theme: "light" } })
   *
   * // Later, with partially changed data:
   * const newData = { name: "Alice", settings: { theme: "dark" } }
   * const updated = userValidator.validateUsingKnownGoodVersion(user, newData)
   * // Only validates the changed 'theme' field for better performance
   * ```
   */
  validateUsingKnownGoodVersion(knownGoodValue, newValue) {
    if (Object.is(knownGoodValue, newValue)) {
      return knownGoodValue;
    }
    if (this.validateUsingKnownGoodVersionFn) {
      return this.validateUsingKnownGoodVersionFn(knownGoodValue, newValue);
    }
    return this.validate(newValue);
  }
  /**
   * Type guard that checks if a value is valid without throwing an error.
   *
   * @param value - The value to check
   * @returns True if the value is valid, false otherwise
   * @example
   * ```ts
   * import { T } from '@tldraw/validate'
   *
   * function processUserInput(input: unknown) {
   *   if (T.string.isValid(input)) {
   *     // input is now typed as string within this block
   *     return input.toUpperCase()
   *   }
   *   if (T.number.isValid(input)) {
   *     // input is now typed as number within this block
   *     return input.toFixed(2)
   *   }
   *   throw new Error('Expected string or number')
   * }
   * ```
   */
  isValid(value) {
    try {
      this.validate(value);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Returns a new validator that also accepts null values.
   *
   * @returns A new validator that accepts T or null
   * @example
   * ```ts
   * import { T } from '@tldraw/validate'
   *
   * const assetValidator = T.object({
   *   id: T.string,
   *   name: T.string,
   *   src: T.srcUrl.nullable(), // Can be null if not loaded yet
   *   mimeType: T.string.nullable()
   * })
   *
   * const asset = assetValidator.validate({
   *   id: "image-123",
   *   name: "photo.jpg",
   *   src: null, // Valid - asset not loaded yet
   *   mimeType: "image/jpeg"
   * })
   * ```
   */
  nullable() {
    return nullable(this);
  }
  /**
   * Returns a new validator that also accepts undefined values.
   *
   * @returns A new validator that accepts T or undefined
   * @example
   * ```ts
   * import { T } from '@tldraw/validate'
   *
   * const shapeConfigValidator = T.object({
   *   type: T.literal('rectangle'),
   *   x: T.number,
   *   y: T.number,
   *   label: T.string.optional(), // Optional property
   *   metadata: T.object({ created: T.string }).optional()
   * })
   *
   * // Both of these are valid:
   * const shape1 = shapeConfigValidator.validate({ type: 'rectangle', x: 0, y: 0 })
   * const shape2 = shapeConfigValidator.validate({
   *   type: 'rectangle', x: 0, y: 0, label: "My Shape"
   * })
   * ```
   */
  optional() {
    return optional(this);
  }
  /**
   * Creates a new validator by refining this validator with additional logic that can transform
   * the validated value to a new type.
   *
   * @param otherValidationFn - Function that transforms/validates the value to type U
   * @returns A new validator that validates to type U
   * @throws ValidationError When validation or refinement fails
   * @example
   * ```ts
   * import { T, ValidationError } from '@tldraw/validate'
   *
   * // Transform string to ensure it starts with a prefix
   * const prefixedIdValidator = T.string.refine((id) => {
   *   return id.startsWith('shape:') ? id : `shape:${id}`
   * })
   *
   * const id1 = prefixedIdValidator.validate("rectangle-123") // Returns "shape:rectangle-123"
   * const id2 = prefixedIdValidator.validate("shape:circle-456") // Returns "shape:circle-456"
   *
   * // Parse and validate JSON strings
   * const jsonValidator = T.string.refine((str) => {
   *   try {
   *     return JSON.parse(str)
   *   } catch {
   *     throw new ValidationError('Invalid JSON string')
   *   }
   * })
   * ```
   */
  refine(otherValidationFn) {
    return new Validator(
      (value) => {
        return otherValidationFn(this.validate(value));
      },
      (knownGoodValue, newValue) => {
        const validated = this.validateUsingKnownGoodVersion(knownGoodValue, newValue);
        if (Object.is(knownGoodValue, validated)) {
          return knownGoodValue;
        }
        return otherValidationFn(validated);
      }
    );
  }
  check(nameOrCheckFn, checkFn) {
    if (typeof nameOrCheckFn === "string") {
      return this.refine((value) => {
        prefixError(`(check ${nameOrCheckFn})`, () => checkFn(value));
        return value;
      });
    } else {
      return this.refine((value) => {
        nameOrCheckFn(value);
        return value;
      });
    }
  }
}
class ArrayOfValidator extends Validator {
  /**
   * Creates a new ArrayOfValidator.
   *
   * itemValidator - Validator used to validate each array element
   */
  constructor(itemValidator) {
    super(
      (value) => {
        const arr = array.validate(value);
        for (let i = 0; i < arr.length; i++) {
          prefixError(i, () => itemValidator.validate(arr[i]));
        }
        return arr;
      },
      (knownGoodValue, newValue) => {
        if (!itemValidator.validateUsingKnownGoodVersion) return this.validate(newValue);
        const arr = array.validate(newValue);
        let isDifferent = knownGoodValue.length !== arr.length;
        for (let i = 0; i < arr.length; i++) {
          const item = arr[i];
          if (i >= knownGoodValue.length) {
            isDifferent = true;
            prefixError(i, () => itemValidator.validate(item));
            continue;
          }
          if (Object.is(knownGoodValue[i], item)) {
            continue;
          }
          const checkedItem = prefixError(
            i,
            () => itemValidator.validateUsingKnownGoodVersion(knownGoodValue[i], item)
          );
          if (!Object.is(checkedItem, knownGoodValue[i])) {
            isDifferent = true;
          }
        }
        return isDifferent ? newValue : knownGoodValue;
      }
    );
    this.itemValidator = itemValidator;
  }
  /**
   * Returns a new validator that ensures the array is not empty.
   *
   * @returns A new validator that rejects empty arrays
   * @throws ValidationError When the array is empty
   * @example
   * ```ts
   * const nonEmptyStrings = T.arrayOf(T.string).nonEmpty()
   * nonEmptyStrings.validate(["hello"]) // Valid
   * nonEmptyStrings.validate([]) // Throws ValidationError
   * ```
   */
  nonEmpty() {
    return this.check((value) => {
      if (value.length === 0) {
        throw new ValidationError("Expected a non-empty array");
      }
    });
  }
  /**
   * Returns a new validator that ensures the array has more than one element.
   *
   * @returns A new validator that requires at least 2 elements
   * @throws ValidationError When the array has 1 or fewer elements
   * @example
   * ```ts
   * const multipleItems = T.arrayOf(T.string).lengthGreaterThan1()
   * multipleItems.validate(["a", "b"]) // Valid
   * multipleItems.validate(["a"]) // Throws ValidationError
   * ```
   */
  lengthGreaterThan1() {
    return this.check((value) => {
      if (value.length <= 1) {
        throw new ValidationError("Expected an array with length greater than 1");
      }
    });
  }
}
class ObjectValidator extends Validator {
  /**
   * Creates a new ObjectValidator.
   *
   * config - Object mapping property names to their validators
   * shouldAllowUnknownProperties - Whether to allow properties not defined in config
   */
  constructor(config, shouldAllowUnknownProperties = false) {
    super(
      (object2) => {
        if (typeof object2 !== "object" || object2 === null) {
          throw new ValidationError(`Expected object, got ${typeToString(object2)}`);
        }
        for (const [key, validator] of Object.entries(config)) {
          prefixError(key, () => {
            ;
            validator.validate(getOwnProperty(object2, key));
          });
        }
        if (!shouldAllowUnknownProperties) {
          for (const key of Object.keys(object2)) {
            if (!hasOwnProperty(config, key)) {
              throw new ValidationError(`Unexpected property`, [key]);
            }
          }
        }
        return object2;
      },
      (knownGoodValue, newValue) => {
        if (typeof newValue !== "object" || newValue === null) {
          throw new ValidationError(`Expected object, got ${typeToString(newValue)}`);
        }
        let isDifferent = false;
        for (const [key, validator] of Object.entries(config)) {
          const prev = getOwnProperty(knownGoodValue, key);
          const next = getOwnProperty(newValue, key);
          if (Object.is(prev, next)) {
            continue;
          }
          const checked = prefixError(key, () => {
            const validatable = validator;
            if (validatable.validateUsingKnownGoodVersion) {
              return validatable.validateUsingKnownGoodVersion(prev, next);
            } else {
              return validatable.validate(next);
            }
          });
          if (!Object.is(checked, prev)) {
            isDifferent = true;
          }
        }
        if (!shouldAllowUnknownProperties) {
          for (const key of Object.keys(newValue)) {
            if (!hasOwnProperty(config, key)) {
              throw new ValidationError(`Unexpected property`, [key]);
            }
          }
        }
        for (const key of Object.keys(knownGoodValue)) {
          if (!hasOwnProperty(newValue, key)) {
            isDifferent = true;
            break;
          }
        }
        return isDifferent ? newValue : knownGoodValue;
      }
    );
    this.config = config;
    this.shouldAllowUnknownProperties = shouldAllowUnknownProperties;
  }
  /**
   * Returns a new validator that allows unknown properties in the validated object.
   *
   * @returns A new ObjectValidator that accepts extra properties
   * @example
   * ```ts
   * const flexibleUser = T.object({ name: T.string }).allowUnknownProperties()
   * flexibleUser.validate({ name: "Alice", extra: "allowed" }) // Valid
   * ```
   */
  allowUnknownProperties() {
    return new ObjectValidator(this.config, true);
  }
  /**
   * Creates a new ObjectValidator by extending this validator with additional properties.
   *
   * @param extension - Object mapping new property names to their validators
   * @returns A new ObjectValidator that validates both original and extended properties
   * @example
   * ```ts
   * const baseUser = T.object({ name: T.string, age: T.number })
   * const adminUser = baseUser.extend({
   *   permissions: T.arrayOf(T.string),
   *   isAdmin: T.boolean
   * })
   * // adminUser validates: { name: string; age: number; permissions: string[]; isAdmin: boolean }
   * ```
   */
  extend(extension) {
    return new ObjectValidator({ ...this.config, ...extension });
  }
}
class UnionValidator extends Validator {
  /**
   * Creates a new UnionValidator.
   *
   * key - The discriminator property name used to determine the variant
   * config - Object mapping variant names to their validators
   * unknownValueValidation - Function to handle unknown variants
   * useNumberKeys - Whether the discriminator uses number keys instead of strings
   */
  constructor(key, config, unknownValueValidation, useNumberKeys) {
    super(
      (input) => {
        this.expectObject(input);
        const { matchingSchema, variant } = this.getMatchingSchemaAndVariant(input);
        if (matchingSchema === void 0) {
          return this.unknownValueValidation(input, variant);
        }
        return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(input));
      },
      (prevValue, newValue) => {
        this.expectObject(newValue);
        this.expectObject(prevValue);
        const { matchingSchema, variant } = this.getMatchingSchemaAndVariant(newValue);
        if (matchingSchema === void 0) {
          return this.unknownValueValidation(newValue, variant);
        }
        if (getOwnProperty(prevValue, key) !== getOwnProperty(newValue, key)) {
          return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(newValue));
        }
        return prefixError(`(${key} = ${variant})`, () => {
          if (matchingSchema.validateUsingKnownGoodVersion) {
            return matchingSchema.validateUsingKnownGoodVersion(prevValue, newValue);
          } else {
            return matchingSchema.validate(newValue);
          }
        });
      }
    );
    this.key = key;
    this.config = config;
    this.unknownValueValidation = unknownValueValidation;
    this.useNumberKeys = useNumberKeys;
  }
  expectObject(value) {
    if (typeof value !== "object" || value === null) {
      throw new ValidationError(`Expected an object, got ${typeToString(value)}`, []);
    }
  }
  getMatchingSchemaAndVariant(object2) {
    const variant = getOwnProperty(object2, this.key);
    if (!this.useNumberKeys && typeof variant !== "string") {
      throw new ValidationError(
        `Expected a string for key "${this.key}", got ${typeToString(variant)}`
      );
    } else if (this.useNumberKeys && !Number.isFinite(Number(variant))) {
      throw new ValidationError(`Expected a number for key "${this.key}", got "${variant}"`);
    }
    const matchingSchema = hasOwnProperty(this.config, variant) ? this.config[variant] : void 0;
    return { matchingSchema, variant };
  }
  /**
   * Returns a new UnionValidator that can handle unknown variants using the provided function.
   *
   * @param unknownValueValidation - Function to validate/transform unknown variants
   * @returns A new UnionValidator that accepts unknown variants
   * @example
   * ```ts
   * const shapeValidator = T.union('type', { circle: circleValidator })
   *   .validateUnknownVariants((obj, variant) => {
   *     console.warn(`Unknown shape type: ${variant}`)
   *     return obj as UnknownShape
   *   })
   * ```
   */
  validateUnknownVariants(unknownValueValidation) {
    return new UnionValidator(this.key, this.config, unknownValueValidation, this.useNumberKeys);
  }
}
class DictValidator extends Validator {
  /**
   * Creates a new DictValidator.
   *
   * keyValidator - Validator for object keys
   * valueValidator - Validator for object values
   */
  constructor(keyValidator, valueValidator) {
    super(
      (object2) => {
        if (typeof object2 !== "object" || object2 === null) {
          throw new ValidationError(`Expected object, got ${typeToString(object2)}`);
        }
        for (const [key, value] of Object.entries(object2)) {
          prefixError(key, () => {
            keyValidator.validate(key);
            valueValidator.validate(value);
          });
        }
        return object2;
      },
      (knownGoodValue, newValue) => {
        if (typeof newValue !== "object" || newValue === null) {
          throw new ValidationError(`Expected object, got ${typeToString(newValue)}`);
        }
        let isDifferent = false;
        for (const [key, value] of Object.entries(newValue)) {
          if (!hasOwnProperty(knownGoodValue, key)) {
            isDifferent = true;
            prefixError(key, () => {
              keyValidator.validate(key);
              valueValidator.validate(value);
            });
            continue;
          }
          const prev = getOwnProperty(knownGoodValue, key);
          const next = value;
          if (Object.is(prev, next)) {
            continue;
          }
          const checked = prefixError(key, () => {
            if (valueValidator.validateUsingKnownGoodVersion) {
              return valueValidator.validateUsingKnownGoodVersion(prev, next);
            } else {
              return valueValidator.validate(next);
            }
          });
          if (!Object.is(checked, prev)) {
            isDifferent = true;
          }
        }
        for (const key of Object.keys(knownGoodValue)) {
          if (!hasOwnProperty(newValue, key)) {
            isDifferent = true;
            break;
          }
        }
        return isDifferent ? newValue : knownGoodValue;
      }
    );
    this.keyValidator = keyValidator;
    this.valueValidator = valueValidator;
  }
}
function typeofValidator(type) {
  return new Validator((value) => {
    if (typeof value !== type) {
      throw new ValidationError(`Expected ${type}, got ${typeToString(value)}`);
    }
    return value;
  });
}
const unknown = new Validator((value) => value);
const any = new Validator((value) => value);
const string = typeofValidator("string");
const number = typeofValidator("number").check((number2) => {
  if (Number.isNaN(number2)) {
    throw new ValidationError("Expected a number, got NaN");
  }
  if (!Number.isFinite(number2)) {
    throw new ValidationError(`Expected a finite number, got ${number2}`);
  }
});
const positiveNumber = number.check((value) => {
  if (value < 0) throw new ValidationError(`Expected a positive number, got ${value}`);
});
const nonZeroNumber = number.check((value) => {
  if (value <= 0) throw new ValidationError(`Expected a non-zero positive number, got ${value}`);
});
const integer = number.check((value) => {
  if (!Number.isInteger(value)) throw new ValidationError(`Expected an integer, got ${value}`);
});
const positiveInteger = integer.check((value) => {
  if (value < 0) throw new ValidationError(`Expected a positive integer, got ${value}`);
});
const nonZeroInteger = integer.check((value) => {
  if (value <= 0) throw new ValidationError(`Expected a non-zero positive integer, got ${value}`);
});
const boolean = typeofValidator("boolean");
function literal(expectedValue) {
  return new Validator((actualValue) => {
    if (actualValue !== expectedValue) {
      throw new ValidationError(`Expected ${expectedValue}, got ${JSON.stringify(actualValue)}`);
    }
    return expectedValue;
  });
}
const array = new Validator((value) => {
  if (!Array.isArray(value)) {
    throw new ValidationError(`Expected an array, got ${typeToString(value)}`);
  }
  return value;
});
function arrayOf(itemValidator) {
  return new ArrayOfValidator(itemValidator);
}
function object(config) {
  return new ObjectValidator(config);
}
function isPlainObject$3(value) {
  return typeof value === "object" && value !== null && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null || Object.getPrototypeOf(value) === STRUCTURED_CLONE_OBJECT_PROTOTYPE);
}
function isValidJson(value) {
  if (value === null || typeof value === "number" || typeof value === "string" || typeof value === "boolean") {
    return true;
  }
  if (Array.isArray(value)) {
    return value.every(isValidJson);
  }
  if (isPlainObject$3(value)) {
    return Object.values(value).every(isValidJson);
  }
  return false;
}
const jsonValue = new Validator(
  (value) => {
    if (isValidJson(value)) {
      return value;
    }
    throw new ValidationError(`Expected json serializable value, got ${typeof value}`);
  },
  (knownGoodValue, newValue) => {
    if (Array.isArray(knownGoodValue) && Array.isArray(newValue)) {
      let isDifferent = knownGoodValue.length !== newValue.length;
      for (let i = 0; i < newValue.length; i++) {
        if (i >= knownGoodValue.length) {
          isDifferent = true;
          jsonValue.validate(newValue[i]);
          continue;
        }
        const prev = knownGoodValue[i];
        const next = newValue[i];
        if (Object.is(prev, next)) {
          continue;
        }
        const checked = jsonValue.validateUsingKnownGoodVersion(prev, next);
        if (!Object.is(checked, prev)) {
          isDifferent = true;
        }
      }
      return isDifferent ? newValue : knownGoodValue;
    } else if (isPlainObject$3(knownGoodValue) && isPlainObject$3(newValue)) {
      let isDifferent = false;
      for (const key of Object.keys(newValue)) {
        if (!hasOwnProperty(knownGoodValue, key)) {
          isDifferent = true;
          jsonValue.validate(newValue[key]);
          continue;
        }
        const prev = knownGoodValue[key];
        const next = newValue[key];
        if (Object.is(prev, next)) {
          continue;
        }
        const checked = jsonValue.validateUsingKnownGoodVersion(prev, next);
        if (!Object.is(checked, prev)) {
          isDifferent = true;
        }
      }
      for (const key of Object.keys(knownGoodValue)) {
        if (!hasOwnProperty(newValue, key)) {
          isDifferent = true;
          break;
        }
      }
      return isDifferent ? newValue : knownGoodValue;
    } else {
      return jsonValue.validate(newValue);
    }
  }
);
function dict(keyValidator, valueValidator) {
  return new DictValidator(keyValidator, valueValidator);
}
function union(key, config) {
  return new UnionValidator(
    key,
    config,
    (_unknownValue, unknownVariant) => {
      throw new ValidationError(
        `Expected one of ${Object.keys(config).map((key2) => JSON.stringify(key2)).join(" or ")}, got ${JSON.stringify(unknownVariant)}`,
        [key]
      );
    },
    false
  );
}
function numberUnion(key, config) {
  return new UnionValidator(
    key,
    config,
    (unknownValue, unknownVariant) => {
      throw new ValidationError(
        `Expected one of ${Object.keys(config).map((key2) => JSON.stringify(key2)).join(" or ")}, got ${JSON.stringify(unknownVariant)}`,
        [key]
      );
    },
    true
  );
}
function model(name, validator) {
  return new Validator(
    (value) => {
      return prefixError(name, () => validator.validate(value));
    },
    (prevValue, newValue) => {
      return prefixError(name, () => {
        if (validator.validateUsingKnownGoodVersion) {
          return validator.validateUsingKnownGoodVersion(prevValue, newValue);
        } else {
          return validator.validate(newValue);
        }
      });
    }
  );
}
function setEnum(values) {
  return new Validator((value) => {
    if (!values.has(value)) {
      const valuesString = Array.from(values, (value2) => JSON.stringify(value2)).join(" or ");
      throw new ValidationError(`Expected ${valuesString}, got ${value}`);
    }
    return value;
  });
}
function optional(validator) {
  return new Validator(
    (value) => {
      if (value === void 0) return void 0;
      return validator.validate(value);
    },
    (knownGoodValue, newValue) => {
      if (knownGoodValue === void 0 && newValue === void 0) return void 0;
      if (newValue === void 0) return void 0;
      if (validator.validateUsingKnownGoodVersion && knownGoodValue !== void 0) {
        return validator.validateUsingKnownGoodVersion(knownGoodValue, newValue);
      }
      return validator.validate(newValue);
    }
  );
}
function nullable(validator) {
  return new Validator(
    (value) => {
      if (value === null) return null;
      return validator.validate(value);
    },
    (knownGoodValue, newValue) => {
      if (newValue === null) return null;
      if (validator.validateUsingKnownGoodVersion && knownGoodValue !== null) {
        return validator.validateUsingKnownGoodVersion(knownGoodValue, newValue);
      }
      return validator.validate(newValue);
    }
  );
}
function literalEnum(...values) {
  return setEnum(new Set(values));
}
function parseUrl(str) {
  try {
    return new URL(str);
  } catch {
    if (str.startsWith("/") || str.startsWith("./")) {
      try {
        return new URL(str, "http://example.com");
      } catch {
        throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`);
      }
    }
    throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`);
  }
}
const validLinkProtocols = /* @__PURE__ */ new Set(["http:", "https:", "mailto:"]);
const linkUrl = string.check((value) => {
  if (value === "") return;
  const url = parseUrl(value);
  if (!validLinkProtocols.has(url.protocol.toLowerCase())) {
    throw new ValidationError(
      `Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
    );
  }
});
const validSrcProtocols = /* @__PURE__ */ new Set(["http:", "https:", "data:", "asset:"]);
const srcUrl = string.check((value) => {
  if (value === "") return;
  const url = parseUrl(value);
  if (!validSrcProtocols.has(url.protocol.toLowerCase())) {
    throw new ValidationError(
      `Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
    );
  }
});
string.check((value) => {
  if (value === "") return;
  const url = parseUrl(value);
  if (!url.protocol.toLowerCase().match(/^https?:$/)) {
    throw new ValidationError(
      `Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
    );
  }
});
const indexKey = string.refine((key) => {
  try {
    validateIndexKey(key);
    return key;
  } catch {
    throw new ValidationError(`Expected an index key, got ${JSON.stringify(key)}`);
  }
});
registerTldrawLibraryVersion(
  "@tldraw/validate",
  "4.2.0",
  "esm"
);
function idValidator(prefix) {
  return string.refine((id) => {
    if (!id.startsWith(`${prefix}:`)) {
      throw new Error(`${prefix} ID must start with "${prefix}:"`);
    }
    return id;
  });
}
const assetIdValidator = idValidator("asset");
function createAssetValidator(type, props) {
  return object({
    id: assetIdValidator,
    typeName: literal("asset"),
    type: literal(type),
    props,
    meta: jsonValue
  });
}
const vecModelValidator = object({
  x: number,
  y: number,
  z: number.optional()
});
const boxModelValidator = object({
  x: number,
  y: number,
  w: number,
  h: number
});
const opacityValidator = number.check((n) => {
  if (n < 0 || n > 1) {
    throw new ValidationError("Opacity must be between 0 and 1");
  }
});
const parentIdValidator = string.refine((id) => {
  if (!id.startsWith("page:") && !id.startsWith("shape:")) {
    throw new Error('Parent ID must start with "page:" or "shape:"');
  }
  return id;
});
const shapeIdValidator = idValidator("shape");
function createShapeValidator(type, props, meta) {
  return object({
    id: shapeIdValidator,
    typeName: literal("shape"),
    x: number,
    y: number,
    rotation: number,
    index: indexKey,
    parentId: parentIdValidator,
    type: literal(type),
    isLocked: boolean,
    opacity: opacityValidator,
    props: props ? object(props) : jsonValue,
    meta: meta ? object(meta) : jsonValue
  });
}
const bindingIdValidator = idValidator("binding");
function createBindingValidator(type, props, meta) {
  return object({
    id: bindingIdValidator,
    typeName: literal("binding"),
    type: literal(type),
    fromId: shapeIdValidator,
    toId: shapeIdValidator,
    props: props ? object(props) : jsonValue,
    meta: meta ? object(meta) : jsonValue
  });
}
createMigrationIds("com.tldraw.binding", {});
createRecordMigrationSequence({
  sequenceId: "com.tldraw.binding",
  recordType: "binding",
  sequence: []
});
function createBindingId(id) {
  return `binding:${uniqueId()}`;
}
function createBindingPropsMigrationSequence(migrations) {
  return migrations;
}
function createBindingPropsMigrationIds(bindingType, ids) {
  return mapObjectMapValues(ids, (_k, v) => `com.tldraw.binding.${bindingType}/${v}`);
}
function createBindingRecordType(bindings) {
  return createRecordType("binding", {
    scope: "document",
    validator: model(
      "binding",
      union(
        "type",
        mapObjectMapValues(
          bindings,
          (type, { props, meta }) => createBindingValidator(type, props, meta)
        )
      )
    )
  }).withDefaultProperties(() => ({
    meta: {}
  }));
}
const richTextValidator = object({ type: string, content: arrayOf(unknown) });
function toRichText(text) {
  const lines = text.split("\n");
  const content = lines.map((text2) => {
    if (!text2) {
      return {
        type: "paragraph"
      };
    }
    return {
      type: "paragraph",
      content: [{ type: "text", text: text2 }]
    };
  });
  return {
    type: "doc",
    content
  };
}
class StyleProp {
  /** @internal */
  constructor(id, defaultValue, type) {
    this.id = id;
    this.defaultValue = defaultValue;
    this.type = type;
  }
  /**
   * Define a new {@link StyleProp}.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `type`: Optionally, describe what type of data you expect for this style prop.
   *
   * @example
   * ```ts
   * import {T} from '@tldraw/validate'
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MyLineWidthProp = StyleProp.define('myApp:lineWidth', {
   *   defaultValue: 1,
   *   type: T.number,
   * })
   * ```
   * @public
   */
  static define(uniqueId2, options) {
    const { defaultValue, type = any } = options;
    return new StyleProp(uniqueId2, defaultValue, type);
  }
  /**
   * Define a new {@link StyleProp} as a list of possible values.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `values`: An array of possible values of this style prop.
   *
   * @example
   * ```ts
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MySizeProp = StyleProp.defineEnum('myApp:size', {
   *   defaultValue: 'medium',
   *   values: ['small', 'medium', 'large'],
   * })
   * ```
   */
  static defineEnum(uniqueId2, options) {
    const { defaultValue, values } = options;
    return new EnumStyleProp(uniqueId2, defaultValue, values);
  }
  setDefaultValue(value) {
    this.defaultValue = value;
  }
  validate(value) {
    return this.type.validate(value);
  }
  validateUsingKnownGoodVersion(prevValue, newValue) {
    if (this.type.validateUsingKnownGoodVersion) {
      return this.type.validateUsingKnownGoodVersion(prevValue, newValue);
    } else {
      return this.validate(newValue);
    }
  }
}
class EnumStyleProp extends StyleProp {
  /** @internal */
  constructor(id, defaultValue, values) {
    super(id, defaultValue, literalEnum(...values));
    this.values = values;
  }
}
const rootShapeVersions = createMigrationIds("com.tldraw.shape", {
  AddIsLocked: 1,
  HoistOpacity: 2,
  AddMeta: 3,
  AddWhite: 4
});
const rootShapeMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.shape",
  recordType: "shape",
  sequence: [
    {
      id: rootShapeVersions.AddIsLocked,
      up: (record) => {
        record.isLocked = false;
      },
      down: (record) => {
        delete record.isLocked;
      }
    },
    {
      id: rootShapeVersions.HoistOpacity,
      up: (record) => {
        record.opacity = Number(record.props.opacity ?? "1");
        delete record.props.opacity;
      },
      down: (record) => {
        const opacity = record.opacity;
        delete record.opacity;
        record.props.opacity = opacity < 0.175 ? "0.1" : opacity < 0.375 ? "0.25" : opacity < 0.625 ? "0.5" : opacity < 0.875 ? "0.75" : "1";
      }
    },
    {
      id: rootShapeVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: rootShapeVersions.AddWhite,
      up: (_record) => {
      },
      down: (record) => {
        if (record.props.color === "white") {
          record.props.color = "black";
        }
      }
    }
  ]
});
function isShape(record) {
  if (!record) return false;
  return record.typeName === "shape";
}
function isShapeId(id) {
  if (!id) return false;
  return id.startsWith("shape:");
}
function createShapeId(id) {
  return `shape:${id ?? uniqueId()}`;
}
function getShapePropKeysByStyle(props) {
  const propKeysByStyle = /* @__PURE__ */ new Map();
  for (const [key, prop] of Object.entries(props)) {
    if (prop instanceof StyleProp) {
      if (propKeysByStyle.has(prop)) {
        throw new Error(
          `Duplicate style prop ${prop.id}. Each style prop can only be used once within a shape.`
        );
      }
      propKeysByStyle.set(prop, key);
    }
  }
  return propKeysByStyle;
}
function createShapePropsMigrationSequence(migrations) {
  return migrations;
}
function createShapePropsMigrationIds(shapeType, ids) {
  return mapObjectMapValues(ids, (_k, v) => `com.tldraw.shape.${shapeType}/${v}`);
}
function createShapeRecordType(shapes) {
  return createRecordType("shape", {
    scope: "document",
    validator: model(
      "shape",
      union(
        "type",
        mapObjectMapValues(
          shapes,
          (type, { props, meta }) => createShapeValidator(type, props, meta)
        )
      )
    )
  }).withDefaultProperties(() => ({
    x: 0,
    y: 0,
    rotation: 0,
    isLocked: false,
    opacity: 1,
    meta: {}
  }));
}
function processPropsMigrations(typeName, records) {
  const result = [];
  for (const [subType, { migrations }] of Object.entries(records)) {
    const sequenceId = `com.tldraw.${typeName}.${subType}`;
    if (!migrations) {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: []
        })
      );
    } else if ("sequenceId" in migrations) {
      assert(
        sequenceId === migrations.sequenceId,
        `sequenceId mismatch for ${subType} ${RecordType} migrations. Expected '${sequenceId}', got '${migrations.sequenceId}'`
      );
      result.push(migrations);
    } else if ("sequence" in migrations) {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: migrations.sequence.map(
            (m) => "id" in m ? createPropsMigration(typeName, subType, m) : m
          )
        })
      );
    } else {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: Object.keys(migrations.migrators).map((k) => Number(k)).sort((a, b) => a - b).map(
            (version2) => ({
              id: `${sequenceId}/${version2}`,
              scope: "record",
              filter: (r) => r.typeName === typeName && r.type === subType,
              up: (record) => {
                const result2 = migrations.migrators[version2].up(record);
                if (result2) {
                  return result2;
                }
              },
              down: (record) => {
                const result2 = migrations.migrators[version2].down(record);
                if (result2) {
                  return result2;
                }
              }
            })
          )
        })
      );
    }
  }
  return result;
}
function createPropsMigration(typeName, subType, m) {
  return {
    id: m.id,
    dependsOn: m.dependsOn,
    scope: "record",
    filter: (r) => r.typeName === typeName && r.type === subType,
    up: (record) => {
      const result = m.up(record.props);
      if (result) {
        record.props = result;
      }
    },
    down: typeof m.down === "function" ? (record) => {
      const result = m.down(record.props);
      if (result) {
        record.props = result;
      }
    } : void 0
  };
}
const defaultColorNames = [
  "black",
  "grey",
  "light-violet",
  "violet",
  "blue",
  "light-blue",
  "yellow",
  "orange",
  "green",
  "light-green",
  "light-red",
  "red",
  "white"
];
const DefaultColorThemePalette = {
  lightMode: {
    id: "light",
    text: "#000000",
    background: "#f9fafb",
    solid: "#fcfffe",
    black: {
      solid: "#1d1d1d",
      fill: "#1d1d1d",
      linedFill: "#363636",
      frameHeadingStroke: "#717171",
      frameHeadingFill: "#ffffff",
      frameStroke: "#717171",
      frameFill: "#ffffff",
      frameText: "#000000",
      noteFill: "#FCE19C",
      noteText: "#000000",
      semi: "#e8e8e8",
      pattern: "#494949",
      highlightSrgb: "#fddd00",
      highlightP3: "color(display-p3 0.972 0.8205 0.05)"
    },
    blue: {
      solid: "#4465e9",
      fill: "#4465e9",
      linedFill: "#6580ec",
      frameHeadingStroke: "#6681ec",
      frameHeadingFill: "#f9fafe",
      frameStroke: "#6681ec",
      frameFill: "#f9fafe",
      frameText: "#000000",
      noteFill: "#8AA3FF",
      noteText: "#000000",
      semi: "#dce1f8",
      pattern: "#6681ee",
      highlightSrgb: "#10acff",
      highlightP3: "color(display-p3 0.308 0.6632 0.9996)"
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      linedFill: "#0bad7c",
      frameHeadingStroke: "#37a684",
      frameHeadingFill: "#f8fcfa",
      frameStroke: "#37a684",
      frameFill: "#f8fcfa",
      frameText: "#000000",
      noteFill: "#6FC896",
      noteText: "#000000",
      semi: "#d3e9e3",
      pattern: "#39a785",
      highlightSrgb: "#00ffc8",
      highlightP3: "color(display-p3 0.2536 0.984 0.7981)"
    },
    grey: {
      solid: "#9fa8b2",
      fill: "#9fa8b2",
      linedFill: "#bbc1c9",
      frameHeadingStroke: "#aaaaab",
      frameHeadingFill: "#fbfcfc",
      frameStroke: "#aaaaab",
      frameFill: "#fcfcfd",
      frameText: "#000000",
      noteFill: "#C0CAD3",
      noteText: "#000000",
      semi: "#eceef0",
      pattern: "#bcc3c9",
      highlightSrgb: "#cbe7f1",
      highlightP3: "color(display-p3 0.8163 0.9023 0.9416)"
    },
    "light-blue": {
      solid: "#4ba1f1",
      fill: "#4ba1f1",
      linedFill: "#7abaf5",
      frameHeadingStroke: "#6cb2f3",
      frameHeadingFill: "#f8fbfe",
      frameStroke: "#6cb2f3",
      frameFill: "#fafcff",
      frameText: "#000000",
      noteFill: "#9BC4FD",
      noteText: "#000000",
      semi: "#ddedfa",
      pattern: "#6fbbf8",
      highlightSrgb: "#00f4ff",
      highlightP3: "color(display-p3 0.1512 0.9414 0.9996)"
    },
    "light-green": {
      solid: "#4cb05e",
      fill: "#4cb05e",
      linedFill: "#7ec88c",
      frameHeadingStroke: "#6dbe7c",
      frameHeadingFill: "#f8fcf9",
      frameStroke: "#6dbe7c",
      frameFill: "#fafdfa",
      frameText: "#000000",
      noteFill: "#98D08A",
      noteText: "#000000",
      semi: "#dbf0e0",
      pattern: "#65cb78",
      highlightSrgb: "#65f641",
      highlightP3: "color(display-p3 0.563 0.9495 0.3857)"
    },
    "light-red": {
      solid: "#f87777",
      fill: "#f87777",
      linedFill: "#f99a9a",
      frameHeadingStroke: "#f89090",
      frameHeadingFill: "#fffafa",
      frameStroke: "#f89090",
      frameFill: "#fffbfb",
      frameText: "#000000",
      noteFill: "#F7A5A1",
      noteText: "#000000",
      semi: "#f4dadb",
      pattern: "#fe9e9e",
      highlightSrgb: "#ff7fa3",
      highlightP3: "color(display-p3 0.9988 0.5301 0.6397)"
    },
    "light-violet": {
      solid: "#e085f4",
      fill: "#e085f4",
      linedFill: "#e9abf7",
      frameHeadingStroke: "#e59bf5",
      frameHeadingFill: "#fefaff",
      frameStroke: "#e59bf5",
      frameFill: "#fefbff",
      frameText: "#000000",
      noteFill: "#DFB0F9",
      noteText: "#000000",
      semi: "#f5eafa",
      pattern: "#e9acf8",
      highlightSrgb: "#ff88ff",
      highlightP3: "color(display-p3 0.9676 0.5652 0.9999)"
    },
    orange: {
      solid: "#e16919",
      fill: "#e16919",
      linedFill: "#ea8643",
      frameHeadingStroke: "#e68544",
      frameHeadingFill: "#fef9f6",
      frameStroke: "#e68544",
      frameFill: "#fef9f6",
      frameText: "#000000",
      noteFill: "#FAA475",
      noteText: "#000000",
      semi: "#f8e2d4",
      pattern: "#f78438",
      highlightSrgb: "#ffa500",
      highlightP3: "color(display-p3 0.9988 0.6905 0.266)"
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      linedFill: "#e75f5f",
      frameHeadingStroke: "#e55757",
      frameHeadingFill: "#fef7f7",
      frameStroke: "#e55757",
      frameFill: "#fef9f9",
      frameText: "#000000",
      noteFill: "#FC8282",
      noteText: "#000000",
      semi: "#f4dadb",
      pattern: "#e55959",
      highlightSrgb: "#ff636e",
      highlightP3: "color(display-p3 0.9992 0.4376 0.45)"
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      linedFill: "#be68d4",
      frameHeadingStroke: "#bc62d3",
      frameHeadingFill: "#fcf7fd",
      frameStroke: "#bc62d3",
      frameFill: "#fdf9fd",
      frameText: "#000000",
      noteFill: "#DB91FD",
      noteText: "#000000",
      semi: "#ecdcf2",
      pattern: "#bd63d3",
      highlightSrgb: "#c77cff",
      highlightP3: "color(display-p3 0.7469 0.5089 0.9995)"
    },
    yellow: {
      solid: "#f1ac4b",
      fill: "#f1ac4b",
      linedFill: "#f5c27a",
      frameHeadingStroke: "#f3bb6c",
      frameHeadingFill: "#fefcf8",
      frameStroke: "#f3bb6c",
      frameFill: "#fffdfa",
      frameText: "#000000",
      noteFill: "#FED49A",
      noteText: "#000000",
      semi: "#f9f0e6",
      pattern: "#fecb92",
      highlightSrgb: "#fddd00",
      highlightP3: "color(display-p3 0.972 0.8705 0.05)"
    },
    white: {
      solid: "#FFFFFF",
      fill: "#FFFFFF",
      linedFill: "#ffffff",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      frameHeadingStroke: "#7d7d7d",
      frameHeadingFill: "#ffffff",
      frameStroke: "#7d7d7d",
      frameFill: "#ffffff",
      frameText: "#000000",
      noteFill: "#FFFFFF",
      noteText: "#000000",
      highlightSrgb: "#ffffff",
      highlightP3: "color(display-p3 1 1 1)"
    }
  },
  darkMode: {
    id: "dark",
    text: "hsl(210, 17%, 98%)",
    background: "hsl(240, 5%, 6.5%)",
    solid: "#010403",
    black: {
      solid: "#f2f2f2",
      fill: "#f2f2f2",
      linedFill: "#ffffff",
      frameHeadingStroke: "#5c5c5c",
      frameHeadingFill: "#252525",
      frameStroke: "#5c5c5c",
      frameFill: "#0c0c0c",
      frameText: "#f2f2f2",
      noteFill: "#2c2c2c",
      noteText: "#f2f2f2",
      semi: "#2c3036",
      pattern: "#989898",
      highlightSrgb: "#d2b700",
      highlightP3: "color(display-p3 0.8078 0.6225 0.0312)"
    },
    blue: {
      solid: "#4f72fc",
      // 3c60f0
      fill: "#4f72fc",
      linedFill: "#3c5cdd",
      frameHeadingStroke: "#384994",
      frameHeadingFill: "#1C2036",
      frameStroke: "#384994",
      frameFill: "#11141f",
      frameText: "#f2f2f2",
      noteFill: "#2A3F98",
      noteText: "#f2f2f2",
      semi: "#262d40",
      pattern: "#3a4b9e",
      highlightSrgb: "#0079d2",
      highlightP3: "color(display-p3 0.0032 0.4655 0.7991)"
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      linedFill: "#087856",
      frameHeadingStroke: "#10513C",
      frameHeadingFill: "#14241f",
      frameStroke: "#10513C",
      frameFill: "#0E1614",
      frameText: "#f2f2f2",
      noteFill: "#014429",
      noteText: "#f2f2f2",
      semi: "#253231",
      pattern: "#366a53",
      highlightSrgb: "#009774",
      highlightP3: "color(display-p3 0.0085 0.582 0.4604)"
    },
    grey: {
      solid: "#9398b0",
      fill: "#9398b0",
      linedFill: "#8388a5",
      frameHeadingStroke: "#42474D",
      frameHeadingFill: "#23262A",
      frameStroke: "#42474D",
      frameFill: "#151719",
      frameText: "#f2f2f2",
      noteFill: "#56595F",
      noteText: "#f2f2f2",
      semi: "#33373c",
      pattern: "#7c8187",
      highlightSrgb: "#9cb4cb",
      highlightP3: "color(display-p3 0.6299 0.7012 0.7856)"
    },
    "light-blue": {
      solid: "#4dabf7",
      fill: "#4dabf7",
      linedFill: "#2793ec",
      frameHeadingStroke: "#075797",
      frameHeadingFill: "#142839",
      frameStroke: "#075797",
      frameFill: "#0B1823",
      frameText: "#f2f2f2",
      noteFill: "#1F5495",
      noteText: "#f2f2f2",
      semi: "#2a3642",
      pattern: "#4d7aa9",
      highlightSrgb: "#00bdc8",
      highlightP3: "color(display-p3 0.0023 0.7259 0.7735)"
    },
    "light-green": {
      solid: "#40c057",
      fill: "#40c057",
      linedFill: "#37a44b",
      frameHeadingStroke: "#1C5427",
      frameHeadingFill: "#18251A",
      frameStroke: "#1C5427",
      frameFill: "#0F1911",
      frameText: "#f2f2f2",
      noteFill: "#21581D",
      noteText: "#f2f2f2",
      semi: "#2a3830",
      pattern: "#4e874e",
      highlightSrgb: "#00a000",
      highlightP3: "color(display-p3 0.2711 0.6172 0.0195)"
    },
    "light-red": {
      solid: "#ff8787",
      fill: "#ff8787",
      linedFill: "#ff6666",
      frameHeadingStroke: "#6f3232",
      // Darker and desaturated variant of solid
      frameHeadingFill: "#341818",
      // Deep, muted dark red
      frameStroke: "#6f3232",
      // Matches headingStroke
      frameFill: "#181212",
      // Darker, muted background shade
      frameText: "#f2f2f2",
      // Consistent bright text color
      noteFill: "#7a3333",
      // Medium-dark, muted variant of solid
      noteText: "#f2f2f2",
      semi: "#3c2b2b",
      // Subdued, darker neutral-red tone
      pattern: "#a56767",
      // Existing pattern shade retained
      highlightSrgb: "#db005b",
      highlightP3: "color(display-p3 0.7849 0.0585 0.3589)"
    },
    "light-violet": {
      solid: "#e599f7",
      fill: "#e599f7",
      linedFill: "#dc71f4",
      frameHeadingStroke: "#6c367a",
      frameHeadingFill: "#2D2230",
      frameStroke: "#6c367a",
      frameFill: "#1C151E",
      frameText: "#f2f2f2",
      noteFill: "#762F8E",
      noteText: "#f2f2f2",
      semi: "#383442",
      pattern: "#9770a9",
      highlightSrgb: "#c400c7",
      highlightP3: "color(display-p3 0.7024 0.0403 0.753)"
    },
    orange: {
      solid: "#f76707",
      fill: "#f76707",
      linedFill: "#f54900",
      frameHeadingStroke: "#773a0e",
      // Darker, muted version of solid
      frameHeadingFill: "#2f1d13",
      // Deep, warm, muted background
      frameStroke: "#773a0e",
      // Matches headingStroke
      frameFill: "#1c1512",
      // Darker, richer muted background
      frameText: "#f2f2f2",
      // Bright text for contrast
      noteFill: "#7c3905",
      // Muted dark variant for note fill
      noteText: "#f2f2f2",
      semi: "#3b2e27",
      // Muted neutral-orange tone
      pattern: "#9f552d",
      // Retained existing shade
      highlightSrgb: "#d07a00",
      highlightP3: "color(display-p3 0.7699 0.4937 0.0085)"
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      linedFill: "#c31d1d",
      frameHeadingStroke: "#701e1e",
      // Darker, muted variation of solid
      frameHeadingFill: "#301616",
      // Deep, muted reddish backdrop
      frameStroke: "#701e1e",
      // Matches headingStroke
      frameFill: "#1b1313",
      // Rich, dark muted background
      frameText: "#f2f2f2",
      // Bright text for readability
      noteFill: "#7e201f",
      // Muted dark variant for note fill
      noteText: "#f2f2f2",
      semi: "#382726",
      // Dark neutral-red tone
      pattern: "#8f3734",
      // Existing pattern color retained
      highlightSrgb: "#de002c",
      highlightP3: "color(display-p3 0.7978 0.0509 0.2035)"
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      linedFill: "#8f2fa7",
      frameHeadingStroke: "#6d1583",
      // Darker, muted variation of solid
      frameHeadingFill: "#27152e",
      // Deep, rich muted violet backdrop
      frameStroke: "#6d1583",
      // Matches headingStroke
      frameFill: "#1b0f21",
      // Darker muted violet background
      frameText: "#f2f2f2",
      // Consistent bright text color
      noteFill: "#5f1c70",
      // Muted dark variant for note fill
      noteText: "#f2f2f2",
      semi: "#342938",
      // Dark neutral-violet tone
      pattern: "#763a8b",
      // Retained existing pattern color
      highlightSrgb: "#9e00ee",
      highlightP3: "color(display-p3 0.5651 0.0079 0.8986)"
    },
    yellow: {
      solid: "#ffc034",
      fill: "#ffc034",
      linedFill: "#ffae00",
      frameHeadingStroke: "#684e12",
      // Darker, muted variant of solid
      frameHeadingFill: "#2a2113",
      // Rich, muted dark-yellow background
      frameStroke: "#684e12",
      // Matches headingStroke
      frameFill: "#1e1911",
      // Darker muted shade for background fill
      frameText: "#f2f2f2",
      // Bright text color for readability
      noteFill: "#8a5e1c",
      // Muted, dark complementary variant
      noteText: "#f2f2f2",
      semi: "#3b352b",
      // Dark muted neutral-yellow tone
      pattern: "#fecb92",
      // Existing shade retained
      highlightSrgb: "#d2b700",
      highlightP3: "color(display-p3 0.8078 0.7225 0.0312)"
    },
    white: {
      solid: "#f3f3f3",
      fill: "#f3f3f3",
      linedFill: "#f3f3f3",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      frameHeadingStroke: "#ffffff",
      frameHeadingFill: "#ffffff",
      frameStroke: "#ffffff",
      frameFill: "#ffffff",
      frameText: "#000000",
      noteFill: "#eaeaea",
      noteText: "#1d1d1d",
      highlightSrgb: "#ffffff",
      highlightP3: "color(display-p3 1 1 1)"
    }
  }
};
function getDefaultColorTheme(opts) {
  return opts.isDarkMode ? DefaultColorThemePalette.darkMode : DefaultColorThemePalette.lightMode;
}
const DefaultColorStyle = StyleProp.defineEnum("tldraw:color", {
  defaultValue: "black",
  values: defaultColorNames
});
const DefaultLabelColorStyle = StyleProp.defineEnum("tldraw:labelColor", {
  defaultValue: "black",
  values: defaultColorNames
});
const defaultColorNamesSet = new Set(defaultColorNames);
function isDefaultThemeColor(color) {
  return defaultColorNamesSet.has(color);
}
function getColorValue(theme, color, variant) {
  if (!isDefaultThemeColor(color)) {
    return color;
  }
  return theme[color][variant];
}
const DefaultDashStyle = StyleProp.defineEnum("tldraw:dash", {
  defaultValue: "draw",
  values: ["draw", "solid", "dashed", "dotted"]
});
const DefaultFillStyle = StyleProp.defineEnum("tldraw:fill", {
  defaultValue: "none",
  values: ["none", "semi", "solid", "pattern", "fill", "lined-fill"]
});
const DefaultFontStyle = StyleProp.defineEnum("tldraw:font", {
  defaultValue: "draw",
  values: ["draw", "sans", "serif", "mono"]
});
const DefaultFontFamilies = {
  draw: "'tldraw_draw', sans-serif",
  sans: "'tldraw_sans', sans-serif",
  serif: "'tldraw_serif', serif",
  mono: "'tldraw_mono', monospace"
};
const DefaultSizeStyle = StyleProp.defineEnum("tldraw:size", {
  defaultValue: "m",
  values: ["s", "m", "l", "xl"]
});
const arrowKinds = ["arc", "elbow"];
const ArrowShapeKindStyle = StyleProp.defineEnum("tldraw:arrowKind", {
  defaultValue: "arc",
  values: arrowKinds
});
const arrowheadTypes = [
  "arrow",
  "triangle",
  "square",
  "dot",
  "pipe",
  "diamond",
  "inverted",
  "bar",
  "none"
];
const ArrowShapeArrowheadStartStyle = StyleProp.defineEnum("tldraw:arrowheadStart", {
  defaultValue: "none",
  values: arrowheadTypes
});
const ArrowShapeArrowheadEndStyle = StyleProp.defineEnum("tldraw:arrowheadEnd", {
  defaultValue: "arrow",
  values: arrowheadTypes
});
const arrowShapeProps = {
  kind: ArrowShapeKindStyle,
  labelColor: DefaultLabelColorStyle,
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  arrowheadStart: ArrowShapeArrowheadStartStyle,
  arrowheadEnd: ArrowShapeArrowheadEndStyle,
  font: DefaultFontStyle,
  start: vecModelValidator,
  end: vecModelValidator,
  bend: number,
  richText: richTextValidator,
  labelPosition: number,
  scale: nonZeroNumber,
  elbowMidPoint: number
};
const arrowShapeVersions = createShapePropsMigrationIds("arrow", {
  AddLabelColor: 1,
  AddIsPrecise: 2,
  AddLabelPosition: 3,
  ExtractBindings: 4,
  AddScale: 5,
  AddElbow: 6,
  AddRichText: 7
});
function propsMigration(migration) {
  return createPropsMigration("shape", "arrow", migration);
}
const arrowShapeMigrations = createMigrationSequence({
  sequenceId: "com.tldraw.shape.arrow",
  retroactive: false,
  sequence: [
    propsMigration({
      id: arrowShapeVersions.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: "retired"
    }),
    propsMigration({
      id: arrowShapeVersions.AddIsPrecise,
      up: ({ start, end }) => {
        if (start.type === "binding") {
          start.isPrecise = !(start.normalizedAnchor.x === 0.5 && start.normalizedAnchor.y === 0.5);
        }
        if (end.type === "binding") {
          end.isPrecise = !(end.normalizedAnchor.x === 0.5 && end.normalizedAnchor.y === 0.5);
        }
      },
      down: ({ start, end }) => {
        if (start.type === "binding") {
          if (!start.isPrecise) {
            start.normalizedAnchor = { x: 0.5, y: 0.5 };
          }
          delete start.isPrecise;
        }
        if (end.type === "binding") {
          if (!end.isPrecise) {
            end.normalizedAnchor = { x: 0.5, y: 0.5 };
          }
          delete end.isPrecise;
        }
      }
    }),
    propsMigration({
      id: arrowShapeVersions.AddLabelPosition,
      up: (props) => {
        props.labelPosition = 0.5;
      },
      down: (props) => {
        delete props.labelPosition;
      }
    }),
    {
      id: arrowShapeVersions.ExtractBindings,
      scope: "store",
      up: (oldStore) => {
        const arrows = Object.values(oldStore).filter(
          (r) => r.typeName === "shape" && r.type === "arrow"
        );
        for (const arrow2 of arrows) {
          const { start, end } = arrow2.props;
          if (start.type === "binding") {
            const id = createBindingId();
            const binding = {
              typeName: "binding",
              id,
              type: "arrow",
              fromId: arrow2.id,
              toId: start.boundShapeId,
              meta: {},
              props: {
                terminal: "start",
                normalizedAnchor: start.normalizedAnchor,
                isExact: start.isExact,
                isPrecise: start.isPrecise
              }
            };
            oldStore[id] = binding;
            arrow2.props.start = { x: 0, y: 0 };
          } else {
            delete arrow2.props.start.type;
          }
          if (end.type === "binding") {
            const id = createBindingId();
            const binding = {
              typeName: "binding",
              id,
              type: "arrow",
              fromId: arrow2.id,
              toId: end.boundShapeId,
              meta: {},
              props: {
                terminal: "end",
                normalizedAnchor: end.normalizedAnchor,
                isExact: end.isExact,
                isPrecise: end.isPrecise
              }
            };
            oldStore[id] = binding;
            arrow2.props.end = { x: 0, y: 0 };
          } else {
            delete arrow2.props.end.type;
          }
        }
      }
    },
    propsMigration({
      id: arrowShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }),
    propsMigration({
      id: arrowShapeVersions.AddElbow,
      up: (props) => {
        props.kind = "arc";
        props.elbowMidPoint = 0.5;
      },
      down: (props) => {
        delete props.kind;
        delete props.elbowMidPoint;
      }
    }),
    propsMigration({
      id: arrowShapeVersions.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    })
  ]
});
const ElbowArrowSnap = literalEnum("center", "edge-point", "edge", "none");
const arrowBindingProps = {
  terminal: literalEnum("start", "end"),
  normalizedAnchor: vecModelValidator,
  isExact: boolean,
  isPrecise: boolean,
  snap: ElbowArrowSnap
};
const arrowBindingVersions = createBindingPropsMigrationIds("arrow", {
  AddSnap: 1
});
const arrowBindingMigrations = createBindingPropsMigrationSequence({
  sequence: [
    { dependsOn: [arrowShapeVersions.ExtractBindings] },
    {
      id: arrowBindingVersions.AddSnap,
      up: (props) => {
        props.snap = "none";
      },
      down: (props) => {
        delete props.snap;
      }
    }
  ]
});
const cameraValidator = model(
  "camera",
  object({
    typeName: literal("camera"),
    id: idValidator("camera"),
    x: number,
    y: number,
    z: number,
    meta: jsonValue
  })
);
const cameraVersions = createMigrationIds("com.tldraw.camera", {
  AddMeta: 1
});
const cameraMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.camera",
  recordType: "camera",
  sequence: [
    {
      id: cameraVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
const CameraRecordType = createRecordType("camera", {
  validator: cameraValidator,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    z: 1,
    meta: {}
  })
);
const TL_CURSOR_TYPES = /* @__PURE__ */ new Set([
  "none",
  "default",
  "pointer",
  "cross",
  "grab",
  "rotate",
  "grabbing",
  "resize-edge",
  "resize-corner",
  "text",
  "move",
  "ew-resize",
  "ns-resize",
  "nesw-resize",
  "nwse-resize",
  "nesw-rotate",
  "nwse-rotate",
  "swne-rotate",
  "senw-rotate",
  "zoom-in",
  "zoom-out"
]);
const cursorTypeValidator = setEnum(TL_CURSOR_TYPES);
const cursorValidator = object({
  type: cursorTypeValidator,
  rotation: number
});
const TL_CANVAS_UI_COLOR_TYPES = /* @__PURE__ */ new Set([
  "accent",
  "white",
  "black",
  "selection-stroke",
  "selection-fill",
  "laser",
  "muted-1"
]);
const canvasUiColorTypeValidator = setEnum(TL_CANVAS_UI_COLOR_TYPES);
const TL_SCRIBBLE_STATES = /* @__PURE__ */ new Set(["starting", "paused", "active", "stopping"]);
const scribbleValidator = object({
  id: string,
  points: arrayOf(vecModelValidator),
  size: positiveNumber,
  color: canvasUiColorTypeValidator,
  opacity: number,
  state: setEnum(TL_SCRIBBLE_STATES),
  delay: number,
  shrink: number,
  taper: boolean
});
const pageIdValidator = idValidator("page");
const pageValidator = model(
  "page",
  object({
    typeName: literal("page"),
    id: pageIdValidator,
    name: string,
    index: indexKey,
    meta: jsonValue
  })
);
const pageVersions = createMigrationIds("com.tldraw.page", {
  AddMeta: 1
});
const pageMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.page",
  recordType: "page",
  sequence: [
    {
      id: pageVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
const PageRecordType = createRecordType("page", {
  validator: pageValidator,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
}));
function isPageId(id) {
  return PageRecordType.isId(id);
}
const shouldKeyBePreservedBetweenSessions = {
  // This object defines keys that should be preserved across calls to loadSnapshot()
  id: false,
  // meta
  typeName: false,
  // meta
  currentPageId: false,
  // does not preserve because who knows if the page still exists
  opacityForNextShape: false,
  // does not preserve because it's a temporary state
  stylesForNextShape: false,
  // does not preserve because it's a temporary state
  followingUserId: false,
  // does not preserve because it's a temporary state
  highlightedUserIds: false,
  // does not preserve because it's a temporary state
  brush: false,
  // does not preserve because it's a temporary state
  cursor: false,
  // does not preserve because it's a temporary state
  scribbles: false,
  // does not preserve because it's a temporary state
  isFocusMode: true,
  // preserves because it's a user preference
  isDebugMode: true,
  // preserves because it's a user preference
  isToolLocked: true,
  // preserves because it's a user preference
  exportBackground: true,
  // preserves because it's a user preference
  screenBounds: true,
  // preserves because it's capturing the user's screen state
  insets: true,
  // preserves because it's capturing the user's screen state
  zoomBrush: false,
  // does not preserve because it's a temporary state
  chatMessage: false,
  // does not preserve because it's a temporary state
  isChatting: false,
  // does not preserve because it's a temporary state
  isPenMode: false,
  // does not preserve because it's a temporary state
  isGridMode: true,
  // preserves because it's a user preference
  isFocused: true,
  // preserves because obviously
  devicePixelRatio: true,
  // preserves because it captures the user's screen state
  isCoarsePointer: true,
  // preserves because it captures the user's screen state
  isHoveringCanvas: false,
  // does not preserve because it's a temporary state
  openMenus: false,
  // does not preserve because it's a temporary state
  isChangingStyle: false,
  // does not preserve because it's a temporary state
  isReadonly: true,
  // preserves because it's a config option
  meta: false,
  // does not preserve because who knows what's in there, leave it up to sdk users to save and reinstate
  duplicateProps: false
  //
};
function pluckPreservingValues(val) {
  return val ? filterEntries(val, (key) => {
    return shouldKeyBePreservedBetweenSessions[key];
  }) : null;
}
idValidator("instance");
function createInstanceRecordType(stylesById) {
  const stylesForNextShapeValidators = {};
  for (const [id, style2] of stylesById) {
    stylesForNextShapeValidators[id] = optional(style2);
  }
  const instanceTypeValidator = model(
    "instance",
    object({
      typeName: literal("instance"),
      id: idValidator("instance"),
      currentPageId: pageIdValidator,
      followingUserId: string.nullable(),
      brush: boxModelValidator.nullable(),
      opacityForNextShape: opacityValidator,
      stylesForNextShape: object(stylesForNextShapeValidators),
      cursor: cursorValidator,
      scribbles: arrayOf(scribbleValidator),
      isFocusMode: boolean,
      isDebugMode: boolean,
      isToolLocked: boolean,
      exportBackground: boolean,
      screenBounds: boxModelValidator,
      insets: arrayOf(boolean),
      zoomBrush: boxModelValidator.nullable(),
      isPenMode: boolean,
      isGridMode: boolean,
      chatMessage: string,
      isChatting: boolean,
      highlightedUserIds: arrayOf(string),
      isFocused: boolean,
      devicePixelRatio: number,
      isCoarsePointer: boolean,
      isHoveringCanvas: boolean.nullable(),
      openMenus: arrayOf(string),
      isChangingStyle: boolean,
      isReadonly: boolean,
      meta: jsonValue,
      duplicateProps: object({
        shapeIds: arrayOf(idValidator("shape")),
        offset: object({
          x: number,
          y: number
        })
      }).nullable()
    })
  );
  return createRecordType("instance", {
    validator: instanceTypeValidator,
    scope: "session",
    ephemeralKeys: {
      currentPageId: false,
      meta: false,
      followingUserId: true,
      opacityForNextShape: true,
      stylesForNextShape: true,
      brush: true,
      cursor: true,
      scribbles: true,
      isFocusMode: true,
      isDebugMode: true,
      isToolLocked: true,
      exportBackground: true,
      screenBounds: true,
      insets: true,
      zoomBrush: true,
      isPenMode: true,
      isGridMode: true,
      chatMessage: true,
      isChatting: true,
      highlightedUserIds: true,
      isFocused: true,
      devicePixelRatio: true,
      isCoarsePointer: true,
      isHoveringCanvas: true,
      openMenus: true,
      isChangingStyle: true,
      isReadonly: true,
      duplicateProps: true
    }
  }).withDefaultProperties(
    () => ({
      followingUserId: null,
      opacityForNextShape: 1,
      stylesForNextShape: {},
      brush: null,
      scribbles: [],
      cursor: {
        type: "default",
        rotation: 0
      },
      isFocusMode: false,
      exportBackground: false,
      isDebugMode: false,
      isToolLocked: false,
      screenBounds: { x: 0, y: 0, w: 1080, h: 720 },
      insets: [false, false, false, false],
      zoomBrush: null,
      isGridMode: false,
      isPenMode: false,
      chatMessage: "",
      isChatting: false,
      highlightedUserIds: [],
      isFocused: false,
      devicePixelRatio: typeof window === "undefined" ? 1 : window.devicePixelRatio,
      isCoarsePointer: false,
      isHoveringCanvas: null,
      openMenus: [],
      isChangingStyle: false,
      isReadonly: false,
      meta: {},
      duplicateProps: null
    })
  );
}
const instanceVersions = createMigrationIds("com.tldraw.instance", {
  AddTransparentExportBgs: 1,
  RemoveDialog: 2,
  AddToolLockMode: 3,
  RemoveExtraPropsForNextShape: 4,
  AddLabelColor: 5,
  AddFollowingUserId: 6,
  RemoveAlignJustify: 7,
  AddZoom: 8,
  AddVerticalAlign: 9,
  AddScribbleDelay: 10,
  RemoveUserId: 11,
  AddIsPenModeAndIsGridMode: 12,
  HoistOpacity: 13,
  AddChat: 14,
  AddHighlightedUserIds: 15,
  ReplacePropsForNextShapeWithStylesForNextShape: 16,
  AddMeta: 17,
  RemoveCursorColor: 18,
  AddLonelyProperties: 19,
  ReadOnlyReadonly: 20,
  AddHoveringCanvas: 21,
  AddScribbles: 22,
  AddInset: 23,
  AddDuplicateProps: 24,
  RemoveCanMoveCamera: 25
});
const instanceMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance",
  recordType: "instance",
  sequence: [
    {
      id: instanceVersions.AddTransparentExportBgs,
      up: (instance) => {
        return { ...instance, exportBackground: true };
      }
    },
    {
      id: instanceVersions.RemoveDialog,
      up: ({ dialog: _, ...instance }) => {
        return instance;
      }
    },
    {
      id: instanceVersions.AddToolLockMode,
      up: (instance) => {
        return { ...instance, isToolLocked: false };
      }
    },
    {
      id: instanceVersions.RemoveExtraPropsForNextShape,
      up: ({ propsForNextShape, ...instance }) => {
        return {
          ...instance,
          propsForNextShape: Object.fromEntries(
            Object.entries(propsForNextShape).filter(
              ([key]) => [
                "color",
                "labelColor",
                "dash",
                "fill",
                "size",
                "font",
                "align",
                "verticalAlign",
                "icon",
                "geo",
                "arrowheadStart",
                "arrowheadEnd",
                "spline"
              ].includes(key)
            )
          )
        };
      }
    },
    {
      id: instanceVersions.AddLabelColor,
      up: ({ propsForNextShape, ...instance }) => {
        return {
          ...instance,
          propsForNextShape: {
            ...propsForNextShape,
            labelColor: "black"
          }
        };
      }
    },
    {
      id: instanceVersions.AddFollowingUserId,
      up: (instance) => {
        return { ...instance, followingUserId: null };
      }
    },
    {
      id: instanceVersions.RemoveAlignJustify,
      up: (instance) => {
        let newAlign = instance.propsForNextShape.align;
        if (newAlign === "justify") {
          newAlign = "start";
        }
        return {
          ...instance,
          propsForNextShape: {
            ...instance.propsForNextShape,
            align: newAlign
          }
        };
      }
    },
    {
      id: instanceVersions.AddZoom,
      up: (instance) => {
        return { ...instance, zoomBrush: null };
      }
    },
    {
      id: instanceVersions.AddVerticalAlign,
      up: (instance) => {
        return {
          ...instance,
          propsForNextShape: {
            ...instance.propsForNextShape,
            verticalAlign: "middle"
          }
        };
      }
    },
    {
      id: instanceVersions.AddScribbleDelay,
      up: (instance) => {
        if (instance.scribble !== null) {
          return { ...instance, scribble: { ...instance.scribble, delay: 0 } };
        }
        return { ...instance };
      }
    },
    {
      id: instanceVersions.RemoveUserId,
      up: ({ userId: _, ...instance }) => {
        return instance;
      }
    },
    {
      id: instanceVersions.AddIsPenModeAndIsGridMode,
      up: (instance) => {
        return { ...instance, isPenMode: false, isGridMode: false };
      }
    },
    {
      id: instanceVersions.HoistOpacity,
      up: ({ propsForNextShape: { opacity, ...propsForNextShape }, ...instance }) => {
        return { ...instance, opacityForNextShape: Number(opacity ?? "1"), propsForNextShape };
      }
    },
    {
      id: instanceVersions.AddChat,
      up: (instance) => {
        return { ...instance, chatMessage: "", isChatting: false };
      }
    },
    {
      id: instanceVersions.AddHighlightedUserIds,
      up: (instance) => {
        return { ...instance, highlightedUserIds: [] };
      }
    },
    {
      id: instanceVersions.ReplacePropsForNextShapeWithStylesForNextShape,
      up: ({ propsForNextShape: _, ...instance }) => {
        return { ...instance, stylesForNextShape: {} };
      }
    },
    {
      id: instanceVersions.AddMeta,
      up: (record) => {
        return {
          ...record,
          meta: {}
        };
      }
    },
    {
      id: instanceVersions.RemoveCursorColor,
      up: (record) => {
        const { color: _, ...cursor } = record.cursor;
        return {
          ...record,
          cursor
        };
      }
    },
    {
      id: instanceVersions.AddLonelyProperties,
      up: (record) => {
        return {
          ...record,
          canMoveCamera: true,
          isFocused: false,
          devicePixelRatio: 1,
          isCoarsePointer: false,
          openMenus: [],
          isChangingStyle: false,
          isReadOnly: false
        };
      }
    },
    {
      id: instanceVersions.ReadOnlyReadonly,
      up: ({ isReadOnly: _isReadOnly, ...record }) => {
        return {
          ...record,
          isReadonly: _isReadOnly
        };
      }
    },
    {
      id: instanceVersions.AddHoveringCanvas,
      up: (record) => {
        return {
          ...record,
          isHoveringCanvas: null
        };
      }
    },
    {
      id: instanceVersions.AddScribbles,
      up: ({ scribble: _, ...record }) => {
        return {
          ...record,
          scribbles: []
        };
      }
    },
    {
      id: instanceVersions.AddInset,
      up: (record) => {
        return {
          ...record,
          insets: [false, false, false, false]
        };
      },
      down: ({ insets: _, ...record }) => {
        return {
          ...record
        };
      }
    },
    {
      id: instanceVersions.AddDuplicateProps,
      up: (record) => {
        return {
          ...record,
          duplicateProps: null
        };
      },
      down: ({ duplicateProps: _, ...record }) => {
        return {
          ...record
        };
      }
    },
    {
      id: instanceVersions.RemoveCanMoveCamera,
      up: ({ canMoveCamera: _, ...record }) => {
        return {
          ...record
        };
      },
      down: (instance) => {
        return { ...instance, canMoveCamera: true };
      }
    }
  ]
});
const TLINSTANCE_ID = "instance:instance";
const instancePageStateValidator = model(
  "instance_page_state",
  object({
    typeName: literal("instance_page_state"),
    id: idValidator("instance_page_state"),
    pageId: pageIdValidator,
    selectedShapeIds: arrayOf(shapeIdValidator),
    hintingShapeIds: arrayOf(shapeIdValidator),
    erasingShapeIds: arrayOf(shapeIdValidator),
    hoveredShapeId: shapeIdValidator.nullable(),
    editingShapeId: shapeIdValidator.nullable(),
    croppingShapeId: shapeIdValidator.nullable(),
    focusedGroupId: shapeIdValidator.nullable(),
    meta: jsonValue
  })
);
const instancePageStateVersions = createMigrationIds("com.tldraw.instance_page_state", {
  AddCroppingId: 1,
  RemoveInstanceIdAndCameraId: 2,
  AddMeta: 3,
  RenameProperties: 4,
  RenamePropertiesAgain: 5
});
const instancePageStateMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance_page_state",
  recordType: "instance_page_state",
  sequence: [
    {
      id: instancePageStateVersions.AddCroppingId,
      up(instance) {
        instance.croppingShapeId = null;
      }
    },
    {
      id: instancePageStateVersions.RemoveInstanceIdAndCameraId,
      up(instance) {
        delete instance.instanceId;
        delete instance.cameraId;
      }
    },
    {
      id: instancePageStateVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: instancePageStateVersions.RenameProperties,
      // this migration is cursed: it was written wrong and doesn't do anything.
      // rather than replace it, I've added another migration below that fixes it.
      up: (_record) => {
      },
      down: (_record) => {
      }
    },
    {
      id: instancePageStateVersions.RenamePropertiesAgain,
      up: (record) => {
        record.selectedShapeIds = record.selectedIds;
        delete record.selectedIds;
        record.hintingShapeIds = record.hintingIds;
        delete record.hintingIds;
        record.erasingShapeIds = record.erasingIds;
        delete record.erasingIds;
        record.hoveredShapeId = record.hoveredId;
        delete record.hoveredId;
        record.editingShapeId = record.editingId;
        delete record.editingId;
        record.croppingShapeId = record.croppingShapeId ?? record.croppingId ?? null;
        delete record.croppingId;
        record.focusedGroupId = record.focusLayerId;
        delete record.focusLayerId;
      },
      down: (record) => {
        record.selectedIds = record.selectedShapeIds;
        delete record.selectedShapeIds;
        record.hintingIds = record.hintingShapeIds;
        delete record.hintingShapeIds;
        record.erasingIds = record.erasingShapeIds;
        delete record.erasingShapeIds;
        record.hoveredId = record.hoveredShapeId;
        delete record.hoveredShapeId;
        record.editingId = record.editingShapeId;
        delete record.editingShapeId;
        record.croppingId = record.croppingShapeId;
        delete record.croppingShapeId;
        record.focusLayerId = record.focusedGroupId;
        delete record.focusedGroupId;
      }
    }
  ]
});
const InstancePageStateRecordType = createRecordType(
  "instance_page_state",
  {
    validator: instancePageStateValidator,
    scope: "session",
    ephemeralKeys: {
      pageId: false,
      selectedShapeIds: false,
      editingShapeId: false,
      croppingShapeId: false,
      meta: false,
      hintingShapeIds: true,
      erasingShapeIds: true,
      hoveredShapeId: true,
      focusedGroupId: true
    }
  }
).withDefaultProperties(
  () => ({
    editingShapeId: null,
    croppingShapeId: null,
    selectedShapeIds: [],
    hoveredShapeId: null,
    erasingShapeIds: [],
    hintingShapeIds: [],
    focusedGroupId: null,
    meta: {}
  })
);
const pointerValidator = model(
  "pointer",
  object({
    typeName: literal("pointer"),
    id: idValidator("pointer"),
    x: number,
    y: number,
    lastActivityTimestamp: number,
    meta: jsonValue
  })
);
const pointerVersions = createMigrationIds("com.tldraw.pointer", {
  AddMeta: 1
});
const pointerMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.pointer",
  recordType: "pointer",
  sequence: [
    {
      id: pointerVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
const PointerRecordType = createRecordType("pointer", {
  validator: pointerValidator,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    lastActivityTimestamp: 0,
    meta: {}
  })
);
const TLPOINTER_ID = PointerRecordType.createId("pointer");
const instancePresenceValidator = model(
  "instance_presence",
  object({
    typeName: literal("instance_presence"),
    id: idValidator("instance_presence"),
    userId: string,
    userName: string,
    lastActivityTimestamp: number.nullable(),
    followingUserId: string.nullable(),
    cursor: object({
      x: number,
      y: number,
      type: cursorTypeValidator,
      rotation: number
    }).nullable(),
    color: string,
    camera: object({
      x: number,
      y: number,
      z: number
    }).nullable(),
    screenBounds: boxModelValidator.nullable(),
    selectedShapeIds: arrayOf(idValidator("shape")),
    currentPageId: idValidator("page"),
    brush: boxModelValidator.nullable(),
    scribbles: arrayOf(scribbleValidator),
    chatMessage: string,
    meta: jsonValue
  })
);
const instancePresenceVersions = createMigrationIds("com.tldraw.instance_presence", {
  AddScribbleDelay: 1,
  RemoveInstanceId: 2,
  AddChatMessage: 3,
  AddMeta: 4,
  RenameSelectedShapeIds: 5,
  NullableCameraCursor: 6
});
const instancePresenceMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance_presence",
  recordType: "instance_presence",
  sequence: [
    {
      id: instancePresenceVersions.AddScribbleDelay,
      up: (instance) => {
        if (instance.scribble !== null) {
          instance.scribble.delay = 0;
        }
      }
    },
    {
      id: instancePresenceVersions.RemoveInstanceId,
      up: (instance) => {
        delete instance.instanceId;
      }
    },
    {
      id: instancePresenceVersions.AddChatMessage,
      up: (instance) => {
        instance.chatMessage = "";
      }
    },
    {
      id: instancePresenceVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: instancePresenceVersions.RenameSelectedShapeIds,
      up: (_record) => {
      }
    },
    {
      id: instancePresenceVersions.NullableCameraCursor,
      up: (_record) => {
      },
      down: (record) => {
        if (record.camera === null) {
          record.camera = { x: 0, y: 0, z: 1 };
        }
        if (record.lastActivityTimestamp === null) {
          record.lastActivityTimestamp = 0;
        }
        if (record.cursor === null) {
          record.cursor = { type: "default", x: 0, y: 0, rotation: 0 };
        }
        if (record.screenBounds === null) {
          record.screenBounds = { x: 0, y: 0, w: 1, h: 1 };
        }
      }
    }
  ]
});
const InstancePresenceRecordType = createRecordType(
  "instance_presence",
  {
    validator: instancePresenceValidator,
    scope: "presence"
  }
).withDefaultProperties(() => ({
  lastActivityTimestamp: null,
  followingUserId: null,
  color: "#FF0000",
  camera: null,
  cursor: null,
  screenBounds: null,
  selectedShapeIds: [],
  brush: null,
  scribbles: [],
  chatMessage: "",
  meta: {}
}));
const documentValidator = model(
  "document",
  object({
    typeName: literal("document"),
    id: literal("document:document"),
    gridSize: number,
    name: string,
    meta: jsonValue
  })
);
const documentVersions = createMigrationIds("com.tldraw.document", {
  AddName: 1,
  AddMeta: 2
});
const documentMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.document",
  recordType: "document",
  sequence: [
    {
      id: documentVersions.AddName,
      up: (document2) => {
        document2.name = "";
      },
      down: (document2) => {
        delete document2.name;
      }
    },
    {
      id: documentVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
const DocumentRecordType = createRecordType("document", {
  validator: documentValidator,
  scope: "document"
}).withDefaultProperties(
  () => ({
    gridSize: 10,
    name: "",
    meta: {}
  })
);
const TLDOCUMENT_ID = DocumentRecordType.createId("document");
function redactRecordForErrorReporting(record) {
  if (record.typeName === "asset") {
    if ("src" in record) {
      record.src = "<redacted>";
    }
    if ("src" in record.props) {
      record.props.src = "<redacted>";
    }
  }
}
function onValidationFailure({
  error,
  phase,
  record,
  recordBefore
}) {
  const isExistingValidationIssue = (
    // if we're initializing the store for the first time, we should
    // allow invalid records so people can load old buggy data:
    phase === "initialize"
  );
  annotateError(error, {
    tags: {
      origin: "store.validateRecord",
      storePhase: phase,
      isExistingValidationIssue
    },
    extras: {
      recordBefore: recordBefore ? redactRecordForErrorReporting(structuredClone(recordBefore)) : void 0,
      recordAfter: redactRecordForErrorReporting(structuredClone(record))
    }
  });
  throw error;
}
function getDefaultPages() {
  return [
    PageRecordType.create({
      id: "page:page",
      name: "Page 1",
      index: "a1",
      meta: {}
    })
  ];
}
function createIntegrityChecker(store) {
  const $pageIds = store.query.ids("page");
  const $pageStates = store.query.records("instance_page_state");
  const ensureStoreIsUsable = () => {
    if (!store.has(TLDOCUMENT_ID)) {
      store.put([DocumentRecordType.create({ id: TLDOCUMENT_ID, name: store.props.defaultName })]);
      return ensureStoreIsUsable();
    }
    if (!store.has(TLPOINTER_ID)) {
      store.put([PointerRecordType.create({ id: TLPOINTER_ID })]);
      return ensureStoreIsUsable();
    }
    const pageIds = $pageIds.get();
    if (pageIds.size === 0) {
      store.put(getDefaultPages());
      return ensureStoreIsUsable();
    }
    const getFirstPageId = () => [...pageIds].map((id) => store.get(id)).sort(sortByIndex)[0].id;
    const instanceState = store.get(TLINSTANCE_ID);
    if (!instanceState) {
      store.put([
        store.schema.types.instance.create({
          id: TLINSTANCE_ID,
          currentPageId: getFirstPageId(),
          exportBackground: true
        })
      ]);
      return ensureStoreIsUsable();
    } else if (!pageIds.has(instanceState.currentPageId)) {
      store.put([{ ...instanceState, currentPageId: getFirstPageId() }]);
      return ensureStoreIsUsable();
    }
    const missingPageStateIds = /* @__PURE__ */ new Set();
    const missingCameraIds = /* @__PURE__ */ new Set();
    for (const id of pageIds) {
      const pageStateId = InstancePageStateRecordType.createId(id);
      const pageState = store.get(pageStateId);
      if (!pageState) {
        missingPageStateIds.add(pageStateId);
      }
      const cameraId = CameraRecordType.createId(id);
      if (!store.has(cameraId)) {
        missingCameraIds.add(cameraId);
      }
    }
    if (missingPageStateIds.size > 0) {
      store.put(
        [...missingPageStateIds].map(
          (id) => InstancePageStateRecordType.create({
            id,
            pageId: InstancePageStateRecordType.parseId(id)
          })
        )
      );
    }
    if (missingCameraIds.size > 0) {
      store.put([...missingCameraIds].map((id) => CameraRecordType.create({ id })));
    }
    const pageStates = $pageStates.get();
    for (const pageState of pageStates) {
      if (!pageIds.has(pageState.pageId)) {
        store.remove([pageState.id]);
        continue;
      }
      if (pageState.croppingShapeId && !store.has(pageState.croppingShapeId)) {
        store.put([{ ...pageState, croppingShapeId: null }]);
        return ensureStoreIsUsable();
      }
      if (pageState.focusedGroupId && !store.has(pageState.focusedGroupId)) {
        store.put([{ ...pageState, focusedGroupId: null }]);
        return ensureStoreIsUsable();
      }
      if (pageState.hoveredShapeId && !store.has(pageState.hoveredShapeId)) {
        store.put([{ ...pageState, hoveredShapeId: null }]);
        return ensureStoreIsUsable();
      }
      const filteredSelectedIds = pageState.selectedShapeIds.filter((id) => store.has(id));
      if (filteredSelectedIds.length !== pageState.selectedShapeIds.length) {
        store.put([{ ...pageState, selectedShapeIds: filteredSelectedIds }]);
        return ensureStoreIsUsable();
      }
      const filteredHintingIds = pageState.hintingShapeIds.filter((id) => store.has(id));
      if (filteredHintingIds.length !== pageState.hintingShapeIds.length) {
        store.put([{ ...pageState, hintingShapeIds: filteredHintingIds }]);
        return ensureStoreIsUsable();
      }
      const filteredErasingIds = pageState.erasingShapeIds.filter((id) => store.has(id));
      if (filteredErasingIds.length !== pageState.erasingShapeIds.length) {
        store.put([{ ...pageState, erasingShapeIds: filteredErasingIds }]);
        return ensureStoreIsUsable();
      }
    }
  };
  return ensureStoreIsUsable;
}
const bookmarkAssetValidator = createAssetValidator(
  "bookmark",
  object({
    title: string,
    description: string,
    image: string,
    favicon: string,
    src: srcUrl.nullable()
  })
);
const Versions$e = createMigrationIds("com.tldraw.asset.bookmark", {
  MakeUrlsValid: 1,
  AddFavicon: 2
});
const bookmarkAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.bookmark",
  recordType: "asset",
  filter: (asset) => asset.type === "bookmark",
  sequence: [
    {
      id: Versions$e.MakeUrlsValid,
      up: (asset) => {
        if (!srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions$e.AddFavicon,
      up: (asset) => {
        if (!srcUrl.isValid(asset.props.favicon)) {
          asset.props.favicon = "";
        }
      },
      down: (asset) => {
        delete asset.props.favicon;
      }
    }
  ]
});
const imageAssetValidator = createAssetValidator(
  "image",
  object({
    w: number,
    h: number,
    name: string,
    isAnimated: boolean,
    mimeType: string.nullable(),
    src: srcUrl.nullable(),
    fileSize: nonZeroNumber.optional()
  })
);
const Versions$d = createMigrationIds("com.tldraw.asset.image", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
});
const imageAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.image",
  recordType: "asset",
  filter: (asset) => asset.type === "image",
  sequence: [
    {
      id: Versions$d.AddIsAnimated,
      up: (asset) => {
        asset.props.isAnimated = false;
      },
      down: (asset) => {
        delete asset.props.isAnimated;
      }
    },
    {
      id: Versions$d.RenameWidthHeight,
      up: (asset) => {
        asset.props.w = asset.props.width;
        asset.props.h = asset.props.height;
        delete asset.props.width;
        delete asset.props.height;
      },
      down: (asset) => {
        asset.props.width = asset.props.w;
        asset.props.height = asset.props.h;
        delete asset.props.w;
        delete asset.props.h;
      }
    },
    {
      id: Versions$d.MakeUrlsValid,
      up: (asset) => {
        if (!srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions$d.AddFileSize,
      up: (asset) => {
        asset.props.fileSize = -1;
      },
      down: (asset) => {
        delete asset.props.fileSize;
      }
    },
    {
      id: Versions$d.MakeFileSizeOptional,
      up: (asset) => {
        if (asset.props.fileSize === -1) {
          asset.props.fileSize = void 0;
        }
      },
      down: (asset) => {
        if (asset.props.fileSize === void 0) {
          asset.props.fileSize = -1;
        }
      }
    }
  ]
});
const videoAssetValidator = createAssetValidator(
  "video",
  object({
    w: number,
    h: number,
    name: string,
    isAnimated: boolean,
    mimeType: string.nullable(),
    src: srcUrl.nullable(),
    fileSize: number.optional()
  })
);
const Versions$c = createMigrationIds("com.tldraw.asset.video", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
});
const videoAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.video",
  recordType: "asset",
  filter: (asset) => asset.type === "video",
  sequence: [
    {
      id: Versions$c.AddIsAnimated,
      up: (asset) => {
        asset.props.isAnimated = false;
      },
      down: (asset) => {
        delete asset.props.isAnimated;
      }
    },
    {
      id: Versions$c.RenameWidthHeight,
      up: (asset) => {
        asset.props.w = asset.props.width;
        asset.props.h = asset.props.height;
        delete asset.props.width;
        delete asset.props.height;
      },
      down: (asset) => {
        asset.props.width = asset.props.w;
        asset.props.height = asset.props.h;
        delete asset.props.w;
        delete asset.props.h;
      }
    },
    {
      id: Versions$c.MakeUrlsValid,
      up: (asset) => {
        if (!srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions$c.AddFileSize,
      up: (asset) => {
        asset.props.fileSize = -1;
      },
      down: (asset) => {
        delete asset.props.fileSize;
      }
    },
    {
      id: Versions$c.MakeFileSizeOptional,
      up: (asset) => {
        if (asset.props.fileSize === -1) {
          asset.props.fileSize = void 0;
        }
      },
      down: (asset) => {
        if (asset.props.fileSize === void 0) {
          asset.props.fileSize = -1;
        }
      }
    }
  ]
});
const assetValidator = model(
  "asset",
  union("type", {
    image: imageAssetValidator,
    video: videoAssetValidator,
    bookmark: bookmarkAssetValidator
  })
);
const assetVersions = createMigrationIds("com.tldraw.asset", {
  AddMeta: 1
});
const assetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset",
  recordType: "asset",
  sequence: [
    {
      id: assetVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
const AssetRecordType = createRecordType("asset", {
  validator: assetValidator,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
}));
const bookmarkShapeProps = {
  w: nonZeroNumber,
  h: nonZeroNumber,
  assetId: assetIdValidator.nullable(),
  url: linkUrl
};
const Versions$b = createShapePropsMigrationIds("bookmark", {
  NullAssetId: 1,
  MakeUrlsValid: 2
});
const bookmarkShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$b.NullAssetId,
      up: (props) => {
        if (props.assetId === void 0) {
          props.assetId = null;
        }
      },
      down: "retired"
    },
    {
      id: Versions$b.MakeUrlsValid,
      up: (props) => {
        if (!linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    }
  ]
});
const DrawShapeSegment = object({
  type: literalEnum("free", "straight"),
  points: arrayOf(vecModelValidator)
});
const drawShapeProps = {
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  segments: arrayOf(DrawShapeSegment),
  isComplete: boolean,
  isClosed: boolean,
  isPen: boolean,
  scale: nonZeroNumber
};
const Versions$a = createShapePropsMigrationIds("draw", {
  AddInPen: 1,
  AddScale: 2
});
const drawShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$a.AddInPen,
      up: (props) => {
        const { points } = props.segments[0];
        if (points.length === 0) {
          props.isPen = false;
          return;
        }
        let isPen = !(points[0].z === 0 || points[0].z === 0.5);
        if (points[1]) {
          isPen = isPen && !(points[1].z === 0 || points[1].z === 0.5);
        }
        props.isPen = isPen;
      },
      down: "retired"
    },
    {
      id: Versions$a.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }
  ]
});
const TLDRAW_APP_RE$1 = /(^\/r\/[^/]+\/?$)/;
const EMBED_DEFINITIONS = [
  {
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE$1)) {
        return url;
      }
      return;
    }
  },
  {
    hostnames: ["figma.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/?$/)) {
        const outUrl = urlObj.searchParams.get("url");
        if (outUrl) {
          return outUrl;
        }
      }
      return;
    }
  },
  {
    hostnames: ["google.*"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const matches2 = urlObj.pathname.match(/^\/maps\/embed\/v1\/view\/?$/);
      if (matches2 && urlObj.searchParams.has("center") && urlObj.searchParams.get("zoom")) {
        const zoom = urlObj.searchParams.get("zoom");
        const [lat, lon] = urlObj.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${lat},${lon},${zoom}z`;
      }
      return;
    }
  },
  {
    hostnames: ["val.town"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/v/${matches2[1]}`;
      }
      return;
    }
  },
  {
    hostnames: ["codesandbox.io"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/s/${matches2[1]}`;
      }
      return;
    }
  },
  {
    hostnames: ["codepen.io"],
    fromEmbedUrl: (url) => {
      const CODEPEN_EMBED_REGEXP = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/;
      const matches2 = url.match(CODEPEN_EMBED_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/pen/${id}`;
      }
      return;
    }
  },
  {
    hostnames: ["scratch.mit.edu"],
    fromEmbedUrl: (url) => {
      const SCRATCH_EMBED_REGEXP = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/;
      const matches2 = url.match(SCRATCH_EMBED_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/${id}`;
      }
      return;
    }
  },
  {
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtube.com") {
        const matches2 = urlObj.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (matches2) {
          return `https://www.youtube.com/watch?v=${matches2[1]}`;
        }
      }
      return;
    }
  },
  {
    hostnames: ["calendar.google.*"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const srcQs = urlObj?.searchParams.get("src");
      if (urlObj?.pathname.match(/\/calendar\/embed/) && srcQs) {
        urlObj.pathname = "/calendar/u/0";
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("cid", srcQs);
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["docs.google.*"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj?.pathname.match(/^\/presentation/) && urlObj?.pathname.match(/\/embed\/?$/)) {
        urlObj.pathname = urlObj.pathname.replace(/\/embed$/, "/pub");
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["gist.github.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([^/]+)/)) {
        if (!url.split("/").pop()) return;
        return url;
      }
      return;
    }
  },
  {
    hostnames: ["replit.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/) && urlObj.searchParams.has("embed")) {
        urlObj.searchParams.delete("embed");
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["felt.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/map\//)) {
        urlObj.pathname = urlObj.pathname.replace(/^\/embed/, "");
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["open.spotify.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/(artist|album)\//)) {
        return urlObj.origin + urlObj.pathname.replace(/^\/embed/, "");
      }
      return;
    }
  },
  {
    hostnames: ["vimeo.com", "player.vimeo.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "player.vimeo.com") {
        const matches2 = urlObj.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (matches2) {
          return "https://vimeo.com/" + matches2[1];
        }
      }
      return;
    }
  },
  {
    hostnames: ["observablehq.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "")}#cell-*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/embed\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "/d")}#cell-*`;
      }
      return;
    }
  },
  {
    hostnames: ["desmos.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "?embed" && urlObj.hash === "") {
        return url.replace("?embed", "");
      }
      return;
    }
  }
];
const embedShapeProps = {
  w: nonZeroNumber,
  h: nonZeroNumber,
  url: string
};
const Versions$9 = createShapePropsMigrationIds("embed", {
  GenOriginalUrlInEmbed: 1,
  RemoveDoesResize: 2,
  RemoveTmpOldUrl: 3,
  RemovePermissionOverrides: 4
});
const embedShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$9.GenOriginalUrlInEmbed,
      // add tmpOldUrl property
      up: (props) => {
        try {
          const url = props.url;
          const host = new URL(url).host.replace("www.", "");
          let originalUrl;
          for (const localEmbedDef of EMBED_DEFINITIONS) {
            if (localEmbedDef.hostnames.includes(host)) {
              try {
                originalUrl = localEmbedDef.fromEmbedUrl(url);
              } catch (err) {
                console.warn(err);
              }
            }
          }
          props.tmpOldUrl = props.url;
          props.url = originalUrl ?? "";
        } catch {
          props.url = "";
          props.tmpOldUrl = props.url;
        }
      },
      down: "retired"
    },
    {
      id: Versions$9.RemoveDoesResize,
      up: (props) => {
        delete props.doesResize;
      },
      down: "retired"
    },
    {
      id: Versions$9.RemoveTmpOldUrl,
      up: (props) => {
        delete props.tmpOldUrl;
      },
      down: "retired"
    },
    {
      id: Versions$9.RemovePermissionOverrides,
      up: (props) => {
        delete props.overridePermissions;
      },
      down: "retired"
    }
  ]
});
const frameShapeProps = {
  w: nonZeroNumber,
  h: nonZeroNumber,
  name: string,
  // because shape colors are an option, we don't want them to be picked up by the editor as a
  // style prop by default, so instead of a proper style we just supply an equivalent validator.
  // Check `FrameShapeUtil.configure` for how we replace this with the original
  // `DefaultColorStyle` style when the option is turned on.
  color: literalEnum(...DefaultColorStyle.values)
};
const Versions$8 = createShapePropsMigrationIds("frame", {
  AddColorProp: 1
});
const frameShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$8.AddColorProp,
      up: (props) => {
        props.color = "black";
      },
      down: (props) => {
        delete props.color;
      }
    }
  ]
});
const DefaultHorizontalAlignStyle = StyleProp.defineEnum("tldraw:horizontalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end", "start-legacy", "end-legacy", "middle-legacy"]
});
const DefaultVerticalAlignStyle = StyleProp.defineEnum("tldraw:verticalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end"]
});
const GeoShapeGeoStyle = StyleProp.defineEnum("tldraw:geo", {
  defaultValue: "rectangle",
  values: [
    "cloud",
    "rectangle",
    "ellipse",
    "triangle",
    "diamond",
    "pentagon",
    "hexagon",
    "octagon",
    "star",
    "rhombus",
    "rhombus-2",
    "oval",
    "trapezoid",
    "arrow-right",
    "arrow-left",
    "arrow-up",
    "arrow-down",
    "x-box",
    "check-box",
    "heart"
  ]
});
const geoShapeProps = {
  geo: GeoShapeGeoStyle,
  dash: DefaultDashStyle,
  url: linkUrl,
  w: nonZeroNumber,
  h: nonZeroNumber,
  growY: positiveNumber,
  scale: nonZeroNumber,
  // Text properties
  labelColor: DefaultLabelColorStyle,
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  align: DefaultHorizontalAlignStyle,
  verticalAlign: DefaultVerticalAlignStyle,
  richText: richTextValidator
};
const geoShapeVersions = createShapePropsMigrationIds("geo", {
  AddUrlProp: 1,
  AddLabelColor: 2,
  RemoveJustify: 3,
  AddCheckBox: 4,
  AddVerticalAlign: 5,
  MigrateLegacyAlign: 6,
  AddCloud: 7,
  MakeUrlsValid: 8,
  AddScale: 9,
  AddRichText: 10
});
const geoShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: geoShapeVersions.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddCheckBox,
      up: (_props) => {
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddVerticalAlign,
      up: (props) => {
        props.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.MigrateLegacyAlign,
      up: (props) => {
        let newAlign;
        switch (props.align) {
          case "start":
            newAlign = "start-legacy";
            break;
          case "end":
            newAlign = "end-legacy";
            break;
          default:
            newAlign = "middle-legacy";
            break;
        }
        props.align = newAlign;
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddCloud,
      up: (_props) => {
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.MakeUrlsValid,
      up: (props) => {
        if (!linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: geoShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    },
    {
      id: geoShapeVersions.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
});
const groupShapeProps = {};
const groupShapeMigrations = createShapePropsMigrationSequence({ sequence: [] });
const highlightShapeProps = {
  color: DefaultColorStyle,
  size: DefaultSizeStyle,
  segments: arrayOf(DrawShapeSegment),
  isComplete: boolean,
  isPen: boolean,
  scale: nonZeroNumber
};
const Versions$7 = createShapePropsMigrationIds("highlight", {
  AddScale: 1
});
const highlightShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$7.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }
  ]
});
const ImageShapeCrop = object({
  topLeft: vecModelValidator,
  bottomRight: vecModelValidator,
  isCircle: boolean.optional()
});
const imageShapeProps = {
  w: nonZeroNumber,
  h: nonZeroNumber,
  playing: boolean,
  url: linkUrl,
  assetId: assetIdValidator.nullable(),
  crop: ImageShapeCrop.nullable(),
  flipX: boolean,
  flipY: boolean,
  altText: string
};
const Versions$6 = createShapePropsMigrationIds("image", {
  AddUrlProp: 1,
  AddCropProp: 2,
  MakeUrlsValid: 3,
  AddFlipProps: 4,
  AddAltText: 5
});
const imageShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$6.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions$6.AddCropProp,
      up: (props) => {
        props.crop = null;
      },
      down: (props) => {
        delete props.crop;
      }
    },
    {
      id: Versions$6.MakeUrlsValid,
      up: (props) => {
        if (!linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions$6.AddFlipProps,
      up: (props) => {
        props.flipX = false;
        props.flipY = false;
      },
      down: (props) => {
        delete props.flipX;
        delete props.flipY;
      }
    },
    {
      id: Versions$6.AddAltText,
      up: (props) => {
        props.altText = "";
      },
      down: (props) => {
        delete props.altText;
      }
    }
  ]
});
const LineShapeSplineStyle = StyleProp.defineEnum("tldraw:spline", {
  defaultValue: "line",
  values: ["cubic", "line"]
});
const lineShapePointValidator = object({
  id: string,
  index: indexKey,
  x: number,
  y: number
});
const lineShapeProps = {
  color: DefaultColorStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  spline: LineShapeSplineStyle,
  points: dict(string, lineShapePointValidator),
  scale: nonZeroNumber
};
const lineShapeVersions = createShapePropsMigrationIds("line", {
  AddSnapHandles: 1,
  RemoveExtraHandleProps: 2,
  HandlesToPoints: 3,
  PointIndexIds: 4,
  AddScale: 5
});
const lineShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: lineShapeVersions.AddSnapHandles,
      up: (props) => {
        for (const handle of Object.values(props.handles)) {
          handle.canSnap = true;
        }
      },
      down: "retired"
    },
    {
      id: lineShapeVersions.RemoveExtraHandleProps,
      up: (props) => {
        props.handles = objectMapFromEntries(
          Object.values(props.handles).map((handle) => [
            handle.index,
            {
              x: handle.x,
              y: handle.y
            }
          ])
        );
      },
      down: (props) => {
        const handles = Object.entries(props.handles).map(([index2, handle]) => ({ index: index2, ...handle })).sort(sortByIndex);
        props.handles = Object.fromEntries(
          handles.map((handle, i) => {
            const id = i === 0 ? "start" : i === handles.length - 1 ? "end" : `handle:${handle.index}`;
            return [
              id,
              {
                id,
                type: "vertex",
                canBind: false,
                canSnap: true,
                index: handle.index,
                x: handle.x,
                y: handle.y
              }
            ];
          })
        );
      }
    },
    {
      id: lineShapeVersions.HandlesToPoints,
      up: (props) => {
        const sortedHandles = Object.entries(props.handles).map(([index2, { x, y }]) => ({ x, y, index: index2 })).sort(sortByIndex);
        props.points = sortedHandles.map(({ x, y }) => ({ x, y }));
        delete props.handles;
      },
      down: (props) => {
        const indices = getIndices(props.points.length);
        props.handles = Object.fromEntries(
          props.points.map((handle, i) => {
            const index2 = indices[i];
            return [
              index2,
              {
                x: handle.x,
                y: handle.y
              }
            ];
          })
        );
        delete props.points;
      }
    },
    {
      id: lineShapeVersions.PointIndexIds,
      up: (props) => {
        const indices = getIndices(props.points.length);
        props.points = Object.fromEntries(
          props.points.map((point, i) => {
            const id = indices[i];
            return [
              id,
              {
                id,
                index: id,
                x: point.x,
                y: point.y
              }
            ];
          })
        );
      },
      down: (props) => {
        const sortedHandles = Object.values(props.points).sort(sortByIndex);
        props.points = sortedHandles.map(({ x, y }) => ({ x, y }));
      }
    },
    {
      id: lineShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }
  ]
});
const noteShapeProps = {
  color: DefaultColorStyle,
  labelColor: DefaultLabelColorStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  fontSizeAdjustment: positiveNumber,
  align: DefaultHorizontalAlignStyle,
  verticalAlign: DefaultVerticalAlignStyle,
  growY: positiveNumber,
  url: linkUrl,
  richText: richTextValidator,
  scale: nonZeroNumber
};
const Versions$5 = createShapePropsMigrationIds("note", {
  AddUrlProp: 1,
  RemoveJustify: 2,
  MigrateLegacyAlign: 3,
  AddVerticalAlign: 4,
  MakeUrlsValid: 5,
  AddFontSizeAdjustment: 6,
  AddScale: 7,
  AddLabelColor: 8,
  AddRichText: 9
});
const noteShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$5.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions$5.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: Versions$5.MigrateLegacyAlign,
      up: (props) => {
        switch (props.align) {
          case "start":
            props.align = "start-legacy";
            return;
          case "end":
            props.align = "end-legacy";
            return;
          default:
            props.align = "middle-legacy";
            return;
        }
      },
      down: "retired"
    },
    {
      id: Versions$5.AddVerticalAlign,
      up: (props) => {
        props.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: Versions$5.MakeUrlsValid,
      up: (props) => {
        if (!linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions$5.AddFontSizeAdjustment,
      up: (props) => {
        props.fontSizeAdjustment = 0;
      },
      down: (props) => {
        delete props.fontSizeAdjustment;
      }
    },
    {
      id: Versions$5.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    },
    {
      id: Versions$5.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: (props) => {
        delete props.labelColor;
      }
    },
    {
      id: Versions$5.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
});
const DefaultTextAlignStyle = StyleProp.defineEnum("tldraw:textAlign", {
  defaultValue: "start",
  values: ["start", "middle", "end"]
});
const textShapeProps = {
  color: DefaultColorStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  textAlign: DefaultTextAlignStyle,
  w: nonZeroNumber,
  richText: richTextValidator,
  scale: nonZeroNumber,
  autoSize: boolean
};
const Versions$4 = createShapePropsMigrationIds("text", {
  RemoveJustify: 1,
  AddTextAlign: 2,
  AddRichText: 3
});
const textShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$4.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: Versions$4.AddTextAlign,
      up: (props) => {
        props.textAlign = props.align;
        delete props.align;
      },
      down: (props) => {
        props.align = props.textAlign;
        delete props.textAlign;
      }
    },
    {
      id: Versions$4.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
});
const videoShapeProps = {
  w: nonZeroNumber,
  h: nonZeroNumber,
  time: number,
  playing: boolean,
  autoplay: boolean,
  url: linkUrl,
  assetId: assetIdValidator.nullable(),
  altText: string
};
const Versions$3 = createShapePropsMigrationIds("video", {
  AddUrlProp: 1,
  MakeUrlsValid: 2,
  AddAltText: 3,
  AddAutoplay: 4
});
const videoShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$3.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions$3.MakeUrlsValid,
      up: (props) => {
        if (!linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions$3.AddAltText,
      up: (props) => {
        props.altText = "";
      },
      down: (props) => {
        delete props.altText;
      }
    },
    {
      id: Versions$3.AddAutoplay,
      up: (props) => {
        props.autoplay = true;
      },
      down: (props) => {
        delete props.autoplay;
      }
    }
  ]
});
const Versions$2 = createMigrationIds("com.tldraw.store", {
  RemoveCodeAndIconShapeTypes: 1,
  AddInstancePresenceType: 2,
  RemoveTLUserAndPresenceAndAddPointer: 3,
  RemoveUserDocument: 4,
  FixIndexKeys: 5
});
const storeMigrations = createMigrationSequence({
  sequenceId: "com.tldraw.store",
  retroactive: false,
  sequence: [
    {
      id: Versions$2.RemoveCodeAndIconShapeTypes,
      scope: "store",
      up: (store) => {
        for (const [id, record] of objectMapEntries(store)) {
          if (record.typeName === "shape" && (record.type === "icon" || record.type === "code")) {
            delete store[id];
          }
        }
      }
    },
    {
      id: Versions$2.AddInstancePresenceType,
      scope: "store",
      up(_store) {
      }
    },
    {
      // remove user and presence records and add pointer records
      id: Versions$2.RemoveTLUserAndPresenceAndAddPointer,
      scope: "store",
      up: (store) => {
        for (const [id, record] of objectMapEntries(store)) {
          if (record.typeName.match(/^(user|user_presence)$/)) {
            delete store[id];
          }
        }
      }
    },
    {
      // remove user document records
      id: Versions$2.RemoveUserDocument,
      scope: "store",
      up: (store) => {
        for (const [id, record] of objectMapEntries(store)) {
          if (record.typeName.match("user_document")) {
            delete store[id];
          }
        }
      }
    },
    {
      id: Versions$2.FixIndexKeys,
      scope: "record",
      up: (record) => {
        if (["shape", "page"].includes(record.typeName) && "index" in record) {
          const recordWithIndex = record;
          if (recordWithIndex.index.endsWith("0") && recordWithIndex.index !== "a0") {
            recordWithIndex.index = recordWithIndex.index.slice(0, -1) + getNRandomBase62Digits(3);
          }
          if (record.typeName === "shape" && recordWithIndex.type === "line") {
            const lineShape = recordWithIndex;
            for (const [_, point] of objectMapEntries(lineShape.props.points)) {
              if (point.index.endsWith("0") && point.index !== "a0") {
                point.index = point.index.slice(0, -1) + getNRandomBase62Digits(3);
              }
            }
          }
        }
      },
      down: () => {
      }
    }
  ]
});
const BASE_62_DIGITS_WITHOUT_ZERO = "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
const getRandomBase62Digit = () => {
  return BASE_62_DIGITS_WITHOUT_ZERO.charAt(
    Math.floor(Math.random() * BASE_62_DIGITS_WITHOUT_ZERO.length)
  );
};
const getNRandomBase62Digits = (n) => {
  return Array.from({ length: n }, getRandomBase62Digit).join("");
};
const defaultShapeSchemas = {
  arrow: { migrations: arrowShapeMigrations, props: arrowShapeProps },
  bookmark: { migrations: bookmarkShapeMigrations, props: bookmarkShapeProps },
  draw: { migrations: drawShapeMigrations, props: drawShapeProps },
  embed: { migrations: embedShapeMigrations, props: embedShapeProps },
  frame: { migrations: frameShapeMigrations, props: frameShapeProps },
  geo: { migrations: geoShapeMigrations, props: geoShapeProps },
  group: { migrations: groupShapeMigrations, props: groupShapeProps },
  highlight: { migrations: highlightShapeMigrations, props: highlightShapeProps },
  image: { migrations: imageShapeMigrations, props: imageShapeProps },
  line: { migrations: lineShapeMigrations, props: lineShapeProps },
  note: { migrations: noteShapeMigrations, props: noteShapeProps },
  text: { migrations: textShapeMigrations, props: textShapeProps },
  video: { migrations: videoShapeMigrations, props: videoShapeProps }
};
const defaultBindingSchemas = {
  arrow: { migrations: arrowBindingMigrations, props: arrowBindingProps }
};
function createTLSchema({
  shapes = defaultShapeSchemas,
  bindings = defaultBindingSchemas,
  migrations
} = {}) {
  const stylesById = /* @__PURE__ */ new Map();
  for (const shape of objectMapValues(shapes)) {
    for (const style2 of getShapePropKeysByStyle(shape.props ?? {}).keys()) {
      if (stylesById.has(style2.id) && stylesById.get(style2.id) !== style2) {
        throw new Error(`Multiple StyleProp instances with the same id: ${style2.id}`);
      }
      stylesById.set(style2.id, style2);
    }
  }
  const ShapeRecordType = createShapeRecordType(shapes);
  const BindingRecordType = createBindingRecordType(bindings);
  const InstanceRecordType = createInstanceRecordType(stylesById);
  return StoreSchema.create(
    {
      asset: AssetRecordType,
      binding: BindingRecordType,
      camera: CameraRecordType,
      document: DocumentRecordType,
      instance: InstanceRecordType,
      instance_page_state: InstancePageStateRecordType,
      page: PageRecordType,
      instance_presence: InstancePresenceRecordType,
      pointer: PointerRecordType,
      shape: ShapeRecordType
    },
    {
      migrations: [
        storeMigrations,
        assetMigrations,
        cameraMigrations,
        documentMigrations,
        instanceMigrations,
        instancePageStateMigrations,
        pageMigrations,
        instancePresenceMigrations,
        pointerMigrations,
        rootShapeMigrations,
        bookmarkAssetMigrations,
        imageAssetMigrations,
        videoAssetMigrations,
        ...processPropsMigrations("shape", shapes),
        ...processPropsMigrations("binding", bindings),
        ...migrations ?? []
      ],
      onValidationFailure,
      createIntegrityChecker
    }
  );
}
const LANGUAGES = [
  { locale: "id", label: "Bahasa Indonesia" },
  { locale: "ms", label: "Bahasa Melayu" },
  { locale: "ca", label: "Catal" },
  { locale: "cs", label: "etina" },
  { locale: "da", label: "Danish" },
  { locale: "de", label: "Deutsch" },
  { locale: "en", label: "English" },
  { locale: "es", label: "Espaol" },
  { locale: "tl", label: "Filipino" },
  { locale: "fr", label: "Franais" },
  { locale: "gl", label: "Galego" },
  { locale: "hr", label: "Hrvatski" },
  { locale: "it", label: "Italiano" },
  { locale: "hu", label: "Magyar" },
  { locale: "nl", label: "Nederlands" },
  { locale: "no", label: "Norwegian" },
  { locale: "pl", label: "Polski" },
  { locale: "pt-br", label: "Portugus - Brasil" },
  { locale: "pt-pt", label: "Portugus - Europeu" },
  { locale: "ro", label: "Romn" },
  { locale: "sl", label: "Slovenina" },
  { locale: "so", label: "Somali" },
  { locale: "fi", label: "Suomi" },
  { locale: "sv", label: "Svenska" },
  { locale: "vi", label: "Ting Vit" },
  { locale: "tr", label: "Trke" },
  { locale: "el", label: "" },
  { locale: "ru", label: "" },
  { locale: "uk", label: "" },
  { locale: "he", label: "" },
  { locale: "ur", label: "" },
  { locale: "ar", label: "" },
  { locale: "fa", label: "" },
  { locale: "ne", label: "" },
  { locale: "mr", label: "" },
  { locale: "hi-in", label: "" },
  { locale: "bn", label: "" },
  { locale: "pa", label: "" },
  { locale: "gu-in", label: "" },
  { locale: "ta", label: "" },
  { locale: "te", label: "" },
  { locale: "kn", label: "" },
  { locale: "ml", label: "" },
  { locale: "th", label: "" },
  { locale: "km-kh", label: "" },
  { locale: "ko-kr", label: "" },
  { locale: "ja", label: "" },
  { locale: "zh-cn", label: "" },
  { locale: "zh-tw", label: " ()" }
];
function getDefaultTranslationLocale() {
  const locales = typeof window !== "undefined" && window.navigator ? window.navigator.languages ?? ["en"] : ["en"];
  return _getDefaultTranslationLocale(locales);
}
function _getDefaultTranslationLocale(locales) {
  for (const locale of locales) {
    const supportedLocale = getSupportedLocale(locale);
    if (supportedLocale) {
      return supportedLocale;
    }
  }
  return "en";
}
const DEFAULT_LOCALE_REGIONS = {
  zh: "zh-cn",
  pt: "pt-br",
  ko: "ko-kr",
  hi: "hi-in"
};
function getSupportedLocale(locale) {
  const exactMatch = LANGUAGES.find((t2) => t2.locale === locale.toLowerCase());
  if (exactMatch) {
    return exactMatch.locale;
  }
  const [language, region] = locale.split(/[-_]/).map((s) => s.toLowerCase());
  if (region) {
    const languageMatch = LANGUAGES.find((t2) => t2.locale === language);
    if (languageMatch) {
      return languageMatch.locale;
    }
  }
  if (language in DEFAULT_LOCALE_REGIONS) {
    return DEFAULT_LOCALE_REGIONS[language];
  }
  return null;
}
registerTldrawLibraryVersion(
  "@tldraw/tlschema",
  "4.2.0",
  "esm"
);
function DefaultBackground() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-background" });
}
function useTransform(ref, x, y, scale, rotate, additionalOffset) {
  reactExports.useLayoutEffect(() => {
    const elm = ref.current;
    if (!elm) return;
    if (x === void 0) return;
    let trans = `translate(${x}px, ${y}px)`;
    if (scale !== void 0) {
      trans += ` scale(${scale})`;
    }
    if (rotate !== void 0) {
      trans += ` rotate(${rotate}rad)`;
    }
    if (additionalOffset) {
      trans += ` translate(${additionalOffset.x}px, ${additionalOffset.y}px)`;
    }
    elm.style.transform = trans;
  });
}
const EASINGS = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => t2 * (2 - t2),
  easeInOutQuad: (t2) => t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2,
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => --t2 * t2 * t2 + 1,
  easeInOutCubic: (t2) => t2 < 0.5 ? 4 * t2 * t2 * t2 : (t2 - 1) * (2 * t2 - 2) * (2 * t2 - 2) + 1,
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => 1 - --t2 * t2 * t2 * t2,
  easeInOutQuart: (t2) => t2 < 0.5 ? 8 * t2 * t2 * t2 * t2 : 1 - 8 * --t2 * t2 * t2 * t2,
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => 1 + --t2 * t2 * t2 * t2 * t2,
  easeInOutQuint: (t2) => t2 < 0.5 ? 16 * t2 * t2 * t2 * t2 * t2 : 1 + 16 * --t2 * t2 * t2 * t2 * t2,
  easeInSine: (t2) => 1 - Math.cos(t2 * Math.PI / 2),
  easeOutSine: (t2) => Math.sin(t2 * Math.PI / 2),
  easeInOutSine: (t2) => -(Math.cos(Math.PI * t2) - 1) / 2,
  easeInExpo: (t2) => t2 <= 0 ? 0 : Math.pow(2, 10 * t2 - 10),
  easeOutExpo: (t2) => t2 >= 1 ? 1 : 1 - Math.pow(2, -10 * t2),
  easeInOutExpo: (t2) => t2 <= 0 ? 0 : t2 >= 1 ? 1 : t2 < 0.5 ? Math.pow(2, 20 * t2 - 10) / 2 : (2 - Math.pow(2, -20 * t2 + 10)) / 2
};
class Vec {
  constructor(x = 0, y = 0, z = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  // eslint-disable-next-line no-restricted-syntax
  get pressure() {
    return this.z;
  }
  set(x = this.x, y = this.y, z = this.z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setTo({ x = 0, y = 0, z = 1 }) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  rot(r) {
    if (r === 0) return this;
    const { x, y } = this;
    const s = Math.sin(r);
    const c = Math.cos(r);
    this.x = x * c - y * s;
    this.y = x * s + y * c;
    return this;
  }
  rotWith(C, r) {
    if (r === 0) return this;
    const x = this.x - C.x;
    const y = this.y - C.y;
    const s = Math.sin(r);
    const c = Math.cos(r);
    this.x = C.x + (x * c - y * s);
    this.y = C.y + (x * s + y * c);
    return this;
  }
  clone() {
    const { x, y, z } = this;
    return new Vec(x, y, z);
  }
  sub(V2) {
    this.x -= V2.x;
    this.y -= V2.y;
    return this;
  }
  subXY(x, y) {
    this.x -= x;
    this.y -= y;
    return this;
  }
  subScalar(n) {
    this.x -= n;
    this.y -= n;
    return this;
  }
  add(V2) {
    this.x += V2.x;
    this.y += V2.y;
    return this;
  }
  addXY(x, y) {
    this.x += x;
    this.y += y;
    return this;
  }
  addScalar(n) {
    this.x += n;
    this.y += n;
    return this;
  }
  clamp(min2, max2) {
    this.x = Math.max(this.x, min2);
    this.y = Math.max(this.y, min2);
    if (max2 !== void 0) {
      this.x = Math.min(this.x, max2);
      this.y = Math.min(this.y, max2);
    }
    return this;
  }
  div(t2) {
    this.x /= t2;
    this.y /= t2;
    return this;
  }
  divV(V2) {
    this.x /= V2.x;
    this.y /= V2.y;
    return this;
  }
  mul(t2) {
    this.x *= t2;
    this.y *= t2;
    return this;
  }
  mulV(V2) {
    this.x *= V2.x;
    this.y *= V2.y;
    return this;
  }
  abs() {
    this.x = Math.abs(this.x);
    this.y = Math.abs(this.y);
    return this;
  }
  nudge(B, distance) {
    const tan = Vec.Tan(B, this);
    return this.add(tan.mul(distance));
  }
  neg() {
    this.x *= -1;
    this.y *= -1;
    return this;
  }
  cross(V2) {
    this.x = this.y * V2.z - this.z * V2.y;
    this.y = this.z * V2.x - this.x * V2.z;
    return this;
  }
  dpr(V2) {
    return Vec.Dpr(this, V2);
  }
  cpr(V2) {
    return Vec.Cpr(this, V2);
  }
  len2() {
    return Vec.Len2(this);
  }
  len() {
    return Vec.Len(this);
  }
  pry(V2) {
    return Vec.Pry(this, V2);
  }
  per() {
    const { x, y } = this;
    this.x = y;
    this.y = -x;
    return this;
  }
  uni() {
    const l = this.len();
    if (l === 0) return this;
    this.x /= l;
    this.y /= l;
    return this;
  }
  tan(V2) {
    return this.sub(V2).uni();
  }
  dist(V2) {
    return Vec.Dist(this, V2);
  }
  distanceToLineSegment(A, B) {
    return Vec.DistanceToLineSegment(A, B, this);
  }
  slope(B) {
    return Vec.Slope(this, B);
  }
  snapToGrid(gridSize) {
    this.x = Math.round(this.x / gridSize) * gridSize;
    this.y = Math.round(this.y / gridSize) * gridSize;
    return this;
  }
  angle(B) {
    return Vec.Angle(this, B);
  }
  toAngle() {
    return Vec.ToAngle(this);
  }
  lrp(B, t2) {
    this.x = this.x + (B.x - this.x) * t2;
    this.y = this.y + (B.y - this.y) * t2;
    return this;
  }
  equals(B) {
    return Vec.Equals(this, B);
  }
  equalsXY(x, y) {
    return Vec.EqualsXY(this, x, y);
  }
  toFixed() {
    this.x = toFixed(this.x);
    this.y = toFixed(this.y);
    return this;
  }
  toString() {
    return Vec.ToString(Vec.ToFixed(this));
  }
  toJson() {
    return Vec.ToJson(this);
  }
  toArray() {
    return Vec.ToArray(this);
  }
  static Add(A, B) {
    return new Vec(A.x + B.x, A.y + B.y);
  }
  static AddXY(A, x, y) {
    return new Vec(A.x + x, A.y + y);
  }
  static Sub(A, B) {
    return new Vec(A.x - B.x, A.y - B.y);
  }
  static SubXY(A, x, y) {
    return new Vec(A.x - x, A.y - y);
  }
  static AddScalar(A, n) {
    return new Vec(A.x + n, A.y + n);
  }
  static SubScalar(A, n) {
    return new Vec(A.x - n, A.y - n);
  }
  static Div(A, t2) {
    return new Vec(A.x / t2, A.y / t2);
  }
  static Mul(A, t2) {
    return new Vec(A.x * t2, A.y * t2);
  }
  static DivV(A, B) {
    return new Vec(A.x / B.x, A.y / B.y);
  }
  static MulV(A, B) {
    return new Vec(A.x * B.x, A.y * B.y);
  }
  static Neg(A) {
    return new Vec(-A.x, -A.y);
  }
  /**
   * Get the perpendicular vector to A.
   */
  static Per(A) {
    return new Vec(A.y, -A.x);
  }
  static Abs(A) {
    return new Vec(Math.abs(A.x), Math.abs(A.y));
  }
  // Get the distance between two points.
  static Dist(A, B) {
    return ((A.y - B.y) ** 2 + (A.x - B.x) ** 2) ** 0.5;
  }
  // Get the Manhattan distance between two points.
  static ManhattanDist(A, B) {
    return Math.abs(A.x - B.x) + Math.abs(A.y - B.y);
  }
  // Get whether a distance between two points is less than a number. This is faster to calulate than using `Vec.Dist(a, b) < n`.
  static DistMin(A, B, n) {
    return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y) < n ** 2;
  }
  // Get the squared distance between two points. This is faster to calculate (no square root) so useful for "minimum distance" checks where the actual measurement does not matter.
  static Dist2(A, B) {
    return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y);
  }
  /**
   * Dot product of two vectors which is used to calculate the angle between them.
   */
  static Dpr(A, B) {
    return A.x * B.x + A.y * B.y;
  }
  static Cross(A, V2) {
    return new Vec(
      A.y * V2.z - A.z * V2.y,
      A.z * V2.x - A.x * V2.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  /**
   * Cross product of two vectors which is used to calculate the area of a parallelogram.
   */
  static Cpr(A, B) {
    return A.x * B.y - B.x * A.y;
  }
  static Len2(A) {
    return A.x * A.x + A.y * A.y;
  }
  static Len(A) {
    return (A.x * A.x + A.y * A.y) ** 0.5;
  }
  /**
   * Get the projection of A onto B.
   */
  static Pry(A, B) {
    return Vec.Dpr(A, B) / Vec.Len(B);
  }
  /**
   * Get the unit vector of A.
   */
  static Uni(A) {
    const l = Vec.Len(A);
    return new Vec(l === 0 ? 0 : A.x / l, l === 0 ? 0 : A.y / l);
  }
  static Tan(A, B) {
    return Vec.Uni(Vec.Sub(A, B));
  }
  static Min(A, B) {
    return new Vec(Math.min(A.x, B.x), Math.min(A.y, B.y));
  }
  static Max(A, B) {
    return new Vec(Math.max(A.x, B.x), Math.max(A.y, B.y));
  }
  static From({ x, y, z = 1 }) {
    return new Vec(x, y, z);
  }
  static FromArray(v) {
    return new Vec(v[0], v[1]);
  }
  static Rot(A, r = 0) {
    const s = Math.sin(r);
    const c = Math.cos(r);
    return new Vec(A.x * c - A.y * s, A.x * s + A.y * c);
  }
  static RotWith(A, C, r) {
    const x = A.x - C.x;
    const y = A.y - C.y;
    const s = Math.sin(r);
    const c = Math.cos(r);
    return new Vec(C.x + (x * c - y * s), C.y + (x * s + y * c));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(A, u, P) {
    return Vec.Mul(u, Vec.Sub(P, A).pry(u)).add(A);
  }
  static NearestPointOnLineSegment(A, B, P, clamp2 = true) {
    if (Vec.Equals(A, P)) return Vec.From(P);
    if (Vec.Equals(B, P)) return Vec.From(P);
    const u = Vec.Tan(B, A);
    const C = Vec.Add(A, Vec.Mul(u, Vec.Sub(P, A).pry(u)));
    if (clamp2) {
      if (C.x < Math.min(A.x, B.x)) return Vec.Cast(A.x < B.x ? A : B);
      if (C.x > Math.max(A.x, B.x)) return Vec.Cast(A.x > B.x ? A : B);
      if (C.y < Math.min(A.y, B.y)) return Vec.Cast(A.y < B.y ? A : B);
      if (C.y > Math.max(A.y, B.y)) return Vec.Cast(A.y > B.y ? A : B);
    }
    return C;
  }
  static DistanceToLineThroughPoint(A, u, P) {
    return Vec.Dist(P, Vec.NearestPointOnLineThroughPoint(A, u, P));
  }
  static DistanceToLineSegment(A, B, P, clamp2 = true) {
    return Vec.Dist(P, Vec.NearestPointOnLineSegment(A, B, P, clamp2));
  }
  static Snap(A, step = 1) {
    return new Vec(Math.round(A.x / step) * step, Math.round(A.y / step) * step);
  }
  static Cast(A) {
    if (A instanceof Vec) return A;
    return Vec.From(A);
  }
  static Slope(A, B) {
    if (A.x === B.y) return NaN;
    return (A.y - B.y) / (A.x - B.x);
  }
  static IsNaN(A) {
    return isNaN(A.x) || isNaN(A.y);
  }
  /**
   * Get the angle from position A to position B.
   */
  static Angle(A, B) {
    return Math.atan2(B.y - A.y, B.x - A.x);
  }
  /**
   * Get the angle between vector A and vector B. This will return the smallest angle between the
   * two vectors, between - and . The sign indicates direction of angle.
   */
  static AngleBetween(A, B) {
    const p = A.x * B.x + A.y * B.y;
    const n = Math.sqrt(
      (Math.pow(A.x, 2) + Math.pow(A.y, 2)) * (Math.pow(B.x, 2) + Math.pow(B.y, 2))
    );
    const sign = A.x * B.y - A.y * B.x < 0 ? -1 : 1;
    const angle = sign * Math.acos(clamp$3(p / n, -1, 1));
    return angle;
  }
  /**
   * Linearly interpolate between two points.
   * @param A - The first point.
   * @param B - The second point.
   * @param t - The interpolation value between 0 and 1.
   * @returns The interpolated point.
   */
  static Lrp(A, B, t2) {
    return Vec.Sub(B, A).mul(t2).add(A);
  }
  static Med(A, B) {
    return new Vec((A.x + B.x) / 2, (A.y + B.y) / 2);
  }
  static Equals(A, B) {
    return Math.abs(A.x - B.x) < 1e-4 && Math.abs(A.y - B.y) < 1e-4;
  }
  static EqualsXY(A, x, y) {
    return A.x === x && A.y === y;
  }
  static Clockwise(A, B, C) {
    return (C.x - A.x) * (B.y - A.y) - (B.x - A.x) * (C.y - A.y) < 0;
  }
  static Rescale(A, n) {
    const l = Vec.Len(A);
    return new Vec(n * A.x / l, n * A.y / l);
  }
  static ScaleWithOrigin(A, scale, origin) {
    return Vec.Sub(A, origin).mul(scale).add(origin);
  }
  static ToFixed(A) {
    return new Vec(toFixed(A.x), toFixed(A.y));
  }
  static ToInt(A) {
    return new Vec(
      parseInt(A.x.toFixed(0)),
      parseInt(A.y.toFixed(0)),
      parseInt((A.z ?? 0).toFixed(0))
    );
  }
  static ToCss(A) {
    return `${A.x},${A.y}`;
  }
  static Nudge(A, B, distance) {
    return Vec.Add(A, Vec.Tan(B, A).mul(distance));
  }
  static ToString(A) {
    return `${A.x}, ${A.y}`;
  }
  static ToAngle(A) {
    let r = Math.atan2(A.y, A.x);
    if (r < 0) r += Math.PI * 2;
    return r;
  }
  static FromAngle(r, length = 1) {
    return new Vec(Math.cos(r) * length, Math.sin(r) * length);
  }
  static ToArray(A) {
    return [A.x, A.y, A.z];
  }
  static ToJson(A) {
    const { x, y, z } = A;
    return { x, y, z };
  }
  static Average(arr) {
    const len = arr.length;
    const avg = new Vec(0, 0);
    if (len === 0) {
      return avg;
    }
    for (let i = 0; i < len; i++) {
      avg.add(arr[i]);
    }
    return avg.div(len);
  }
  static Clamp(A, min2, max2) {
    if (max2 === void 0) {
      return new Vec(Math.min(Math.max(A.x, min2)), Math.min(Math.max(A.y, min2)));
    }
    return new Vec(Math.min(Math.max(A.x, min2), max2), Math.min(Math.max(A.y, min2), max2));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(A, B, steps = 6) {
    const results = [];
    for (let i = 0; i < steps; i++) {
      const t2 = EASINGS.easeInQuad(i / (steps - 1));
      const point = Vec.Lrp(A, B, t2);
      point.z = Math.min(1, 0.5 + Math.abs(0.5 - ease(t2)) * 0.65);
      results.push(point);
    }
    return results;
  }
  static SnapToGrid(A, gridSize = 8) {
    return new Vec(Math.round(A.x / gridSize) * gridSize, Math.round(A.y / gridSize) * gridSize);
  }
}
const ease = (t2) => t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2;
function precise(A) {
  return `${toDomPrecision(A.x)},${toDomPrecision(A.y)} `;
}
function average(A, B) {
  return `${toDomPrecision((A.x + B.x) / 2)},${toDomPrecision((A.y + B.y) / 2)} `;
}
const PI$1 = Math.PI;
const HALF_PI = PI$1 / 2;
const PI2 = PI$1 * 2;
const SIN = Math.sin;
function clamp$3(n, min2, max2) {
  return Math.max(min2, typeof max2 !== "undefined" ? Math.min(n, max2) : n);
}
function toPrecision(n, precision = 1e10) {
  if (!n) return 0;
  return Math.round(n * precision) / precision;
}
function approximately(a, b, precision = 1e-6) {
  return Math.abs(a - b) <= precision;
}
function approximatelyLte(a, b, precision = 1e-6) {
  return a < b || approximately(a, b, precision);
}
function perimeterOfEllipse(rx, ry) {
  const h2 = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
  return PI$1 * (rx + ry) * (1 + 3 * h2 / (10 + Math.sqrt(4 - 3 * h2)));
}
function canonicalizeRotation(a) {
  a = a % PI2;
  if (a < 0) {
    a = a + PI2;
  } else if (a === 0) {
    a = 0;
  }
  return a;
}
function clockwiseAngleDist(a0, a1) {
  a0 = canonicalizeRotation(a0);
  a1 = canonicalizeRotation(a1);
  if (a0 > a1) {
    a1 += PI2;
  }
  return a1 - a0;
}
function counterClockwiseAngleDist(a0, a1) {
  return PI2 - clockwiseAngleDist(a0, a1);
}
function shortAngleDist(a0, a1) {
  const da = (a1 - a0) % PI2;
  return 2 * da % PI2 - da;
}
function clampRadians(r) {
  return (PI2 + r) % PI2;
}
function snapAngle(r, segments) {
  const seg = PI2 / segments;
  let ang = Math.floor((clampRadians(r) + seg / 2) / seg) * seg % PI2;
  if (ang < PI$1) ang += PI2;
  if (ang > PI$1) ang -= PI2;
  return ang;
}
function areAnglesCompatible(a, b) {
  return a === b || approximately(a % (Math.PI / 2) - b % (Math.PI / 2), 0);
}
function degreesToRadians(d) {
  return d * PI$1 / 180;
}
function radiansToDegrees(r) {
  return r * 180 / PI$1;
}
function getPointOnCircle(center, r, a) {
  return new Vec(center.x, center.y).add(Vec.FromAngle(a, r));
}
function getPolygonVertices(width, height, sides2) {
  const cx = width / 2;
  const cy = height / 2;
  const pointsOnPerimeter = [];
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < sides2; i++) {
    const step = PI2 / sides2;
    const t2 = -HALF_PI + i * step;
    const x = cx + cx * Math.cos(t2);
    const y = cy + cy * Math.sin(t2);
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
    pointsOnPerimeter.push(new Vec(x, y));
  }
  const w = maxX - minX;
  const h2 = maxY - minY;
  const dx = width - w;
  const dy = height - h2;
  if (dx !== 0 || dy !== 0) {
    for (let i = 0; i < pointsOnPerimeter.length; i++) {
      const pt = pointsOnPerimeter[i];
      pt.x = (pt.x - minX) / w * width;
      pt.y = (pt.y - minY) / h2 * height;
    }
  }
  return pointsOnPerimeter;
}
function rangesOverlap(a0, a1, b0, b1) {
  return a0 < b1 && b0 < a1;
}
function rangeIntersection(a0, a1, b0, b1) {
  const min2 = Math.max(a0, b0);
  const max2 = Math.min(a1, b1);
  if (min2 <= max2) {
    return [min2, max2];
  }
  return null;
}
function cross(x, y, z) {
  return (y.x - x.x) * (z.y - x.y) - (z.x - x.x) * (y.y - x.y);
}
function pointInPolygon(A, points) {
  let windingNumber = 0;
  let a;
  let b;
  for (let i = 0; i < points.length; i++) {
    a = points[i];
    if (a.x === A.x && a.y === A.y) return true;
    b = points[(i + 1) % points.length];
    if (Vec.Dist(A, a) + Vec.Dist(A, b) === Vec.Dist(a, b)) return true;
    if (a.y <= A.y) {
      if (b.y > A.y && cross(a, b, A) > 0) {
        windingNumber += 1;
      }
    } else if (b.y <= A.y && cross(a, b, A) < 0) {
      windingNumber -= 1;
    }
  }
  return windingNumber !== 0;
}
function toDomPrecision(v) {
  return Math.round(v * 1e4) / 1e4;
}
function toFixed(v) {
  return Math.round(v * 100) / 100;
}
const isSafeFloat = (n) => {
  return Math.abs(n) < Number.MAX_SAFE_INTEGER;
};
function getPointInArcT(mAB, A, B, P) {
  let mAP;
  if (Math.abs(mAB) > PI$1) {
    mAP = shortAngleDist(A, P);
    const mPB = shortAngleDist(P, B);
    if (Math.abs(mAP) < Math.abs(mPB)) {
      return mAP / mAB;
    } else {
      return (mAB - mPB) / mAB;
    }
  } else {
    mAP = shortAngleDist(A, P);
    const t2 = mAP / mAB;
    if (Math.sign(mAP) !== Math.sign(mAB)) {
      return Math.abs(t2) > 0.5 ? 1 : 0;
    }
    return t2;
  }
}
function getArcMeasure(A, B, sweepFlag, largeArcFlag) {
  const m = 2 * ((B - A) % PI2) % PI2 - (B - A) % PI2;
  if (!largeArcFlag) return m;
  return (PI2 - Math.abs(m)) * (sweepFlag ? 1 : -1);
}
function centerOfCircleFromThreePoints(a, b, c) {
  const u = -2 * (a.x * (b.y - c.y) - a.y * (b.x - c.x) + b.x * c.y - c.x * b.y);
  const x = ((a.x * a.x + a.y * a.y) * (c.y - b.y) + (b.x * b.x + b.y * b.y) * (a.y - c.y) + (c.x * c.x + c.y * c.y) * (b.y - a.y)) / u;
  const y = ((a.x * a.x + a.y * a.y) * (b.x - c.x) + (b.x * b.x + b.y * b.y) * (c.x - a.x) + (c.x * c.x + c.y * c.y) * (a.x - b.x)) / u;
  if (!Number.isFinite(x) || !Number.isFinite(y)) {
    return null;
  }
  return new Vec(x, y);
}
const DefaultBrush = ({ brush, color, opacity, className }) => {
  const rSvg = reactExports.useRef(null);
  useTransform(rSvg, brush.x, brush.y);
  const w = toDomPrecision(Math.max(1, brush.w));
  const h2 = toDomPrecision(Math.max(1, brush.h));
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "tl-overlays__item", ref: rSvg, "aria-hidden": "true", children: color ? /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: "tl-brush", opacity, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: w, height: h2, fill: color, opacity: 0.75 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: w, height: h2, fill: "none", stroke: color, opacity: 0.1 })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { className: `tl-brush tl-brush__default ${className}`, width: w, height: h2 }) });
};
var classnames = { exports: {} };
var hasRequiredClassnames;
function requireClassnames() {
  if (hasRequiredClassnames) return classnames.exports;
  hasRequiredClassnames = 1;
  (function(module) {
    (function() {
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else {
        window.classNames = classNames2;
      }
    })();
  })(classnames);
  return classnames.exports;
}
var classnamesExports = requireClassnames();
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
const tlenv = {
  isSafari: false,
  isIos: false,
  isChromeForIos: false,
  isFirefox: false,
  isAndroid: false,
  isDarwin: false,
  hasCanvasSupport: false
};
if (typeof window !== "undefined" && "navigator" in window) {
  tlenv.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  tlenv.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i);
  tlenv.isChromeForIos = /crios.*safari/i.test(navigator.userAgent);
  tlenv.isFirefox = /firefox/i.test(navigator.userAgent);
  tlenv.isAndroid = /android/i.test(navigator.userAgent);
  tlenv.isDarwin = window.navigator.userAgent.toLowerCase().indexOf("mac") > -1;
  tlenv.hasCanvasSupport = typeof window !== "undefined" && "Promise" in window && "HTMLCanvasElement" in window;
}
const DEFAULT_CAMERA_OPTIONS = {
  isLocked: false,
  wheelBehavior: "pan",
  panSpeed: 1,
  zoomSpeed: 1,
  zoomSteps: [0.05, 0.1, 0.25, 0.5, 1, 2, 4, 8]
};
const DEFAULT_ANIMATION_OPTIONS = {
  duration: 0,
  easing: EASINGS.easeInOutCubic
};
const INTERNAL_POINTER_IDS = {
  CAMERA_MOVE: -10
};
const SIDES = ["top", "right", "bottom", "left"];
const LEFT_MOUSE_BUTTON = 0;
const RIGHT_MOUSE_BUTTON = 2;
const MIDDLE_MOUSE_BUTTON = 1;
const STYLUS_ERASER_BUTTON = 5;
const ZOOM_TO_FIT_PADDING = 128;
var define_process_env_default$2 = {};
const featureFlags = {};
const pointerCaptureTrackingObject = createDebugValue(
  "pointerCaptureTrackingObject",
  // ideally we wouldn't store this mutable value in an atom but it's not
  // a big deal for debug values
  {
    defaults: { all: /* @__PURE__ */ new Map() },
    shouldStoreForSession: false
  }
);
const debugFlags = {
  // --- DEBUG VALUES ---
  logPreventDefaults: createDebugValue("logPreventDefaults", {
    defaults: { all: false }
  }),
  logPointerCaptures: createDebugValue("logPointerCaptures", {
    defaults: { all: false }
  }),
  logElementRemoves: createDebugValue("logElementRemoves", {
    defaults: { all: false }
  }),
  debugSvg: createDebugValue("debugSvg", {
    defaults: { all: false }
  }),
  showFps: createDebugValue("showFps", {
    defaults: { all: false }
  }),
  measurePerformance: createDebugValue("measurePerformance", { defaults: { all: false } }),
  throwToBlob: createDebugValue("throwToBlob", {
    defaults: { all: false }
  }),
  reconnectOnPing: createDebugValue("reconnectOnPing", {
    defaults: { all: false }
  }),
  debugCursors: createDebugValue("debugCursors", {
    defaults: { all: false }
  }),
  forceSrgb: createDebugValue("forceSrgbColors", { defaults: { all: false } }),
  debugGeometry: createDebugValue("debugGeometry", { defaults: { all: false } }),
  hideShapes: createDebugValue("hideShapes", { defaults: { all: false } }),
  editOnType: createDebugValue("editOnType", { defaults: { all: false } }),
  a11y: createDebugValue("a11y", { defaults: { all: false } }),
  debugElbowArrows: createDebugValue("debugElbowArrows", { defaults: { all: false } })
};
if (typeof Element !== "undefined") {
  const nativeElementRemoveChild = Element.prototype.removeChild;
  react("element removal logging", () => {
    if (debugFlags.logElementRemoves.get()) {
      Element.prototype.removeChild = function(child) {
        console.warn("[tldraw] removing child:", child);
        return nativeElementRemoveChild.call(this, child);
      };
    } else {
      Element.prototype.removeChild = nativeElementRemoveChild;
    }
  });
}
function createDebugValue(name, {
  defaults: defaults2,
  shouldStoreForSession = true
}) {
  return createDebugValueBase({
    name,
    defaults: defaults2,
    shouldStoreForSession
  });
}
function createDebugValueBase(def) {
  const defaultValue = getDefaultValue(def);
  const storedValue = def.shouldStoreForSession ? getStoredInitialValue(def.name) : null;
  const valueAtom = atom(`debug:${def.name}`, storedValue ?? defaultValue);
  if (typeof window !== "undefined") {
    if (def.shouldStoreForSession) {
      react(`debug:${def.name}`, () => {
        const currentValue = valueAtom.get();
        if (currentValue === defaultValue) {
          deleteFromSessionStorage(`tldraw_debug:${def.name}`);
        } else {
          setInSessionStorage(`tldraw_debug:${def.name}`, JSON.stringify(currentValue));
        }
      });
    }
    Object.defineProperty(window, `tldraw${def.name.replace(/^[a-z]/, (l) => l.toUpperCase())}`, {
      get() {
        return valueAtom.get();
      },
      set(newValue) {
        valueAtom.set(newValue);
      },
      configurable: true
    });
  }
  return Object.assign(valueAtom, def, {
    reset: () => valueAtom.set(defaultValue)
  });
}
function getStoredInitialValue(name) {
  try {
    return JSON.parse(getFromSessionStorage(`tldraw_debug:${name}`) ?? "null");
  } catch {
    return null;
  }
}
function readEnv(fn) {
  try {
    return fn();
  } catch {
    return null;
  }
}
function getDefaultValue(def) {
  const env = readEnv(() => define_process_env_default$2.TLDRAW_ENV) ?? readEnv(() => define_process_env_default$2.VERCEL_PUBLIC_TLDRAW_ENV) ?? readEnv(() => define_process_env_default$2.NEXT_PUBLIC_TLDRAW_ENV) ?? // default to production because if we don't have one of these, this is probably a library use
  "production";
  switch (env) {
    case "production":
      return def.defaults.production ?? def.defaults.all;
    case "preview":
    case "staging":
      return def.defaults.staging ?? def.defaults.all;
    default:
      return def.defaults.development ?? def.defaults.all;
  }
}
function loopToHtmlElement(elm) {
  if (elm.nodeType === Node.ELEMENT_NODE) return elm;
  if (elm.parentElement) return loopToHtmlElement(elm.parentElement);
  else throw Error("Could not find a parent element of an HTML type!");
}
function preventDefault(event) {
  event.preventDefault();
  if (debugFlags.logPreventDefaults.get()) {
    console.warn("preventDefault called on event:", event);
  }
}
function setPointerCapture(element, event) {
  element.setPointerCapture(event.pointerId);
  if (debugFlags.logPointerCaptures.get()) {
    const trackingObj = pointerCaptureTrackingObject.get();
    trackingObj.set(element, (trackingObj.get(element) ?? 0) + 1);
    console.warn("setPointerCapture called on element:", element, event);
  }
}
function releasePointerCapture(element, event) {
  if (!element.hasPointerCapture(event.pointerId)) {
    return;
  }
  element.releasePointerCapture(event.pointerId);
  if (debugFlags.logPointerCaptures.get()) {
    const trackingObj = pointerCaptureTrackingObject.get();
    if (trackingObj.get(element) === 1) {
      trackingObj.delete(element);
    } else if (trackingObj.has(element)) {
      trackingObj.set(element, trackingObj.get(element) - 1);
    } else {
      console.warn("Release without capture");
    }
    console.warn("releasePointerCapture called on element:", element, event);
  }
}
const setStyleProperty = (elm, property, value) => {
  if (!elm) return;
  elm.style.setProperty(property, value);
};
function activeElementShouldCaptureKeys(allowButtons = false) {
  const { activeElement } = document;
  const elements = allowButtons ? ["input", "textarea"] : ["input", "select", "button", "textarea"];
  return !!(activeElement && (activeElement.isContentEditable || elements.indexOf(activeElement.tagName.toLowerCase()) > -1 || activeElement.classList.contains("tlui-slider__thumb")));
}
const isAccelKey = (e) => {
  return tlenv.isDarwin ? e.metaKey : e.ctrlKey || e.metaKey;
};
function getPointerInfo(editor, e) {
  editor.markEventAsHandled(e);
  return {
    point: {
      x: e.clientX,
      y: e.clientY,
      z: e.pressure
    },
    shiftKey: e.shiftKey,
    altKey: e.altKey,
    ctrlKey: e.metaKey || e.ctrlKey,
    metaKey: e.metaKey,
    accelKey: isAccelKey(e),
    pointerId: e.pointerId,
    button: e.button,
    isPen: e.pointerType === "pen"
  };
}
function suffixSafeId(id, suffix) {
  return sanitizeId(`${id}_${suffix}`);
}
function useUniqueSafeId(suffix) {
  return sanitizeId(`${reactExports.useId()}${suffix ?? ""}`);
}
function useSharedSafeId(id) {
  const idScope = assertExists(reactExports.useContext(IdContext));
  return sanitizeId(`${idScope}_${id}`);
}
function sanitizeId(id) {
  return id.replace(/:/g, "_");
}
const IdContext = reactExports.createContext(null);
function IdProvider({ children }) {
  const id = useUniqueSafeId();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IdContext.Provider, { value: id, children });
}
const EditorContext = reactExports.createContext(null);
function useEditor() {
  const editor = React.useContext(EditorContext);
  if (!editor) {
    throw new Error(
      "useEditor must be used inside of the <Tldraw /> or <TldrawEditor /> components"
    );
  }
  return editor;
}
function useMaybeEditor() {
  return React.useContext(EditorContext);
}
function EditorProvider({ editor, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EditorContext.Provider, { value: editor, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IdProvider, { children }) });
}
function useCanvasEvents() {
  const editor = useEditor();
  const currentTool = useValue("current tool", () => editor.getCurrentTool(), [editor]);
  const events = reactExports.useMemo(
    function canvasEvents() {
      function onPointerDown(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (e.button === RIGHT_MOUSE_BUTTON) {
          editor.dispatch({
            type: "pointer",
            target: "canvas",
            name: "right_click",
            ...getPointerInfo(editor, e)
          });
          return;
        }
        if (e.button !== 0 && e.button !== 1 && e.button !== 5) return;
        setPointerCapture(e.currentTarget, e);
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_down",
          ...getPointerInfo(editor, e)
        });
      }
      function onPointerUp(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (e.button !== 0 && e.button !== 1 && e.button !== 2 && e.button !== 5) return;
        releasePointerCapture(e.currentTarget, e);
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_up",
          ...getPointerInfo(editor, e)
        });
      }
      function onPointerEnter(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (editor.getInstanceState().isPenMode && e.pointerType !== "pen") return;
        const canHover = e.pointerType === "mouse" || e.pointerType === "pen";
        editor.updateInstanceState({ isHoveringCanvas: canHover ? true : null });
      }
      function onPointerLeave(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (editor.getInstanceState().isPenMode && e.pointerType !== "pen") return;
        const canHover = e.pointerType === "mouse" || e.pointerType === "pen";
        editor.updateInstanceState({ isHoveringCanvas: canHover ? false : null });
      }
      function onTouchStart(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        editor.markEventAsHandled(e);
        preventDefault(e);
      }
      function onTouchEnd(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        editor.markEventAsHandled(e);
        if (!(e.target instanceof HTMLElement)) return;
        const editingShapeId = editor.getEditingShape()?.id;
        if (
          // if the target is not inside the editing shape
          !(editingShapeId && e.target.closest(`[data-shape-id="${editingShapeId}"]`)) && // and the target is not an clickable element
          e.target.tagName !== "A" && // or a TextArea.tsx ?
          e.target.tagName !== "TEXTAREA" && !e.target.isContentEditable
        ) {
          preventDefault(e);
        }
      }
      function onDragOver(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        preventDefault(e);
      }
      async function onDrop(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        preventDefault(e);
        e.stopPropagation();
        if (e.dataTransfer?.files?.length) {
          const files = Array.from(e.dataTransfer.files);
          await editor.putExternalContent({
            type: "files",
            files,
            point: editor.screenToPage({ x: e.clientX, y: e.clientY })
          });
          return;
        }
        const url = e.dataTransfer.getData("url");
        if (url) {
          await editor.putExternalContent({
            type: "url",
            url,
            point: editor.screenToPage({ x: e.clientX, y: e.clientY })
          });
          return;
        }
      }
      function onClick(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        e.stopPropagation();
      }
      return {
        onPointerDown,
        onPointerUp,
        onPointerEnter,
        onPointerLeave,
        onDragOver,
        onDrop,
        onTouchStart,
        onTouchEnd,
        onClick
      };
    },
    [editor]
  );
  reactExports.useEffect(() => {
    let lastX, lastY;
    function onPointerMove(e) {
      if (editor.wasEventAlreadyHandled(e)) return;
      editor.markEventAsHandled(e);
      if (e.clientX === lastX && e.clientY === lastY) return;
      lastX = e.clientX;
      lastY = e.clientY;
      const events2 = !tlenv.isIos && currentTool.useCoalescedEvents && e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
      for (const singleEvent of events2) {
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          ...getPointerInfo(editor, singleEvent)
        });
      }
    }
    document.body.addEventListener("pointermove", onPointerMove);
    return () => {
      document.body.removeEventListener("pointermove", onPointerMove);
    };
  }, [editor, currentTool]);
  return events;
}
function useCoarsePointer() {
  const editor = useEditor();
  reactExports.useEffect(() => {
    let isCoarse = editor.getInstanceState().isCoarsePointer;
    const handlePointerDown = (e) => {
      const isCoarseEvent = e.pointerType !== "mouse";
      if (isCoarse === isCoarseEvent) return;
      isCoarse = isCoarseEvent;
      editor.updateInstanceState({ isCoarsePointer: isCoarseEvent });
    };
    window.addEventListener("pointerdown", handlePointerDown, { capture: true });
    const mql = window.matchMedia && window.matchMedia("(any-pointer: coarse)");
    const isForcedFinePointer = tlenv.isFirefox && !tlenv.isAndroid && !tlenv.isIos;
    const handleMediaQueryChange = () => {
      const next = isForcedFinePointer ? false : mql.matches;
      if (isCoarse !== next) return;
      isCoarse = next;
      editor.updateInstanceState({ isCoarsePointer: next });
    };
    if (mql) {
      mql.addEventListener("change", handleMediaQueryChange);
      handleMediaQueryChange();
    }
    return () => {
      window.removeEventListener("pointerdown", handlePointerDown, { capture: true });
      if (mql) {
        mql.removeEventListener("change", handleMediaQueryChange);
      }
    };
  }, [editor]);
}
const ContainerContext = reactExports.createContext(null);
function ContainerProvider({ container, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerContext.Provider, { value: container, children });
}
function useContainer() {
  return assertExists(reactExports.useContext(ContainerContext), "useContainer used outside of <Tldraw />");
}
function useDocumentEvents() {
  const editor = useEditor();
  const container = useContainer();
  const isEditing = useValue("isEditing", () => editor.getEditingShapeId(), [editor]);
  const isAppFocused = useValue("isFocused", () => editor.getIsFocused(), [editor]);
  reactExports.useEffect(() => {
    if (!container) return;
    function onDrop(e) {
      if (e.isSpecialRedispatchedEvent) return;
      preventDefault(e);
      e.stopPropagation();
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs) return;
      const newEvent = new DragEvent(e.type, e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    container.addEventListener("dragover", onDrop);
    container.addEventListener("drop", onDrop);
    return () => {
      container.removeEventListener("dragover", onDrop);
      container.removeEventListener("drop", onDrop);
    };
  }, [container]);
  reactExports.useEffect(() => {
    if (typeof window === "undefined" || !("matchMedia" in window)) return;
    let remove2 = null;
    const updatePixelRatio = () => {
      if (remove2 != null) {
        remove2();
      }
      const mqString = `(resolution: ${window.devicePixelRatio}dppx)`;
      const media = matchMedia(mqString);
      const safariCb = (ev) => {
        if (ev.type === "change") {
          updatePixelRatio();
        }
      };
      if (media.addEventListener) {
        media.addEventListener("change", updatePixelRatio);
      } else if (media.addListener) {
        media.addListener(safariCb);
      }
      remove2 = () => {
        if (media.removeEventListener) {
          media.removeEventListener("change", updatePixelRatio);
        } else if (media.removeListener) {
          media.removeListener(safariCb);
        }
      };
      editor.updateInstanceState({ devicePixelRatio: window.devicePixelRatio });
    };
    updatePixelRatio();
    return () => {
      remove2?.();
    };
  }, [editor]);
  reactExports.useEffect(() => {
    if (!isAppFocused) return;
    const handleKeyDown2 = (e) => {
      if (e.altKey && // todo: When should we allow the alt key to be used? Perhaps states should declare which keys matter to them?
      (editor.isIn("zoom") || !editor.getPath().endsWith(".idle")) && !areShortcutsDisabled$2(editor)) {
        preventDefault(e);
      }
      if (editor.wasEventAlreadyHandled(e)) return;
      editor.markEventAsHandled(e);
      const hasSelectedShapes = !!editor.getSelectedShapeIds().length;
      switch (e.key) {
        case "=":
        case "-":
        case "0": {
          if (e.metaKey || e.ctrlKey) {
            preventDefault(e);
            return;
          }
          break;
        }
        case "Tab": {
          if (areShortcutsDisabled$2(editor)) {
            return;
          }
          if (hasSelectedShapes && !isEditing) {
            preventDefault(e);
          }
          break;
        }
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "ArrowDown": {
          if (areShortcutsDisabled$2(editor)) {
            return;
          }
          if (hasSelectedShapes && (e.metaKey || e.ctrlKey)) {
            preventDefault(e);
          }
          break;
        }
        case ",": {
          return;
        }
        case "Escape": {
          if (editor.getEditingShape() || editor.getSelectedShapeIds().length > 0) {
            preventDefault(e);
          }
          if (editor.menus.getOpenMenus().length > 0) return;
          if (editor.inputs.keys.has("Escape")) ;
          else {
            editor.inputs.keys.add("Escape");
            editor.cancel();
            container.focus();
          }
          return;
        }
        default: {
          if (areShortcutsDisabled$2(editor)) {
            return;
          }
        }
      }
      const info = {
        type: "keyboard",
        name: e.repeat ? "key_repeat" : "key_down",
        key: e.key,
        code: e.code,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      };
      editor.dispatch(info);
    };
    const handleKeyUp = (e) => {
      if (editor.wasEventAlreadyHandled(e)) return;
      editor.markEventAsHandled(e);
      if (areShortcutsDisabled$2(editor)) {
        return;
      }
      if (e.key === ",") {
        return;
      }
      const info = {
        type: "keyboard",
        name: "key_up",
        key: e.key,
        code: e.code,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      };
      editor.dispatch(info);
    };
    function handleTouchStart(e) {
      if (container.contains(e.target)) {
        const touchXPosition = e.touches[0].pageX;
        const touchXRadius = e.touches[0].radiusX || 0;
        if (touchXPosition - touchXRadius < 10 || touchXPosition + touchXRadius > editor.getViewportScreenBounds().width - 10) {
          if (e.target?.tagName === "BUTTON") {
            e.target?.click();
          }
          preventDefault(e);
        }
      }
    }
    const handleWheel = (e) => {
      if (container.contains(e.target) && (e.ctrlKey || e.metaKey)) {
        preventDefault(e);
      }
    };
    container.addEventListener("touchstart", handleTouchStart, { passive: false });
    container.addEventListener("wheel", handleWheel, { passive: false });
    document.addEventListener("gesturestart", preventDefault);
    document.addEventListener("gesturechange", preventDefault);
    document.addEventListener("gestureend", preventDefault);
    container.addEventListener("keydown", handleKeyDown2);
    container.addEventListener("keyup", handleKeyUp);
    return () => {
      container.removeEventListener("touchstart", handleTouchStart);
      container.removeEventListener("wheel", handleWheel);
      document.removeEventListener("gesturestart", preventDefault);
      document.removeEventListener("gesturechange", preventDefault);
      document.removeEventListener("gestureend", preventDefault);
      container.removeEventListener("keydown", handleKeyDown2);
      container.removeEventListener("keyup", handleKeyUp);
    };
  }, [editor, container, isAppFocused, isEditing]);
}
function areShortcutsDisabled$2(editor) {
  return editor.menus.hasOpenMenus() || activeElementShouldCaptureKeys();
}
function DefaultCollaboratorHint({
  className,
  zoom,
  point,
  color,
  viewport,
  opacity = 1
}) {
  const rSvg = reactExports.useRef(null);
  useTransform(
    rSvg,
    clamp$3(point.x, viewport.minX + 5 / zoom, viewport.maxX - 5 / zoom),
    clamp$3(point.y, viewport.minY + 5 / zoom, viewport.maxY - 5 / zoom),
    1 / zoom,
    Vec.Angle(viewport.center, point)
  );
  const cursorHintId = useSharedSafeId("cursor_hint");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { ref: rSvg, className: classNames("tl-overlays__item", className), "aria-hidden": "true", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "use",
      {
        href: `#${cursorHintId}`,
        color,
        strokeWidth: 3,
        stroke: "var(--tl-color-background)"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("use", { href: `#${cursorHintId}`, color, opacity })
  ] });
}
const DefaultCursor = reactExports.memo(function DefaultCursor2({
  className,
  zoom,
  point,
  color,
  name,
  chatMessage
}) {
  const rCursor = reactExports.useRef(null);
  useTransform(rCursor, point?.x, point?.y, 1 / zoom);
  const cursorId = useSharedSafeId("cursor");
  if (!point) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: rCursor, className: classNames("tl-overlays__item", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "tl-cursor", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("use", { href: `#${cursorId}`, color }) }),
    chatMessage ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      name && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-nametag-title", style: { color }, children: name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-nametag-chat", style: { backgroundColor: color }, children: chatMessage })
    ] }) : name && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-nametag", style: { backgroundColor: color }, children: name })
  ] });
});
const runtime = {
  openWindow(url, target, allowReferrer = false) {
    return window.open(url, target, allowReferrer ? "noopener" : "noopener noreferrer");
  },
  refreshPage() {
    window.location.reload();
  },
  async hardReset() {
    return await window.__tldraw__hardReset?.();
  }
};
function hardResetEditor() {
  runtime.hardReset();
}
function refreshPage() {
  runtime.refreshPage();
}
const initialState = { error: null };
class ErrorBoundary extends reactExports.Component {
  static getDerivedStateFromError(error) {
    return { error };
  }
  state = initialState;
  componentDidCatch(error) {
    this.props.onError?.(error);
  }
  render() {
    const { error } = this.state;
    if (error !== null) {
      const { fallback: Fallback } = this.props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Fallback, { error });
    }
    return this.props.children;
  }
}
function OptionalErrorBoundary({
  children,
  fallback,
  ...props
}) {
  if (fallback === null) {
    return children;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { fallback, ...props, children });
}
const BASE_ERROR_URL = "https://github.com/tldraw/tldraw/issues/new";
const DefaultErrorFallback = ({ error, editor }) => {
  const containerRef = reactExports.useRef(null);
  const [shouldShowError, setShouldShowError] = reactExports.useState(false);
  const [didCopy, setDidCopy] = reactExports.useState(false);
  const [shouldShowResetConfirmation, setShouldShowResetConfirmation] = reactExports.useState(false);
  let Canvas = null;
  try {
    const components = useEditorComponents();
    Canvas = components.Canvas ?? null;
  } catch {
  }
  const errorMessage = error instanceof Error ? error.message : String(error);
  const errorStack = error instanceof Error ? error.stack : null;
  const isDarkModeFromApp = useValue(
    "isDarkMode",
    () => {
      try {
        if (editor) {
          return editor.user.getIsDarkMode();
        }
      } catch {
      }
      return null;
    },
    [editor]
  );
  const [isDarkMode, setIsDarkMode] = reactExports.useState(null);
  reactExports.useLayoutEffect(() => {
    if (isDarkModeFromApp !== null) {
      setIsDarkMode(isDarkModeFromApp);
    }
    let parent = containerRef.current?.parentElement;
    let foundParentThemeClass = false;
    while (parent) {
      if (parent.classList.contains("tl-theme__dark") || parent.classList.contains("tl-theme__light")) {
        foundParentThemeClass = true;
        break;
      }
      parent = parent.parentElement;
    }
    if (foundParentThemeClass) {
      setIsDarkMode(null);
      return;
    }
    if (typeof window !== "undefined" && window.matchMedia) {
      setIsDarkMode(window.matchMedia("(prefers-color-scheme: dark)").matches);
    }
  }, [isDarkModeFromApp]);
  reactExports.useEffect(() => {
    if (didCopy) {
      const timeout = editor?.timers.setTimeout(() => {
        setDidCopy(false);
      }, 2e3);
      return () => clearTimeout(timeout);
    }
  }, [didCopy, editor]);
  const copyError = () => {
    const textarea = document.createElement("textarea");
    textarea.value = errorStack ?? errorMessage;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    textarea.remove();
    setDidCopy(true);
  };
  const refresh = () => {
    refreshPage();
  };
  const resetLocalState = async () => {
    hardResetEditor();
  };
  const url = new URL(BASE_ERROR_URL);
  url.searchParams.set("title", errorMessage);
  url.searchParams.set("labels", `bug`);
  url.searchParams.set(
    "body",
    `Hey, I ran into an error while using tldraw:

\`\`\`js
${errorStack ?? errorMessage}
\`\`\`

My browser: ${navigator.userAgent}`
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: containerRef,
      className: classNames(
        "tl-container tl-error-boundary",
        // error-boundary is sometimes used outside of the theme
        // container, so we need to provide it with a theme for our
        // styles to work correctly
        isDarkMode === null ? "" : isDarkMode ? "tl-theme__dark" : "tl-theme__light"
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-error-boundary__overlay" }),
        editor && // opportunistically attempt to render the canvas to reassure
        // the user that their document is still there. there's a good
        // chance this won't work (ie the error that we're currently
        // notifying the user about originates in the canvas) so it's
        // not a big deal if it doesn't work - in that case we just have
        // a plain grey background.
        /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { onError: noop$3, fallback: () => null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditorProvider, { editor, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-overlay tl-error-boundary__canvas", children: Canvas ? /* @__PURE__ */ jsxRuntimeExports.jsx(Canvas, {}) : null }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: classNames("tl-modal", "tl-error-boundary__content", {
              "tl-error-boundary__content__expanded": shouldShowError && !shouldShowResetConfirmation
            }),
            children: shouldShowResetConfirmation ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Are you sure?" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Resetting your data will delete your drawing and cannot be undone." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-error-boundary__content__actions", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "tlui-button", onClick: () => setShouldShowResetConfirmation(false), children: "Cancel" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "tlui-button tl-error-boundary__reset", onClick: resetLocalState, children: "Reset data" })
              ] })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Something went wrong" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Please refresh your browser." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "If the issue continues after refreshing, you may need to reset the tldraw data stored on your device." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Note:" }),
                " Resetting will erase your current project and any unsaved work."
              ] }),
              false,
              shouldShowError && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                "Message:",
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: errorMessage }) }),
                "Stack trace:",
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-error-boundary__content__error", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: errorStack ?? errorMessage }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "tlui-button", onClick: copyError, children: didCopy ? "Copied!" : "Copy" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-error-boundary__content__actions", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "tlui-button", onClick: () => setShouldShowError(!shouldShowError), children: shouldShowError ? "Hide details" : "Show details" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-error-boundary__content__actions__group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "tlui-button tl-error-boundary__reset",
                      onClick: () => setShouldShowResetConfirmation(true),
                      children: "Reset data"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "tlui-button tl-error-boundary__refresh", onClick: refresh, children: "Refresh Page" })
                ] })
              ] })
            ] })
          }
        )
      ]
    }
  );
};
function DefaultGrid({ x, y, z, size: size2 }) {
  const id = useUniqueSafeId("grid");
  const editor = useEditor();
  const { gridSteps } = editor.options;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: gridSteps.map(({ min: min2, mid, step }, i) => {
      const s = step * size2 * z;
      const xo = 0.5 + x * z;
      const yo = 0.5 + y * z;
      const gxo = xo > 0 ? xo % s : s + xo % s;
      const gyo = yo > 0 ? yo % s : s + yo % s;
      const opacity = z < mid ? modulate(z, [min2, mid], [0, 1]) : 1;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "pattern",
        {
          id: suffixSafeId(id, `${step}`),
          width: s,
          height: s,
          patternUnits: "userSpaceOnUse",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "tl-grid-dot", cx: gxo, cy: gyo, r: 1, opacity })
        },
        i
      );
    }) }),
    gridSteps.map(({ step }, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "100%", height: "100%", fill: `url(#${id}_${step})` }, i))
  ] });
}
function DefaultHandle({ handle, isCoarse, className, zoom }) {
  const editor = useEditor();
  const br = (isCoarse ? editor.options.coarseHandleRadius : editor.options.handleRadius) / zoom;
  if (handle.type === "clone") {
    const fr2 = 3 / zoom;
    const path = `M0,${-fr2} A${fr2},${fr2} 0 0,1 0,${fr2}`;
    const index2 = SIDES.indexOf(handle.id);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: classNames(`tl-handle tl-handle__${handle.type}`, className), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "tl-handle__bg", r: br }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: "tl-handle__fg", d: path, transform: `rotate(${-90 + 90 * index2})` })
    ] });
  }
  const fr = (handle.type === "create" && isCoarse ? 3 : 4) / Math.max(zoom, 0.25);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: classNames(`tl-handle tl-handle__${handle.type}`, className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "tl-handle__bg", r: br }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "tl-handle__fg", r: fr })
  ] });
}
const DefaultHandles = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "tl-user-handles tl-overlays__item", "aria-hidden": "true", children });
};
const version = "4.2.0";
const publishDates = {
  major: "2025-09-18T14:39:22.803Z",
  minor: "2025-11-19T11:47:45.748Z"
};
function useIdentity(value, isEqual2) {
  const ref = reactExports.useRef(value);
  if (isEqual2(value, ref.current)) {
    return ref.current;
  }
  ref.current = value;
  return value;
}
const areNullableArraysShallowEqual = (a, b) => {
  a ??= null;
  b ??= null;
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return areArraysShallowEqual(a, b);
};
function useShallowArrayIdentity(arr) {
  return useIdentity(arr, areNullableArraysShallowEqual);
}
const areNullableObjectsShallowEqual = (a, b) => {
  a ??= null;
  b ??= null;
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return areObjectsShallowEqual(a, b);
};
function useShallowObjectIdentity(obj) {
  return useIdentity(obj, areNullableObjectsShallowEqual);
}
const USER_DATA_KEY = "TLDRAW_USER_DATA_v3";
const userTypeValidator = object({
  id: string,
  name: string.nullable().optional(),
  color: string.nullable().optional(),
  // N.B. These are duplicated in TLdrawAppUser.
  locale: string.nullable().optional(),
  animationSpeed: number.nullable().optional(),
  areKeyboardShortcutsEnabled: boolean.nullable().optional(),
  edgeScrollSpeed: number.nullable().optional(),
  colorScheme: literalEnum("light", "dark", "system").optional(),
  isSnapMode: boolean.nullable().optional(),
  isWrapMode: boolean.nullable().optional(),
  isDynamicSizeMode: boolean.nullable().optional(),
  isPasteAtCursorMode: boolean.nullable().optional(),
  enhancedA11yMode: boolean.nullable().optional(),
  inputMode: literalEnum("trackpad", "mouse").nullable().optional()
});
const Versions$1 = {
  AddAnimationSpeed: 1,
  AddIsSnapMode: 2,
  MakeFieldsNullable: 3,
  AddEdgeScrollSpeed: 4,
  AddExcalidrawSelectMode: 5,
  AddDynamicSizeMode: 6,
  AllowSystemColorScheme: 7,
  AddPasteAtCursor: 8,
  AddKeyboardShortcuts: 9,
  AddShowUiLabels: 10,
  AddPointerPeripheral: 11,
  RenameShowUiLabelsToEnhancedA11yMode: 12
};
const CURRENT_VERSION = Math.max(...Object.values(Versions$1));
function migrateSnapshot(data) {
  if (data.version < Versions$1.AddAnimationSpeed) {
    data.user.animationSpeed = 1;
  }
  if (data.version < Versions$1.AddIsSnapMode) {
    data.user.isSnapMode = false;
  }
  if (data.version < Versions$1.MakeFieldsNullable) ;
  if (data.version < Versions$1.AddEdgeScrollSpeed) {
    data.user.edgeScrollSpeed = 1;
  }
  if (data.version < Versions$1.AddExcalidrawSelectMode) {
    data.user.isWrapMode = false;
  }
  if (data.version < Versions$1.AllowSystemColorScheme) {
    if (data.user.isDarkMode === true) {
      data.user.colorScheme = "dark";
    } else if (data.user.isDarkMode === false) {
      data.user.colorScheme = "light";
    }
    delete data.user.isDarkMode;
  }
  if (data.version < Versions$1.AddDynamicSizeMode) {
    data.user.isDynamicSizeMode = false;
  }
  if (data.version < Versions$1.AddPasteAtCursor) {
    data.user.isPasteAtCursorMode = false;
  }
  if (data.version < Versions$1.AddKeyboardShortcuts) {
    data.user.areKeyboardShortcutsEnabled = true;
  }
  if (data.version < Versions$1.AddShowUiLabels) {
    data.user.showUiLabels = false;
  }
  if (data.version < Versions$1.RenameShowUiLabelsToEnhancedA11yMode) {
    data.user.enhancedA11yMode = data.user.showUiLabels;
    delete data.user.showUiLabels;
  }
  if (data.version < Versions$1.AddPointerPeripheral) {
    data.user.inputMode = null;
  }
  data.version = CURRENT_VERSION;
}
const USER_COLORS = [
  "#FF802B",
  "#EC5E41",
  "#F2555A",
  "#F04F88",
  "#E34BA9",
  "#BD54C6",
  "#9D5BD2",
  "#7B66DC",
  "#02B1CC",
  "#11B3A3",
  "#39B178",
  "#55B467"
];
function getRandomColor() {
  return USER_COLORS[Math.floor(Math.random() * USER_COLORS.length)];
}
function userPrefersReducedMotion() {
  if (typeof window !== "undefined" && window.matchMedia) {
    return window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches ?? false;
  }
  return false;
}
const defaultUserPreferences = Object.freeze({
  name: "",
  locale: getDefaultTranslationLocale(),
  color: getRandomColor(),
  // N.B. These are duplicated in TLdrawAppUser.
  edgeScrollSpeed: 1,
  animationSpeed: userPrefersReducedMotion() ? 0 : 1,
  areKeyboardShortcutsEnabled: true,
  isSnapMode: false,
  isWrapMode: false,
  isDynamicSizeMode: false,
  isPasteAtCursorMode: false,
  enhancedA11yMode: false,
  colorScheme: "light",
  inputMode: null
});
function getFreshUserPreferences() {
  return {
    id: uniqueId(),
    color: getRandomColor()
  };
}
function migrateUserPreferences(userData) {
  if (userData === null || typeof userData !== "object") {
    return getFreshUserPreferences();
  }
  if (!("version" in userData) || !("user" in userData) || typeof userData.version !== "number") {
    return getFreshUserPreferences();
  }
  const snapshot = structuredClone(userData);
  migrateSnapshot(snapshot);
  try {
    return userTypeValidator.validate(snapshot.user);
  } catch {
    return getFreshUserPreferences();
  }
}
function loadUserPreferences() {
  const userData = JSON.parse(getFromLocalStorage(USER_DATA_KEY) || "null") ?? null;
  return migrateUserPreferences(userData);
}
const globalUserPreferences = atom("globalUserData", null);
function storeUserPreferences() {
  setInLocalStorage(
    USER_DATA_KEY,
    JSON.stringify({
      version: CURRENT_VERSION,
      user: globalUserPreferences.get()
    })
  );
}
function setUserPreferences(user) {
  userTypeValidator.validate(user);
  globalUserPreferences.set(user);
  storeUserPreferences();
  broadcastUserPreferencesChange();
}
const channel = typeof BroadcastChannel !== "undefined" && true ? new BroadcastChannel("tldraw-user-sync") : null;
channel?.addEventListener("message", (e) => {
  const data = e.data;
  if (data?.type === broadcastEventKey && data?.origin !== getBroadcastOrigin()) {
    globalUserPreferences.set(migrateUserPreferences(data.data));
  }
});
let _broadcastOrigin = null;
function getBroadcastOrigin() {
  if (_broadcastOrigin === null) {
    _broadcastOrigin = uniqueId();
  }
  return _broadcastOrigin;
}
const broadcastEventKey = "tldraw-user-preferences-change";
function broadcastUserPreferencesChange() {
  channel?.postMessage({
    type: broadcastEventKey,
    origin: getBroadcastOrigin(),
    data: {
      user: getUserPreferences(),
      version: CURRENT_VERSION
    }
  });
}
function getUserPreferences() {
  let prefs = globalUserPreferences.get();
  if (!prefs) {
    prefs = loadUserPreferences();
    setUserPreferences(prefs);
  }
  return prefs;
}
const defaultLocalStorageUserPrefs = computed(
  "defaultLocalStorageUserPrefs",
  () => getUserPreferences()
);
function createTLUser(opts = {}) {
  return {
    userPreferences: opts.userPreferences ?? defaultLocalStorageUserPrefs,
    setUserPreferences: opts.setUserPreferences ?? setUserPreferences
  };
}
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers2 = this._events[evt];
      if (!handlers2) return [];
      if (handlers2.fn) return [handlers2.fn];
      for (var i = 0, l = handlers2.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers2[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
const tabIdKey = "TLDRAW_TAB_ID_v2";
const window$1 = globalThis.window;
function iOS() {
  if (!window$1) return false;
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    window$1.navigator.platform
  ) || // iPad on iOS 13 detection
  tlenv.isDarwin && "ontouchend" in document;
}
const TAB_ID = window$1 ? window$1[tabIdKey] ?? getFromSessionStorage(tabIdKey) ?? `TLDRAW_INSTANCE_STATE_V1_` + uniqueId() : "<error>";
if (window$1) {
  window$1[tabIdKey] = TAB_ID;
  if (iOS()) {
    setInSessionStorage(tabIdKey, TAB_ID);
  } else {
    deleteFromSessionStorage(tabIdKey);
  }
}
window$1?.addEventListener("beforeunload", () => {
  setInSessionStorage(tabIdKey, TAB_ID);
});
const Versions = {
  Initial: 0
};
const CURRENT_SESSION_STATE_SNAPSHOT_VERSION = Math.max(...Object.values(Versions));
function migrate(snapshot) {
  if (snapshot.version < Versions.Initial) ;
  snapshot.version = CURRENT_SESSION_STATE_SNAPSHOT_VERSION;
}
const sessionStateSnapshotValidator = object({
  version: number,
  currentPageId: pageIdValidator.optional(),
  isFocusMode: boolean.optional(),
  exportBackground: boolean.optional(),
  isDebugMode: boolean.optional(),
  isToolLocked: boolean.optional(),
  isGridMode: boolean.optional(),
  pageStates: arrayOf(
    object({
      pageId: pageIdValidator,
      camera: object({
        x: number,
        y: number,
        z: number
      }).optional(),
      selectedShapeIds: arrayOf(shapeIdValidator).optional(),
      focusedGroupId: shapeIdValidator.nullable().optional()
    })
  ).optional()
});
function migrateAndValidateSessionStateSnapshot(state) {
  if (!state || typeof state !== "object") {
    console.warn("Invalid instance state");
    return null;
  }
  if (!("version" in state) || typeof state.version !== "number") {
    console.warn("No version in instance state");
    return null;
  }
  if (state.version !== CURRENT_SESSION_STATE_SNAPSHOT_VERSION) {
    state = structuredClone(state);
    migrate(state);
  }
  try {
    return sessionStateSnapshotValidator.validate(state);
  } catch (e) {
    console.warn(e);
    return null;
  }
}
function createSessionStateSnapshotSignal(store) {
  const $allPageIds = store.query.ids("page");
  return computed(
    "sessionStateSnapshot",
    () => {
      const instanceState = store.get(TLINSTANCE_ID);
      if (!instanceState) return null;
      const allPageIds = [...$allPageIds.get()];
      return {
        version: CURRENT_SESSION_STATE_SNAPSHOT_VERSION,
        currentPageId: instanceState.currentPageId,
        exportBackground: instanceState.exportBackground,
        isFocusMode: instanceState.isFocusMode,
        isDebugMode: instanceState.isDebugMode,
        isToolLocked: instanceState.isToolLocked,
        isGridMode: instanceState.isGridMode,
        pageStates: allPageIds.map((id) => {
          const ps = store.get(InstancePageStateRecordType.createId(id));
          const camera = store.get(CameraRecordType.createId(id));
          return {
            pageId: id,
            camera: {
              x: camera?.x ?? 0,
              y: camera?.y ?? 0,
              z: camera?.z ?? 1
            },
            selectedShapeIds: ps?.selectedShapeIds ?? [],
            focusedGroupId: ps?.focusedGroupId ?? null
          };
        })
      };
    },
    { isEqual }
  );
}
function loadSessionStateSnapshotIntoStore(store, snapshot, opts) {
  const res = migrateAndValidateSessionStateSnapshot(snapshot);
  if (!res) return;
  const preserved = pluckPreservingValues(store.get(TLINSTANCE_ID));
  const primary = opts?.forceOverwrite ? res : preserved;
  const secondary = opts?.forceOverwrite ? preserved : res;
  const instanceState = store.schema.types.instance.create({
    id: TLINSTANCE_ID,
    ...preserved,
    // the integrity checker will ensure that the currentPageId is valid
    currentPageId: res.currentPageId,
    isDebugMode: primary?.isDebugMode ?? secondary?.isDebugMode,
    isFocusMode: primary?.isFocusMode ?? secondary?.isFocusMode,
    isToolLocked: primary?.isToolLocked ?? secondary?.isToolLocked,
    isGridMode: primary?.isGridMode ?? secondary?.isGridMode,
    exportBackground: primary?.exportBackground ?? secondary?.exportBackground
  });
  store.atomic(() => {
    for (const ps of res.pageStates ?? []) {
      if (!store.has(ps.pageId)) continue;
      const cameraId = CameraRecordType.createId(ps.pageId);
      const instancePageState = InstancePageStateRecordType.createId(ps.pageId);
      const previousCamera = store.get(cameraId);
      const previousInstanceState = store.get(instancePageState);
      store.put([
        CameraRecordType.create({
          id: cameraId,
          x: ps.camera?.x ?? previousCamera?.x,
          y: ps.camera?.y ?? previousCamera?.y,
          z: ps.camera?.z ?? previousCamera?.z
        }),
        InstancePageStateRecordType.create({
          id: instancePageState,
          pageId: ps.pageId,
          selectedShapeIds: ps.selectedShapeIds ?? previousInstanceState?.selectedShapeIds,
          focusedGroupId: ps.focusedGroupId ?? previousInstanceState?.focusedGroupId
        })
      ]);
    }
    store.put([instanceState]);
    store.ensureStoreIsUsable();
  });
}
function extractSessionStateFromLegacySnapshot(store) {
  const instanceRecords = [];
  for (const record of Object.values(store)) {
    if (record.typeName?.match(/^(instance.*|pointer|camera)$/)) {
      instanceRecords.push(record);
    }
  }
  const oldInstance = instanceRecords.filter(
    (r) => r.typeName === "instance" && r.id !== TLINSTANCE_ID
  )[0];
  if (!oldInstance) return null;
  const result = {
    version: CURRENT_SESSION_STATE_SNAPSHOT_VERSION,
    currentPageId: oldInstance.currentPageId,
    exportBackground: !!oldInstance.exportBackground,
    isFocusMode: !!oldInstance.isFocusMode,
    isDebugMode: !!oldInstance.isDebugMode,
    isToolLocked: !!oldInstance.isToolLocked,
    isGridMode: false,
    pageStates: instanceRecords.filter((r) => r.typeName === "instance_page_state" && r.instanceId === oldInstance.id).map((ps) => {
      const camera = store[ps.cameraId] ?? { x: 0, y: 0, z: 1 };
      return {
        pageId: ps.pageId,
        camera: {
          x: camera.x,
          y: camera.y,
          z: camera.z
        },
        selectedShapeIds: ps.selectedShapeIds,
        focusedGroupId: ps.focusedGroupId
      };
    })
  };
  try {
    sessionStateSnapshotValidator.validate(result);
    return result;
  } catch {
    return null;
  }
}
function loadSnapshot(store, _snapshot, opts) {
  let snapshot = {};
  if ("store" in _snapshot) {
    const migrationResult = store.schema.migrateStoreSnapshot(_snapshot);
    if (migrationResult.type !== "success") {
      throw new Error("Failed to migrate store snapshot: " + migrationResult.reason);
    }
    snapshot.document = {
      schema: store.schema.serialize(),
      store: filterEntries(
        migrationResult.value,
        (_, { typeName }) => store.scopedTypes.document.has(typeName)
      )
    };
  } else {
    snapshot = _snapshot;
  }
  const preservingInstanceState = pluckPreservingValues(store.get(TLINSTANCE_ID));
  const preservingSessionState = sessionStateCache.get(store, createSessionStateSnapshotSignal).get();
  store.atomic(() => {
    if (snapshot.document) {
      store.loadStoreSnapshot(snapshot.document);
    }
    if (preservingInstanceState) {
      store.update(TLINSTANCE_ID, (r) => ({ ...r, ...preservingInstanceState }));
    }
    if (preservingSessionState) {
      loadSessionStateSnapshotIntoStore(store, preservingSessionState);
    }
    if (snapshot.session) {
      loadSessionStateSnapshotIntoStore(store, snapshot.session, {
        forceOverwrite: opts?.forceOverwriteSessionState
      });
    }
  });
}
const sessionStateCache = new WeakCache();
function getSnapshot(store) {
  const sessionState$ = sessionStateCache.get(store, createSessionStateSnapshotSignal);
  const session = sessionState$.get();
  if (!session) {
    throw new Error("Session state is not ready yet");
  }
  return {
    document: store.getStoreSnapshot(),
    session
  };
}
function checkBindings(customBindings) {
  const bindings = [];
  const addedCustomBindingTypes = /* @__PURE__ */ new Set();
  for (const customBinding of customBindings) {
    if (addedCustomBindingTypes.has(customBinding.type)) {
      throw new Error(`Binding type "${customBinding.type}" is defined more than once`);
    }
    bindings.push(customBinding);
    addedCustomBindingTypes.add(customBinding.type);
  }
  return bindings;
}
function SVGContainer({ children, className = "", ...rest }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { ...rest, className: classNames("tl-svg-container", className), "aria-hidden": "true", children });
}
class Box {
  constructor(x = 0, y = 0, w = 0, h2 = 0) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h2;
  }
  x = 0;
  y = 0;
  w = 0;
  h = 0;
  // eslint-disable-next-line no-restricted-syntax
  get point() {
    return new Vec(this.x, this.y);
  }
  // eslint-disable-next-line no-restricted-syntax
  set point(val) {
    this.x = val.x;
    this.y = val.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minX() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minX(n) {
    this.x = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get left() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midX() {
    return this.x + this.w / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxX() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get right() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minY() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minY(n) {
    this.y = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get top() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midY() {
    return this.y + this.h / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxY() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get bottom() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get width() {
    return this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  set width(n) {
    this.w = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get height() {
    return this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  set height(n) {
    this.h = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get aspectRatio() {
    return this.width / this.height;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return new Vec(this.x + this.w / 2, this.y + this.h / 2);
  }
  // eslint-disable-next-line no-restricted-syntax
  set center(v) {
    this.x = v.x - this.w / 2;
    this.y = v.y - this.h / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get corners() {
    return [
      new Vec(this.x, this.y),
      new Vec(this.x + this.w, this.y),
      new Vec(this.x + this.w, this.y + this.h),
      new Vec(this.x, this.y + this.h)
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get cornersAndCenter() {
    return [
      new Vec(this.x, this.y),
      new Vec(this.x + this.w, this.y),
      new Vec(this.x + this.w, this.y + this.h),
      new Vec(this.x, this.y + this.h),
      new Vec(this.x + this.w / 2, this.y + this.h / 2)
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get sides() {
    const { corners } = this;
    return [
      [corners[0], corners[1]],
      [corners[1], corners[2]],
      [corners[2], corners[3]],
      [corners[3], corners[0]]
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return new Vec(this.w, this.h);
  }
  toFixed() {
    this.x = toPrecision(this.x);
    this.y = toPrecision(this.y);
    this.w = toPrecision(this.w);
    this.h = toPrecision(this.h);
    return this;
  }
  setTo(B) {
    this.x = B.x;
    this.y = B.y;
    this.w = B.w;
    this.h = B.h;
    return this;
  }
  set(x = 0, y = 0, w = 0, h2 = 0) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h2;
    return this;
  }
  expand(A) {
    const minX = Math.min(this.x, A.x);
    const minY = Math.min(this.y, A.y);
    const maxX = Math.max(this.x + this.w, A.x + A.w);
    const maxY = Math.max(this.y + this.h, A.y + A.h);
    this.x = minX;
    this.y = minY;
    this.w = maxX - minX;
    this.h = maxY - minY;
    return this;
  }
  expandBy(n) {
    this.x -= n;
    this.y -= n;
    this.w += n * 2;
    this.h += n * 2;
    return this;
  }
  scale(n) {
    this.x /= n;
    this.y /= n;
    this.w /= n;
    this.h /= n;
    return this;
  }
  clone() {
    const { x, y, w, h: h2 } = this;
    return new Box(x, y, w, h2);
  }
  translate(delta) {
    this.x += delta.x;
    this.y += delta.y;
    return this;
  }
  snapToGrid(size2) {
    const minX = Math.round(this.x / size2) * size2;
    const minY = Math.round(this.y / size2) * size2;
    const maxX = Math.round((this.x + this.w) / size2) * size2;
    const maxY = Math.round((this.y + this.h) / size2) * size2;
    this.minX = minX;
    this.minY = minY;
    this.width = Math.max(1, maxX - minX);
    this.height = Math.max(1, maxY - minY);
  }
  collides(B) {
    return Box.Collides(this, B);
  }
  contains(B) {
    return Box.Contains(this, B);
  }
  includes(B) {
    return Box.Includes(this, B);
  }
  containsPoint(V2, margin = 0) {
    return Box.ContainsPoint(this, V2, margin);
  }
  getHandlePoint(handle) {
    switch (handle) {
      case "top_left":
        return new Vec(this.x, this.y);
      case "top_right":
        return new Vec(this.x + this.w, this.y);
      case "bottom_left":
        return new Vec(this.x, this.y + this.h);
      case "bottom_right":
        return new Vec(this.x + this.w, this.y + this.h);
      case "top":
        return new Vec(this.x + this.w / 2, this.y);
      case "right":
        return new Vec(this.x + this.w, this.y + this.h / 2);
      case "bottom":
        return new Vec(this.x + this.w / 2, this.y + this.h);
      case "left":
        return new Vec(this.x, this.y + this.h / 2);
    }
  }
  toJson() {
    return { x: this.x, y: this.y, w: this.w, h: this.h };
  }
  resize(handle, dx, dy) {
    const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = this;
    let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = this;
    switch (handle) {
      case "left":
      case "top_left":
      case "bottom_left": {
        b0x += dx;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        b1x += dx;
        break;
      }
    }
    switch (handle) {
      case "top":
      case "top_left":
      case "top_right": {
        b0y += dy;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        b1y += dy;
        break;
      }
    }
    const scaleX = (b1x - b0x) / (a1x - a0x);
    const scaleY = (b1y - b0y) / (a1y - a0y);
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    if (flipX) {
      const t2 = b1x;
      b1x = b0x;
      b0x = t2;
    }
    if (flipY) {
      const t2 = b1y;
      b1y = b0y;
      b0y = t2;
    }
    this.minX = b0x;
    this.minY = b0y;
    this.width = Math.abs(b1x - b0x);
    this.height = Math.abs(b1y - b0y);
  }
  union(box) {
    const minX = Math.min(this.x, box.x);
    const minY = Math.min(this.y, box.y);
    const maxX = Math.max(this.x + this.w, box.x + box.w);
    const maxY = Math.max(this.y + this.h, box.y + box.h);
    this.x = minX;
    this.y = minY;
    this.width = maxX - minX;
    this.height = maxY - minY;
    return this;
  }
  static From(box) {
    return new Box(box.x, box.y, box.w, box.h);
  }
  static FromCenter(center, size2) {
    return new Box(center.x - size2.x / 2, center.y - size2.y / 2, size2.x, size2.y);
  }
  static FromPoints(points) {
    if (points.length === 0) return new Box();
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let point;
    for (let i = 0, n = points.length; i < n; i++) {
      point = points[i];
      minX = Math.min(point.x, minX);
      minY = Math.min(point.y, minY);
      maxX = Math.max(point.x, maxX);
      maxY = Math.max(point.y, maxY);
    }
    return new Box(minX, minY, maxX - minX, maxY - minY);
  }
  static Expand(A, B) {
    const minX = Math.min(B.minX, A.minX);
    const minY = Math.min(B.minY, A.minY);
    const maxX = Math.max(B.maxX, A.maxX);
    const maxY = Math.max(B.maxY, A.maxY);
    return new Box(minX, minY, maxX - minX, maxY - minY);
  }
  static ExpandBy(A, n) {
    return new Box(A.minX - n, A.minY - n, A.width + n * 2, A.height + n * 2);
  }
  static Collides(A, B) {
    return !(A.maxX < B.minX || A.minX > B.maxX || A.maxY < B.minY || A.minY > B.maxY);
  }
  static Contains(A, B) {
    return A.minX < B.minX && A.minY < B.minY && A.maxY > B.maxY && A.maxX > B.maxX;
  }
  static ContainsApproximately(A, B, precision) {
    return approximatelyLte(A.minX, B.minX, precision) && approximatelyLte(A.minY, B.minY, precision) && approximatelyLte(B.maxX, A.maxX, precision) && approximatelyLte(B.maxY, A.maxY, precision);
  }
  static Includes(A, B) {
    return Box.Collides(A, B) || Box.Contains(A, B);
  }
  static ContainsPoint(A, B, margin = 0) {
    return !(B.x < A.minX - margin || B.y < A.minY - margin || B.x > A.maxX + margin || B.y > A.maxY + margin);
  }
  static Common(boxes) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < boxes.length; i++) {
      const B = boxes[i];
      minX = Math.min(minX, B.minX);
      minY = Math.min(minY, B.minY);
      maxX = Math.max(maxX, B.maxX);
      maxY = Math.max(maxY, B.maxY);
    }
    return new Box(minX, minY, maxX - minX, maxY - minY);
  }
  static Sides(A, inset = 0) {
    const { corners } = A;
    return [
      [corners[0], corners[1]],
      [corners[1], corners[2]],
      [corners[2], corners[3]],
      [corners[3], corners[0]]
    ];
  }
  static Resize(box, handle, dx, dy, isAspectRatioLocked = false) {
    const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = box;
    let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = box;
    switch (handle) {
      case "left":
      case "top_left":
      case "bottom_left": {
        b0x += dx;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        b1x += dx;
        break;
      }
    }
    switch (handle) {
      case "top":
      case "top_left":
      case "top_right": {
        b0y += dy;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        b1y += dy;
        break;
      }
    }
    const scaleX = (b1x - b0x) / (a1x - a0x);
    const scaleY = (b1y - b0y) / (a1y - a0y);
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    if (isAspectRatioLocked) {
      const aspectRatio = (a1x - a0x) / (a1y - a0y);
      const bw = Math.abs(b1x - b0x);
      const bh = Math.abs(b1y - b0y);
      const tw = bw * (scaleY < 0 ? 1 : -1) * (1 / aspectRatio);
      const th = bh * (scaleX < 0 ? 1 : -1) * aspectRatio;
      const isTall = aspectRatio < bw / bh;
      switch (handle) {
        case "top_left": {
          if (isTall) b0y = b1y + tw;
          else b0x = b1x + th;
          break;
        }
        case "top_right": {
          if (isTall) b0y = b1y + tw;
          else b1x = b0x - th;
          break;
        }
        case "bottom_right": {
          if (isTall) b1y = b0y - tw;
          else b1x = b0x - th;
          break;
        }
        case "bottom_left": {
          if (isTall) b1y = b0y - tw;
          else b0x = b1x + th;
          break;
        }
        case "bottom":
        case "top": {
          const m = (b0x + b1x) / 2;
          const w = bh * aspectRatio;
          b0x = m - w / 2;
          b1x = m + w / 2;
          break;
        }
        case "left":
        case "right": {
          const m = (b0y + b1y) / 2;
          const h2 = bw / aspectRatio;
          b0y = m - h2 / 2;
          b1y = m + h2 / 2;
          break;
        }
      }
    }
    if (flipX) {
      const t2 = b1x;
      b1x = b0x;
      b0x = t2;
    }
    if (flipY) {
      const t2 = b1y;
      b1y = b0y;
      b0y = t2;
    }
    const final = new Box(b0x, b0y, Math.abs(b1x - b0x), Math.abs(b1y - b0y));
    return {
      box: final,
      scaleX: +(final.width / box.width * (scaleX > 0 ? 1 : -1)).toFixed(5),
      scaleY: +(final.height / box.height * (scaleY > 0 ? 1 : -1)).toFixed(5)
    };
  }
  equals(other) {
    return Box.Equals(this, other);
  }
  static Equals(a, b) {
    return b.x === a.x && b.y === a.y && b.w === a.w && b.h === a.h;
  }
  zeroFix() {
    this.w = Math.max(1, this.w);
    this.h = Math.max(1, this.h);
    return this;
  }
  static ZeroFix(other) {
    return new Box(other.x, other.y, Math.max(1, other.w), Math.max(1, other.h));
  }
}
function flipSelectionHandleY(handle) {
  switch (handle) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "top_left":
      return "bottom_left";
    case "top_right":
      return "bottom_right";
    case "bottom_left":
      return "top_left";
    case "bottom_right":
      return "top_right";
    default:
      return handle;
  }
}
function flipSelectionHandleX(handle) {
  switch (handle) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top_left":
      return "top_right";
    case "top_right":
      return "top_left";
    case "bottom_left":
      return "bottom_right";
    case "bottom_right":
      return "bottom_left";
    default:
      return handle;
  }
}
function isSelectionCorner(selection) {
  return selection === "top_left" || selection === "top_right" || selection === "bottom_right" || selection === "bottom_left";
}
class Mat {
  constructor(a, b, c, d, e, f) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
  }
  a = 1;
  b = 0;
  c = 0;
  d = 1;
  e = 0;
  f = 0;
  equals(m) {
    return this === m || this.a === m.a && this.b === m.b && this.c === m.c && this.d === m.d && this.e === m.e && this.f === m.f;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.e = 0;
    this.f = 0;
    return this;
  }
  multiply(m) {
    const m2 = m;
    const { a, b, c, d, e, f } = this;
    this.a = a * m2.a + c * m2.b;
    this.c = a * m2.c + c * m2.d;
    this.e = a * m2.e + c * m2.f + e;
    this.b = b * m2.a + d * m2.b;
    this.d = b * m2.c + d * m2.d;
    this.f = b * m2.e + d * m2.f + f;
    return this;
  }
  rotate(r, cx, cy) {
    if (r === 0) return this;
    if (cx === void 0) return this.multiply(Mat.Rotate(r));
    return this.translate(cx, cy).multiply(Mat.Rotate(r)).translate(-cx, -cy);
  }
  translate(x, y) {
    return this.multiply(Mat.Translate(x, y));
  }
  scale(x, y) {
    return this.multiply(Mat.Scale(x, y));
  }
  invert() {
    const { a, b, c, d, e, f } = this;
    const denom = a * d - b * c;
    this.a = d / denom;
    this.b = b / -denom;
    this.c = c / -denom;
    this.d = a / denom;
    this.e = (d * e - c * f) / -denom;
    this.f = (b * e - a * f) / denom;
    return this;
  }
  applyToPoint(point) {
    return Mat.applyToPoint(this, point);
  }
  applyToPoints(points) {
    return Mat.applyToPoints(this, points);
  }
  rotation() {
    return Mat.Rotation(this);
  }
  point() {
    return Mat.Point(this);
  }
  decomposed() {
    return Mat.Decompose(this);
  }
  toCssString() {
    return Mat.toCssString(this);
  }
  setTo(model2) {
    Object.assign(this, model2);
    return this;
  }
  decompose() {
    return Mat.Decompose(this);
  }
  clone() {
    return new Mat(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  /* --------------------- Static --------------------- */
  static Identity() {
    return new Mat(1, 0, 0, 1, 0, 0);
  }
  static Translate(x, y) {
    return new Mat(1, 0, 0, 1, x, y);
  }
  static Rotate(r, cx, cy) {
    if (r === 0) return Mat.Identity();
    const cosAngle = Math.cos(r);
    const sinAngle = Math.sin(r);
    const rotationMatrix = new Mat(cosAngle, sinAngle, -sinAngle, cosAngle, 0, 0);
    if (cx === void 0) return rotationMatrix;
    return Mat.Compose(Mat.Translate(cx, cy), rotationMatrix, Mat.Translate(-cx, -cy));
  }
  static Scale(x, y, cx, cy) {
    const scaleMatrix = new Mat(x, 0, 0, y, 0, 0);
    if (cx === void 0) return scaleMatrix;
    return Mat.Translate(cx, cy).multiply(scaleMatrix).translate(-cx, -cy);
  }
  static Multiply(m1, m2) {
    return {
      a: m1.a * m2.a + m1.c * m2.b,
      c: m1.a * m2.c + m1.c * m2.d,
      e: m1.a * m2.e + m1.c * m2.f + m1.e,
      b: m1.b * m2.a + m1.d * m2.b,
      d: m1.b * m2.c + m1.d * m2.d,
      f: m1.b * m2.e + m1.d * m2.f + m1.f
    };
  }
  static Inverse(m) {
    const denom = m.a * m.d - m.b * m.c;
    return {
      a: m.d / denom,
      b: m.b / -denom,
      c: m.c / -denom,
      d: m.a / denom,
      e: (m.d * m.e - m.c * m.f) / -denom,
      f: (m.b * m.e - m.a * m.f) / denom
    };
  }
  static Absolute(m) {
    const denom = m.a * m.d - m.b * m.c;
    return {
      a: m.d / denom,
      b: m.b / -denom,
      c: m.c / -denom,
      d: m.a / denom,
      e: (m.d * m.e - m.c * m.f) / denom,
      f: (m.b * m.e - m.a * m.f) / -denom
    };
  }
  static Compose(...matrices) {
    const matrix = Mat.Identity();
    for (let i = 0, n = matrices.length; i < n; i++) {
      matrix.multiply(matrices[i]);
    }
    return matrix;
  }
  static Point(m) {
    return new Vec(m.e, m.f);
  }
  static Rotation(m) {
    let rotation;
    if (m.a !== 0 || m.c !== 0) {
      const hypotAc = (m.a * m.a + m.c * m.c) ** 0.5;
      rotation = Math.acos(m.a / hypotAc) * (m.c > 0 ? -1 : 1);
    } else if (m.b !== 0 || m.d !== 0) {
      const hypotBd = (m.b * m.b + m.d * m.d) ** 0.5;
      rotation = HALF_PI + Math.acos(m.b / hypotBd) * (m.d > 0 ? -1 : 1);
    } else {
      rotation = 0;
    }
    return clampRadians(rotation);
  }
  static Decompose(m) {
    let scaleX, scaleY, rotation;
    if (m.a !== 0 || m.c !== 0) {
      const hypotAc = (m.a * m.a + m.c * m.c) ** 0.5;
      scaleX = hypotAc;
      scaleY = (m.a * m.d - m.b * m.c) / hypotAc;
      rotation = Math.acos(m.a / hypotAc) * (m.c > 0 ? -1 : 1);
    } else if (m.b !== 0 || m.d !== 0) {
      const hypotBd = (m.b * m.b + m.d * m.d) ** 0.5;
      scaleX = (m.a * m.d - m.b * m.c) / hypotBd;
      scaleY = hypotBd;
      rotation = HALF_PI + Math.acos(m.b / hypotBd) * (m.d > 0 ? -1 : 1);
    } else {
      scaleX = 0;
      scaleY = 0;
      rotation = 0;
    }
    return {
      x: m.e,
      y: m.f,
      scaleX,
      scaleY,
      rotation: clampRadians(rotation)
    };
  }
  static Smooth(m, precision = 1e10) {
    m.a = Math.round(m.a * precision) / precision;
    m.b = Math.round(m.b * precision) / precision;
    m.c = Math.round(m.c * precision) / precision;
    m.d = Math.round(m.d * precision) / precision;
    m.e = Math.round(m.e * precision) / precision;
    m.f = Math.round(m.f * precision) / precision;
    return m;
  }
  static toCssString(m) {
    return `matrix(${toDomPrecision(m.a)}, ${toDomPrecision(m.b)}, ${toDomPrecision(
      m.c
    )}, ${toDomPrecision(m.d)}, ${toDomPrecision(m.e)}, ${toDomPrecision(m.f)})`;
  }
  static applyToPoint(m, point) {
    return new Vec(
      m.a * point.x + m.c * point.y + m.e,
      m.b * point.x + m.d * point.y + m.f,
      point.z
    );
  }
  static applyToXY(m, x, y) {
    return [m.a * x + m.c * y + m.e, m.b * x + m.d * y + m.f];
  }
  static applyToPoints(m, points) {
    return points.map(
      (point) => new Vec(m.a * point.x + m.c * point.y + m.e, m.b * point.x + m.d * point.y + m.f, point.z)
    );
  }
  static applyToBounds(m, box) {
    return new Box(m.e + box.minX, m.f + box.minY, box.width, box.height);
  }
  static From(m) {
    return new Mat(m.a, m.b, m.c, m.d, m.e, m.f);
  }
  static Cast(m) {
    return m instanceof Mat ? m : Mat.From(m);
  }
}
function intersectLineSegmentLineSegment(a1, a2, b1, b2, precision = 1e-10) {
  const ABx = a1.x - b1.x;
  const ABy = a1.y - b1.y;
  const BVx = b2.x - b1.x;
  const BVy = b2.y - b1.y;
  const AVx = a2.x - a1.x;
  const AVy = a2.y - a1.y;
  const ua_t = BVx * ABy - BVy * ABx;
  const ub_t = AVx * ABy - AVy * ABx;
  const u_b = BVy * AVx - BVx * AVy;
  if (approximately(ua_t, 0, precision) || approximately(ub_t, 0, precision)) return null;
  if (approximately(u_b, 0, precision)) return null;
  if (u_b !== 0) {
    const ua = ua_t / u_b;
    const ub = ub_t / u_b;
    if (approximatelyLte(0, ua, precision) && approximatelyLte(ua, 1, precision) && approximatelyLte(0, ub, precision) && approximatelyLte(ub, 1, precision)) {
      return Vec.AddXY(a1, ua * AVx, ua * AVy);
    }
  }
  return null;
}
function intersectLineSegmentCircle(a1, a2, c, r) {
  const a = (a2.x - a1.x) * (a2.x - a1.x) + (a2.y - a1.y) * (a2.y - a1.y);
  const b = 2 * ((a2.x - a1.x) * (a1.x - c.x) + (a2.y - a1.y) * (a1.y - c.y));
  const cc = c.x * c.x + c.y * c.y + a1.x * a1.x + a1.y * a1.y - 2 * (c.x * a1.x + c.y * a1.y) - r * r;
  const deter = b * b - 4 * a * cc;
  if (deter < 0) return null;
  if (deter === 0) return null;
  const e = Math.sqrt(deter);
  const u1 = (-b + e) / (2 * a);
  const u2 = (-b - e) / (2 * a);
  if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {
    return null;
  }
  const result = [];
  if (0 <= u1 && u1 <= 1) result.push(Vec.Lrp(a1, a2, u1));
  if (0 <= u2 && u2 <= 1) result.push(Vec.Lrp(a1, a2, u2));
  if (result.length === 0) return null;
  return result;
}
function intersectLineSegmentPolyline(a1, a2, points) {
  const result = [];
  let segmentIntersection;
  for (let i = 0, n = points.length - 1; i < n; i++) {
    segmentIntersection = intersectLineSegmentLineSegment(a1, a2, points[i], points[i + 1]);
    if (segmentIntersection) result.push(segmentIntersection);
  }
  if (result.length === 0) return null;
  return result;
}
function intersectLineSegmentPolygon(a1, a2, points) {
  const result = [];
  let segmentIntersection;
  for (let i = 1, n = points.length; i < n + 1; i++) {
    segmentIntersection = intersectLineSegmentLineSegment(
      a1,
      a2,
      points[i - 1],
      points[i % points.length]
    );
    if (segmentIntersection) result.push(segmentIntersection);
  }
  if (result.length === 0) return null;
  return result;
}
function intersectCircleCircle(c1, r1, c2, r2) {
  let dx = c2.x - c1.x;
  let dy = c2.y - c1.y;
  const d = Math.sqrt(dx * dx + dy * dy), x = (d * d - r2 * r2 + r1 * r1) / (2 * d), y = Math.sqrt(r1 * r1 - x * x);
  dx /= d;
  dy /= d;
  return [
    new Vec(c1.x + dx * x - dy * y, c1.y + dy * x + dx * y),
    new Vec(c1.x + dx * x + dy * y, c1.y + dy * x - dx * y)
  ];
}
function intersectCirclePolygon(c, r, points) {
  const result = [];
  let a, b, int;
  for (let i = 0, n = points.length; i < n; i++) {
    a = points[i];
    b = points[(i + 1) % points.length];
    int = intersectLineSegmentCircle(a, b, c, r);
    if (int) result.push(...int);
  }
  if (result.length === 0) return null;
  return result;
}
function intersectCirclePolyline(c, r, points) {
  const result = [];
  let a, b, int;
  for (let i = 1, n = points.length; i < n; i++) {
    a = points[i - 1];
    b = points[i];
    int = intersectLineSegmentCircle(a, b, c, r);
    if (int) result.push(...int);
  }
  if (result.length === 0) return null;
  return result;
}
function ccw(A, B, C) {
  return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
}
function linesIntersect(A, B, C, D) {
  return ccw(A, C, D) !== ccw(B, C, D) && ccw(A, B, C) !== ccw(A, B, D);
}
function intersectPolygonPolygon(polygonA, polygonB) {
  const result = /* @__PURE__ */ new Map();
  let a, b, c, d;
  for (let i = 0, n = polygonA.length; i < n; i++) {
    a = polygonA[i];
    if (pointInPolygon(a, polygonB)) {
      const id = getPointId(a);
      if (!result.has(id)) {
        result.set(id, a);
      }
    }
  }
  for (let i = 0, n = polygonB.length; i < n; i++) {
    a = polygonB[i];
    if (pointInPolygon(a, polygonA)) {
      const id = getPointId(a);
      if (!result.has(id)) {
        result.set(id, a);
      }
    }
  }
  for (let i = 0, n = polygonA.length; i < n; i++) {
    a = polygonA[i];
    b = polygonA[(i + 1) % polygonA.length];
    for (let j = 0, m = polygonB.length; j < m; j++) {
      c = polygonB[j];
      d = polygonB[(j + 1) % polygonB.length];
      const intersection = intersectLineSegmentLineSegment(a, b, c, d);
      if (intersection !== null) {
        const id = getPointId(intersection);
        if (!result.has(id)) {
          result.set(id, intersection);
        }
      }
    }
  }
  if (result.size === 0) return null;
  return orderClockwise([...result.values()]);
}
function intersectPolys(polyA, polyB, isAClosed, isBClosed) {
  const result = /* @__PURE__ */ new Map();
  for (let i = 0, n = isAClosed ? polyA.length : polyA.length - 1; i < n; i++) {
    const currentA = polyA[i];
    const nextA = polyA[(i + 1) % polyA.length];
    for (let j = 0, m = isBClosed ? polyB.length : polyB.length - 1; j < m; j++) {
      const currentB = polyB[j];
      const nextB = polyB[(j + 1) % polyB.length];
      const intersection = intersectLineSegmentLineSegment(currentA, nextA, currentB, nextB);
      if (intersection !== null) {
        const id = getPointId(intersection);
        if (!result.has(id)) {
          result.set(id, intersection);
        }
      }
    }
  }
  return [...result.values()];
}
function getPointId(point) {
  return `${point.x},${point.y}`;
}
function orderClockwise(points) {
  const C = Vec.Average(points);
  return points.sort((A, B) => Vec.Angle(C, A) - Vec.Angle(C, B));
}
function polygonsIntersect(a, b) {
  let a0, a1, b0, b1;
  for (let i = 0, n = a.length; i < n; i++) {
    a0 = a[i];
    a1 = a[(i + 1) % n];
    for (let j = 0, m = b.length; j < m; j++) {
      b0 = b[j];
      b1 = b[(j + 1) % m];
      if (linesIntersect(a0, a1, b0, b1)) return true;
    }
  }
  return false;
}
function polygonIntersectsPolyline(polygon, polyline) {
  let a, b, c, d;
  for (let i = 0, n = polygon.length; i < n; i++) {
    a = polygon[i];
    b = polygon[(i + 1) % n];
    for (let j = 1, m = polyline.length; j < m; j++) {
      c = polyline[j - 1];
      d = polyline[j];
      if (linesIntersect(a, b, c, d)) return true;
    }
  }
  return false;
}
const Geometry2dFilters = {
  EXCLUDE_NON_STANDARD: {
    includeLabels: false,
    includeInternal: false
  },
  EXCLUDE_LABELS: { includeLabels: false, includeInternal: true }
};
class Geometry2d {
  // todo: consider making accessors for these too, so that they can be overridden in subclasses by geometries with more complex logic
  isFilled = false;
  isClosed = true;
  isLabel = false;
  isEmptyLabel = false;
  isInternal = false;
  excludeFromShapeBounds = false;
  debugColor;
  ignore;
  constructor(opts) {
    const {
      isLabel = false,
      isEmptyLabel = false,
      isInternal = false,
      excludeFromShapeBounds = false
    } = opts;
    this.isFilled = opts.isFilled;
    this.isClosed = opts.isClosed;
    this.debugColor = opts.debugColor;
    this.ignore = opts.ignore;
    this.isLabel = isLabel;
    this.isEmptyLabel = isEmptyLabel;
    this.isInternal = isInternal;
    this.excludeFromShapeBounds = excludeFromShapeBounds;
  }
  isExcludedByFilter(filters) {
    if (!filters) return false;
    if (this.isLabel && !filters.includeLabels) return true;
    if (this.isInternal && !filters.includeInternal) return true;
    return false;
  }
  hitTestPoint(point, margin = 0, hitInside = false, _filters) {
    if (this.isClosed && (this.isFilled || hitInside) && pointInPolygon(point, this.vertices)) {
      return true;
    }
    return Vec.Dist2(point, this.nearestPoint(point)) <= margin * margin;
  }
  distanceToPoint(point, hitInside = false, filters) {
    return Vec.Dist(point, this.nearestPoint(point, filters)) * (this.isClosed && (this.isFilled || hitInside) && pointInPolygon(point, this.vertices) ? -1 : 1);
  }
  distanceToLineSegment(A, B, filters) {
    if (Vec.Equals(A, B)) return this.distanceToPoint(A, false, filters);
    const { vertices } = this;
    if (vertices.length === 0) throw Error("nearest point not found");
    if (vertices.length === 1) return Vec.Dist(A, vertices[0]);
    let nearest;
    let dist = Infinity;
    let d, p, q;
    const nextLimit = this.isClosed ? vertices.length : vertices.length - 1;
    for (let i = 0; i < vertices.length; i++) {
      p = vertices[i];
      if (i < nextLimit) {
        const next = vertices[(i + 1) % vertices.length];
        if (linesIntersect(A, B, p, next)) return 0;
      }
      q = Vec.NearestPointOnLineSegment(A, B, p, true);
      d = Vec.Dist2(p, q);
      if (d < dist) {
        dist = d;
        nearest = q;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return this.isClosed && this.isFilled && pointInPolygon(nearest, this.vertices) ? -dist : dist;
  }
  hitTestLineSegment(A, B, distance = 0, filters) {
    return this.distanceToLineSegment(A, B, filters) <= distance;
  }
  intersectLineSegment(A, B, _filters) {
    const intersections = this.isClosed ? intersectLineSegmentPolygon(A, B, this.vertices) : intersectLineSegmentPolyline(A, B, this.vertices);
    return intersections ?? [];
  }
  intersectCircle(center, radius, _filters) {
    const intersections = this.isClosed ? intersectCirclePolygon(center, radius, this.vertices) : intersectCirclePolyline(center, radius, this.vertices);
    return intersections ?? [];
  }
  intersectPolygon(polygon, _filters) {
    return intersectPolys(polygon, this.vertices, true, this.isClosed);
  }
  intersectPolyline(polyline, _filters) {
    return intersectPolys(polyline, this.vertices, false, this.isClosed);
  }
  /**
   * Find a point along the edge of the geometry that is a fraction `t` along the entire way round.
   */
  interpolateAlongEdge(t2, _filters) {
    const { vertices } = this;
    if (vertices.length === 0) return new Vec(0, 0);
    if (vertices.length === 1) return vertices[0];
    if (t2 <= 0) return vertices[0];
    const distanceToTravel = t2 * this.length;
    let distanceTraveled = 0;
    for (let i = 0; i < (this.isClosed ? vertices.length : vertices.length - 1); i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % vertices.length];
      const dist = Vec.Dist(curr, next);
      const newDistanceTraveled = distanceTraveled + dist;
      if (newDistanceTraveled >= distanceToTravel) {
        const p = Vec.Lrp(
          curr,
          next,
          invLerp(distanceTraveled, newDistanceTraveled, distanceToTravel)
        );
        return p;
      }
      distanceTraveled = newDistanceTraveled;
    }
    return this.isClosed ? vertices[0] : vertices[vertices.length - 1];
  }
  /**
   * Take `point`, find the closest point to it on the edge of the geometry, and return how far
   * along the edge it is as a fraction of the total length.
   */
  uninterpolateAlongEdge(point, _filters) {
    const { vertices, length } = this;
    let closestSegment = null;
    let closestDistance = Infinity;
    let distanceTraveled = 0;
    if (vertices.length === 0 || vertices.length === 1) return 0;
    for (let i = 0; i < (this.isClosed ? vertices.length : vertices.length - 1); i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % vertices.length];
      const nearestPoint = Vec.NearestPointOnLineSegment(curr, next, point, true);
      const distance = Vec.Dist(nearestPoint, point);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestSegment = {
          start: curr,
          end: next,
          nearestPoint,
          distanceToStart: distanceTraveled
        };
      }
      distanceTraveled += Vec.Dist(curr, next);
    }
    assert(closestSegment);
    const distanceAlongRoute = closestSegment.distanceToStart + Vec.Dist(closestSegment.start, closestSegment.nearestPoint);
    return distanceAlongRoute / length;
  }
  isPointInBounds(point, margin = 0) {
    const { bounds } = this;
    return !(point.x < bounds.minX - margin || point.y < bounds.minY - margin || point.x > bounds.maxX + margin || point.y > bounds.maxY + margin);
  }
  overlapsPolygon(_polygon) {
    const polygon = _polygon.map((v) => Vec.From(v));
    const { vertices, center, isFilled, isEmptyLabel, isClosed } = this;
    if (isEmptyLabel) return false;
    if (vertices.some((v) => pointInPolygon(v, polygon))) {
      return true;
    }
    if (isClosed) {
      if (isFilled) {
        if (pointInPolygon(center, polygon)) {
          return true;
        }
        if (polygon.every((v) => pointInPolygon(v, vertices))) {
          return true;
        }
      }
      if (polygonsIntersect(polygon, vertices)) {
        return true;
      }
    } else {
      if (polygonIntersectsPolyline(polygon, vertices)) {
        return true;
      }
    }
    return false;
  }
  transform(transform, opts) {
    return new TransformedGeometry2d(this, transform, opts);
  }
  _vertices;
  // eslint-disable-next-line no-restricted-syntax
  get vertices() {
    if (!this._vertices) {
      this._vertices = this.getVertices(Geometry2dFilters.EXCLUDE_LABELS);
    }
    return this._vertices;
  }
  getBoundsVertices() {
    if (this.excludeFromShapeBounds) return [];
    return this.vertices;
  }
  _boundsVertices;
  // eslint-disable-next-line no-restricted-syntax
  get boundsVertices() {
    if (!this._boundsVertices) {
      this._boundsVertices = this.getBoundsVertices();
    }
    return this._boundsVertices;
  }
  getBounds() {
    return Box.FromPoints(this.boundsVertices);
  }
  _bounds;
  // eslint-disable-next-line no-restricted-syntax
  get bounds() {
    if (!this._bounds) {
      this._bounds = this.getBounds();
    }
    return this._bounds;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return this.bounds.center;
  }
  _area;
  // eslint-disable-next-line no-restricted-syntax
  get area() {
    if (!this._area) {
      this._area = this.getArea();
    }
    return this._area;
  }
  getArea() {
    if (!this.isClosed) {
      return 0;
    }
    const { vertices } = this;
    let area = 0;
    for (let i = 0, n = vertices.length; i < n; i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % n];
      area += curr.x * next.y - next.x * curr.y;
    }
    return area / 2;
  }
  toSimpleSvgPath() {
    let path = "";
    const { vertices } = this;
    const n = vertices.length;
    if (n === 0) return path;
    path += `M${vertices[0].x},${vertices[0].y}`;
    for (let i = 1; i < n; i++) {
      path += `L${vertices[i].x},${vertices[i].y}`;
    }
    if (this.isClosed) {
      path += "Z";
    }
    return path;
  }
  _length;
  // eslint-disable-next-line no-restricted-syntax
  get length() {
    if (this._length) return this._length;
    this._length = this.getLength(Geometry2dFilters.EXCLUDE_LABELS);
    return this._length;
  }
  getLength(_filters) {
    const vertices = this.getVertices(_filters ?? Geometry2dFilters.EXCLUDE_LABELS);
    if (vertices.length === 0) return 0;
    let prev = vertices[0];
    let length = 0;
    for (let i = 1; i < vertices.length; i++) {
      const next = vertices[i];
      length += Vec.Dist(prev, next);
      prev = next;
    }
    if (this.isClosed) {
      length += Vec.Dist(vertices[vertices.length - 1], vertices[0]);
    }
    return length;
  }
}
class TransformedGeometry2d extends Geometry2d {
  constructor(geometry, matrix, opts) {
    super(geometry);
    this.geometry = geometry;
    this.matrix = matrix;
    this.inverse = Mat.Inverse(matrix);
    this.decomposed = Mat.Decompose(matrix);
    if (opts) {
      if (opts.isLabel != null) this.isLabel = opts.isLabel;
      if (opts.isInternal != null) this.isInternal = opts.isInternal;
      if (opts.debugColor != null) this.debugColor = opts.debugColor;
      if (opts.ignore != null) this.ignore = opts.ignore;
    }
    assert(
      approximately(this.decomposed.scaleX, this.decomposed.scaleY),
      "non-uniform scaling is not yet supported"
    );
  }
  inverse;
  decomposed;
  getVertices(filters) {
    return this.geometry.getVertices(filters).map((v) => Mat.applyToPoint(this.matrix, v));
  }
  getBoundsVertices() {
    return this.geometry.getBoundsVertices().map((v) => Mat.applyToPoint(this.matrix, v));
  }
  nearestPoint(point, filters) {
    return Mat.applyToPoint(
      this.matrix,
      this.geometry.nearestPoint(Mat.applyToPoint(this.inverse, point), filters)
    );
  }
  hitTestPoint(point, margin = 0, hitInside, filters) {
    return this.geometry.hitTestPoint(
      Mat.applyToPoint(this.inverse, point),
      margin / this.decomposed.scaleX,
      hitInside,
      filters
    );
  }
  distanceToPoint(point, hitInside = false, filters) {
    return this.geometry.distanceToPoint(Mat.applyToPoint(this.inverse, point), hitInside, filters) * this.decomposed.scaleX;
  }
  distanceToLineSegment(A, B, filters) {
    return this.geometry.distanceToLineSegment(
      Mat.applyToPoint(this.inverse, A),
      Mat.applyToPoint(this.inverse, B),
      filters
    ) * this.decomposed.scaleX;
  }
  hitTestLineSegment(A, B, distance = 0, filters) {
    return this.geometry.hitTestLineSegment(
      Mat.applyToPoint(this.inverse, A),
      Mat.applyToPoint(this.inverse, B),
      distance / this.decomposed.scaleX,
      filters
    );
  }
  intersectLineSegment(A, B, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectLineSegment(
        Mat.applyToPoint(this.inverse, A),
        Mat.applyToPoint(this.inverse, B),
        filters
      )
    );
  }
  intersectCircle(center, radius, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectCircle(
        Mat.applyToPoint(this.inverse, center),
        radius / this.decomposed.scaleX,
        filters
      )
    );
  }
  intersectPolygon(polygon, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectPolygon(Mat.applyToPoints(this.inverse, polygon), filters)
    );
  }
  intersectPolyline(polyline, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectPolyline(Mat.applyToPoints(this.inverse, polyline), filters)
    );
  }
  transform(transform, opts) {
    return new TransformedGeometry2d(this.geometry, Mat.Multiply(transform, this.matrix), {
      isLabel: opts?.isLabel ?? this.isLabel,
      isInternal: opts?.isInternal ?? this.isInternal,
      debugColor: opts?.debugColor ?? this.debugColor,
      ignore: opts?.ignore ?? this.ignore
    });
  }
  getSvgPathData() {
    throw new Error("Cannot get SVG path data for transformed geometry.");
  }
}
class Group2d extends Geometry2d {
  children = [];
  ignoredChildren = [];
  constructor(config) {
    super({ ...config, isClosed: true, isFilled: false });
    const addChildren = (children) => {
      for (const child of children) {
        if (child instanceof Group2d) {
          addChildren(child.children);
        } else if (child.ignore) {
          this.ignoredChildren.push(child);
        } else {
          this.children.push(child);
        }
      }
    };
    addChildren(config.children);
    if (this.children.length === 0) throw Error("Group2d must have at least one child");
  }
  getVertices(filters) {
    if (this.isExcludedByFilter(filters)) return [];
    return this.children.filter((c) => !c.isExcludedByFilter(filters)).flatMap((c) => c.getVertices(filters));
  }
  nearestPoint(point, filters) {
    let dist = Infinity;
    let nearest;
    const { children } = this;
    if (children.length === 0) {
      throw Error("no children");
    }
    let p;
    let d;
    for (const child of children) {
      if (child.isExcludedByFilter(filters)) continue;
      p = child.nearestPoint(point, filters);
      d = Vec.Dist2(p, point);
      if (d < dist) {
        dist = d;
        nearest = p;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  distanceToPoint(point, hitInside = false, filters) {
    let smallestDistance = Infinity;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      const distance = child.distanceToPoint(point, hitInside, filters);
      if (distance < smallestDistance) {
        smallestDistance = distance;
      }
    }
    return smallestDistance;
  }
  hitTestPoint(point, margin, hitInside, filters = Geometry2dFilters.EXCLUDE_LABELS) {
    return !!this.children.filter((c) => !c.isExcludedByFilter(filters)).find((c) => c.hitTestPoint(point, margin, hitInside));
  }
  hitTestLineSegment(A, B, zoom, filters = Geometry2dFilters.EXCLUDE_LABELS) {
    return !!this.children.filter((c) => !c.isExcludedByFilter(filters)).find((c) => c.hitTestLineSegment(A, B, zoom));
  }
  intersectLineSegment(A, B, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectLineSegment(A, B, filters);
    });
  }
  intersectCircle(center, radius, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectCircle(center, radius, filters);
    });
  }
  getBoundsVertices() {
    if (this.excludeFromShapeBounds) return [];
    return this.children.flatMap((child) => child.getBoundsVertices());
  }
  intersectPolygon(polygon, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectPolygon(polygon, filters);
    });
  }
  intersectPolyline(polyline, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectPolyline(polyline, filters);
    });
  }
  interpolateAlongEdge(t2, filters) {
    const totalLength = this.getLength(filters);
    const distanceToTravel = t2 * totalLength;
    let distanceTraveled = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      const childLength = child.length;
      const newDistanceTraveled = distanceTraveled + childLength;
      if (newDistanceTraveled >= distanceToTravel) {
        return child.interpolateAlongEdge(
          invLerp(distanceTraveled, newDistanceTraveled, distanceToTravel),
          filters
        );
      }
      distanceTraveled = newDistanceTraveled;
    }
    return this.children[this.children.length - 1].interpolateAlongEdge(1, filters);
  }
  uninterpolateAlongEdge(point, filters) {
    const totalLength = this.getLength(filters);
    let closestChild = null;
    let closestDistance = Infinity;
    let distanceTraveled = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      const childLength = child.getLength(filters);
      const newDistanceTraveled = distanceTraveled + childLength;
      const distance = child.distanceToPoint(point, false, filters);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestChild = {
          startLength: distanceTraveled,
          endLength: newDistanceTraveled,
          child
        };
      }
      distanceTraveled = newDistanceTraveled;
    }
    assert(closestChild);
    const normalizedDistanceInChild = closestChild.child.uninterpolateAlongEdge(point, filters);
    const childTLength = lerp(
      closestChild.startLength,
      closestChild.endLength,
      normalizedDistanceInChild
    );
    return childTLength / totalLength;
  }
  transform(transform) {
    return new Group2d({
      children: this.children.map((c) => c.transform(transform)),
      isLabel: this.isLabel,
      debugColor: this.debugColor,
      ignore: this.ignore
    });
  }
  getArea() {
    return this.children[0].area;
  }
  toSimpleSvgPath() {
    let path = "";
    for (const child of this.children) {
      path += child.toSimpleSvgPath();
    }
    const corners = Box.FromPoints(this.boundsVertices).corners;
    for (let i = 0, n = corners.length; i < n; i++) {
      const corner = corners[i];
      const prevCorner = corners[(i - 1 + n) % n];
      const prevDist = corner.dist(prevCorner);
      const nextCorner = corners[(i + 1) % n];
      const nextDist = corner.dist(nextCorner);
      const A = corner.clone().lrp(prevCorner, 4 / prevDist);
      const B = corner;
      const C = corner.clone().lrp(nextCorner, 4 / nextDist);
      path += `M${A.x},${A.y} L${B.x},${B.y} L${C.x},${C.y} `;
    }
    return path;
  }
  getLength(filters) {
    let length = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      length += child.length;
    }
    return length;
  }
  getSvgPathData() {
    return this.children.map((c, i) => c.isLabel ? "" : c.getSvgPathData(i === 0)).join(" ");
  }
  overlapsPolygon(polygon) {
    return this.children.some((child) => child.overlapsPolygon(polygon));
  }
}
class Edge2d extends Geometry2d {
  _start;
  _end;
  _d;
  _u;
  _ul;
  constructor(config) {
    super({ ...config, isClosed: false, isFilled: false });
    const { start, end } = config;
    this._start = start;
    this._end = end;
    this._d = start.clone().sub(end);
    this._u = this._d.clone().uni();
    this._ul = this._u.len();
  }
  getLength() {
    return this._d.len();
  }
  getVertices() {
    return [this._start, this._end];
  }
  nearestPoint(point) {
    const { _start: start, _end: end, _d: d, _u: u, _ul: l } = this;
    if (d.len() === 0) return start;
    if (l === 0) return start;
    const k = Vec.Sub(point, start).dpr(u) / l;
    const cx = start.x + u.x * k;
    if (cx < Math.min(start.x, end.x)) return start.x < end.x ? start : end;
    if (cx > Math.max(start.x, end.x)) return start.x > end.x ? start : end;
    const cy = start.y + u.y * k;
    if (cy < Math.min(start.y, end.y)) return start.y < end.y ? start : end;
    if (cy > Math.max(start.y, end.y)) return start.y > end.y ? start : end;
    return new Vec(cx, cy);
  }
  getSvgPathData(first2 = true) {
    const { _start: start, _end: end } = this;
    return `${first2 ? `M${start.toFixed()}` : ``} L${end.toFixed()}`;
  }
}
class Polyline2d extends Geometry2d {
  _points;
  _segments;
  constructor(config) {
    super({ isClosed: false, isFilled: false, ...config });
    const { points } = config;
    this._points = points;
    if (points.length < 2) {
      throw new Error("Polyline2d: points must be an array of at least 2 points");
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { vertices } = this;
      for (let i = 0, n = vertices.length - 1; i < n; i++) {
        const start = vertices[i];
        const end = vertices[i + 1];
        this._segments.push(new Edge2d({ start, end }));
      }
      if (this.isClosed) {
        this._segments.push(new Edge2d({ start: vertices[vertices.length - 1], end: vertices[0] }));
      }
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((acc, segment) => acc + segment.length, 0);
  }
  getVertices() {
    return this._points;
  }
  nearestPoint(A) {
    const { segments } = this;
    let nearest = this._points[0];
    let dist = Infinity;
    let p;
    let d;
    for (let i = 0; i < segments.length; i++) {
      p = segments[i].nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B, distance = 0) {
    const { segments } = this;
    for (let i = 0, n = segments.length; i < n; i++) {
      if (segments[i].hitTestLineSegment(A, B, distance)) {
        return true;
      }
    }
    return false;
  }
  getSvgPathData() {
    const { vertices } = this;
    if (vertices.length < 2) return "";
    return vertices.reduce((acc, vertex, i) => {
      if (i === 0) return `M ${vertex.x} ${vertex.y}`;
      return `${acc} L ${vertex.x} ${vertex.y}`;
    }, "");
  }
}
class Polygon2d extends Polyline2d {
  constructor(config) {
    super({ ...config });
    this.isClosed = true;
    if (config.points.length < 3) {
      throw new Error("Polygon2d: points must be an array of at least 3 points");
    }
  }
}
class Rectangle2d extends Polygon2d {
  _x;
  _y;
  _w;
  _h;
  constructor(config) {
    const { x = 0, y = 0, width, height } = config;
    super({
      ...config,
      points: [
        new Vec(x, y),
        new Vec(x + width, y),
        new Vec(x + width, y + height),
        new Vec(x, y + height)
      ]
    });
    this._x = x;
    this._y = y;
    this._w = width;
    this._h = height;
  }
  getBounds() {
    return new Box(this._x, this._y, this._w, this._h);
  }
  getSvgPathData() {
    const { _x: x, _y: y, _w: w, _h: h2 } = this;
    this.negativeZeroFix();
    return `M${x},${y} h${w} v${h2} h${-w}z`;
  }
  negativeZeroFix() {
    this._x = zeroFix(this._x);
    this._y = zeroFix(this._y);
    this._w = zeroFix(this._w);
    this._h = zeroFix(this._h);
  }
}
function zeroFix(value) {
  if (Object.is(value, -0)) return 0;
  return value;
}
class ShapeUtil {
  constructor(editor) {
    this.editor = editor;
  }
  /** Configure this shape utils {@link ShapeUtil.options | `options`}. */
  static configure(options) {
    return class extends this {
      // @ts-expect-error
      options = { ...this.options, ...options };
    };
  }
  /**
   * Options for this shape util. If you're implementing a custom shape util, you can override
   * this to provide customization options for your shape. If using an existing shape util, you
   * can customizing this by calling {@link ShapeUtil.configure}.
   */
  options = {};
  /**
   * Props allow you to define the shape's properties in a way that the editor can understand.
   * This has two main uses:
   *
   * 1. Validation. Shapes will be validated using these props to stop bad data from being saved.
   * 2. Styles. Each {@link @tldraw/tlschema#StyleProp} in the props can be set on many shapes at
   *    once, and will be remembered from one shape to the next.
   *
   * @example
   * ```tsx
   * import {T, TLBaseShape, TLDefaultColorStyle, DefaultColorStyle, ShapeUtil} from 'tldraw'
   *
   * type MyShape = TLBaseShape<'mine', {
   *      color: TLDefaultColorStyle,
   *      text: string,
   * }>
   *
   * class MyShapeUtil extends ShapeUtil<MyShape> {
   *     static props = {
   *         // we use tldraw's built-in color style:
   *         color: DefaultColorStyle,
   *         // validate that the text prop is a string:
   *         text: T.string,
   *     }
   * }
   * ```
   */
  static props;
  /**
   * Migrations allow you to make changes to a shape's props over time. Read the
   * {@link https://www.tldraw.dev/docs/persistence#Shape-props-migrations | shape prop migrations}
   * guide for more information.
   */
  static migrations;
  /**
   * The type of the shape util, which should match the shape's type.
   *
   * @public
   */
  static type;
  /**
   * Get the font faces that should be rendered in the document in order for this shape to render
   * correctly.
   *
   * @param shape - The shape.
   * @public
   */
  getFontFaces(shape) {
    return EMPTY_ARRAY;
  }
  /**
   * Whether the shape can be snapped to by another shape.
   *
   * @param shape - The shape.
   * @public
   */
  canSnap(_shape) {
    return true;
  }
  /**
   * Whether the shape can be tabbed to.
   *
   * @param shape - The shape.
   * @public
   */
  canTabTo(_shape) {
    return true;
  }
  /**
   * Whether the shape can be scrolled while editing.
   *
   * @public
   */
  canScroll(_shape) {
    return false;
  }
  /**
   * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.
   *
   * @public
   */
  canBind(_opts) {
    return true;
  }
  /**
   * Whether the shape can be double clicked to edit.
   *
   * @public
   */
  canEdit(_shape) {
    return false;
  }
  /**
   * Whether the shape can be resized.
   *
   * @public
   */
  canResize(_shape) {
    return true;
  }
  /**
   * When the shape is resized, whether the shape's children should also be resized.
   *
   * @public
   */
  canResizeChildren(_shape) {
    return true;
  }
  /**
   * Whether the shape can be edited in read-only mode.
   *
   * @public
   */
  canEditInReadonly(_shape) {
    return false;
  }
  /**
   * Whether the shape can be cropped.
   *
   * @public
   */
  canCrop(_shape) {
    return false;
  }
  /**
   * Whether the shape can participate in layout functions such as alignment or distribution.
   *
   * @param shape - The shape.
   * @param info - Additional context information: the type of action causing the layout and the
   * @public
   *
   * @public
   */
  canBeLaidOut(_shape, _info) {
    return true;
  }
  /**
   * Whether this shape can be culled. By default, shapes are culled for
   * performance reasons when they are outside of the viewport. Culled shapes are still rendered
   * to the DOM, but have their `display` property set to `none`.
   *
   * @param shape - The shape.
   */
  canCull(_shape) {
    return true;
  }
  /**
   * Does this shape provide a background for its children? If this is true,
   * then any children with a `renderBackground` method will have their
   * backgrounds rendered _above_ this shape. Otherwise, the children's
   * backgrounds will be rendered above either the next ancestor that provides
   * a background, or the canvas background.
   *
   * @internal
   */
  providesBackgroundForChildren(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideResizeHandles(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its rotation handles when selected.
   *
   * @public
   */
  hideRotateHandle(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its selection bounds background when selected.
   *
   * @public
   */
  hideSelectionBoundsBg(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its selection bounds foreground when selected.
   *
   * @public
   */
  hideSelectionBoundsFg(_shape) {
    return false;
  }
  /**
   * Whether the shape's aspect ratio is locked.
   *
   * @public
   */
  isAspectRatioLocked(_shape) {
    return false;
  }
  /**
   * By default, the bounds of an image export are the bounds of all the shapes it contains, plus
   * some padding. If an export includes a shape where `isExportBoundsContainer` is true, then the
   * padding is skipped _if the bounds of that shape contains all the other shapes_. This is
   * useful in cases like annotating on top of an image, where you usually want to avoid extra
   * padding around the image if you don't need it.
   *
   * @param _shape - The shape to check
   * @returns True if this shape should be treated as an export bounds container
   */
  isExportBoundsContainer(_shape) {
    return false;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape.
   * @param type - The shape type.
   * @public
   */
  canReceiveNewChildrenOfType(_shape, _type) {
    return false;
  }
  /** @internal */
  expandSelectionOutlinePx(shape) {
    return 0;
  }
  /**
   * Return elements to be added to the \<defs\> section of the canvases SVG context. This can be
   * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg
   * elements returned by `component`.
   *
   * Each def should have a unique `key`. If multiple defs from different shapes all have the same
   * key, only one will be used.
   */
  getCanvasSvgDefs() {
    return [];
  }
  /**
   * Get the geometry to use when snapping to this this shape in translate/resize operations. See
   * {@link BoundsSnapGeometry} for details.
   */
  getBoundsSnapGeometry(_shape) {
    return {};
  }
  /**
   * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}
   * for details.
   */
  getHandleSnapGeometry(_shape) {
    return {};
  }
  getText(_shape) {
    return void 0;
  }
  getAriaDescriptor(_shape) {
    return void 0;
  }
}
function getPerfectDashProps(totalLength, strokeWidth, opts = {}) {
  const {
    closed = false,
    snap = 1,
    start = "outset",
    end = "outset",
    lengthRatio = 2,
    style: style2 = "dashed",
    forceSolid = false
  } = opts;
  let dashLength = 0;
  let dashCount = 0;
  let ratio = 1;
  let gapLength = 0;
  let strokeDashoffset = 0;
  if (forceSolid) {
    return {
      strokeDasharray: "none",
      strokeDashoffset: "none"
    };
  }
  switch (style2) {
    case "dashed": {
      ratio = 1;
      dashLength = Math.min(strokeWidth * lengthRatio, totalLength / 4);
      break;
    }
    case "dotted": {
      ratio = 100;
      dashLength = strokeWidth / ratio;
      break;
    }
    default: {
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
    }
  }
  if (!closed) {
    if (start === "outset") {
      totalLength += dashLength / 2;
      strokeDashoffset += dashLength / 2;
    } else if (start === "skip") {
      totalLength -= dashLength;
      strokeDashoffset -= dashLength;
    }
    if (end === "outset") {
      totalLength += dashLength / 2;
    } else if (end === "skip") {
      totalLength -= dashLength;
    }
  }
  dashCount = Math.floor(totalLength / dashLength / (2 * ratio));
  dashCount -= dashCount % snap;
  if (dashCount < 3 && style2 === "dashed") {
    if (totalLength / strokeWidth < 4) {
      dashLength = totalLength;
      dashCount = 1;
      gapLength = 0;
    } else {
      dashLength = totalLength * (1 / 3);
      gapLength = totalLength * (1 / 3);
    }
  } else {
    dashLength = totalLength / dashCount / (2 * ratio);
    if (closed) {
      strokeDashoffset = dashLength / 2;
      gapLength = (totalLength - dashCount * dashLength) / dashCount;
    } else {
      gapLength = (totalLength - dashCount * dashLength) / Math.max(1, dashCount - 1);
    }
  }
  return {
    strokeDasharray: [dashLength, gapLength].join(" "),
    strokeDashoffset: strokeDashoffset.toString()
  };
}
function DashedOutlineBox({ bounds, className }) {
  const editor = useEditor();
  const zoomLevel = useValue("zoom level", () => editor.getZoomLevel(), [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round", children: bounds.sides.map((side, i) => {
    const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
      side[0].dist(side[1]),
      1 / zoomLevel,
      {
        style: "dashed",
        lengthRatio: 4
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        x1: side[0].x,
        y1: side[0].y,
        x2: side[1].x,
        y2: side[1].y,
        strokeDasharray,
        strokeDashoffset
      },
      i
    );
  }) });
}
class GroupShapeUtil extends ShapeUtil {
  static type = "group";
  static props = groupShapeProps;
  static migrations = groupShapeMigrations;
  hideSelectionBoundsFg() {
    return true;
  }
  canBind() {
    return false;
  }
  canResize() {
    return true;
  }
  canResizeChildren() {
    return true;
  }
  getDefaultProps() {
    return {};
  }
  getGeometry(shape) {
    const children = this.editor.getSortedChildIdsForParent(shape.id);
    if (children.length === 0) {
      return new Rectangle2d({ width: 1, height: 1, isFilled: false });
    }
    return new Group2d({
      children: children.map((childId) => {
        const shape2 = this.editor.getShape(childId);
        return this.editor.getShapeGeometry(childId).transform(this.editor.getShapeLocalTransform(shape2), { isLabel: false });
      })
    });
  }
  component(shape) {
    const isErasing = this.editor.getErasingShapeIds().includes(shape.id);
    const { hintingShapeIds } = this.editor.getCurrentPageState();
    const isHintingOtherGroup = hintingShapeIds.length > 0 && hintingShapeIds.some(
      (id) => id !== shape.id && this.editor.isShapeOfType(this.editor.getShape(id), "group")
    );
    const isFocused = this.editor.getCurrentPageState().focusedGroupId !== shape.id;
    if (!isErasing && // always show the outline while we're erasing the group
    // show the outline while the group is focused unless something outside of the group is being hinted
    // this happens dropping shapes from a group onto some outside group
    (isFocused || isHintingOtherGroup)) {
      return null;
    }
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DashedOutlineBox, { className: "tl-group", bounds }) });
  }
  indicator(shape) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DashedOutlineBox, { className: "", bounds });
  }
  onChildrenChange(group) {
    const children = this.editor.getSortedChildIdsForParent(group.id);
    if (children.length === 0) {
      if (this.editor.getCurrentPageState().focusedGroupId === group.id) {
        this.editor.popFocusedGroupId();
      }
      this.editor.deleteShapes([group.id]);
      return;
    } else if (children.length === 1) {
      if (this.editor.getCurrentPageState().focusedGroupId === group.id) {
        this.editor.popFocusedGroupId();
      }
      this.editor.reparentShapes(children, group.parentId);
      this.editor.deleteShapes([group.id]);
      return;
    }
  }
}
const coreShapes = [
  // created by grouping interactions, probably the corest core shape that we have
  GroupShapeUtil
];
const coreShapeTypes = new Set(coreShapes.map((s) => s.type));
function checkShapesAndAddCore(customShapes) {
  const shapes = [...coreShapes];
  const addedCustomShapeTypes = /* @__PURE__ */ new Set();
  for (const customShape of customShapes) {
    if (coreShapeTypes.has(customShape.type)) {
      throw new Error(
        `Shape type "${customShape.type}" is a core shapes type and cannot be overridden`
      );
    }
    if (addedCustomShapeTypes.has(customShape.type)) {
      throw new Error(`Shape type "${customShape.type}" is defined more than once`);
    }
    shapes.push(customShape);
    addedCustomShapeTypes.add(customShape.type);
  }
  return shapes;
}
var reactDomExports = requireReactDom();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
function fetchCache(cb, init2) {
  const cache = /* @__PURE__ */ new Map();
  return async function fetchCached(url) {
    const existing = cache.get(url);
    if (existing) return existing;
    const promise = (async () => {
      try {
        const response = await fetch$1(url, init2);
        assert(response.ok);
        return await cb(response);
      } catch (err) {
        console.error(err);
        return null;
      }
    })();
    cache.set(url, promise);
    return promise;
  };
}
const resourceToDataUrl = fetchCache(async (response) => {
  return await FileHelpers.blobToDataUrl(await response.blob());
});
const importsRegex = /@import\s+(?:"([^"]+)"|'([^']+)'|url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\))([^;]+);/gi;
const fontFaceRegex = /@font-face\s*{([^}]+)}/gi;
const urlsRegex = /url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\)/gi;
const fontFamilyRegex = /(?:^|;)\s*font-family\s*:\s*(?:([^'"][^;\n]+)|"([^"]+)"|'([^']+)')\s*(?:;|$)/gi;
function parseCssImports(css) {
  return Array.from(css.matchAll(importsRegex), (m) => ({
    url: m[1] || m[2] || m[3] || m[4] || m[5],
    extras: m[6]
  }));
}
function parseCssFontFaces(css, baseUrl) {
  return Array.from(css.matchAll(fontFaceRegex), (m) => {
    const fontFace = m[1];
    const urls = Array.from(fontFace.matchAll(urlsRegex), (m2) => {
      const original = m2[1] || m2[2] || m2[3];
      return {
        original,
        resolved: safeParseUrl(original, baseUrl)?.href ?? null
      };
    });
    const fontFamilies = new Set(
      Array.from(fontFace.matchAll(fontFamilyRegex), (m2) => (m2[1] || m2[2] || m2[3]).toLowerCase())
    );
    return { fontFace, urls, fontFamilies };
  });
}
function parseCssFontFamilyValue(value) {
  const valueRegex = /\s*(?:([^'"][^;\n\s,]+)|"([^"]+)"|'([^']+)')\s*/gi;
  const separatorRegex = /\s*,\s*/gi;
  const fontFamilies = /* @__PURE__ */ new Set();
  while (true) {
    const valueMatch = valueRegex.exec(value);
    if (!valueMatch) {
      break;
    }
    const fontFamily = valueMatch[1] || valueMatch[2] || valueMatch[3];
    fontFamilies.add(fontFamily.toLowerCase());
    separatorRegex.lastIndex = valueRegex.lastIndex;
    const separatorMatch = separatorRegex.exec(value);
    if (!separatorMatch) {
      break;
    }
    valueRegex.lastIndex = separatorRegex.lastIndex;
  }
  return fontFamilies;
}
function shouldIncludeCssProperty(property) {
  if (property.startsWith("-")) return false;
  if (property.startsWith("animation")) return false;
  if (property.startsWith("transition")) return false;
  if (property === "cursor") return false;
  if (property === "pointer-events") return false;
  if (property === "user-select") return false;
  if (property === "touch-action") return false;
  return true;
}
function parseCss(css, baseUrl) {
  return {
    imports: parseCssImports(css),
    fontFaces: parseCssFontFaces(css, baseUrl)
  };
}
function parseCssValueUrls(value) {
  return Array.from(value.matchAll(urlsRegex), (m) => ({
    original: m[0],
    url: m[1] || m[2] || m[3]
  }));
}
var __create$b = Object.create;
var __defProp$f = Object.defineProperty;
var __getOwnPropDesc$b = Object.getOwnPropertyDescriptor;
var __knownSymbol$b = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$b = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$b = (base2) => [, , , __create$b(null)];
var __decoratorStrings$b = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$b = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$b("Function expected") : fn;
var __decoratorContext$b = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings$b[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError$b("Already initialized") : fns.push(__expectFn$b(fn || null)) });
var __decoratorMetadata$b = (array2, target) => __defNormalProp$b(target, __knownSymbol$b("metadata"), array2[3]);
var __runInitializers$c = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$b = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings$b[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$b(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$b(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$b(it) && (desc[key] = it);
  }
  return desc && __defProp$f(target, name, desc), target;
};
var __publicField$b = (obj, key, value) => __defNormalProp$b(obj, typeof key !== "symbol" ? key + "" : key, value);
var _onFontFamilyValue_dec, _init$b;
const SVG_EXPORT_CLASSNAME = "tldraw-svg-export";
_onFontFamilyValue_dec = [bind$1];
class FontEmbedder {
  constructor() {
    __runInitializers$c(_init$b, 5, this);
    __publicField$b(this, "fontFacesPromise", null);
    __publicField$b(this, "foundFontNames", /* @__PURE__ */ new Set());
    __publicField$b(this, "fontFacesToEmbed", /* @__PURE__ */ new Set());
    __publicField$b(this, "pendingPromises", []);
  }
  startFindingCurrentDocumentFontFaces() {
    assert(!this.fontFacesPromise, "FontEmbedder already started");
    this.fontFacesPromise = getCurrentDocumentFontFaces();
  }
  onFontFamilyValue(fontFamilyValue) {
    assert(this.fontFacesPromise, "FontEmbedder not started");
    const fonts = parseCssFontFamilyValue(fontFamilyValue);
    for (const font of fonts) {
      if (this.foundFontNames.has(font)) return;
      this.foundFontNames.add(font);
      this.pendingPromises.push(
        this.fontFacesPromise.then((fontFaces) => {
          const relevantFontFaces = fontFaces.filter((fontFace) => fontFace.fontFamilies.has(font));
          for (const fontFace of relevantFontFaces) {
            if (this.fontFacesToEmbed.has(fontFace)) continue;
            this.fontFacesToEmbed.add(fontFace);
            for (const url of fontFace.urls) {
              if (!url.resolved || url.embedded) continue;
              url.embedded = resourceToDataUrl(url.resolved);
            }
          }
        })
      );
    }
  }
  async createCss() {
    await Promise.all(this.pendingPromises);
    let css = "";
    for (const fontFace of this.fontFacesToEmbed) {
      let fontFaceString = `@font-face {${fontFace.fontFace}}`;
      for (const url of fontFace.urls) {
        if (!url.embedded) continue;
        const dataUrl = await url.embedded;
        if (!dataUrl) continue;
        fontFaceString = fontFaceString.replace(url.original, dataUrl);
      }
      css += fontFaceString;
    }
    return css;
  }
}
_init$b = __decoratorStart$b();
__decorateElement$b(_init$b, 1, "onFontFamilyValue", _onFontFamilyValue_dec, FontEmbedder);
__decoratorMetadata$b(_init$b, FontEmbedder);
async function getCurrentDocumentFontFaces() {
  const fontFaces = [];
  const styleSheetsWithoutSvgExports = Array.from(document.styleSheets).filter(
    (styleSheet) => !styleSheet.ownerNode?.closest(`.${SVG_EXPORT_CLASSNAME}`)
  );
  for (const styleSheet of styleSheetsWithoutSvgExports) {
    let cssRules2;
    try {
      cssRules2 = styleSheet.cssRules;
    } catch {
    }
    if (cssRules2) {
      for (const rule of styleSheet.cssRules) {
        if (rule instanceof CSSFontFaceRule) {
          fontFaces.push(parseCssFontFaces(rule.cssText, styleSheet.href ?? document.baseURI));
        } else if (rule instanceof CSSImportRule) {
          const absoluteUrl = new URL(rule.href, rule.parentStyleSheet?.href ?? document.baseURI);
          fontFaces.push(fetchCssFontFaces(absoluteUrl.href));
        }
      }
    } else if (styleSheet.href) {
      fontFaces.push(fetchCssFontFaces(styleSheet.href));
    }
  }
  return compact(await Promise.all(fontFaces)).flat();
}
const fetchCssFontFaces = fetchCache(async (response) => {
  const parsed = parseCss(await response.text(), response.url);
  const importedFontFaces = await Promise.all(
    parsed.imports.map(({ url }) => fetchCssFontFaces(new URL(url, response.url).href))
  );
  return [...parsed.fontFaces, ...compact(importedFontFaces).flat()];
});
const isCoveredByCurrentColor = (value, property, { currentColor }) => {
  return value === "currentColor" || value === currentColor;
};
const isInherited = (value, property, { parentStyles }) => {
  return parentStyles[property] === value;
};
const isExcludedBorder = (borderDirection) => (value, property, { getStyle }) => {
  const borderWidth = getStyle(`border-${borderDirection}-width`);
  const borderStyle = getStyle(`border-${borderDirection}-style`);
  if (borderWidth === "0px") return true;
  if (borderStyle === "none") return true;
  return false;
};
const cssRules = {
  // currentColor properties:
  "border-block-end-color": isCoveredByCurrentColor,
  "border-block-start-color": isCoveredByCurrentColor,
  "border-bottom-color": isCoveredByCurrentColor,
  "border-inline-end-color": isCoveredByCurrentColor,
  "border-inline-start-color": isCoveredByCurrentColor,
  "border-left-color": isCoveredByCurrentColor,
  "border-right-color": isCoveredByCurrentColor,
  "border-top-color": isCoveredByCurrentColor,
  "caret-color": isCoveredByCurrentColor,
  "column-rule-color": isCoveredByCurrentColor,
  "outline-color": isCoveredByCurrentColor,
  "text-decoration": (value, property, { currentColor }) => {
    return value === "none solid currentColor" || value === "none solid " + currentColor;
  },
  "text-decoration-color": isCoveredByCurrentColor,
  "text-emphasis-color": isCoveredByCurrentColor,
  // inherited properties:
  "border-collapse": isInherited,
  "border-spacing": isInherited,
  "caption-side": isInherited,
  // N.B. We shouldn't inherit 'color' because there's some UA styling, e.g. `mark` elements
  // 'color': isInherited,
  cursor: isInherited,
  direction: isInherited,
  "empty-cells": isInherited,
  "font-family": isInherited,
  "font-size": isInherited,
  "font-style": isInherited,
  "font-variant": isInherited,
  "font-weight": isInherited,
  "font-size-adjust": isInherited,
  "font-stretch": isInherited,
  font: isInherited,
  "letter-spacing": isInherited,
  "line-height": isInherited,
  "list-style-image": isInherited,
  "list-style-position": isInherited,
  "list-style-type": isInherited,
  "list-style": isInherited,
  orphans: isInherited,
  "overflow-wrap": isInherited,
  quotes: isInherited,
  "stroke-linecap": isInherited,
  "stroke-linejoin": isInherited,
  "tab-size": isInherited,
  "text-align": isInherited,
  "text-align-last": isInherited,
  "text-indent": isInherited,
  "text-justify": isInherited,
  "text-shadow": isInherited,
  "text-transform": isInherited,
  visibility: isInherited,
  "white-space": isInherited,
  "white-space-collapse": isInherited,
  widows: isInherited,
  "word-break": isInherited,
  "word-spacing": isInherited,
  "word-wrap": isInherited,
  // special border cases - we have a weird case (tailwind seems to trigger this) where all
  // border-styles sometimes get set to 'solid', but the border-width is 0 so they don't render.
  // but in SVGs, **sometimes**, the border-width defaults (i think from a UA style-sheet? but
  // honestly can't tell) to 1.5px so the border displays. we work around this by only including
  // border styles at all if both the border-width and border-style are set to something that
  // would show a border.
  "border-top": isExcludedBorder("top"),
  "border-right": isExcludedBorder("right"),
  "border-bottom": isExcludedBorder("bottom"),
  "border-left": isExcludedBorder("left"),
  "border-block-end": isExcludedBorder("block-end"),
  "border-block-start": isExcludedBorder("block-start"),
  "border-inline-end": isExcludedBorder("inline-end"),
  "border-inline-start": isExcludedBorder("inline-start"),
  "border-top-style": isExcludedBorder("top"),
  "border-right-style": isExcludedBorder("right"),
  "border-bottom-style": isExcludedBorder("bottom"),
  "border-left-style": isExcludedBorder("left"),
  "border-block-end-style": isExcludedBorder("block-end"),
  "border-block-start-style": isExcludedBorder("block-start"),
  "border-inline-end-style": isExcludedBorder("inline-end"),
  "border-inline-start-style": isExcludedBorder("inline-start"),
  "border-top-width": isExcludedBorder("top"),
  "border-right-width": isExcludedBorder("right"),
  "border-bottom-width": isExcludedBorder("bottom"),
  "border-left-width": isExcludedBorder("left"),
  "border-block-end-width": isExcludedBorder("block-end"),
  "border-block-start-width": isExcludedBorder("block-start"),
  "border-inline-end-width": isExcludedBorder("inline-end")
};
function getRenderedChildNodes(node) {
  if (node.shadowRoot) {
    return node.shadowRoot.childNodes;
  }
  if (isShadowSlotElement(node)) {
    const assignedNodes = node.assignedNodes();
    if (assignedNodes?.length) {
      return assignedNodes;
    }
  }
  return node.childNodes;
}
function* getRenderedChildren(node) {
  for (const child of getRenderedChildNodes(node)) {
    if (isElement$1(child)) yield child;
  }
}
function getWindow$1(node) {
  return node.ownerDocument?.defaultView ?? globalThis;
}
function isElement$1(node) {
  return node instanceof getWindow$1(node).Element;
}
function isShadowRoot$1(node) {
  return node instanceof getWindow$1(node).ShadowRoot;
}
function isInShadowRoot(node) {
  return "getRootNode" in node && isShadowRoot$1(node.getRootNode());
}
function isShadowSlotElement(node) {
  return isInShadowRoot(node) && node instanceof getWindow$1(node).HTMLSlotElement;
}
function elementStyle(element) {
  return element.style;
}
function getComputedStyle$2(element, pseudoElement) {
  return getWindow$1(element).getComputedStyle(element, pseudoElement);
}
const NO_STYLES = {};
class StyleEmbedder {
  constructor(root) {
    this.root = root;
  }
  styles = /* @__PURE__ */ new Map();
  fonts = new FontEmbedder();
  readRootElementStyles(rootElement) {
    this.readElementStyles(rootElement, {
      shouldRespectDefaults: false,
      shouldSkipInheritedParentStyles: false
    });
    const children = Array.from(getRenderedChildren(rootElement));
    while (children.length) {
      const child = children.pop();
      children.push(...getRenderedChildren(child));
      this.readElementStyles(child, {
        shouldRespectDefaults: true,
        shouldSkipInheritedParentStyles: true
      });
    }
  }
  readElementStyles(element, { shouldRespectDefaults = true, shouldSkipInheritedParentStyles = true }) {
    const defaultStyles = shouldRespectDefaults ? getDefaultStylesForTagName(element.tagName.toLowerCase()) : NO_STYLES;
    const parentStyles = Object.assign({}, NO_STYLES);
    if (shouldSkipInheritedParentStyles) {
      let el = element.parentElement;
      while (el) {
        const currentStyles = this.styles.get(el)?.self;
        for (const style2 in currentStyles) {
          if (!parentStyles[style2]) {
            parentStyles[style2] = currentStyles[style2];
          }
        }
        el = el.parentElement;
      }
    }
    const info = {
      self: styleFromElement(element, { defaultStyles, parentStyles }),
      before: styleFromPseudoElement(element, "::before"),
      after: styleFromPseudoElement(element, "::after")
    };
    this.styles.set(element, info);
  }
  fetchResources() {
    const promises = [];
    for (const info of this.styles.values()) {
      for (const styles of objectMapValues(info)) {
        if (!styles) continue;
        for (const [property, value] of Object.entries(styles)) {
          if (!value) continue;
          if (property === "font-family") {
            this.fonts.onFontFamilyValue(value);
          }
          const urlMatches = parseCssValueUrls(value);
          if (urlMatches.length === 0) continue;
          promises.push(
            ...urlMatches.map(async ({ url, original }) => {
              const dataUrl = await resourceToDataUrl(url) ?? "data:";
              styles[property] = value.replace(original, `url("${dataUrl}")`);
            })
          );
        }
      }
    }
    return Promise.all(promises);
  }
  // custom elements are tricky. if we serialize the dom as-is, the custom elements wont have
  // their shadow-dom contents serialized. after we've read all the styles, we need to unwrap the
  // contents of each custom elements shadow dom directly into the parent element itself.
  unwrapCustomElements() {
    const visited = /* @__PURE__ */ new Set();
    const visit = (element, clonedParent) => {
      if (visited.has(element)) return;
      visited.add(element);
      const shadowRoot = element.shadowRoot;
      if (shadowRoot) {
        const clonedCustomEl = document.createElement("div");
        this.styles.set(clonedCustomEl, this.styles.get(element));
        clonedCustomEl.setAttribute("data-tl-custom-element", element.tagName);
        (clonedParent ?? element.parentElement).appendChild(clonedCustomEl);
        for (const child of shadowRoot.childNodes) {
          if (child instanceof Element) {
            visit(child, clonedCustomEl);
          } else {
            clonedCustomEl.appendChild(child.cloneNode(true));
          }
        }
        element.remove();
      } else if (clonedParent) {
        if (element.tagName.toLowerCase() === "style") {
          return;
        }
        const clonedEl = element.cloneNode(false);
        this.styles.set(clonedEl, this.styles.get(element));
        clonedParent.appendChild(clonedEl);
        for (const child of getRenderedChildNodes(element)) {
          if (child instanceof Element) {
            visit(child, clonedEl);
          } else {
            clonedEl.appendChild(child.cloneNode(true));
          }
        }
      }
    };
    for (const element of this.styles.keys()) {
      visit(element, null);
    }
  }
  embedStyles() {
    let css = "";
    for (const [element, info] of this.styles) {
      if (info.after || info.before) {
        const className = `pseudo-${uniqueId()}`;
        element.classList.add(className);
        if (info.before) {
          css += `.${className}::before {${formatCss(info.before)}}
`;
        }
        if (info.after) {
          css += `.${className}::after {${formatCss(info.after)}}
`;
        }
      }
      const style2 = elementStyle(element);
      for (const [property, value] of Object.entries(info.self)) {
        if (!value) continue;
        style2.setProperty(property, value);
      }
      if (style2.fontKerning === "auto") {
        style2.fontKerning = "normal";
      }
    }
    return css;
  }
  async getFontFaceCss() {
    return await this.fonts.createCss();
  }
  dispose() {
    destroyDefaultStyleFrame();
  }
}
function styleFromElement(element, { defaultStyles, parentStyles }) {
  if (element.computedStyleMap) {
    return styleFromComputedStyleMap(element.computedStyleMap(), { defaultStyles, parentStyles });
  }
  return styleFromComputedStyle(getComputedStyle$2(element), { defaultStyles, parentStyles });
}
function styleFromPseudoElement(element, pseudo) {
  const style2 = getComputedStyle$2(element, pseudo);
  const content = style2.getPropertyValue("content");
  if (content === "" || content === "none") {
    return void 0;
  }
  return styleFromComputedStyle(style2, { defaultStyles: NO_STYLES, parentStyles: NO_STYLES });
}
function styleFromComputedStyleMap(style2, { defaultStyles, parentStyles }) {
  const styles = {};
  const currentColor = style2.get("color")?.toString() || "";
  const ruleOptions = {
    currentColor,
    parentStyles,
    defaultStyles,
    getStyle: (property) => style2.get(property)?.toString() ?? ""
  };
  for (const property of style2.keys()) {
    if (!shouldIncludeCssProperty(property)) continue;
    const value = style2.get(property).toString();
    if (defaultStyles[property] === value) continue;
    const rule = getOwnProperty(cssRules, property);
    if (rule && rule(value, property, ruleOptions)) continue;
    styles[property] = value;
  }
  return styles;
}
function styleFromComputedStyle(style2, { defaultStyles, parentStyles }) {
  const styles = {};
  const currentColor = style2.color;
  const ruleOptions = {
    currentColor,
    parentStyles,
    defaultStyles,
    getStyle: (property) => style2.getPropertyValue(property)
  };
  for (const property in style2) {
    if (!shouldIncludeCssProperty(property)) continue;
    const value = style2.getPropertyValue(property);
    if (defaultStyles[property] === value) continue;
    const rule = getOwnProperty(cssRules, property);
    if (rule && rule(value, property, ruleOptions)) continue;
    styles[property] = value;
  }
  return styles;
}
function formatCss(style2) {
  let cssText = "";
  for (const [property, value] of Object.entries(style2)) {
    cssText += `${property}: ${value};`;
  }
  return cssText;
}
let defaultStyleFrame;
const defaultStylesByTagName = {};
function getDefaultStyleFrame() {
  if (!defaultStyleFrame) {
    const frame = document.createElement("iframe");
    frame.style.display = "none";
    document.body.appendChild(frame);
    const frameDocument = assertExists(frame.contentDocument, "frame must have a document");
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
    svg.appendChild(foreignObject);
    frameDocument.body.appendChild(svg);
    defaultStyleFrame = { iframe: frame, foreignObject, document: frameDocument };
  }
  return defaultStyleFrame;
}
function destroyDefaultStyleFrame() {
  if (defaultStyleFrame) {
    document.body.removeChild(defaultStyleFrame.iframe);
    defaultStyleFrame = void 0;
  }
}
const defaultStyleReadOptions = { defaultStyles: NO_STYLES, parentStyles: NO_STYLES };
function getDefaultStylesForTagName(tagName) {
  let existing = defaultStylesByTagName[tagName];
  if (!existing) {
    const { foreignObject, document: document2 } = getDefaultStyleFrame();
    const element = document2.createElement(tagName);
    foreignObject.appendChild(element);
    existing = element.computedStyleMap ? styleFromComputedStyleMap(element.computedStyleMap(), defaultStyleReadOptions) : styleFromComputedStyle(getComputedStyle$2(element), defaultStyleReadOptions);
    foreignObject.removeChild(element);
    defaultStylesByTagName[tagName] = existing;
  }
  return existing;
}
function copyAttrs(source, target) {
  const attrs = Array.from(source.attributes);
  attrs.forEach((attr) => {
    target.setAttribute(attr.name, attr.value);
  });
}
function replace$1(original, replacement) {
  original.replaceWith(replacement);
  return replacement;
}
async function createImage(dataUrl, cloneAttributesFrom) {
  const image = document.createElement("img");
  if (cloneAttributesFrom) {
    copyAttrs(cloneAttributesFrom, image);
  }
  image.setAttribute("src", dataUrl ?? "data:");
  image.setAttribute("decoding", "sync");
  image.setAttribute("loading", "eager");
  try {
    await image.decode();
  } catch {
  }
  return image;
}
async function getCanvasReplacement(canvas) {
  try {
    const dataURL = canvas.toDataURL();
    return await createImage(dataURL, canvas);
  } catch {
    return await createImage(null, canvas);
  }
}
async function getVideoReplacement(video) {
  try {
    const dataUrl = await MediaHelpers.getVideoFrameAsDataUrl(video);
    return createImage(dataUrl, video);
  } catch (err) {
    console.error("Could not get video frame", err);
  }
  if (video.poster) {
    const dataUrl = await resourceToDataUrl(video.poster);
    return createImage(dataUrl, video);
  }
  return createImage(null, video);
}
async function embedMedia(node) {
  if (node instanceof HTMLCanvasElement) {
    return replace$1(node, await getCanvasReplacement(node));
  } else if (node instanceof HTMLVideoElement) {
    return replace$1(node, await getVideoReplacement(node));
  } else if (node instanceof HTMLImageElement) {
    const src = node.currentSrc || node.src;
    const dataUrl = await resourceToDataUrl(src);
    node.setAttribute("src", dataUrl ?? "data:");
    node.setAttribute("decoding", "sync");
    node.setAttribute("loading", "eager");
    try {
      await node.decode();
    } catch {
    }
    return node;
  } else if (node instanceof HTMLInputElement) {
    node.setAttribute("value", node.value);
  } else if (node instanceof HTMLTextAreaElement) {
    node.textContent = node.value;
  }
  await Promise.all(
    Array.from(getRenderedChildren(node), (child) => embedMedia(child))
  );
}
const areShapesContentEqual = (a, b) => a.props === b.props && a.meta === b.meta;
const Shape = reactExports.memo(function Shape2({
  id,
  shape,
  util,
  index: index2,
  backgroundIndex,
  opacity
}) {
  const editor = useEditor();
  const { ShapeErrorFallback, ShapeWrapper } = useEditorComponents();
  const containerRef = reactExports.useRef(null);
  const bgContainerRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    return react("load fonts", () => {
      const fonts = editor.fonts.getShapeFontFaces(id);
      editor.fonts.requestFonts(fonts);
    });
  }, [editor, id]);
  const memoizedStuffRef = reactExports.useRef({
    transform: "",
    clipPath: "none",
    width: 0,
    height: 0,
    x: 0,
    y: 0,
    isCulled: false
  });
  useQuickReactor(
    "set shape stuff",
    () => {
      const shape2 = editor.getShape(id);
      if (!shape2) return;
      const prev = memoizedStuffRef.current;
      const clipPath = editor.getShapeClipPath(id) ?? "none";
      if (clipPath !== prev.clipPath) {
        setStyleProperty(containerRef.current, "clip-path", clipPath);
        setStyleProperty(bgContainerRef.current, "clip-path", clipPath);
        prev.clipPath = clipPath;
      }
      const pageTransform = editor.getShapePageTransform(id);
      const transform = Mat.toCssString(pageTransform);
      const bounds = editor.getShapeGeometry(shape2).bounds;
      if (transform !== prev.transform) {
        setStyleProperty(containerRef.current, "transform", transform);
        setStyleProperty(bgContainerRef.current, "transform", transform);
        prev.transform = transform;
      }
      const width = Math.max(bounds.width, 1);
      const height = Math.max(bounds.height, 1);
      if (width !== prev.width || height !== prev.height) {
        setStyleProperty(containerRef.current, "width", width + "px");
        setStyleProperty(containerRef.current, "height", height + "px");
        setStyleProperty(bgContainerRef.current, "width", width + "px");
        setStyleProperty(bgContainerRef.current, "height", height + "px");
        prev.width = width;
        prev.height = height;
      }
    },
    [editor]
  );
  reactExports.useLayoutEffect(() => {
    const container = containerRef.current;
    const bgContainer = bgContainerRef.current;
    setStyleProperty(container, "opacity", opacity);
    setStyleProperty(bgContainer, "opacity", opacity);
    setStyleProperty(container, "z-index", index2);
    setStyleProperty(bgContainer, "z-index", backgroundIndex);
  }, [opacity, index2, backgroundIndex]);
  useQuickReactor(
    "set display",
    () => {
      const shape2 = editor.getShape(id);
      if (!shape2) return;
      const culledShapes = editor.getCulledShapes();
      const isCulled = culledShapes.has(id);
      if (isCulled !== memoizedStuffRef.current.isCulled) {
        setStyleProperty(containerRef.current, "display", isCulled ? "none" : "block");
        setStyleProperty(bgContainerRef.current, "display", isCulled ? "none" : "block");
        memoizedStuffRef.current.isCulled = isCulled;
      }
    },
    [editor]
  );
  const annotateError2 = reactExports.useCallback(
    (error) => editor.annotateError(error, { origin: "shape", willCrashApp: false }),
    [editor]
  );
  if (!shape || !ShapeWrapper) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    util.backgroundComponent && /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeWrapper, { ref: bgContainerRef, shape, isBackground: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(OptionalErrorBoundary, { fallback: ShapeErrorFallback, onError: annotateError2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(InnerShapeBackground, { shape, util }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeWrapper, { ref: containerRef, shape, isBackground: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(OptionalErrorBoundary, { fallback: ShapeErrorFallback, onError: annotateError2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(InnerShape, { shape, util }) }) })
  ] });
});
const InnerShape = reactExports.memo(
  function InnerShape2({ shape, util }) {
    return useStateTracking(
      "InnerShape:" + shape.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        util.component(util.editor.store.unsafeGetWithoutCapture(shape.id))
      ),
      [util, shape.id]
    );
  },
  (prev, next) => areShapesContentEqual(prev.shape, next.shape) && prev.util === next.util
);
const InnerShapeBackground = reactExports.memo(
  function InnerShapeBackground2({
    shape,
    util
  }) {
    return useStateTracking(
      "InnerShape:" + shape.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        util.backgroundComponent?.(util.editor.store.unsafeGetWithoutCapture(shape.id))
      ),
      [util, shape.id]
    );
  },
  (prev, next) => prev.shape.props === next.shape.props && prev.shape.meta === next.shape.meta && prev.util === next.util
);
function useEvent(handler) {
  const handlerRef = reactExports.useRef();
  reactExports.useLayoutEffect(() => {
    handlerRef.current = handler;
  });
  reactExports.useDebugValue(handler);
  return reactExports.useCallback((...args) => {
    const fn = handlerRef.current;
    assert(fn, "fn does not exist");
    return fn(...args);
  }, []);
}
const Context = reactExports.createContext(null);
function SvgExportContextProvider({
  context,
  editor,
  children
}) {
  const Provider2 = editor.options.exportProvider;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EditorProvider, { editor, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerProvider, { container: editor.getContainer(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value: context, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Provider2, { children }) }) }) });
}
function useSvgExportContext() {
  return reactExports.useContext(Context);
}
function useDelaySvgExport() {
  const ctx = reactExports.useContext(Context);
  const [promise] = reactExports.useState(promiseWithResolve);
  reactExports.useEffect(() => {
    ctx?.waitUntil(promise);
    return () => {
      promise.resolve();
    };
  }, [promise, ctx]);
  return useEvent(() => {
    promise.resolve();
  });
}
var __create$a = Object.create;
var __defProp$e = Object.defineProperty;
var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;
var __knownSymbol$a = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$a = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$a = (base2) => [, , , __create$a(null)];
var __decoratorStrings$a = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$a = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$a("Function expected") : fn;
var __decoratorContext$a = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings$a[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError$a("Already initialized") : fns.push(__expectFn$a(fn || null)) });
var __decoratorMetadata$a = (array2, target) => __defNormalProp$a(target, __knownSymbol$a("metadata"), array2[3]);
var __runInitializers$b = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$a = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings$a[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$a(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$a(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$a(it) && (desc[key] = it);
  }
  return desc && __defProp$e(target, name, desc), target;
};
var __publicField$a = (obj, key, value) => __defNormalProp$a(obj, typeof key !== "symbol" ? key + "" : key, value);
var _waitUntil_dec, _init$a;
_waitUntil_dec = [bind$1];
class ExportDelay {
  constructor(maxDelayTimeMs) {
    this.maxDelayTimeMs = maxDelayTimeMs;
    __runInitializers$b(_init$a, 5, this);
    __publicField$a(this, "isResolved", false);
    __publicField$a(this, "promisesToWaitFor", []);
  }
  waitUntil(promise) {
    if (this.isResolved) {
      throw new Error(
        "Cannot `waitUntil` - the export has already been resolved. Make sure to call `waitUntil` as soon as possible during an export - ie within the first react effect after rendering."
      );
    }
    this.promisesToWaitFor.push(
      promise.catch((err) => console.error("Error while waiting for export:", err))
    );
  }
  async resolvePromises() {
    let lastLength = null;
    while (this.promisesToWaitFor.length !== lastLength) {
      lastLength = this.promisesToWaitFor.length;
      await Promise.allSettled(this.promisesToWaitFor);
      await sleep(0);
    }
  }
  async resolve() {
    const timeoutPromise = sleep(this.maxDelayTimeMs).then(() => "timeout");
    const resolvePromise = this.resolvePromises().then(() => "resolved");
    const result = await Promise.race([timeoutPromise, resolvePromise]);
    if (result === "timeout") {
      console.warn("[tldraw] Export delay timed out after ${this.maxDelayTimeMs}ms");
    }
    this.isResolved = true;
  }
}
_init$a = __decoratorStart$a();
__decorateElement$a(_init$a, 1, "waitUntil", _waitUntil_dec, ExportDelay);
__decoratorMetadata$a(_init$a, ExportDelay);
function getSvgJsx(editor, ids, opts = {}) {
  if (!window.document) throw Error("No document");
  const {
    scale = 1,
    // should we include the background in the export? or is it transparent?
    background = editor.getInstanceState().exportBackground,
    padding = editor.options.defaultSvgPadding,
    preserveAspectRatio
  } = opts;
  const isDarkMode = opts.darkMode ?? editor.user.getIsDarkMode();
  const shapeIdsToInclude = editor.getShapeAndDescendantIds(ids);
  const renderingShapes = editor.getUnorderedRenderingShapes(false).filter(({ id }) => shapeIdsToInclude.has(id));
  const singleFrameShapeId = ids.length === 1 && editor.isShapeOfType(editor.getShape(ids[0]), "frame") ? ids[0] : null;
  let bbox = null;
  if (opts.bounds) {
    bbox = opts.bounds.clone().expandBy(padding);
  } else {
    bbox = getExportDefaultBounds(editor, renderingShapes, padding, singleFrameShapeId);
  }
  if (!bbox) return;
  const w = bbox.width * scale;
  const h2 = bbox.height * scale;
  try {
    document.body.focus?.();
  } catch {
  }
  const exportDelay = new ExportDelay(editor.options.maxExportDelayMs);
  const initialEffectPromise = promiseWithResolve();
  exportDelay.waitUntil(initialEffectPromise);
  const svg = /* @__PURE__ */ jsxRuntimeExports.jsx(
    SvgExport,
    {
      editor,
      preserveAspectRatio,
      scale,
      pixelRatio: opts.pixelRatio ?? null,
      bbox,
      background,
      singleFrameShapeId,
      isDarkMode,
      renderingShapes,
      onMount: initialEffectPromise.resolve,
      waitUntil: exportDelay.waitUntil
    }
  );
  return { jsx: svg, width: w, height: h2, exportDelay };
}
function getExportDefaultBounds(editor, renderingShapes, padding, singleFrameShapeId) {
  let isBoundedByContainer = false;
  let bbox = null;
  for (const { id } of renderingShapes) {
    const maskedPageBounds = editor.getShapeMaskedPageBounds(id);
    if (!maskedPageBounds) continue;
    const shape = editor.getShape(id);
    const isContainer = editor.getShapeUtil(shape).isExportBoundsContainer(shape);
    if (bbox) {
      if (isContainer && Box.ContainsApproximately(maskedPageBounds, bbox)) {
        isBoundedByContainer = true;
        bbox = maskedPageBounds.clone();
      } else {
        if (isBoundedByContainer && !Box.ContainsApproximately(bbox, maskedPageBounds)) {
          isBoundedByContainer = false;
        }
        bbox.union(maskedPageBounds);
      }
    } else {
      isBoundedByContainer = isContainer;
      bbox = maskedPageBounds.clone();
    }
  }
  if (!bbox) return null;
  if (!singleFrameShapeId && !isBoundedByContainer) {
    bbox.expandBy(padding);
  }
  return bbox;
}
function SvgExport({
  editor,
  preserveAspectRatio,
  scale,
  pixelRatio,
  bbox,
  background,
  singleFrameShapeId,
  isDarkMode,
  renderingShapes,
  onMount,
  waitUntil
}) {
  const masksId = useUniqueSafeId();
  const theme = getDefaultColorTheme({ isDarkMode });
  const stateAtom = useAtom("export state", { defsById: {}, shapeElements: null });
  const { defsById, shapeElements } = useValue(stateAtom);
  const addExportDef = useEvent((def) => {
    stateAtom.update((state) => {
      if (hasOwnProperty(state.defsById, def.key)) return state;
      const promise = Promise.resolve(def.getElement());
      waitUntil(
        promise.then((result) => {
          stateAtom.update((state2) => ({
            ...state2,
            defsById: { ...state2.defsById, [def.key]: { pending: false, element: result } }
          }));
        })
      );
      return {
        ...state,
        defsById: { ...state.defsById, [def.key]: { pending: true, element: promise } }
      };
    });
  });
  const exportContext = reactExports.useMemo(
    () => ({
      isDarkMode,
      waitUntil,
      addExportDef,
      scale,
      pixelRatio,
      async resolveAssetUrl(assetId, width) {
        const asset = editor.getAsset(assetId);
        if (!asset || asset.type !== "image" && asset.type !== "video") return null;
        return await editor.resolveAssetUrl(assetId, {
          screenScale: scale * (width / asset.props.w),
          shouldResolveToOriginal: pixelRatio === null,
          dpr: pixelRatio ?? void 0
        });
      }
    }),
    [isDarkMode, waitUntil, addExportDef, scale, pixelRatio, editor]
  );
  const didRenderRef = reactExports.useRef(false);
  reactExports.useLayoutEffect(() => {
    if (didRenderRef.current) {
      throw new Error("SvgExport should only render once - do not use with react strict mode");
    }
    didRenderRef.current = true;
    (async () => {
      const shapeDefs = {};
      const unorderedShapeElementPromises = renderingShapes.map(
        async ({ id, opacity, index: index2, backgroundIndex }) => {
          if (id === singleFrameShapeId) return [];
          const shape = editor.getShape(id);
          if (editor.isShapeOfType(shape, "group")) return [];
          const elements = [];
          const util = editor.getShapeUtil(shape);
          if (util.toSvg || util.toBackgroundSvg) {
            const [toSvgResult, toBackgroundSvgResult] = await Promise.all([
              util.toSvg?.(shape, exportContext),
              util.toBackgroundSvg?.(shape, exportContext)
            ]);
            const pageTransform = editor.getShapePageTransform(shape);
            let pageTransformString = pageTransform.toCssString();
            let scale2 = 1;
            if ("scale" in shape.props) {
              if (shape.props.scale !== 1) {
                scale2 = shape.props.scale;
                pageTransformString = `${pageTransformString} scale(${shape.props.scale}, ${shape.props.scale})`;
              }
            }
            const pageMask = editor.getShapeMask(shape.id);
            const shapeMask = pageMask ? Mat.From(Mat.Inverse(pageTransform)).applyToPoints(pageMask) : null;
            const shapeMaskId = suffixSafeId(masksId, shape.id);
            if (shapeMask) {
              shapeDefs[shapeMaskId] = {
                pending: false,
                element: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: shapeMaskId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: `M${shapeMask.map(({ x, y }) => `${x / scale2},${y / scale2}`).join("L")}Z`
                  }
                ) })
              };
            }
            if (toSvgResult) {
              elements.push({
                zIndex: index2,
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "g",
                  {
                    transform: pageTransformString,
                    opacity,
                    clipPath: pageMask ? `url(#${shapeMaskId})` : void 0,
                    children: toSvgResult
                  },
                  `fg_${shape.id}`
                )
              });
            }
            if (toBackgroundSvgResult) {
              elements.push({
                zIndex: backgroundIndex,
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "g",
                  {
                    transform: pageTransformString,
                    opacity,
                    clipPath: pageMask ? `url(#${shapeMaskId})` : void 0,
                    children: toBackgroundSvgResult
                  },
                  `bg_${shape.id}`
                )
              });
            }
          } else {
            elements.push({
              zIndex: index2,
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(
                ForeignObjectShape,
                {
                  shape,
                  util,
                  component: InnerShape,
                  className: "tl-shape",
                  bbox,
                  opacity
                },
                `fg_${shape.id}`
              )
            });
            if (util.backgroundComponent) {
              elements.push({
                zIndex: backgroundIndex,
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ForeignObjectShape,
                  {
                    shape,
                    util,
                    component: InnerShapeBackground,
                    className: "tl-shape tl-shape-background",
                    bbox,
                    opacity
                  },
                  `bg_${shape.id}`
                )
              });
            }
          }
          return elements;
        }
      );
      const unorderedShapeElements = (await Promise.all(unorderedShapeElementPromises)).flat();
      reactDomExports.flushSync(() => {
        stateAtom.update((state) => ({
          ...state,
          shapeElements: unorderedShapeElements.sort((a, b) => a.zIndex - b.zIndex).map(({ element }) => element),
          defsById: { ...state.defsById, ...shapeDefs }
        }));
      });
    })();
  }, [bbox, editor, exportContext, masksId, renderingShapes, singleFrameShapeId, stateAtom]);
  reactExports.useEffect(() => {
    const fontsInUse = /* @__PURE__ */ new Set();
    for (const { id } of renderingShapes) {
      for (const font of editor.fonts.getShapeFontFaces(id)) {
        fontsInUse.add(font);
      }
    }
    for (const font of fontsInUse) {
      addExportDef({
        key: uniqueId(),
        getElement: async () => {
          const declaration = await editor.fonts.toEmbeddedCssDeclaration(font);
          return /* @__PURE__ */ jsxRuntimeExports.jsx("style", { nonce: editor.options.nonce, children: declaration });
        }
      });
    }
  }, [editor, renderingShapes, addExportDef]);
  reactExports.useEffect(() => {
    if (shapeElements === null) return;
    onMount();
  }, [onMount, shapeElements]);
  let backgroundColor = background ? theme.background : "transparent";
  if (singleFrameShapeId && background) {
    const frameShapeUtil = editor.getShapeUtil("frame");
    if (frameShapeUtil?.options.showColors) {
      const shape = editor.getShape(singleFrameShapeId);
      backgroundColor = getColorValue(theme, shape.props.color, "frameFill");
    } else {
      backgroundColor = theme.solid;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgExportContextProvider, { editor, context: exportContext, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      preserveAspectRatio,
      direction: "ltr",
      width: bbox.width * scale,
      height: bbox.height * scale,
      viewBox: `${bbox.minX} ${bbox.minY} ${bbox.width} ${bbox.height}`,
      strokeLinecap: "round",
      strokeLinejoin: "round",
      style: { backgroundColor },
      "data-color-mode": isDarkMode ? "dark" : "light",
      className: `tl-container tl-theme__force-sRGB ${isDarkMode ? "tl-theme__dark" : "tl-theme__light"}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: Object.entries(defsById).map(
          ([key, def]) => def.pending ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: def.element }, key)
        ) }),
        shapeElements
      ]
    }
  ) });
}
function ForeignObjectShape({
  shape,
  util,
  className,
  component: Component,
  bbox,
  opacity
}) {
  const editor = useEditor();
  const transform = Mat.Translate(-bbox.minX, -bbox.minY).multiply(
    editor.getShapePageTransform(shape.id)
  );
  const bounds = editor.getShapeGeometry(shape.id).bounds;
  const width = Math.max(bounds.width, 1);
  const height = Math.max(bounds.height, 1);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { fallback: () => null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "foreignObject",
    {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.w,
      height: bbox.h,
      className: "tl-shape-foreign-object tl-export-embed-styles",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className,
          "data-shape-type": shape.type,
          style: {
            clipPath: editor.getShapeClipPath(shape.id),
            transform: transform.toCssString(),
            width,
            height,
            opacity
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { shape, util })
        }
      )
    }
  ) });
}
let idCounter$1 = 1;
async function exportToSvg(editor, shapeIds, opts = {}) {
  const result = getSvgJsx(editor, shapeIds, opts);
  if (!result) return void 0;
  const container = editor.getContainer();
  const renderTarget = document.createElement("div");
  renderTarget.className = SVG_EXPORT_CLASSNAME;
  renderTarget.inert = true;
  renderTarget.tabIndex = -1;
  Object.assign(renderTarget.style, {
    position: "absolute",
    top: "0px",
    left: "0px",
    width: result.width + "px",
    height: result.height + "px",
    pointerEvents: "none",
    opacity: 0
  });
  container.appendChild(renderTarget);
  const root = clientExports.createRoot(renderTarget, { identifierPrefix: `export_${idCounter$1++}_` });
  try {
    await Promise.resolve();
    reactDomExports.flushSync(() => {
      root.render(result.jsx);
    });
    await result.exportDelay.resolve();
    const svg = renderTarget.firstElementChild;
    assert(svg instanceof SVGSVGElement, "Expected an SVG element");
    await applyChangesToForeignObjects(svg);
    return { svg, width: result.width, height: result.height };
  } finally {
    setTimeout(() => {
      root.unmount();
      container.removeChild(renderTarget);
    }, 0);
  }
}
async function applyChangesToForeignObjects(svg) {
  const foreignObjectChildren = [
    ...svg.querySelectorAll("foreignObject.tl-export-embed-styles > *")
  ];
  if (!foreignObjectChildren.length) return;
  const styleEmbedder = new StyleEmbedder(svg);
  try {
    styleEmbedder.fonts.startFindingCurrentDocumentFontFaces();
    await Promise.all(foreignObjectChildren.map((el) => embedMedia(el)));
    for (const el of foreignObjectChildren) {
      styleEmbedder.readRootElementStyles(el);
    }
    await styleEmbedder.fetchResources();
    const fontCss = await styleEmbedder.getFontFaceCss();
    styleEmbedder.unwrapCustomElements();
    const pseudoCss = styleEmbedder.embedStyles();
    if (fontCss || pseudoCss) {
      const style2 = document.createElementNS("http://www.w3.org/2000/svg", "style");
      style2.textContent = `${fontCss}
${pseudoCss}`;
      svg.prepend(style2);
    }
  } finally {
    styleEmbedder.dispose();
  }
}
let maxCanvasSizes = null;
function getBrowserCanvasMaxSize() {
  if (!maxCanvasSizes) {
    maxCanvasSizes = {
      maxWidth: getCanvasSize("width"),
      // test very wide but 1 pixel tall canvases
      maxHeight: getCanvasSize("height"),
      // test very tall but 1 pixel wide canvases
      maxArea: getCanvasSize("area")
      // test square canvases
    };
  }
  return maxCanvasSizes;
}
const MAX_SAFE_CANVAS_DIMENSION = 8192;
const MAX_SAFE_CANVAS_AREA = 4096 * 4096;
const TEST_SIZES = {
  area: [
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4)
    // Edge 17 (Win)
    // Safari 7-12 (Mac)
    16384,
    // Chrome 68 (Android 7.1-9)
    14188,
    // Chrome 68 (Android 5)
    11402,
    // Firefox 63 (Mac, Win)
    11180,
    // Chrome 68 (Android 6)
    10836,
    // IE 9-11 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    // Safari (iOS 9 - 12)
    4096
  ],
  height: [
    // Safari 7-12 (Mac)
    // Safari (iOS 9-12)
    8388607,
    // Chrome 83 (Mac, Win)
    65535,
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4-9)
    // Firefox 63 (Mac, Win)
    32767,
    // Edge 17 (Win)
    // IE11 (Win)
    16384,
    // IE 9-10 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    4096
  ],
  width: [
    // Safari 7-12 (Mac)
    // Safari (iOS 9-12)
    4194303,
    // Chrome 83 (Mac, Win)
    65535,
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4-9)
    // Firefox 63 (Mac, Win)
    32767,
    // Edge 17 (Win)
    // IE11 (Win)
    16384,
    // IE 9-10 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    4096
  ]
};
function getCanvasSize(dimension) {
  const cropCvs = document.createElement("canvas");
  cropCvs.width = 1;
  cropCvs.height = 1;
  const cropCtx = cropCvs.getContext("2d");
  for (const size2 of TEST_SIZES[dimension]) {
    const w = dimension === "height" ? 1 : size2;
    const h2 = dimension === "width" ? 1 : size2;
    const testCvs = document.createElement("canvas");
    testCvs.width = w;
    testCvs.height = h2;
    const testCtx = testCvs.getContext("2d");
    testCtx.fillRect(w - 1, h2 - 1, 1, 1);
    cropCtx.drawImage(testCvs, w - 1, h2 - 1, 1, 1, 0, 0, 1, 1);
    const isTestPassed = cropCtx.getImageData(0, 0, 1, 1).data[3] !== 0;
    testCvs.width = 0;
    testCvs.height = 0;
    if (isTestPassed) {
      cropCvs.width = 0;
      cropCvs.height = 0;
      if (dimension === "area") {
        return size2 * size2;
      } else {
        return size2;
      }
    }
  }
  cropCvs.width = 0;
  cropCvs.height = 0;
  throw Error("Failed to determine maximum canvas dimension");
}
function clampToBrowserMaxCanvasSize(width, height) {
  if (width <= MAX_SAFE_CANVAS_DIMENSION && height <= MAX_SAFE_CANVAS_DIMENSION && width * height <= MAX_SAFE_CANVAS_AREA) {
    return [width, height];
  }
  const { maxWidth, maxHeight, maxArea } = getBrowserCanvasMaxSize();
  const aspectRatio = width / height;
  if (width > maxWidth) {
    width = maxWidth;
    height = width / aspectRatio;
  }
  if (height > maxHeight) {
    height = maxHeight;
    width = height * aspectRatio;
  }
  if (width * height > maxArea) {
    const ratio = Math.sqrt(maxArea / (width * height));
    width *= ratio;
    height *= ratio;
  }
  return [width, height];
}
async function getSvgAsImage(svgString, options) {
  const { type, width, height, quality = 1, pixelRatio = 2 } = options;
  let [clampedWidth, clampedHeight] = clampToBrowserMaxCanvasSize(
    width * pixelRatio,
    height * pixelRatio
  );
  clampedWidth = Math.floor(clampedWidth);
  clampedHeight = Math.floor(clampedHeight);
  const effectiveScale = clampedWidth / width;
  const svgUrl = await FileHelpers.blobToDataUrl(new Blob([svgString], { type: "image/svg+xml" }));
  const canvas = await new Promise((resolve) => {
    const image = Image();
    image.crossOrigin = "anonymous";
    image.onload = async () => {
      if (tlenv.isSafari) {
        await sleep(250);
      }
      const canvas2 = document.createElement("canvas");
      const ctx = canvas2.getContext("2d");
      canvas2.width = clampedWidth;
      canvas2.height = clampedHeight;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(image, 0, 0, clampedWidth, clampedHeight);
      URL.revokeObjectURL(svgUrl);
      resolve(canvas2);
    };
    image.onerror = () => {
      resolve(null);
    };
    image.src = svgUrl;
  });
  if (!canvas) return null;
  const blob = await new Promise(
    (resolve) => canvas.toBlob(
      (blob2) => {
        if (!blob2 || debugFlags.throwToBlob.get()) {
          resolve(null);
        }
        resolve(blob2);
      },
      "image/" + type,
      quality
    )
  );
  if (!blob) return null;
  if (type === "png") {
    const view = new DataView(await blob.arrayBuffer());
    return PngHelpers.setPhysChunk(view, effectiveScale, {
      type: "image/" + type
    });
  } else {
    return blob;
  }
}
const tlmenus = {
  /**
   * A set of strings representing any open menus. When menus are open,
   * certain interactions will behave differently; for example, when a
   * draw tool is selected and a menu is open, a pointer-down will not
   * create a dot (because the user is probably trying to close the menu)
   * however a pointer-down event followed by a drag will begin drawing
   * a line (because the user is BOTH trying to close the menu AND start
   * drawing a line).
   *
   * @public
   */
  menus: atom("open menus", []),
  /**
   * Get the current open menus.
   *
   * @param contextId - An optional context to get menus for.
   *
   * @public
   */
  getOpenMenus(contextId) {
    if (contextId) return this.menus.get().filter((m) => m.endsWith("-" + contextId));
    return this.menus.get();
  },
  /**
   * Add an open menu.
   *
   * @example
   * ```ts
   * addOpenMenu('menu-id')
   * addOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to add.
   * @param contextId - An optional context to add the menu to.
   *
   * @public
   */
  addOpenMenu(id, contextId = "") {
    const idWithContext = contextId ? `${id}-${contextId}` : id;
    const menus = new Set(this.menus.get());
    if (!menus.has(idWithContext)) {
      menus.add(idWithContext);
      this.menus.set([...menus]);
    }
  },
  /**
   * Delete an open menu.
   *
   * @example
   * ```ts
   * deleteOpenMenu('menu-id')
   * deleteOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to delete.
   * @param contextId - An optional context to delete the menu from.
   *
   * @public
   */
  deleteOpenMenu(id, contextId = "") {
    const idWithContext = contextId ? `${id}-${contextId}` : id;
    const menus = new Set(this.menus.get());
    if (menus.has(idWithContext)) {
      menus.delete(idWithContext);
      this.menus.set([...menus]);
    }
  },
  /**
   * Clear all open menus.
   *
   * @example
   * ```ts
   * clearOpenMenus()
   * clearOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to clear menus for.
   *
   * @public
   */
  clearOpenMenus(contextId) {
    this.menus.set(contextId ? this.menus.get().filter((m) => !m.endsWith("-" + contextId)) : []);
  },
  _hiddenMenus: [],
  /**
   * Hide all open menus. Restore them with the `showOpenMenus` method.
   *
   * @example
   * ```ts
   * hideOpenMenus()
   * hideOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to hide menus for.
   *
   * @public
   */
  hideOpenMenus(contextId) {
    this._hiddenMenus = [...this.getOpenMenus(contextId)];
    if (this._hiddenMenus.length === 0) return;
    for (const menu of this._hiddenMenus) {
      this.deleteOpenMenu(menu, contextId);
    }
  },
  /**
   * Show all hidden menus.
   *
   * @example
   * ```ts
   * showOpenMenus()
   * showOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to show menus for.
   *
   * @public
   */
  showOpenMenus(contextId) {
    if (this._hiddenMenus.length === 0) return;
    for (const menu of this._hiddenMenus) {
      this.addOpenMenu(menu, contextId);
    }
    this._hiddenMenus = [];
  },
  /**
   * Get whether a menu is open for a given context.
   *
   * @example
   * ```ts
   * isMenuOpem(id, myEditorId)
   * ```
   *
   * @param id - The id of the menu to check.
   * @param contextId - An optional context to check menus for.
   *
   * @public
   */
  isMenuOpen(id, contextId) {
    return this.getOpenMenus(contextId).includes(id);
  },
  /**
   * Get whether any menus are open for a given context.
   *
   * @example
   * ```ts
   * hasOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - A context to check menus for.
   *
   * @public
   */
  hasOpenMenus(contextId) {
    return this.getOpenMenus(contextId).length > 0;
  },
  /**
   * Get whether any menus are open for any context.
   *
   * @example
   * ```ts
   * hasAnyOpenMenus()
   * ```
   *
   * @public
   */
  hasAnyOpenMenus() {
    return this.getOpenMenus().length > 0;
  },
  forContext(contextId) {
    return {
      getOpenMenus: () => this.getOpenMenus(contextId),
      addOpenMenu: (id) => this.addOpenMenu(id, contextId),
      deleteOpenMenu: (id) => this.deleteOpenMenu(id, contextId),
      clearOpenMenus: () => this.clearOpenMenus(contextId),
      // Gets whether any menus are open
      isMenuOpen: (id) => this.isMenuOpen(id, contextId),
      hasOpenMenus: () => this.hasOpenMenus(contextId),
      hasAnyOpenMenus: () => this.hasAnyOpenMenus()
    };
  }
};
const tltime = new Timers();
const defaultTldrawOptions = {
  maxShapesPerPage: 4e3,
  maxFilesAtOnce: 100,
  maxPages: 40,
  animationMediumMs: 320,
  followChaseViewportSnap: 2,
  doubleClickDurationMs: 450,
  multiClickDurationMs: 200,
  coarseDragDistanceSquared: 36,
  // 6 squared
  dragDistanceSquared: 16,
  // 4 squared
  uiDragDistanceSquared: 16,
  // 4 squared
  // it's really easy to accidentally drag from the toolbar on mobile, so we use a much larger
  // threshold than usual here to try and prevent accidental drags.
  uiCoarseDragDistanceSquared: 625,
  // 25 squared
  defaultSvgPadding: 32,
  cameraSlideFriction: 0.09,
  gridSteps: [
    { min: -1, mid: 0.15, step: 64 },
    { min: 0.05, mid: 0.375, step: 16 },
    { min: 0.15, mid: 1, step: 4 },
    { min: 0.7, mid: 2.5, step: 1 }
  ],
  collaboratorInactiveTimeoutMs: 6e4,
  collaboratorIdleTimeoutMs: 3e3,
  collaboratorCheckIntervalMs: 1200,
  cameraMovingTimeoutMs: 64,
  hitTestMargin: 8,
  edgeScrollDelay: 200,
  edgeScrollEaseDuration: 200,
  edgeScrollSpeed: 25,
  edgeScrollDistance: 8,
  coarsePointerWidth: 12,
  coarseHandleRadius: 20,
  handleRadius: 12,
  longPressDurationMs: 500,
  textShadowLod: 0.35,
  adjacentShapeMargin: 10,
  flattenImageBoundsExpand: 64,
  flattenImageBoundsPadding: 16,
  laserDelayMs: 1200,
  maxExportDelayMs: 5e3,
  tooltipDelayMs: 700,
  temporaryAssetPreviewLifetimeMs: 18e4,
  actionShortcutsLocation: "swap",
  createTextOnCanvasDoubleClick: true,
  exportProvider: reactExports.Fragment,
  enableToolbarKeyboardShortcuts: true,
  maxFontsToLoadBeforeRender: Infinity,
  nonce: void 0
};
function sharedStyleEquals(a, b) {
  if (!b) return false;
  switch (a.type) {
    case "mixed":
      return b.type === "mixed";
    case "shared":
      return b.type === "shared" && a.value === b.value;
    default:
      throw exhaustiveSwitchError(a);
  }
}
class ReadonlySharedStyleMap {
  /** @internal */
  map;
  constructor(entries) {
    this.map = new Map(entries);
  }
  get(prop) {
    return this.map.get(prop);
  }
  getAsKnownValue(prop) {
    const value = this.get(prop);
    if (!value) return void 0;
    if (value.type === "mixed") return void 0;
    return value.value;
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.map.size;
  }
  equals(other) {
    if (this.size !== other.size) return false;
    const checkedKeys = /* @__PURE__ */ new Set();
    for (const [styleProp, value] of this) {
      if (!sharedStyleEquals(value, other.get(styleProp))) return false;
      checkedKeys.add(styleProp);
    }
    for (const [styleProp, value] of other) {
      if (checkedKeys.has(styleProp)) continue;
      if (!sharedStyleEquals(value, this.get(styleProp))) return false;
    }
    return true;
  }
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
  [Symbol.iterator]() {
    return this.map[Symbol.iterator]();
  }
}
class SharedStyleMap extends ReadonlySharedStyleMap {
  set(prop, value) {
    this.map.set(prop, value);
  }
  applyValue(prop, value) {
    const existingValue = this.get(prop);
    if (!existingValue) {
      this.set(prop, { type: "shared", value });
      return;
    }
    switch (existingValue.type) {
      case "mixed":
        return;
      case "shared":
        if (existingValue.value !== value) {
          this.set(prop, { type: "mixed" });
        }
        return;
      default:
        exhaustiveSwitchError(existingValue, "type");
    }
  }
}
function dataUrlToFile(url, filename, mimeType) {
  return fetch$1(url).then(function(res) {
    return res.arrayBuffer();
  }).then(function(buf) {
    return new File([buf], filename, { type: mimeType });
  });
}
const CDN_BASE_URL = "https://cdn.tldraw.com";
function getDefaultCdnBaseUrl() {
  return `${CDN_BASE_URL}/${version}`;
}
function createDeepLinkString(deepLink) {
  switch (deepLink.type) {
    case "shapes": {
      const ids = deepLink.shapeIds.map((id) => encodeId(id.slice("shape:".length)));
      return `s${ids.join(".")}`;
    }
    case "page": {
      return "p" + encodeId(PageRecordType.parseId(deepLink.pageId));
    }
    case "viewport": {
      const { bounds, pageId } = deepLink;
      let res = `v${Math.round(bounds.x)}.${Math.round(bounds.y)}.${Math.round(bounds.w)}.${Math.round(bounds.h)}`;
      if (pageId) {
        res += "." + encodeId(PageRecordType.parseId(pageId));
      }
      return res;
    }
    default:
      exhaustiveSwitchError(deepLink);
  }
}
function parseDeepLinkString(deepLinkString) {
  const type = deepLinkString[0];
  switch (type) {
    case "s": {
      const shapeIds = deepLinkString.slice(1).split(".").filter(Boolean).map((id) => createShapeId(decodeURIComponent(id)));
      return { type: "shapes", shapeIds };
    }
    case "p": {
      const pageId = PageRecordType.createId(decodeURIComponent(deepLinkString.slice(1)));
      return { type: "page", pageId };
    }
    case "v": {
      const [x, y, w, h2, pageId] = deepLinkString.slice(1).split(".");
      return {
        type: "viewport",
        bounds: new Box(Number(x), Number(y), Number(w), Number(h2)),
        pageId: pageId ? PageRecordType.createId(decodeURIComponent(pageId)) : void 0
      };
    }
    default:
      throw Error("Invalid deep link string");
  }
}
function encodeId(str) {
  return encodeURIComponent(str).replace(/\./g, "%2E");
}
function getIncrementedName(name, others) {
  let result = name;
  const set = new Set(others);
  while (set.has(result)) {
    result = /^.*(\d+)$/.exec(result)?.[1] ? result.replace(/(\d+)(?=\D?)$/, (m) => {
      return (+m + 1).toString();
    }) : `${result} 1`;
  }
  return result;
}
function getReorderingShapesChanges(editor, operation, ids, opts) {
  if (ids.length === 0) return [];
  const parents = /* @__PURE__ */ new Map();
  for (const shape of compact(ids.map((id) => editor.getShape(id)))) {
    const { parentId } = shape;
    if (!parents.has(parentId)) {
      parents.set(parentId, {
        children: compact(
          editor.getSortedChildIdsForParent(parentId).map((id) => editor.getShape(id))
        ),
        moving: /* @__PURE__ */ new Set()
      });
    }
    parents.get(parentId).moving.add(shape);
  }
  const changes = [];
  switch (operation) {
    case "toBack": {
      parents.forEach(({ moving, children }) => reorderToBack(moving, children, changes));
      break;
    }
    case "toFront": {
      parents.forEach(({ moving, children }) => reorderToFront(moving, children, changes));
      break;
    }
    case "forward": {
      parents.forEach(
        ({ moving, children }) => reorderForward(editor, moving, children, changes, opts)
      );
      break;
    }
    case "backward": {
      parents.forEach(
        ({ moving, children }) => reorderBackward(editor, moving, children, changes, opts)
      );
      break;
    }
  }
  return changes;
}
function reorderToBack(moving, children, changes) {
  const len = children.length;
  if (moving.size === len) return;
  let below;
  let above;
  for (let i = 0; i < len; i++) {
    const shape = children[i];
    if (moving.has(shape)) {
      below = shape.index;
      moving.delete(shape);
    } else {
      above = shape.index;
      break;
    }
  }
  if (moving.size === 0) {
    return;
  } else {
    const indices = getIndicesBetween(below, above, moving.size);
    changes.push(
      ...Array.from(moving.values()).sort(sortByIndex).map((shape, i) => ({ ...shape, index: indices[i] }))
    );
  }
}
function reorderToFront(moving, children, changes) {
  const len = children.length;
  if (moving.size === len) return;
  let below;
  let above;
  for (let i = len - 1; i > -1; i--) {
    const shape = children[i];
    if (moving.has(shape)) {
      above = shape.index;
      moving.delete(shape);
    } else {
      below = shape.index;
      break;
    }
  }
  if (moving.size === 0) {
    return;
  } else {
    const indices = getIndicesBetween(below, above, moving.size);
    changes.push(
      ...Array.from(moving.values()).sort(sortByIndex).map((shape, i) => ({ ...shape, index: indices[i] }))
    );
  }
}
function getOverlapChecker(editor, moving) {
  const movingBounds = compact(
    Array.from(moving).map((shape) => {
      const bounds = editor.getShapePageBounds(shape);
      if (!bounds) return null;
      return { shape, bounds };
    })
  );
  const isOverlapping = (child) => {
    const bounds = editor.getShapePageBounds(child);
    if (!bounds) return false;
    return movingBounds.some((other) => {
      return other.bounds.includes(bounds);
    });
  };
  return isOverlapping;
}
function reorderForward(editor, moving, children, changes, opts) {
  const isOverlapping = getOverlapChecker(editor, moving);
  const len = children.length;
  if (moving.size === len) return;
  let state = { name: "skipping" };
  for (let i = 0; i < len; i++) {
    const isMoving = moving.has(children[i]);
    switch (state.name) {
      case "skipping": {
        if (!isMoving) continue;
        state = { name: "selecting", selectIndex: i };
        break;
      }
      case "selecting": {
        if (isMoving) continue;
        if (!opts?.considerAllShapes && !isOverlapping(children[i])) continue;
        const { selectIndex } = state;
        getIndicesBetween(children[i].index, children[i + 1]?.index, i - selectIndex).forEach(
          (index2, k) => {
            const child = children[selectIndex + k];
            if (!moving.has(child)) return;
            changes.push({ ...child, index: index2 });
          }
        );
        state = { name: "skipping" };
        break;
      }
    }
  }
}
function reorderBackward(editor, moving, children, changes, opts) {
  const isOverlapping = getOverlapChecker(editor, moving);
  const len = children.length;
  if (moving.size === len) return;
  let state = { name: "skipping" };
  for (let i = len - 1; i > -1; i--) {
    const isMoving = moving.has(children[i]);
    switch (state.name) {
      case "skipping": {
        if (!isMoving) continue;
        state = { name: "selecting", selectIndex: i };
        break;
      }
      case "selecting": {
        if (isMoving) continue;
        if (!opts?.considerAllShapes && !isOverlapping(children[i])) continue;
        getIndicesBetween(children[i - 1]?.index, children[i].index, state.selectIndex - i).forEach(
          (index2, k) => {
            const child = children[i + k + 1];
            if (!moving.has(child)) return;
            changes.push({ ...child, index: index2 });
          }
        );
        state = { name: "skipping" };
        break;
      }
    }
  }
}
function getRotationSnapshot({
  editor,
  ids
}) {
  const shapes = compact(ids.map((id) => editor.getShape(id)));
  const rotation = editor.getShapesSharedRotation(ids);
  const rotatedPageBounds = editor.getShapesRotatedPageBounds(ids);
  if (!rotatedPageBounds) {
    return null;
  }
  const initialPageCenter = rotatedPageBounds.center.clone().rotWith(rotatedPageBounds.point, rotation);
  return {
    initialPageCenter,
    initialCursorAngle: initialPageCenter.angle(editor.inputs.originPagePoint),
    initialShapesRotation: rotation,
    shapeSnapshots: shapes.map((shape) => ({
      shape,
      initialPagePoint: editor.getShapePageTransform(shape.id).point()
    }))
  };
}
function applyRotationToSnapshotShapes({
  delta,
  editor,
  snapshot,
  stage,
  centerOverride
}) {
  const { initialPageCenter, shapeSnapshots } = snapshot;
  editor.updateShapes(
    shapeSnapshots.map(({ shape, initialPagePoint }) => {
      const parentTransform = isShapeId(shape.parentId) ? editor.getShapePageTransform(shape.parentId) : Mat.Identity();
      const newPagePoint = Vec.RotWith(initialPagePoint, centerOverride ?? initialPageCenter, delta);
      const newLocalPoint = Mat.applyToPoint(
        // use the current parent transform in case it has moved/resized since the start
        // (e.g. if rotating a shape at the edge of a group)
        Mat.Inverse(parentTransform),
        newPagePoint
      );
      const newRotation = canonicalizeRotation(shape.rotation + delta);
      return {
        id: shape.id,
        type: shape.type,
        x: newLocalPoint.x,
        y: newLocalPoint.y,
        rotation: newRotation
      };
    })
  );
  const changes = [];
  shapeSnapshots.forEach(({ shape }) => {
    const current = editor.getShape(shape.id);
    if (!current) return;
    const util = editor.getShapeUtil(shape);
    if (stage === "start" || stage === "one-off") {
      const changeStart = util.onRotateStart?.(shape);
      if (changeStart) changes.push(changeStart);
    }
    const changeUpdate = util.onRotate?.(shape, current);
    if (changeUpdate) changes.push(changeUpdate);
    if (stage === "end" || stage === "one-off") {
      const changeEnd = util.onRotateEnd?.(shape, current);
      if (changeEnd) changes.push(changeEnd);
    }
  });
  if (changes.length > 0) {
    editor.updateShapes(changes);
  }
}
function fromScratch$2(bindingsQuery) {
  const allBindings = bindingsQuery.get();
  const shapesToBindings = /* @__PURE__ */ new Map();
  for (const binding of allBindings) {
    const { fromId, toId } = binding;
    const bindingsForFromShape = shapesToBindings.get(fromId);
    if (!bindingsForFromShape) {
      shapesToBindings.set(fromId, [binding]);
    } else {
      bindingsForFromShape.push(binding);
    }
    const bindingsForToShape = shapesToBindings.get(toId);
    if (!bindingsForToShape) {
      shapesToBindings.set(toId, [binding]);
    } else {
      bindingsForToShape.push(binding);
    }
  }
  return shapesToBindings;
}
const bindingsIndex = (editor) => {
  const { store } = editor;
  const bindingsHistory = store.query.filterHistory("binding");
  const bindingsQuery = store.query.records("binding");
  return computed("arrowBindingsIndex", (_lastValue, lastComputedEpoch) => {
    if (isUninitialized(_lastValue)) {
      return fromScratch$2(bindingsQuery);
    }
    const lastValue = _lastValue;
    const diff = bindingsHistory.getDiffSince(lastComputedEpoch);
    if (diff === RESET_VALUE) {
      return fromScratch$2(bindingsQuery);
    }
    let nextValue = void 0;
    function removingBinding(binding) {
      nextValue ??= new Map(lastValue);
      const prevFrom = nextValue.get(binding.fromId);
      const nextFrom = prevFrom?.filter((b) => b.id !== binding.id);
      if (!nextFrom?.length) {
        nextValue.delete(binding.fromId);
      } else {
        nextValue.set(binding.fromId, nextFrom);
      }
      const prevTo = nextValue.get(binding.toId);
      const nextTo = prevTo?.filter((b) => b.id !== binding.id);
      if (!nextTo?.length) {
        nextValue.delete(binding.toId);
      } else {
        nextValue.set(binding.toId, nextTo);
      }
    }
    function ensureNewArray(shapeId) {
      nextValue ??= new Map(lastValue);
      let result = nextValue.get(shapeId);
      if (!result) {
        result = [];
        nextValue.set(shapeId, result);
      } else if (result === lastValue.get(shapeId)) {
        result = result.slice(0);
        nextValue.set(shapeId, result);
      }
      return result;
    }
    function addBinding(binding) {
      ensureNewArray(binding.fromId).push(binding);
      ensureNewArray(binding.toId).push(binding);
    }
    for (const changes of diff) {
      for (const newBinding of objectMapValues(changes.added)) {
        addBinding(newBinding);
      }
      for (const [prev, next] of objectMapValues(changes.updated)) {
        removingBinding(prev);
        addBinding(next);
      }
      for (const prev of objectMapValues(changes.removed)) {
        removingBinding(prev);
      }
    }
    return nextValue ?? lastValue;
  });
};
function fromScratch$1(editor) {
  const shapesIds = editor.getCurrentPageShapeIds();
  const viewportPageBounds = editor.getViewportPageBounds();
  const notVisibleShapes2 = /* @__PURE__ */ new Set();
  shapesIds.forEach((id) => {
    const shape = editor.getShape(id);
    if (!shape) return;
    const canCull = editor.getShapeUtil(shape.type).canCull(shape);
    if (!canCull) return;
    const pageBounds = editor.getShapePageBounds(id);
    if (pageBounds === void 0 || !viewportPageBounds.includes(pageBounds)) {
      notVisibleShapes2.add(id);
    }
  });
  return notVisibleShapes2;
}
function notVisibleShapes(editor) {
  return computed("notVisibleShapes", function updateNotVisibleShapes(prevValue) {
    const nextValue = fromScratch$1(editor);
    if (isUninitialized(prevValue)) {
      return nextValue;
    }
    if (prevValue.size !== nextValue.size) return nextValue;
    for (const prev of prevValue) {
      if (!nextValue.has(prev)) {
        return nextValue;
      }
    }
    return prevValue;
  });
}
function fromScratch(shapeIdsQuery, store) {
  const result = {};
  const shapeIds = shapeIdsQuery.get();
  const sortedShapes = Array.from(shapeIds, (id) => store.get(id)).sort(sortByIndex);
  sortedShapes.forEach((shape) => {
    result[shape.parentId] ??= [];
    result[shape.parentId].push(shape.id);
  });
  return result;
}
const parentsToChildren = (store) => {
  const shapeIdsQuery = store.query.ids("shape");
  const shapeHistory = store.query.filterHistory("shape");
  return computed(
    "parentsToChildrenWithIndexes",
    (lastValue, lastComputedEpoch) => {
      if (isUninitialized(lastValue)) {
        return fromScratch(shapeIdsQuery, store);
      }
      const diff = shapeHistory.getDiffSince(lastComputedEpoch);
      if (diff === RESET_VALUE) {
        return fromScratch(shapeIdsQuery, store);
      }
      if (diff.length === 0) return lastValue;
      let newValue = null;
      const ensureNewArray = (parentId) => {
        if (!newValue) {
          newValue = { ...lastValue };
        }
        if (!newValue[parentId]) {
          newValue[parentId] = [];
        } else if (newValue[parentId] === lastValue[parentId]) {
          newValue[parentId] = [...newValue[parentId]];
        }
      };
      const toSort = /* @__PURE__ */ new Set();
      let changes;
      for (let i = 0, n = diff.length; i < n; i++) {
        changes = diff[i];
        for (const record of Object.values(changes.added)) {
          if (!isShape(record)) continue;
          ensureNewArray(record.parentId);
          newValue[record.parentId].push(record.id);
          toSort.add(newValue[record.parentId]);
        }
        for (const [from2, to] of Object.values(changes.updated)) {
          if (!isShape(to)) continue;
          if (!isShape(from2)) continue;
          if (from2.parentId !== to.parentId) {
            ensureNewArray(from2.parentId);
            ensureNewArray(to.parentId);
            newValue[from2.parentId].splice(newValue[from2.parentId].indexOf(to.id), 1);
            newValue[to.parentId].push(to.id);
            toSort.add(newValue[to.parentId]);
          } else if (from2.index !== to.index) {
            ensureNewArray(to.parentId);
            const idx = newValue[to.parentId].indexOf(to.id);
            newValue[to.parentId][idx] = to.id;
            toSort.add(newValue[to.parentId]);
          }
        }
        for (const record of Object.values(changes.removed)) {
          if (!isShape(record)) continue;
          ensureNewArray(record.parentId);
          newValue[record.parentId].splice(newValue[record.parentId].indexOf(record.id), 1);
        }
      }
      for (const arr of toSort) {
        const shapesInArr = compact(arr.map((id) => store.get(id)));
        shapesInArr.sort(sortByIndex);
        arr.splice(0, arr.length, ...shapesInArr.map((shape) => shape.id));
      }
      return newValue ?? lastValue;
    }
  );
};
const isShapeInPage = (store, pageId, shape) => {
  while (!isPageId(shape.parentId)) {
    const parent = store.get(shape.parentId);
    if (!parent) return false;
    shape = parent;
  }
  return shape.parentId === pageId;
};
const deriveShapeIdsInCurrentPage = (store, getCurrentPageId) => {
  const shapesIndex = store.query.ids("shape");
  let lastPageId = null;
  function fromScratch2() {
    const currentPageId = getCurrentPageId();
    lastPageId = currentPageId;
    return new Set(
      [...shapesIndex.get()].filter((id) => isShapeInPage(store, currentPageId, store.get(id)))
    );
  }
  return computed("_shapeIdsInCurrentPage", (prevValue, lastComputedEpoch) => {
    if (isUninitialized(prevValue)) {
      return fromScratch2();
    }
    const currentPageId = getCurrentPageId();
    if (currentPageId !== lastPageId) {
      return fromScratch2();
    }
    const diff = store.history.getDiffSince(lastComputedEpoch);
    if (diff === RESET_VALUE) {
      return fromScratch2();
    }
    const builder = new IncrementalSetConstructor(
      prevValue
    );
    for (const changes of diff) {
      for (const record of Object.values(changes.added)) {
        if (isShape(record) && isShapeInPage(store, currentPageId, record)) {
          builder.add(record.id);
        }
      }
      for (const [_from, to] of Object.values(changes.updated)) {
        if (isShape(to)) {
          if (isShapeInPage(store, currentPageId, to)) {
            builder.add(to.id);
          } else {
            builder.remove(to.id);
          }
        }
      }
      for (const id of Object.keys(changes.removed)) {
        if (isShapeId(id)) {
          builder.remove(id);
        }
      }
    }
    const result = builder.get();
    if (!result) {
      return prevValue;
    }
    return withDiff(result.value, result.diff);
  });
};
var __create$9 = Object.create;
var __defProp$d = Object.defineProperty;
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
var __knownSymbol$9 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$9 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$9 = (base2) => [, , , __create$9(null)];
var __decoratorStrings$9 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$9 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$9("Function expected") : fn;
var __decoratorContext$9 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings$9[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError$9("Already initialized") : fns.push(__expectFn$9(fn || null)) });
var __decoratorMetadata$9 = (array2, target) => __defNormalProp$9(target, __knownSymbol$9("metadata"), array2[3]);
var __runInitializers$a = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$9 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings$9[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$9(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$9(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$9(it) && (desc[key] = it);
  }
  return desc && __defProp$d(target, name, desc), target;
};
var __publicField$9 = (obj, key, value) => __defNormalProp$9(obj, typeof key !== "symbol" ? key + "" : key, value);
var _cancelDoubleClickTimeout_dec, __getClickTimeout_dec, _init$9;
const MAX_CLICK_DISTANCE = 40;
__getClickTimeout_dec = [bind$1], _cancelDoubleClickTimeout_dec = [bind$1];
class ClickManager {
  constructor(editor) {
    this.editor = editor;
    __runInitializers$a(_init$9, 5, this);
    __publicField$9(this, "_clickId", "");
    __publicField$9(this, "_clickTimeout");
    __publicField$9(this, "_clickScreenPoint");
    __publicField$9(this, "_previousScreenPoint");
    __publicField$9(this, "_clickState", "idle");
    __publicField$9(this, "lastPointerInfo", {});
  }
  _getClickTimeout(state, id = uniqueId()) {
    this._clickId = id;
    clearTimeout(this._clickTimeout);
    this._clickTimeout = this.editor.timers.setTimeout(
      () => {
        if (this._clickState === state && this._clickId === id) {
          switch (this._clickState) {
            case "pendingTriple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "double_click",
                phase: "settle"
              });
              break;
            }
            case "pendingQuadruple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "triple_click",
                phase: "settle"
              });
              break;
            }
            case "pendingOverflow": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "quadruple_click",
                phase: "settle"
              });
              break;
            }
          }
          this._clickState = "idle";
        }
      },
      state === "idle" || state === "pendingDouble" ? this.editor.options.doubleClickDurationMs : this.editor.options.multiClickDurationMs
    );
  }
  /**
   * The current click state.
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get clickState() {
    return this._clickState;
  }
  handlePointerEvent(info) {
    switch (info.name) {
      case "pointer_down": {
        if (!this._clickState) return info;
        this._clickScreenPoint = Vec.From(info.point);
        if (this._previousScreenPoint && Vec.Dist2(this._previousScreenPoint, this._clickScreenPoint) > MAX_CLICK_DISTANCE ** 2) {
          this._clickState = "idle";
        }
        this._previousScreenPoint = this._clickScreenPoint;
        this.lastPointerInfo = info;
        switch (this._clickState) {
          case "pendingDouble": {
            this._clickState = "pendingTriple";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "double_click",
              phase: "down"
            };
          }
          case "pendingTriple": {
            this._clickState = "pendingQuadruple";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "triple_click",
              phase: "down"
            };
          }
          case "pendingQuadruple": {
            this._clickState = "pendingOverflow";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "quadruple_click",
              phase: "down"
            };
          }
          case "idle": {
            this._clickState = "pendingDouble";
            break;
          }
          case "pendingOverflow": {
            this._clickState = "overflow";
            break;
          }
        }
        this._clickTimeout = this._getClickTimeout(this._clickState);
        return info;
      }
      case "pointer_up": {
        if (!this._clickState) return info;
        this._clickScreenPoint = Vec.From(info.point);
        switch (this._clickState) {
          case "pendingTriple": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "double_click",
              phase: "up"
            };
          }
          case "pendingQuadruple": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "triple_click",
              phase: "up"
            };
          }
          case "pendingOverflow": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "quadruple_click",
              phase: "up"
            };
          }
        }
        return info;
      }
      case "pointer_move": {
        if (this._clickState !== "idle" && this._clickScreenPoint && Vec.Dist2(this._clickScreenPoint, this.editor.inputs.currentScreenPoint) > (this.editor.getInstanceState().isCoarsePointer ? this.editor.options.coarseDragDistanceSquared : this.editor.options.dragDistanceSquared)) {
          this.cancelDoubleClickTimeout();
        }
        return info;
      }
    }
    return info;
  }
  cancelDoubleClickTimeout() {
    this._clickTimeout = clearTimeout(this._clickTimeout);
    this._clickState = "idle";
  }
}
_init$9 = __decoratorStart$9();
__decorateElement$9(_init$9, 1, "_getClickTimeout", __getClickTimeout_dec, ClickManager);
__decorateElement$9(_init$9, 1, "cancelDoubleClickTimeout", _cancelDoubleClickTimeout_dec, ClickManager);
__decoratorMetadata$9(_init$9, ClickManager);
class EdgeScrollManager {
  constructor(editor) {
    this.editor = editor;
  }
  _isEdgeScrolling = false;
  _edgeScrollDuration = -1;
  /**
   * Update the camera position when the mouse is close to the edge of the screen.
   * Run this on every tick when in a state where edge scrolling is enabled.
   *
   * @public
   */
  updateEdgeScrolling(elapsed) {
    const { editor } = this;
    const edgeScrollProximityFactor = this.getEdgeScroll();
    if (edgeScrollProximityFactor.x === 0 && edgeScrollProximityFactor.y === 0) {
      if (this._isEdgeScrolling) {
        this._isEdgeScrolling = false;
        this._edgeScrollDuration = 0;
      }
    } else {
      if (!this._isEdgeScrolling) {
        this._isEdgeScrolling = true;
        this._edgeScrollDuration = 0;
      }
      this._edgeScrollDuration += elapsed;
      if (this._edgeScrollDuration > editor.options.edgeScrollDelay) {
        const eased = editor.options.edgeScrollEaseDuration > 0 ? EASINGS.easeInCubic(
          Math.min(
            1,
            this._edgeScrollDuration / (editor.options.edgeScrollDelay + editor.options.edgeScrollEaseDuration)
          )
        ) : 1;
        this.moveCameraWhenCloseToEdge({
          x: edgeScrollProximityFactor.x * eased,
          y: edgeScrollProximityFactor.y * eased
        });
      }
    }
  }
  /**
   * Helper function to get the scroll proximity factor for a given position.
   * @param position - The mouse position on the axis.
   * @param dimension - The component dimension on the axis.
   * @param isCoarse - Whether the pointer is coarse.
   * @param insetStart - Whether the pointer is inset at the start of the axis.
   * @param insetEnd - Whether the pointer is inset at the end of the axis.
   * @internal
   */
  getEdgeProximityFactors(position, dimension, isCoarse, insetStart, insetEnd) {
    const { editor } = this;
    const dist = editor.options.edgeScrollDistance;
    const pw = isCoarse ? editor.options.coarsePointerWidth : 0;
    const pMin = position - pw;
    const pMax = position + pw;
    const min2 = insetStart ? 0 : dist;
    const max2 = insetEnd ? dimension : dimension - dist;
    if (pMin < min2) {
      return Math.min(1, (min2 - pMin) / dist);
    } else if (pMax > max2) {
      return -Math.min(1, (pMax - max2) / dist);
    }
    return 0;
  }
  getEdgeScroll() {
    const { editor } = this;
    const {
      inputs: {
        currentScreenPoint: { x, y }
      }
    } = editor;
    const screenBounds = editor.getViewportScreenBounds();
    const {
      isCoarsePointer,
      insets: [t2, r, b, l]
    } = editor.getInstanceState();
    const proximityFactorX = this.getEdgeProximityFactors(x, screenBounds.w, isCoarsePointer, l, r);
    const proximityFactorY = this.getEdgeProximityFactors(y, screenBounds.h, isCoarsePointer, t2, b);
    return {
      x: proximityFactorX,
      y: proximityFactorY
    };
  }
  /**
   * Moves the camera when the mouse is close to the edge of the screen.
   * @public
   */
  moveCameraWhenCloseToEdge(proximityFactor) {
    const { editor } = this;
    if (!editor.inputs.isDragging || editor.inputs.isPanning || editor.getCameraOptions().isLocked)
      return;
    if (proximityFactor.x === 0 && proximityFactor.y === 0) return;
    const screenBounds = editor.getViewportScreenBounds();
    const screenSizeFactorX = screenBounds.w < 1e3 ? 0.612 : 1;
    const screenSizeFactorY = screenBounds.h < 1e3 ? 0.612 : 1;
    const zoomLevel = editor.getZoomLevel();
    const pxSpeed = editor.user.getEdgeScrollSpeed() * editor.options.edgeScrollSpeed;
    const scrollDeltaX = pxSpeed * proximityFactor.x * screenSizeFactorX / zoomLevel;
    const scrollDeltaY = pxSpeed * proximityFactor.y * screenSizeFactorY / zoomLevel;
    const { x, y, z } = editor.getCamera();
    editor.setCamera(new Vec(x + scrollDeltaX, y + scrollDeltaY, z));
  }
}
class FocusManager {
  constructor(editor, autoFocus) {
    this.editor = editor;
    this.disposeSideEffectListener = editor.sideEffects.registerAfterChangeHandler(
      "instance",
      (prev, next) => {
        if (prev.isFocused !== next.isFocused) {
          this.updateContainerClass();
        }
      }
    );
    const currentFocusState = editor.getInstanceState().isFocused;
    if (autoFocus !== currentFocusState) {
      editor.updateInstanceState({ isFocused: !!autoFocus });
    }
    this.updateContainerClass();
    document.body.addEventListener("keydown", this.handleKeyDown.bind(this));
    document.body.addEventListener("mousedown", this.handleMouseDown.bind(this));
  }
  disposeSideEffectListener;
  /**
   * The editor's focus state and the container's focus state
   * are not necessarily always in sync. For that reason we
   * can't rely on the css `:focus` or `:focus-within` selectors to style the
   * editor when it is in focus.
   *
   * For that reason we synchronize the editor's focus state with a
   * special class on the container: tl-container__focused
   */
  updateContainerClass() {
    const container = this.editor.getContainer();
    const instanceState = this.editor.getInstanceState();
    if (instanceState.isFocused) {
      container.classList.add("tl-container__focused");
    } else {
      container.classList.remove("tl-container__focused");
    }
    container.classList.add("tl-container__no-focus-ring");
  }
  handleKeyDown(keyEvent2) {
    const container = this.editor.getContainer();
    const activeEl = document.activeElement;
    if (this.editor.isIn("select.editing_shape") && !activeEl?.closest(".tlui-contextual-toolbar"))
      return;
    if (activeEl === container && this.editor.getSelectedShapeIds().length > 0) return;
    if (["Tab", "ArrowUp", "ArrowDown"].includes(keyEvent2.key)) {
      container.classList.remove("tl-container__no-focus-ring");
    }
  }
  handleMouseDown() {
    const container = this.editor.getContainer();
    container.classList.add("tl-container__no-focus-ring");
  }
  focus() {
    this.editor.getContainer().focus();
  }
  blur() {
    this.editor.complete();
    this.editor.getContainer().blur();
  }
  dispose() {
    document.body.removeEventListener("keydown", this.handleKeyDown.bind(this));
    document.body.removeEventListener("mousedown", this.handleMouseDown.bind(this));
    this.disposeSideEffectListener?.();
  }
}
class FontManager {
  constructor(editor, assetUrls) {
    this.editor = editor;
    this.assetUrls = assetUrls;
    this.shapeFontFacesCache = editor.store.createComputedCache(
      "shape font faces",
      (shape) => {
        const shapeUtil = this.editor.getShapeUtil(shape);
        return shapeUtil.getFontFaces(shape);
      },
      {
        areResultsEqual: areArraysShallowEqual,
        areRecordsEqual: (a, b) => a.props === b.props && a.meta === b.meta
      }
    );
    this.shapeFontLoadStateCache = editor.store.createCache(
      (id) => {
        const fontFacesComputed = computed("font faces", () => this.getShapeFontFaces(id));
        return computed(
          "font load state",
          () => {
            const states = fontFacesComputed.get().map((face) => this.getFontState(face));
            return states;
          },
          { isEqual: areArraysShallowEqual }
        );
      }
    );
  }
  shapeFontFacesCache;
  shapeFontLoadStateCache;
  getShapeFontFaces(shape) {
    const shapeId = typeof shape === "string" ? shape : shape.id;
    return this.shapeFontFacesCache.get(shapeId) ?? EMPTY_ARRAY;
  }
  trackFontsForShape(shape) {
    const shapeId = typeof shape === "string" ? shape : shape.id;
    this.shapeFontLoadStateCache.get(shapeId);
  }
  async loadRequiredFontsForCurrentPage(limit = Infinity) {
    const neededFonts = /* @__PURE__ */ new Set();
    for (const shapeId of this.editor.getCurrentPageShapeIds()) {
      for (const font of this.getShapeFontFaces(this.editor.getShape(shapeId))) {
        neededFonts.add(font);
      }
    }
    if (neededFonts.size > limit) {
      return;
    }
    const promises = Array.from(neededFonts, (font) => this.ensureFontIsLoaded(font));
    await Promise.all(promises);
  }
  fontStates = new AtomMap("font states");
  getFontState(font) {
    return this.fontStates.get(font) ?? null;
  }
  ensureFontIsLoaded(font) {
    const existingState = this.getFontState(font);
    if (existingState) return existingState.loadingPromise;
    const instance = this.findOrCreateFontFace(font);
    const state = {
      state: "loading",
      instance,
      loadingPromise: instance.load().then(() => {
        document.fonts.add(instance);
        this.fontStates.update(font, (s) => ({ ...s, state: "ready" }));
      }).catch((err) => {
        console.error(err);
        this.fontStates.update(font, (s) => ({ ...s, state: "error" }));
      })
    };
    this.fontStates.set(font, state);
    return state.loadingPromise;
  }
  fontsToLoad = /* @__PURE__ */ new Set();
  requestFonts(fonts) {
    if (!this.fontsToLoad.size) {
      queueMicrotask(() => {
        if (this.editor.isDisposed) return;
        const toLoad = this.fontsToLoad;
        this.fontsToLoad = /* @__PURE__ */ new Set();
        transact(() => {
          for (const font of toLoad) {
            this.ensureFontIsLoaded(font);
          }
        });
      });
    }
    for (const font of fonts) {
      this.fontsToLoad.add(font);
    }
  }
  findOrCreateFontFace(font) {
    for (const existing of document.fonts) {
      if (existing.family === font.family && objectMapEntries(defaultFontFaceDescriptors).every(
        ([key, defaultValue]) => existing[key] === (font[key] ?? defaultValue)
      )) {
        return existing;
      }
    }
    const url = this.assetUrls?.[font.src.url] ?? font.src.url;
    const instance = new FontFace(font.family, `url(${JSON.stringify(url)})`, {
      ...mapObjectMapValues(defaultFontFaceDescriptors, (key) => font[key]),
      display: "swap"
    });
    document.fonts.add(instance);
    return instance;
  }
  async toEmbeddedCssDeclaration(font) {
    const url = this.assetUrls?.[font.src.url] ?? font.src.url;
    const dataUrl = await FileHelpers.urlToDataUrl(url);
    const src = compact([
      `url("${dataUrl}")`,
      font.src.format ? `format(${font.src.format})` : null,
      font.src.tech ? `tech(${font.src.tech})` : null
    ]).join(" ");
    return compact([
      `@font-face {`,
      `  font-family: "${font.family}";`,
      font.ascentOverride ? `  ascent-override: ${font.ascentOverride};` : null,
      font.descentOverride ? `  descent-override: ${font.descentOverride};` : null,
      font.stretch ? `  font-stretch: ${font.stretch};` : null,
      font.style ? `  font-style: ${font.style};` : null,
      font.weight ? `  font-weight: ${font.weight};` : null,
      font.featureSettings ? `  font-feature-settings: ${font.featureSettings};` : null,
      font.lineGapOverride ? `  line-gap-override: ${font.lineGapOverride};` : null,
      font.unicodeRange ? `  unicode-range: ${font.unicodeRange};` : null,
      `  src: ${src};`,
      `}`
    ]).join("\n");
  }
}
const defaultFontFaceDescriptors = {
  style: "normal",
  weight: "normal",
  stretch: "normal",
  unicodeRange: "U+0-10FFFF",
  featureSettings: "normal",
  ascentOverride: "normal",
  descentOverride: "normal",
  lineGapOverride: "normal"
};
class HistoryManager {
  store;
  dispose;
  state = "recording";
  pendingDiff = new PendingDiff();
  stacks = atom(
    "HistoryManager.stacks",
    {
      undos: stack(),
      redos: stack()
    },
    {
      isEqual: (a, b) => a.undos === b.undos && a.redos === b.redos
    }
  );
  annotateError;
  constructor(opts) {
    this.store = opts.store;
    this.annotateError = opts.annotateError ?? noop$3;
    this.dispose = this.store.addHistoryInterceptor((entry2, source) => {
      if (source !== "user") return;
      switch (this.state) {
        case "recording":
          this.pendingDiff.apply(entry2.changes);
          this.stacks.update(({ undos }) => ({ undos, redos: stack() }));
          break;
        case "recordingPreserveRedoStack":
          this.pendingDiff.apply(entry2.changes);
          break;
        case "paused":
          break;
        default:
          exhaustiveSwitchError(this.state);
      }
    });
  }
  flushPendingDiff() {
    if (this.pendingDiff.isEmpty()) return;
    const diff = this.pendingDiff.clear();
    this.stacks.update(({ undos, redos }) => ({
      undos: undos.push({ type: "diff", diff }),
      redos
    }));
  }
  getNumUndos() {
    return this.stacks.get().undos.length + (this.pendingDiff.isEmpty() ? 0 : 1);
  }
  getNumRedos() {
    return this.stacks.get().redos.length;
  }
  /** @internal */
  _isInBatch = false;
  batch(fn, opts) {
    const previousState = this.state;
    if (previousState !== "paused" && opts?.history) {
      this.state = modeToState[opts.history];
    }
    try {
      if (this._isInBatch) {
        transact(fn);
        return this;
      }
      this._isInBatch = true;
      try {
        transact(fn);
      } catch (error) {
        this.annotateError(error);
        throw error;
      } finally {
        this._isInBatch = false;
      }
      return this;
    } finally {
      this.state = previousState;
    }
  }
  // History
  _undo({ pushToRedoStack, toMark = void 0 }) {
    const previousState = this.state;
    this.state = "paused";
    try {
      let { undos, redos } = this.stacks.get();
      const pendingDiff = this.pendingDiff.clear();
      const isPendingDiffEmpty = isRecordsDiffEmpty(pendingDiff);
      const diffToUndo = reverseRecordsDiff(pendingDiff);
      if (pushToRedoStack && !isPendingDiffEmpty) {
        redos = redos.push({ type: "diff", diff: pendingDiff });
      }
      let didFindMark = false;
      if (isPendingDiffEmpty) {
        while (undos.head?.type === "stop") {
          const mark = undos.head;
          undos = undos.tail;
          if (pushToRedoStack) {
            redos = redos.push(mark);
          }
          if (mark.id === toMark) {
            didFindMark = true;
            break;
          }
        }
      }
      if (!didFindMark) {
        loop: while (undos.head) {
          const undo2 = undos.head;
          undos = undos.tail;
          if (pushToRedoStack) {
            redos = redos.push(undo2);
          }
          switch (undo2.type) {
            case "diff":
              squashRecordDiffsMutable(diffToUndo, [reverseRecordsDiff(undo2.diff)]);
              break;
            case "stop":
              if (!toMark) break loop;
              if (undo2.id === toMark) {
                didFindMark = true;
                break loop;
              }
              break;
            default:
              exhaustiveSwitchError(undo2);
          }
        }
      }
      if (!didFindMark && toMark) {
        return this;
      }
      this.store.applyDiff(diffToUndo, { ignoreEphemeralKeys: true });
      this.store.ensureStoreIsUsable();
      this.stacks.set({ undos, redos });
    } finally {
      this.state = previousState;
    }
    return this;
  }
  undo() {
    this._undo({ pushToRedoStack: true });
    return this;
  }
  redo() {
    const previousState = this.state;
    this.state = "paused";
    try {
      this.flushPendingDiff();
      let { undos, redos } = this.stacks.get();
      if (redos.length === 0) {
        return this;
      }
      while (redos.head?.type === "stop") {
        undos = undos.push(redos.head);
        redos = redos.tail;
      }
      const diffToRedo = createEmptyRecordsDiff();
      while (redos.head) {
        const redo2 = redos.head;
        undos = undos.push(redo2);
        redos = redos.tail;
        if (redo2.type === "diff") {
          squashRecordDiffsMutable(diffToRedo, [redo2.diff]);
        } else {
          break;
        }
      }
      this.store.applyDiff(diffToRedo, { ignoreEphemeralKeys: true });
      this.store.ensureStoreIsUsable();
      this.stacks.set({ undos, redos });
    } finally {
      this.state = previousState;
    }
    return this;
  }
  bail() {
    this._undo({ pushToRedoStack: false });
    return this;
  }
  bailToMark(id) {
    if (id) {
      this._undo({ pushToRedoStack: false, toMark: id });
    }
    return this;
  }
  squashToMark(id) {
    let top = this.stacks.get().undos;
    const popped = [];
    while (top.head && !(top.head.type === "stop" && top.head.id === id)) {
      if (top.head.type === "diff") {
        popped.push(top.head.diff);
      }
      top = top.tail;
    }
    if (!top.head || top.head?.id !== id) {
      console.error("Could not find mark to squash to: ", id);
      return this;
    }
    if (popped.length === 0) {
      return this;
    }
    const diff = createEmptyRecordsDiff();
    squashRecordDiffsMutable(diff, popped.reverse());
    this.stacks.update(({ redos }) => ({
      undos: top.push({
        type: "diff",
        diff
      }),
      redos
    }));
    return this;
  }
  /** @internal */
  _mark(id) {
    transact(() => {
      this.flushPendingDiff();
      this.stacks.update(({ undos, redos }) => ({ undos: undos.push({ type: "stop", id }), redos }));
    });
  }
  clear() {
    this.stacks.set({ undos: stack(), redos: stack() });
    this.pendingDiff.clear();
  }
  /** @internal */
  getMarkIdMatching(idSubstring) {
    let top = this.stacks.get().undos;
    while (top.head) {
      if (top.head.type === "stop" && top.head.id.includes(idSubstring)) {
        return top.head.id;
      }
      top = top.tail;
    }
    return null;
  }
  /** @internal */
  debug() {
    const { undos, redos } = this.stacks.get();
    return {
      undos: undos.toArray(),
      redos: redos.toArray(),
      pendingDiff: this.pendingDiff.debug(),
      state: this.state
    };
  }
}
const modeToState = {
  record: "recording",
  "record-preserveRedoStack": "recordingPreserveRedoStack",
  ignore: "paused"
  /* Paused */
};
class PendingDiff {
  diff = createEmptyRecordsDiff();
  isEmptyAtom = atom("PendingDiff.isEmpty", true);
  clear() {
    const diff = this.diff;
    this.diff = createEmptyRecordsDiff();
    this.isEmptyAtom.set(true);
    return diff;
  }
  isEmpty() {
    return this.isEmptyAtom.get();
  }
  apply(diff) {
    squashRecordDiffsMutable(this.diff, [diff]);
    this.isEmptyAtom.set(isRecordsDiffEmpty(this.diff));
  }
  debug() {
    return { diff: this.diff, isEmpty: this.isEmpty() };
  }
}
function stack(items) {
  return EMPTY_STACK_ITEM;
}
class EmptyStackItem {
  length = 0;
  head = null;
  tail = this;
  push(head) {
    return new StackItem(head, this);
  }
  toArray() {
    return EMPTY_ARRAY;
  }
  [Symbol.iterator]() {
    return {
      next() {
        return { value: void 0, done: true };
      }
    };
  }
}
const EMPTY_STACK_ITEM = new EmptyStackItem();
class StackItem {
  constructor(head, tail) {
    this.head = head;
    this.tail = tail;
    this.length = tail.length + 1;
  }
  length;
  push(head) {
    return new StackItem(head, this);
  }
  toArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let stack2 = this;
    return {
      next() {
        if (stack2.length) {
          const value = stack2.head;
          stack2 = stack2.tail;
          return { value, done: false };
        } else {
          return { value: void 0, done: true };
        }
      }
    };
  }
}
class ScribbleManager {
  constructor(editor) {
    this.editor = editor;
  }
  scribbleItems = /* @__PURE__ */ new Map();
  state = "paused";
  addScribble(scribble, id = uniqueId()) {
    const item = {
      id,
      scribble: {
        id,
        size: 20,
        color: "accent",
        opacity: 0.8,
        delay: 0,
        points: [],
        shrink: 0.1,
        taper: true,
        ...scribble,
        state: "starting"
      },
      timeoutMs: 0,
      delayRemaining: scribble.delay ?? 0,
      prev: null,
      next: null
    };
    this.scribbleItems.set(id, item);
    return item;
  }
  reset() {
    this.editor.updateInstanceState({ scribbles: [] });
    this.scribbleItems.clear();
  }
  /**
   * Start stopping the scribble. The scribble won't be removed until its last point is cleared.
   *
   * @public
   */
  stop(id) {
    const item = this.scribbleItems.get(id);
    if (!item) throw Error(`Scribble with id ${id} not found`);
    item.delayRemaining = Math.min(item.delayRemaining, 200);
    item.scribble.state = "stopping";
    return item;
  }
  /**
   * Set the scribble's next point.
   *
   * @param id - The id of the scribble to add a point to.
   * @param x - The x coordinate of the point.
   * @param y - The y coordinate of the point.
   * @param z - The z coordinate of the point.
   * @public
   */
  addPoint(id, x, y, z = 0.5) {
    const item = this.scribbleItems.get(id);
    if (!item) throw Error(`Scribble with id ${id} not found`);
    const { prev } = item;
    const point = { x, y, z };
    if (!prev || Vec.Dist(prev, point) >= 1) {
      item.next = point;
    }
    return item;
  }
  /**
   * Update on each animation frame.
   *
   * @param elapsed - The number of milliseconds since the last tick.
   * @public
   */
  tick(elapsed) {
    if (this.scribbleItems.size === 0) return;
    this.editor.run(() => {
      this.scribbleItems.forEach((item) => {
        if (item.scribble.state === "starting") {
          const { next: next2, prev: prev2 } = item;
          if (next2 && next2 !== prev2) {
            item.prev = next2;
            item.scribble.points.push(next2);
          }
          if (item.scribble.points.length > 8) {
            item.scribble.state = "active";
          }
          return;
        }
        if (item.delayRemaining > 0) {
          item.delayRemaining = Math.max(0, item.delayRemaining - elapsed);
        }
        item.timeoutMs += elapsed;
        if (item.timeoutMs >= 16) {
          item.timeoutMs = 0;
        }
        const { delayRemaining, timeoutMs, prev, next, scribble } = item;
        switch (scribble.state) {
          case "active": {
            if (next && next !== prev) {
              item.prev = next;
              scribble.points.push(next);
              if (delayRemaining === 0) {
                if (scribble.points.length > 8) {
                  scribble.points.shift();
                }
              }
            } else {
              if (timeoutMs === 0) {
                if (scribble.points.length > 1) {
                  scribble.points.shift();
                } else {
                  item.delayRemaining = scribble.delay;
                }
              }
            }
            break;
          }
          case "stopping": {
            if (item.delayRemaining === 0) {
              if (timeoutMs === 0) {
                if (scribble.points.length === 1) {
                  this.scribbleItems.delete(item.id);
                  return;
                }
                if (scribble.shrink) {
                  scribble.size = Math.max(1, scribble.size * (1 - scribble.shrink));
                }
                scribble.points.shift();
              }
            }
            break;
          }
        }
      });
      this.editor.updateInstanceState({
        scribbles: Array.from(this.scribbleItems.values()).map(({ scribble }) => ({
          ...scribble,
          points: [...scribble.points]
        })).slice(-5)
        // limit to three as a minor sanity check
      });
    });
  }
}
var __create$8 = Object.create;
var __defProp$c = Object.defineProperty;
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __knownSymbol$8 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$8 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$8 = (base2) => [, , , __create$8(null)];
var __decoratorStrings$8 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$8 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$8("Function expected") : fn;
var __decoratorContext$8 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings$8[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError$8("Already initialized") : fns.push(__expectFn$8(fn || null)) });
var __decoratorMetadata$8 = (array2, target) => __defNormalProp$8(target, __knownSymbol$8("metadata"), array2[3]);
var __runInitializers$9 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$8 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings$8[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$8(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$8(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$8(it) && (desc[key] = it);
  }
  return desc && __defProp$c(target, name, desc), target;
};
var __publicField$8 = (obj, key, value) => __defNormalProp$8(obj, key + "", value);
var _getVisibleGaps_dec, _getSnappableGapNodes_dec, _getSnappablePoints_dec, _getSnapPointsCache_dec, _init$8;
const round$1 = (x) => {
  const decimalPlacesTolerance = 8;
  return Math.round(x * 10 ** decimalPlacesTolerance) / 10 ** decimalPlacesTolerance;
};
function findAdjacentGaps(gaps, shapeId, gapLength, direction, intersection) {
  const matches2 = gaps.filter(
    (gap) => (direction === "forward" ? gap.startNode.id === shapeId : gap.endNode.id === shapeId) && round$1(gap.length) === round$1(gapLength) && rangeIntersection(
      gap.breadthIntersection[0],
      gap.breadthIntersection[1],
      intersection[0],
      intersection[1]
    )
  );
  if (matches2.length === 0) return [];
  const nextNodes = /* @__PURE__ */ new Set();
  matches2.forEach((match) => {
    const node = direction === "forward" ? match.endNode.id : match.startNode.id;
    if (!nextNodes.has(node)) {
      nextNodes.add(node);
      const foundGaps = findAdjacentGaps(
        gaps,
        node,
        gapLength,
        direction,
        rangeIntersection(
          match.breadthIntersection[0],
          match.breadthIntersection[1],
          intersection[0],
          intersection[1]
        )
      );
      matches2.push(...foundGaps);
    }
  });
  return matches2;
}
function dedupeGapSnaps(snaps) {
  snaps.sort((a, b) => b.gaps.length - a.gaps.length);
  for (let i = snaps.length - 1; i > 0; i--) {
    const snap = snaps[i];
    for (let j = i - 1; j >= 0; j--) {
      const otherSnap = snaps[j];
      if (otherSnap.direction === snap.direction && snap.gaps.every(
        (gap) => otherSnap.gaps.some(
          (otherGap) => round$1(gap.startEdge[0].x) === round$1(otherGap.startEdge[0].x) && round$1(gap.startEdge[0].y) === round$1(otherGap.startEdge[0].y) && round$1(gap.startEdge[1].x) === round$1(otherGap.startEdge[1].x) && round$1(gap.startEdge[1].y) === round$1(otherGap.startEdge[1].y)
        ) && otherSnap.gaps.some(
          (otherGap) => round$1(gap.endEdge[0].x) === round$1(otherGap.endEdge[0].x) && round$1(gap.endEdge[0].y) === round$1(otherGap.endEdge[0].y) && round$1(gap.endEdge[1].x) === round$1(otherGap.endEdge[1].x) && round$1(gap.endEdge[1].y) === round$1(otherGap.endEdge[1].y)
        )
      )) {
        snaps.splice(i, 1);
        break;
      }
    }
  }
}
_getSnapPointsCache_dec = [computed], _getSnappablePoints_dec = [computed], _getSnappableGapNodes_dec = [computed], _getVisibleGaps_dec = [computed];
class BoundsSnaps {
  constructor(manager) {
    this.manager = manager;
    __runInitializers$9(_init$8, 5, this);
    __publicField$8(this, "editor");
    this.editor = manager.editor;
  }
  getSnapPointsCache() {
    const { editor } = this;
    return editor.store.createComputedCache("snapPoints", (shape) => {
      const pageTransform = editor.getShapePageTransform(shape.id);
      if (!pageTransform) return void 0;
      const boundsSnapGeometry = editor.getShapeUtil(shape).getBoundsSnapGeometry(shape);
      const snapPoints = boundsSnapGeometry.points ?? editor.getShapeGeometry(shape).bounds.cornersAndCenter;
      if (!pageTransform || !snapPoints) return void 0;
      return snapPoints.map((point, i) => {
        const { x, y } = Mat.applyToPoint(pageTransform, point);
        return { x, y, id: `${shape.id}:${i}` };
      });
    });
  }
  getSnapPoints(shapeId) {
    return this.getSnapPointsCache().get(shapeId) ?? [];
  }
  getSnappablePoints() {
    const snapPointsCache = this.getSnapPointsCache();
    const snappableShapes = this.manager.getSnappableShapes();
    const result = [];
    for (const shapeId of snappableShapes) {
      const snapPoints = snapPointsCache.get(shapeId);
      if (snapPoints) {
        result.push(...snapPoints);
      }
    }
    return result;
  }
  getSnappableGapNodes() {
    return Array.from(this.manager.getSnappableShapes(), (shapeId) => ({
      id: shapeId,
      pageBounds: assertExists(this.editor.getShapePageBounds(shapeId))
    }));
  }
  getVisibleGaps() {
    const horizontal = [];
    const vertical = [];
    let startNode, endNode;
    const sortedShapesOnCurrentPageHorizontal = this.getSnappableGapNodes().sort((a, b) => {
      return a.pageBounds.minX - b.pageBounds.minX;
    });
    for (let i = 0; i < sortedShapesOnCurrentPageHorizontal.length; i++) {
      startNode = sortedShapesOnCurrentPageHorizontal[i];
      for (let j = i + 1; j < sortedShapesOnCurrentPageHorizontal.length; j++) {
        endNode = sortedShapesOnCurrentPageHorizontal[j];
        if (
          // is there space between the boxes
          startNode.pageBounds.maxX < endNode.pageBounds.minX && // and they overlap in the y axis
          rangesOverlap(
            startNode.pageBounds.minY,
            startNode.pageBounds.maxY,
            endNode.pageBounds.minY,
            endNode.pageBounds.maxY
          )
        ) {
          horizontal.push({
            startNode,
            endNode,
            startEdge: [
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.minY),
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.maxY)
            ],
            endEdge: [
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.minY),
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.maxY)
            ],
            length: endNode.pageBounds.minX - startNode.pageBounds.maxX,
            breadthIntersection: rangeIntersection(
              startNode.pageBounds.minY,
              startNode.pageBounds.maxY,
              endNode.pageBounds.minY,
              endNode.pageBounds.maxY
            )
          });
        }
      }
    }
    const sortedShapesOnCurrentPageVertical = sortedShapesOnCurrentPageHorizontal.sort((a, b) => {
      return a.pageBounds.minY - b.pageBounds.minY;
    });
    for (let i = 0; i < sortedShapesOnCurrentPageVertical.length; i++) {
      startNode = sortedShapesOnCurrentPageVertical[i];
      for (let j = i + 1; j < sortedShapesOnCurrentPageVertical.length; j++) {
        endNode = sortedShapesOnCurrentPageVertical[j];
        if (
          // is there space between the boxes
          startNode.pageBounds.maxY < endNode.pageBounds.minY && // do they overlap in the x axis
          rangesOverlap(
            startNode.pageBounds.minX,
            startNode.pageBounds.maxX,
            endNode.pageBounds.minX,
            endNode.pageBounds.maxX
          )
        ) {
          vertical.push({
            startNode,
            endNode,
            startEdge: [
              new Vec(startNode.pageBounds.minX, startNode.pageBounds.maxY),
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.maxY)
            ],
            endEdge: [
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.minY),
              new Vec(endNode.pageBounds.maxX, endNode.pageBounds.minY)
            ],
            length: endNode.pageBounds.minY - startNode.pageBounds.maxY,
            breadthIntersection: rangeIntersection(
              startNode.pageBounds.minX,
              startNode.pageBounds.maxX,
              endNode.pageBounds.minX,
              endNode.pageBounds.maxX
            )
          });
        }
      }
    }
    return { horizontal, vertical };
  }
  snapTranslateShapes({
    lockedAxis,
    initialSelectionPageBounds,
    initialSelectionSnapPoints,
    dragDelta
  }) {
    const snapThreshold = this.manager.getSnapThreshold();
    const visibleSnapPointsNotInSelection = this.getSnappablePoints();
    const selectionPageBounds = initialSelectionPageBounds.clone().translate(dragDelta);
    const selectionSnapPoints = initialSelectionSnapPoints.map(
      ({ x, y }, i) => ({
        id: "selection:" + i,
        x: x + dragDelta.x,
        y: y + dragDelta.y
      })
    );
    const otherNodeSnapPoints = visibleSnapPointsNotInSelection;
    const nearestSnapsX = [];
    const nearestSnapsY = [];
    const minOffset = new Vec(snapThreshold, snapThreshold);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    this.collectGapSnaps({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY,
      minOffset
    });
    const nudge = new Vec(
      lockedAxis === "x" ? 0 : nearestSnapsX[0]?.nudge ?? 0,
      lockedAxis === "y" ? 0 : nearestSnapsY[0]?.nudge ?? 0
    );
    minOffset.x = 0;
    minOffset.y = 0;
    nearestSnapsX.length = 0;
    nearestSnapsY.length = 0;
    selectionSnapPoints.forEach((s) => {
      s.x += nudge.x;
      s.y += nudge.y;
    });
    selectionPageBounds.translate(nudge);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    this.collectGapSnaps({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY,
      minOffset
    });
    const pointSnapsLines = this.getPointSnapLines({
      nearestSnapsX,
      nearestSnapsY
    });
    const gapSnapLines = this.getGapSnapLines({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY
    });
    this.manager.setIndicators([...gapSnapLines, ...pointSnapsLines]);
    return { nudge };
  }
  snapResizeShapes({
    initialSelectionPageBounds,
    dragDelta,
    handle: originalHandle,
    isAspectRatioLocked,
    isResizingFromCenter
  }) {
    const snapThreshold = this.manager.getSnapThreshold();
    const {
      box: unsnappedResizedPageBounds,
      scaleX,
      scaleY
    } = Box.Resize(
      initialSelectionPageBounds,
      originalHandle,
      isResizingFromCenter ? dragDelta.x * 2 : dragDelta.x,
      isResizingFromCenter ? dragDelta.y * 2 : dragDelta.y,
      isAspectRatioLocked
    );
    let handle = originalHandle;
    if (scaleX < 0) {
      handle = flipSelectionHandleX(handle);
    }
    if (scaleY < 0) {
      handle = flipSelectionHandleY(handle);
    }
    if (isResizingFromCenter) {
      unsnappedResizedPageBounds.center = initialSelectionPageBounds.center;
    }
    const isXLocked = handle === "top" || handle === "bottom";
    const isYLocked = handle === "left" || handle === "right";
    const selectionSnapPoints = getResizeSnapPointsForHandle(handle, unsnappedResizedPageBounds);
    const otherNodeSnapPoints = this.getSnappablePoints();
    const nearestSnapsX = [];
    const nearestSnapsY = [];
    const minOffset = new Vec(snapThreshold, snapThreshold);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    const nudge = new Vec(
      isXLocked ? 0 : nearestSnapsX[0]?.nudge ?? 0,
      isYLocked ? 0 : nearestSnapsY[0]?.nudge ?? 0
    );
    if (isAspectRatioLocked && isSelectionCorner(handle) && nudge.len() !== 0) {
      const primaryNudgeAxis = nearestSnapsX.length && nearestSnapsY.length ? Math.abs(nudge.x) < Math.abs(nudge.y) ? "x" : "y" : nearestSnapsX.length ? "x" : "y";
      const ratio = initialSelectionPageBounds.aspectRatio;
      if (primaryNudgeAxis === "x") {
        nearestSnapsY.length = 0;
        nudge.y = nudge.x / ratio;
        if (handle === "bottom_left" || handle === "top_right") {
          nudge.y = -nudge.y;
        }
      } else {
        nearestSnapsX.length = 0;
        nudge.x = nudge.y * ratio;
        if (handle === "bottom_left" || handle === "top_right") {
          nudge.x = -nudge.x;
        }
      }
    }
    const snappedDelta = Vec.Add(dragDelta, nudge);
    const { box: snappedResizedPageBounds } = Box.Resize(
      initialSelectionPageBounds,
      originalHandle,
      isResizingFromCenter ? snappedDelta.x * 2 : snappedDelta.x,
      isResizingFromCenter ? snappedDelta.y * 2 : snappedDelta.y,
      isAspectRatioLocked
    );
    if (isResizingFromCenter) {
      snappedResizedPageBounds.center = initialSelectionPageBounds.center;
    }
    const snappedSelectionPoints = getResizeSnapPointsForHandle("any", snappedResizedPageBounds);
    nearestSnapsX.length = 0;
    nearestSnapsY.length = 0;
    minOffset.x = 0;
    minOffset.y = 0;
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints: snappedSelectionPoints
    });
    const pointSnaps = this.getPointSnapLines({
      nearestSnapsX,
      nearestSnapsY
    });
    this.manager.setIndicators([...pointSnaps]);
    return { nudge };
  }
  collectPointSnaps({
    selectionSnapPoints,
    otherNodeSnapPoints,
    minOffset,
    nearestSnapsX,
    nearestSnapsY
  }) {
    for (const thisSnapPoint of selectionSnapPoints) {
      for (const otherSnapPoint of otherNodeSnapPoints) {
        const offset2 = Vec.Sub(thisSnapPoint, otherSnapPoint);
        const offsetX = Math.abs(offset2.x);
        const offsetY = Math.abs(offset2.y);
        if (round$1(offsetX) <= round$1(minOffset.x)) {
          if (round$1(offsetX) < round$1(minOffset.x)) {
            nearestSnapsX.length = 0;
          }
          nearestSnapsX.push({
            type: "points",
            points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
            nudge: otherSnapPoint.x - thisSnapPoint.x
          });
          minOffset.x = offsetX;
        }
        if (round$1(offsetY) <= round$1(minOffset.y)) {
          if (round$1(offsetY) < round$1(minOffset.y)) {
            nearestSnapsY.length = 0;
          }
          nearestSnapsY.push({
            type: "points",
            points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
            nudge: otherSnapPoint.y - thisSnapPoint.y
          });
          minOffset.y = offsetY;
        }
      }
    }
  }
  collectGapSnaps({
    selectionPageBounds,
    minOffset,
    nearestSnapsX,
    nearestSnapsY
  }) {
    const { horizontal, vertical } = this.getVisibleGaps();
    for (const gap of horizontal) {
      if (!rangesOverlap(
        gap.breadthIntersection[0],
        gap.breadthIntersection[1],
        selectionPageBounds.minY,
        selectionPageBounds.maxY
      )) {
        continue;
      }
      const gapMidX = gap.startEdge[0].x + gap.length / 2;
      const centerNudge = gapMidX - selectionPageBounds.center.x;
      const gapIsLargerThanSelection = gap.length > selectionPageBounds.width;
      if (gapIsLargerThanSelection && round$1(Math.abs(centerNudge)) <= round$1(minOffset.x)) {
        if (round$1(Math.abs(centerNudge)) < round$1(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(centerNudge);
        const snap = {
          type: "gap_center",
          gap,
          nudge: centerNudge
        };
        const otherCenterSnap = nearestSnapsX.find(({ type }) => type === "gap_center");
        const gapBreadthsOverlap = otherCenterSnap && rangeIntersection(
          gap.breadthIntersection[0],
          gap.breadthIntersection[1],
          otherCenterSnap.gap.breadthIntersection[0],
          otherCenterSnap.gap.breadthIntersection[1]
        );
        if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
          nearestSnapsX[nearestSnapsX.indexOf(otherCenterSnap)] = snap;
        } else if (!otherCenterSnap || !gapBreadthsOverlap) {
          nearestSnapsX.push(snap);
        }
      }
      const duplicationLeftX = gap.startNode.pageBounds.minX - gap.length;
      const selectionRightX = selectionPageBounds.maxX;
      const duplicationLeftNudge = duplicationLeftX - selectionRightX;
      if (round$1(Math.abs(duplicationLeftNudge)) <= round$1(minOffset.x)) {
        if (round$1(Math.abs(duplicationLeftNudge)) < round$1(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(duplicationLeftNudge);
        nearestSnapsX.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "left",
          nudge: duplicationLeftNudge
        });
      }
      const duplicationRightX = gap.endNode.pageBounds.maxX + gap.length;
      const selectionLeftX = selectionPageBounds.minX;
      const duplicationRightNudge = duplicationRightX - selectionLeftX;
      if (round$1(Math.abs(duplicationRightNudge)) <= round$1(minOffset.x)) {
        if (round$1(Math.abs(duplicationRightNudge)) < round$1(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(duplicationRightNudge);
        nearestSnapsX.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "right",
          nudge: duplicationRightNudge
        });
      }
    }
    for (const gap of vertical) {
      if (!rangesOverlap(
        gap.breadthIntersection[0],
        gap.breadthIntersection[1],
        selectionPageBounds.minX,
        selectionPageBounds.maxX
      )) {
        continue;
      }
      const gapMidY = gap.startEdge[0].y + gap.length / 2;
      const centerNudge = gapMidY - selectionPageBounds.center.y;
      const gapIsLargerThanSelection = gap.length > selectionPageBounds.height;
      if (gapIsLargerThanSelection && round$1(Math.abs(centerNudge)) <= round$1(minOffset.y)) {
        if (round$1(Math.abs(centerNudge)) < round$1(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(centerNudge);
        const snap = {
          type: "gap_center",
          gap,
          nudge: centerNudge
        };
        const otherCenterSnap = nearestSnapsY.find(({ type }) => type === "gap_center");
        const gapBreadthsOverlap = otherCenterSnap && rangesOverlap(
          otherCenterSnap.gap.breadthIntersection[0],
          otherCenterSnap.gap.breadthIntersection[1],
          gap.breadthIntersection[0],
          gap.breadthIntersection[1]
        );
        if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
          nearestSnapsY[nearestSnapsY.indexOf(otherCenterSnap)] = snap;
        } else if (!otherCenterSnap || !gapBreadthsOverlap) {
          nearestSnapsY.push(snap);
        }
        continue;
      }
      const duplicationTopY = gap.startNode.pageBounds.minY - gap.length;
      const selectionBottomY = selectionPageBounds.maxY;
      const duplicationTopNudge = duplicationTopY - selectionBottomY;
      if (round$1(Math.abs(duplicationTopNudge)) <= round$1(minOffset.y)) {
        if (round$1(Math.abs(duplicationTopNudge)) < round$1(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(duplicationTopNudge);
        nearestSnapsY.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "top",
          nudge: duplicationTopNudge
        });
      }
      const duplicationBottomY = gap.endNode.pageBounds.maxY + gap.length;
      const selectionTopY = selectionPageBounds.minY;
      const duplicationBottomNudge = duplicationBottomY - selectionTopY;
      if (round$1(Math.abs(duplicationBottomNudge)) <= round$1(minOffset.y)) {
        if (round$1(Math.abs(duplicationBottomNudge)) < round$1(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(duplicationBottomNudge);
        nearestSnapsY.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "bottom",
          nudge: duplicationBottomNudge
        });
      }
    }
  }
  getPointSnapLines({
    nearestSnapsX,
    nearestSnapsY
  }) {
    const snapGroupsX = {};
    const snapGroupsY = {};
    if (nearestSnapsX.length > 0) {
      for (const snap of nearestSnapsX) {
        if (snap.type === "points") {
          const key = round$1(snap.points.otherPoint.x);
          if (!snapGroupsX[key]) {
            snapGroupsX[key] = [];
          }
          snapGroupsX[key].push(snap.points);
        }
      }
    }
    if (nearestSnapsY.length > 0) {
      for (const snap of nearestSnapsY) {
        if (snap.type === "points") {
          const key = round$1(snap.points.otherPoint.y);
          if (!snapGroupsY[key]) {
            snapGroupsY[key] = [];
          }
          snapGroupsY[key].push(snap.points);
        }
      }
    }
    return Object.values(snapGroupsX).concat(Object.values(snapGroupsY)).map((snapGroup) => ({
      id: uniqueId(),
      type: "points",
      points: dedupe(
        snapGroup.map((snap) => Vec.From(snap.otherPoint)).concat(snapGroup.map((snap) => Vec.From(snap.thisPoint))),
        (a, b) => a.equals(b)
      )
    }));
  }
  getGapSnapLines({
    selectionPageBounds,
    nearestSnapsX,
    nearestSnapsY
  }) {
    const { vertical, horizontal } = this.getVisibleGaps();
    const selectionSides = {
      top: selectionPageBounds.sides[0],
      right: selectionPageBounds.sides[1],
      // need bottom and left to be sorted asc, which .sides is not.
      bottom: [selectionPageBounds.corners[3], selectionPageBounds.corners[2]],
      left: [selectionPageBounds.corners[0], selectionPageBounds.corners[3]]
    };
    const result = [];
    if (nearestSnapsX.length > 0) {
      for (const snap of nearestSnapsX) {
        if (snap.type === "points") continue;
        const {
          gap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge }
        } = snap;
        switch (snap.type) {
          case "gap_center": {
            const newGapsLength = (length - selectionPageBounds.width) / 2;
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minY,
              selectionPageBounds.maxY
            );
            result.push({
              type: "gaps",
              direction: "horizontal",
              id: uniqueId(),
              gaps: [
                ...findAdjacentGaps(
                  horizontal,
                  startNode.id,
                  newGapsLength,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge,
                  endEdge: selectionSides.left
                },
                {
                  startEdge: selectionSides.right,
                  endEdge
                },
                ...findAdjacentGaps(
                  horizontal,
                  endNode.id,
                  newGapsLength,
                  "forward",
                  gapBreadthIntersection
                )
              ]
            });
            break;
          }
          case "gap_duplicate": {
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minY,
              selectionPageBounds.maxY
            );
            result.push({
              type: "gaps",
              direction: "horizontal",
              id: uniqueId(),
              gaps: snap.protrusionDirection === "left" ? [
                {
                  startEdge: selectionSides.right,
                  endEdge: startEdge.map(
                    (v) => v.clone().addXY(-startNode.pageBounds.width, 0)
                  )
                },
                { startEdge, endEdge },
                ...findAdjacentGaps(
                  horizontal,
                  endNode.id,
                  length,
                  "forward",
                  gapBreadthIntersection
                )
              ] : [
                ...findAdjacentGaps(
                  horizontal,
                  startNode.id,
                  length,
                  "backward",
                  gapBreadthIntersection
                ),
                { startEdge, endEdge },
                {
                  startEdge: endEdge.map(
                    (v) => v.clone().addXY(snap.gap.endNode.pageBounds.width, 0)
                  ),
                  endEdge: selectionSides.left
                }
              ]
            });
            break;
          }
        }
      }
    }
    if (nearestSnapsY.length > 0) {
      for (const snap of nearestSnapsY) {
        if (snap.type === "points") continue;
        const {
          gap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge }
        } = snap;
        switch (snap.type) {
          case "gap_center": {
            const newGapsLength = (length - selectionPageBounds.height) / 2;
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minX,
              selectionPageBounds.maxX
            );
            result.push({
              type: "gaps",
              direction: "vertical",
              id: uniqueId(),
              gaps: [
                ...findAdjacentGaps(
                  vertical,
                  startNode.id,
                  newGapsLength,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge,
                  endEdge: selectionSides.top
                },
                {
                  startEdge: selectionSides.bottom,
                  endEdge
                },
                ...findAdjacentGaps(
                  vertical,
                  snap.gap.endNode.id,
                  newGapsLength,
                  "forward",
                  gapBreadthIntersection
                )
              ]
            });
            break;
          }
          case "gap_duplicate":
            {
              const gapBreadthIntersection = rangeIntersection(
                breadthIntersection[0],
                breadthIntersection[1],
                selectionPageBounds.minX,
                selectionPageBounds.maxX
              );
              result.push({
                type: "gaps",
                direction: "vertical",
                id: uniqueId(),
                gaps: snap.protrusionDirection === "top" ? [
                  {
                    startEdge: selectionSides.bottom,
                    endEdge: startEdge.map(
                      (v) => v.clone().addXY(0, -startNode.pageBounds.height)
                    )
                  },
                  { startEdge, endEdge },
                  ...findAdjacentGaps(
                    vertical,
                    endNode.id,
                    length,
                    "forward",
                    gapBreadthIntersection
                  )
                ] : [
                  ...findAdjacentGaps(
                    vertical,
                    startNode.id,
                    length,
                    "backward",
                    gapBreadthIntersection
                  ),
                  { startEdge, endEdge },
                  {
                    startEdge: endEdge.map(
                      (v) => v.clone().addXY(0, endNode.pageBounds.height)
                    ),
                    endEdge: selectionSides.top
                  }
                ]
              });
            }
            break;
        }
      }
    }
    dedupeGapSnaps(result);
    return result;
  }
}
_init$8 = __decoratorStart$8();
__decorateElement$8(_init$8, 1, "getSnapPointsCache", _getSnapPointsCache_dec, BoundsSnaps);
__decorateElement$8(_init$8, 1, "getSnappablePoints", _getSnappablePoints_dec, BoundsSnaps);
__decorateElement$8(_init$8, 1, "getSnappableGapNodes", _getSnappableGapNodes_dec, BoundsSnaps);
__decorateElement$8(_init$8, 1, "getVisibleGaps", _getVisibleGaps_dec, BoundsSnaps);
__decoratorMetadata$8(_init$8, BoundsSnaps);
function getResizeSnapPointsForHandle(handle, selectionPageBounds) {
  const { minX, maxX, minY, maxY } = selectionPageBounds;
  const result = [];
  switch (handle) {
    case "top":
    case "left":
    case "top_left":
    case "any":
      result.push({
        id: "top_left",
        handle: "top_left",
        x: minX,
        y: minY
      });
  }
  switch (handle) {
    case "top":
    case "right":
    case "top_right":
    case "any":
      result.push({
        id: "top_right",
        handle: "top_right",
        x: maxX,
        y: minY
      });
  }
  switch (handle) {
    case "bottom":
    case "right":
    case "bottom_right":
    case "any":
      result.push({
        id: "bottom_right",
        handle: "bottom_right",
        x: maxX,
        y: maxY
      });
  }
  switch (handle) {
    case "bottom":
    case "left":
    case "bottom_left":
    case "any":
      result.push({
        id: "bottom_left",
        handle: "bottom_left",
        x: minX,
        y: maxY
      });
  }
  return result;
}
var __create$7 = Object.create;
var __defProp$b = Object.defineProperty;
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
var __knownSymbol$7 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$7 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$7 = (base2) => [, , , __create$7(null)];
var __decoratorStrings$7 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$7 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$7("Function expected") : fn;
var __decoratorContext$7 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings$7[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError$7("Already initialized") : fns.push(__expectFn$7(fn || null)) });
var __decoratorMetadata$7 = (array2, target) => __defNormalProp$7(target, __knownSymbol$7("metadata"), array2[3]);
var __runInitializers$8 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$7 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings$7[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$7(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$7(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$7(it) && (desc[key] = it);
  }
  return desc && __defProp$b(target, name, desc), target;
};
var __publicField$7 = (obj, key, value) => __defNormalProp$7(obj, key + "", value);
var _getSnapGeometryCache_dec, _init$7;
const defaultGetSelfSnapOutline = () => null;
const defaultGetSelfSnapPoints = () => [];
_getSnapGeometryCache_dec = [computed];
class HandleSnaps {
  constructor(manager) {
    this.manager = manager;
    __runInitializers$8(_init$7, 5, this);
    __publicField$7(this, "editor");
    this.editor = manager.editor;
  }
  getSnapGeometryCache() {
    const { editor } = this;
    return editor.store.createComputedCache("handle snap geometry", (shape) => {
      const snapGeometry = editor.getShapeUtil(shape).getHandleSnapGeometry(shape);
      const getSelfSnapOutline = snapGeometry.getSelfSnapOutline ? snapGeometry.getSelfSnapOutline.bind(snapGeometry) : defaultGetSelfSnapOutline;
      const getSelfSnapPoints = snapGeometry.getSelfSnapPoints ? snapGeometry.getSelfSnapPoints.bind(snapGeometry) : defaultGetSelfSnapPoints;
      return {
        outline: snapGeometry.outline === void 0 ? editor.getShapeGeometry(shape) : snapGeometry.outline,
        points: snapGeometry.points ?? [],
        getSelfSnapOutline,
        getSelfSnapPoints
      };
    });
  }
  *iterateSnapPointsInPageSpace(currentShapeId, currentHandle) {
    const selfSnapPoints = this.getSnapGeometryCache().get(currentShapeId)?.getSelfSnapPoints(currentHandle);
    if (selfSnapPoints && selfSnapPoints.length) {
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(currentShapeId));
      for (const point of selfSnapPoints) {
        yield shapePageTransform.applyToPoint(point);
      }
    }
    for (const shapeId of this.manager.getSnappableShapes()) {
      if (shapeId === currentShapeId) continue;
      const snapPoints = this.getSnapGeometryCache().get(shapeId)?.points;
      if (!snapPoints || !snapPoints.length) continue;
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(shapeId));
      for (const point of snapPoints) {
        yield shapePageTransform.applyToPoint(point);
      }
    }
  }
  *iterateSnapOutlines(currentShapeId, currentHandle) {
    const selfSnapOutline = this.getSnapGeometryCache().get(currentShapeId)?.getSelfSnapOutline(currentHandle);
    if (selfSnapOutline) {
      yield { shapeId: currentShapeId, outline: selfSnapOutline };
    }
    for (const shapeId of this.manager.getSnappableShapes()) {
      if (shapeId === currentShapeId) continue;
      const snapOutline = this.getSnapGeometryCache().get(shapeId)?.outline;
      if (!snapOutline) continue;
      yield { shapeId, outline: snapOutline };
    }
  }
  getHandleSnapPosition({
    currentShapeId,
    handle,
    handleInPageSpace
  }) {
    const snapThreshold = this.manager.getSnapThreshold();
    let minDistanceForSnapPoint = snapThreshold;
    let nearestSnapPoint = null;
    for (const snapPoint of this.iterateSnapPointsInPageSpace(currentShapeId, handle)) {
      if (Vec.DistMin(handleInPageSpace, snapPoint, minDistanceForSnapPoint)) {
        minDistanceForSnapPoint = Vec.Dist(handleInPageSpace, snapPoint);
        nearestSnapPoint = snapPoint;
      }
    }
    if (nearestSnapPoint) return nearestSnapPoint;
    let minDistanceForOutline = snapThreshold;
    let nearestPointOnOutline = null;
    for (const { shapeId, outline } of this.iterateSnapOutlines(currentShapeId, handle)) {
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(shapeId));
      const pointInShapeSpace = this.editor.getPointInShapeSpace(shapeId, handleInPageSpace);
      const nearestShapePointInShapeSpace = outline.nearestPoint(pointInShapeSpace);
      const nearestInPageSpace = shapePageTransform.applyToPoint(nearestShapePointInShapeSpace);
      if (Vec.DistMin(handleInPageSpace, nearestInPageSpace, minDistanceForOutline)) {
        minDistanceForOutline = Vec.Dist(handleInPageSpace, nearestInPageSpace);
        nearestPointOnOutline = nearestInPageSpace;
      }
    }
    if (nearestPointOnOutline) return nearestPointOnOutline;
    return null;
  }
  getHandleSnapData({
    handle,
    currentShapeId
  }) {
    const snapThreshold = this.manager.getSnapThreshold();
    const currentShapeTransform = assertExists(this.editor.getShapePageTransform(currentShapeId));
    const handleInPageSpace = currentShapeTransform.applyToPoint(handle);
    let nearestXSnap = null;
    let nearestYSnap = null;
    let minOffsetX = snapThreshold;
    let minOffsetY = snapThreshold;
    for (const snapPoint of this.iterateSnapPointsInPageSpace(currentShapeId, handle)) {
      const offsetX = Math.abs(handleInPageSpace.x - snapPoint.x);
      const offsetY = Math.abs(handleInPageSpace.y - snapPoint.y);
      if (offsetX < minOffsetX) {
        minOffsetX = offsetX;
        nearestXSnap = snapPoint;
      }
      if (offsetY < minOffsetY) {
        minOffsetY = offsetY;
        nearestYSnap = snapPoint;
      }
    }
    if (!nearestXSnap && !nearestYSnap) {
      return null;
    }
    const nudge = new Vec(
      nearestXSnap ? nearestXSnap.x - handleInPageSpace.x : 0,
      nearestYSnap ? nearestYSnap.y - handleInPageSpace.y : 0
    );
    const snappedHandle = Vec.Add(handleInPageSpace, nudge);
    const snaps = [];
    if (nearestXSnap) {
      const snappedHandleOnX = new Vec(nearestXSnap.x, snappedHandle.y);
      snaps.push({
        id: uniqueId(),
        type: "points",
        points: [nearestXSnap, snappedHandleOnX]
      });
    }
    if (nearestYSnap) {
      const snappedHandleOnY = new Vec(snappedHandle.x, nearestYSnap.y);
      snaps.push({
        id: uniqueId(),
        type: "points",
        points: [nearestYSnap, snappedHandleOnY]
      });
    }
    return { snaps, nudge };
  }
  snapHandle({
    currentShapeId,
    handle
  }) {
    const currentShapeTransform = assertExists(this.editor.getShapePageTransform(currentShapeId));
    const handleInPageSpace = currentShapeTransform.applyToPoint(handle);
    const snapType = handle.canSnap ? "point" : handle.snapType;
    if (snapType === "point") {
      const snapPosition = this.getHandleSnapPosition({ currentShapeId, handle, handleInPageSpace });
      if (!snapPosition) {
        return null;
      }
      this.manager.setIndicators([
        {
          id: uniqueId(),
          type: "points",
          points: [snapPosition]
        }
      ]);
      return { nudge: Vec.Sub(snapPosition, handleInPageSpace) };
    }
    if (snapType === "align") {
      const snapData = this.getHandleSnapData({
        handle,
        currentShapeId
      });
      if (!snapData) {
        return null;
      }
      this.manager.setIndicators(snapData.snaps);
      return { nudge: snapData.nudge };
    }
    return null;
  }
}
_init$7 = __decoratorStart$7();
__decorateElement$7(_init$7, 1, "getSnapGeometryCache", _getSnapGeometryCache_dec, HandleSnaps);
__decoratorMetadata$7(_init$7, HandleSnaps);
var __create$6 = Object.create;
var __defProp$a = Object.defineProperty;
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __knownSymbol$6 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$6 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$6 = (base2) => [, , , __create$6(null)];
var __decoratorStrings$6 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$6 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$6("Function expected") : fn;
var __decoratorContext$6 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings$6[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError$6("Already initialized") : fns.push(__expectFn$6(fn || null)) });
var __decoratorMetadata$6 = (array2, target) => __defNormalProp$6(target, __knownSymbol$6("metadata"), array2[3]);
var __runInitializers$7 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$6 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings$6[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$6(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$6(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$6(it) && (desc[key] = it);
  }
  return desc && __defProp$a(target, name, desc), target;
};
var __publicField$6 = (obj, key, value) => __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
var _getCurrentCommonAncestor_dec, _getSnappableShapes_dec, _getSnapThreshold_dec, _init$6;
_getSnapThreshold_dec = [computed], _getSnappableShapes_dec = [computed], _getCurrentCommonAncestor_dec = [computed];
class SnapManager {
  constructor(editor) {
    this.editor = editor;
    __runInitializers$7(_init$6, 5, this);
    __publicField$6(this, "shapeBounds");
    __publicField$6(this, "handles");
    __publicField$6(this, "_snapIndicators", atom("snapLines", void 0));
    this.shapeBounds = new BoundsSnaps(this);
    this.handles = new HandleSnaps(this);
  }
  getIndicators() {
    return this._snapIndicators.get() ?? EMPTY_ARRAY;
  }
  clearIndicators() {
    if (this.getIndicators().length) {
      this._snapIndicators.set(void 0);
    }
  }
  setIndicators(indicators) {
    this._snapIndicators.set(indicators);
  }
  getSnapThreshold() {
    return 8 / this.editor.getZoomLevel();
  }
  getSnappableShapes() {
    const { editor } = this;
    const renderingBounds = editor.getViewportPageBounds();
    const selectedShapeIds = editor.getSelectedShapeIds();
    const snappableShapes = /* @__PURE__ */ new Set();
    const collectSnappableShapesFromParent = (parentId) => {
      if (isShapeId(parentId)) {
        const parent = editor.getShape(parentId);
        if (parent && editor.isShapeOfType(parent, "frame")) {
          snappableShapes.add(parentId);
        }
      }
      const sortedChildIds = editor.getSortedChildIdsForParent(parentId);
      for (const childId of sortedChildIds) {
        if (selectedShapeIds.includes(childId)) continue;
        const childShape = editor.getShape(childId);
        if (!childShape) continue;
        const util = editor.getShapeUtil(childShape);
        if (!util.canSnap(childShape)) continue;
        const pageBounds = editor.getShapePageBounds(childId);
        if (!(pageBounds && renderingBounds.includes(pageBounds))) continue;
        if (editor.isShapeOfType(childShape, "group")) {
          collectSnappableShapesFromParent(childId);
          continue;
        }
        snappableShapes.add(childId);
      }
    };
    collectSnappableShapesFromParent(this.getCurrentCommonAncestor() ?? editor.getCurrentPageId());
    return snappableShapes;
  }
  getCurrentCommonAncestor() {
    return this.editor.findCommonAncestor(this.editor.getSelectedShapes());
  }
}
_init$6 = __decoratorStart$6();
__decorateElement$6(_init$6, 1, "getSnapThreshold", _getSnapThreshold_dec, SnapManager);
__decorateElement$6(_init$6, 1, "getSnappableShapes", _getSnappableShapes_dec, SnapManager);
__decorateElement$6(_init$6, 1, "getCurrentCommonAncestor", _getCurrentCommonAncestor_dec, SnapManager);
__decoratorMetadata$6(_init$6, SnapManager);
const fixNewLines = /\r?\n|\r/g;
function normalizeTextForDom(text) {
  return text.replace(fixNewLines, "\n").split("\n").map((x) => x || " ").join("\n");
}
const textAlignmentsForLtr = {
  start: "left",
  "start-legacy": "left",
  middle: "center",
  "middle-legacy": "center",
  end: "right",
  "end-legacy": "right"
};
const spaceCharacterRegex = /\s/;
const initialDefaultStyles = Object.freeze({
  "overflow-wrap": "break-word",
  "word-break": "auto",
  width: null,
  height: null,
  "max-width": null,
  "min-width": null
});
class TextManager {
  constructor(editor) {
    this.editor = editor;
    const elm = document.createElement("div");
    elm.classList.add("tl-text");
    elm.classList.add("tl-text-measure");
    elm.setAttribute("dir", "auto");
    elm.tabIndex = -1;
    this.editor.getContainer().appendChild(elm);
    this.elm = elm;
    for (const key of objectMapKeys(initialDefaultStyles)) {
      elm.style.setProperty(key, initialDefaultStyles[key]);
    }
  }
  elm;
  setElementStyles(styles) {
    const stylesToReinstate = {};
    for (const key of objectMapKeys(styles)) {
      if (typeof styles[key] === "string") {
        const oldValue = this.elm.style.getPropertyValue(key);
        if (oldValue === styles[key]) continue;
        stylesToReinstate[key] = oldValue;
        this.elm.style.setProperty(key, styles[key]);
      }
    }
    return () => {
      for (const key of objectMapKeys(stylesToReinstate)) {
        this.elm.style.setProperty(key, stylesToReinstate[key]);
      }
    };
  }
  dispose() {
    return this.elm.remove();
  }
  measureText(textToMeasure, opts) {
    const div = document.createElement("div");
    div.textContent = normalizeTextForDom(textToMeasure);
    return this.measureHtml(div.innerHTML, opts);
  }
  measureHtml(html2, opts) {
    const { elm } = this;
    const newStyles = {
      "font-family": opts.fontFamily,
      "font-style": opts.fontStyle,
      "font-weight": opts.fontWeight,
      "font-size": opts.fontSize + "px",
      "line-height": opts.lineHeight.toString(),
      padding: opts.padding,
      "max-width": opts.maxWidth ? opts.maxWidth + "px" : void 0,
      "min-width": opts.minWidth ? opts.minWidth + "px" : void 0,
      "overflow-wrap": opts.disableOverflowWrapBreaking ? "normal" : void 0,
      ...opts.otherStyles
    };
    const restoreStyles = this.setElementStyles(newStyles);
    try {
      elm.innerHTML = html2;
      const scrollWidth = opts.measureScrollWidth ? elm.scrollWidth : 0;
      const rect = elm.getBoundingClientRect();
      return {
        x: 0,
        y: 0,
        w: rect.width,
        h: rect.height,
        scrollWidth
      };
    } finally {
      restoreStyles();
    }
  }
  /**
   * Given an html element, measure the position of each span of unbroken
   * word/white-space characters within any text nodes it contains.
   */
  measureElementTextNodeSpans(element, { shouldTruncateToFirstLine = false } = {}) {
    const spans = [];
    const elmBounds = element.getBoundingClientRect();
    const offsetX = -elmBounds.left;
    const offsetY = -elmBounds.top;
    const range = new Range();
    const textNode = element.childNodes[0];
    let idx = 0;
    let currentSpan = null;
    let prevCharWasSpaceCharacter = null;
    let prevCharTop = 0;
    let prevCharLeftForRTLTest = 0;
    let didTruncate = false;
    for (const childNode of element.childNodes) {
      if (childNode.nodeType !== Node.TEXT_NODE) continue;
      for (const char of childNode.textContent ?? "") {
        range.setStart(textNode, idx);
        range.setEnd(textNode, idx + char.length);
        const rects = range.getClientRects();
        const rect = rects[rects.length - 1];
        const top = rect.top + offsetY;
        const left = rect.left + offsetX;
        const right = rect.right + offsetX;
        const isRTL2 = left < prevCharLeftForRTLTest;
        const isSpaceCharacter = spaceCharacterRegex.test(char);
        if (
          // If we're at a word boundary...
          isSpaceCharacter !== prevCharWasSpaceCharacter || // ...or we're on a different line...
          top !== prevCharTop || // ...or we're at the start of the text and haven't created a span yet...
          !currentSpan
        ) {
          if (currentSpan) {
            if (shouldTruncateToFirstLine && top !== prevCharTop) {
              didTruncate = true;
              break;
            }
            spans.push(currentSpan);
          }
          currentSpan = {
            box: { x: left, y: top, w: rect.width, h: rect.height },
            text: char
          };
          prevCharLeftForRTLTest = left;
        } else {
          if (isRTL2) {
            currentSpan.box.x = left;
          }
          currentSpan.box.w = isRTL2 ? currentSpan.box.w + rect.width : right - currentSpan.box.x;
          currentSpan.text += char;
        }
        if (char === "\n") {
          prevCharLeftForRTLTest = 0;
        }
        prevCharWasSpaceCharacter = isSpaceCharacter;
        prevCharTop = top;
        idx += char.length;
      }
    }
    if (currentSpan) {
      spans.push(currentSpan);
    }
    return { spans, didTruncate };
  }
  /**
   * Measure text into individual spans. Spans are created by rendering the
   * text, then dividing it up according to line breaks and word boundaries.
   *
   * It works by having the browser render the text, then measuring the
   * position of each character. You can use this to replicate the text-layout
   * algorithm of the current browser in e.g. an SVG export.
   */
  measureTextSpans(textToMeasure, opts) {
    if (textToMeasure === "") return [];
    const { elm } = this;
    const shouldTruncateToFirstLine = opts.overflow === "truncate-ellipsis" || opts.overflow === "truncate-clip";
    const elementWidth = Math.ceil(opts.width - opts.padding * 2);
    const newStyles = {
      "font-family": opts.fontFamily,
      "font-style": opts.fontStyle,
      "font-weight": opts.fontWeight,
      "font-size": opts.fontSize + "px",
      "line-height": opts.lineHeight.toString(),
      width: `${elementWidth}px`,
      height: "min-content",
      "text-align": textAlignmentsForLtr[opts.textAlign],
      "overflow-wrap": shouldTruncateToFirstLine ? "anywhere" : void 0,
      "word-break": shouldTruncateToFirstLine ? "break-all" : void 0,
      ...opts.otherStyles
    };
    const restoreStyles = this.setElementStyles(newStyles);
    try {
      const normalizedText = normalizeTextForDom(textToMeasure);
      elm.textContent = normalizedText;
      const { spans, didTruncate } = this.measureElementTextNodeSpans(elm, {
        shouldTruncateToFirstLine
      });
      if (opts.overflow === "truncate-ellipsis" && didTruncate) {
        elm.textContent = "";
        const ellipsisWidth = Math.ceil(this.measureElementTextNodeSpans(elm).spans[0].box.w);
        elm.style.setProperty("width", `${elementWidth - ellipsisWidth}px`);
        elm.textContent = normalizedText;
        const truncatedSpans = this.measureElementTextNodeSpans(elm, {
          shouldTruncateToFirstLine: true
        }).spans;
        const lastSpan = truncatedSpans[truncatedSpans.length - 1];
        truncatedSpans.push({
          text: "",
          box: {
            x: Math.min(lastSpan.box.x + lastSpan.box.w, opts.width - opts.padding - ellipsisWidth),
            y: lastSpan.box.y,
            w: ellipsisWidth,
            h: lastSpan.box.h
          }
        });
        return truncatedSpans;
      }
      return spans;
    } finally {
      restoreStyles();
    }
  }
}
var __create$5 = Object.create;
var __defProp$9 = Object.defineProperty;
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __knownSymbol$5 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$5 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$5 = (base2) => [, , , __create$5(null)];
var __decoratorStrings$5 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$5 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$5("Function expected") : fn;
var __decoratorContext$5 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings$5[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError$5("Already initialized") : fns.push(__expectFn$5(fn || null)) });
var __decoratorMetadata$5 = (array2, target) => __defNormalProp$5(target, __knownSymbol$5("metadata"), array2[3]);
var __runInitializers$6 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$5 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings$5[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$5(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$5(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$5(it) && (desc[key] = it);
  }
  return desc && __defProp$9(target, name, desc), target;
};
var __publicField$5 = (obj, key, value) => __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
var _dispose_dec$1, _tick_dec, _init$5;
const throttleToNextFrame = throttleToNextFrame$1;
_tick_dec = [bind$1], _dispose_dec$1 = [bind$1];
class TickManager {
  constructor(editor) {
    this.editor = editor;
    __runInitializers$6(_init$5, 5, this);
    __publicField$5(this, "cancelRaf");
    __publicField$5(this, "isPaused", true);
    __publicField$5(this, "now", 0);
    __publicField$5(this, "prevPoint", new Vec());
    this.editor.disposables.add(this.dispose);
    this.start();
  }
  start() {
    this.isPaused = false;
    this.cancelRaf?.();
    this.cancelRaf = throttleToNextFrame(this.tick);
    this.now = Date.now();
  }
  tick() {
    if (this.isPaused) {
      return;
    }
    const now = Date.now();
    const elapsed = now - this.now;
    this.now = now;
    this.updatePointerVelocity(elapsed);
    this.editor.emit("frame", elapsed);
    this.editor.emit("tick", elapsed);
    this.cancelRaf = throttleToNextFrame(this.tick);
  }
  dispose() {
    this.isPaused = true;
    this.cancelRaf?.();
  }
  updatePointerVelocity(elapsed) {
    const {
      prevPoint,
      editor: {
        inputs: { currentScreenPoint, pointerVelocity }
      }
    } = this;
    if (elapsed === 0) return;
    const delta = Vec.Sub(currentScreenPoint, prevPoint);
    this.prevPoint = currentScreenPoint.clone();
    const length = delta.len();
    const direction = length ? delta.div(length) : new Vec(0, 0);
    const next = pointerVelocity.clone().lrp(direction.mul(length / elapsed), 0.5);
    if (Math.abs(next.x) < 0.01) next.x = 0;
    if (Math.abs(next.y) < 0.01) next.y = 0;
    if (!pointerVelocity.equals(next)) {
      this.editor.inputs.pointerVelocity = next;
    }
  }
}
_init$5 = __decoratorStart$5();
__decorateElement$5(_init$5, 1, "tick", _tick_dec, TickManager);
__decorateElement$5(_init$5, 1, "dispose", _dispose_dec$1, TickManager);
__decoratorMetadata$5(_init$5, TickManager);
var __create$4 = Object.create;
var __defProp$8 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __knownSymbol$4 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$4 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$4 = (base2) => [, , , __create$4(null)];
var __decoratorStrings$4 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$4 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$4("Function expected") : fn;
var __decoratorContext$4 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings$4[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError$4("Already initialized") : fns.push(__expectFn$4(fn || null)) });
var __decoratorMetadata$4 = (array2, target) => __defNormalProp$4(target, __knownSymbol$4("metadata"), array2[3]);
var __runInitializers$5 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$4 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings$4[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$4(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$4(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$4(it) && (desc[key] = it);
  }
  return desc && __defProp$8(target, name, desc), target;
};
var __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
var _getInputMode_dec, _getEnhancedA11yMode_dec, _getIsPasteAtCursorMode_dec, _getIsDynamicResizeMode_dec, _getIsWrapMode_dec, _getIsSnapMode_dec, _getColor_dec, _getLocale_dec, _getName_dec, _getId_dec, _getAreKeyboardShortcutsEnabled_dec, _getAnimationSpeed_dec, _getEdgeScrollSpeed_dec, _getIsDarkMode_dec, _getUserPreferences_dec, _init$4;
_getUserPreferences_dec = [computed], _getIsDarkMode_dec = [computed], _getEdgeScrollSpeed_dec = [computed], _getAnimationSpeed_dec = [computed], _getAreKeyboardShortcutsEnabled_dec = [computed], _getId_dec = [computed], _getName_dec = [computed], _getLocale_dec = [computed], _getColor_dec = [computed], _getIsSnapMode_dec = [computed], _getIsWrapMode_dec = [computed], _getIsDynamicResizeMode_dec = [computed], _getIsPasteAtCursorMode_dec = [computed], _getEnhancedA11yMode_dec = [computed], _getInputMode_dec = [computed];
class UserPreferencesManager {
  constructor(user, inferDarkMode) {
    this.user = user;
    this.inferDarkMode = inferDarkMode;
    __runInitializers$5(_init$4, 5, this);
    __publicField$4(this, "systemColorScheme", atom("systemColorScheme", "light"));
    __publicField$4(this, "disposables", /* @__PURE__ */ new Set());
    if (typeof window === "undefined" || !window.matchMedia) return;
    const darkModeMediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    if (darkModeMediaQuery?.matches) {
      this.systemColorScheme.set("dark");
    }
    const handleChange = (e) => {
      if (e.matches) {
        this.systemColorScheme.set("dark");
      } else {
        this.systemColorScheme.set("light");
      }
    };
    darkModeMediaQuery?.addEventListener("change", handleChange);
    this.disposables.add(() => darkModeMediaQuery?.removeEventListener("change", handleChange));
  }
  dispose() {
    this.disposables.forEach((d) => d());
  }
  updateUserPreferences(userPreferences) {
    this.user.setUserPreferences({
      ...this.user.userPreferences.get(),
      ...userPreferences
    });
  }
  getUserPreferences() {
    return {
      id: this.getId(),
      name: this.getName(),
      locale: this.getLocale(),
      color: this.getColor(),
      animationSpeed: this.getAnimationSpeed(),
      areKeyboardShortcutsEnabled: this.getAreKeyboardShortcutsEnabled(),
      isSnapMode: this.getIsSnapMode(),
      colorScheme: this.user.userPreferences.get().colorScheme,
      isDarkMode: this.getIsDarkMode(),
      isWrapMode: this.getIsWrapMode(),
      isDynamicResizeMode: this.getIsDynamicResizeMode(),
      enhancedA11yMode: this.getEnhancedA11yMode(),
      inputMode: this.getInputMode()
    };
  }
  getIsDarkMode() {
    switch (this.user.userPreferences.get().colorScheme) {
      case "dark":
        return true;
      case "light":
        return false;
      case "system":
        return this.systemColorScheme.get() === "dark";
      default:
        return this.inferDarkMode ? this.systemColorScheme.get() === "dark" : false;
    }
  }
  getEdgeScrollSpeed() {
    return this.user.userPreferences.get().edgeScrollSpeed ?? defaultUserPreferences.edgeScrollSpeed;
  }
  getAnimationSpeed() {
    return this.user.userPreferences.get().animationSpeed ?? defaultUserPreferences.animationSpeed;
  }
  getAreKeyboardShortcutsEnabled() {
    return this.user.userPreferences.get().areKeyboardShortcutsEnabled ?? defaultUserPreferences.areKeyboardShortcutsEnabled;
  }
  getId() {
    return this.user.userPreferences.get().id;
  }
  getName() {
    return this.user.userPreferences.get().name?.trim() ?? defaultUserPreferences.name;
  }
  getLocale() {
    return this.user.userPreferences.get().locale ?? defaultUserPreferences.locale;
  }
  getColor() {
    return this.user.userPreferences.get().color ?? defaultUserPreferences.color;
  }
  getIsSnapMode() {
    return this.user.userPreferences.get().isSnapMode ?? defaultUserPreferences.isSnapMode;
  }
  getIsWrapMode() {
    return this.user.userPreferences.get().isWrapMode ?? defaultUserPreferences.isWrapMode;
  }
  getIsDynamicResizeMode() {
    return this.user.userPreferences.get().isDynamicSizeMode ?? defaultUserPreferences.isDynamicSizeMode;
  }
  getIsPasteAtCursorMode() {
    return this.user.userPreferences.get().isPasteAtCursorMode ?? defaultUserPreferences.isPasteAtCursorMode;
  }
  getEnhancedA11yMode() {
    return this.user.userPreferences.get().enhancedA11yMode ?? defaultUserPreferences.enhancedA11yMode;
  }
  getInputMode() {
    return this.user.userPreferences.get().inputMode ?? defaultUserPreferences.inputMode;
  }
}
_init$4 = __decoratorStart$4();
__decorateElement$4(_init$4, 1, "getUserPreferences", _getUserPreferences_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getIsDarkMode", _getIsDarkMode_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getEdgeScrollSpeed", _getEdgeScrollSpeed_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getAnimationSpeed", _getAnimationSpeed_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getAreKeyboardShortcutsEnabled", _getAreKeyboardShortcutsEnabled_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getId", _getId_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getName", _getName_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getLocale", _getLocale_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getColor", _getColor_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getIsSnapMode", _getIsSnapMode_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getIsWrapMode", _getIsWrapMode_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getIsDynamicResizeMode", _getIsDynamicResizeMode_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getIsPasteAtCursorMode", _getIsPasteAtCursorMode_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getEnhancedA11yMode", _getEnhancedA11yMode_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getInputMode", _getInputMode_dec, UserPreferencesManager);
__decoratorMetadata$4(_init$4, UserPreferencesManager);
const EVENT_NAME_MAP = {
  wheel: "onWheel",
  pointer_down: "onPointerDown",
  pointer_move: "onPointerMove",
  long_press: "onLongPress",
  pointer_up: "onPointerUp",
  right_click: "onRightClick",
  middle_click: "onMiddleClick",
  key_down: "onKeyDown",
  key_up: "onKeyUp",
  key_repeat: "onKeyRepeat",
  cancel: "onCancel",
  complete: "onComplete",
  interrupt: "onInterrupt",
  double_click: "onDoubleClick",
  triple_click: "onTripleClick",
  quadruple_click: "onQuadrupleClick",
  tick: "onTick"
};
const STATE_NODES_TO_MEASURE = [
  "brushing",
  "cropping",
  "dragging",
  "dragging_handle",
  "drawing",
  "erasing",
  "lasering",
  "resizing",
  "rotating",
  "scribble_brushing",
  "translating"
];
class StateNode {
  constructor(editor, parent) {
    this.editor = editor;
    const { id, children, initial, isLockable, useCoalescedEvents } = this.constructor;
    this.id = id;
    this._isActive = atom("toolIsActive" + this.id, false);
    this._current = atom("toolState" + this.id, void 0);
    this._path = computed("toolPath" + this.id, () => {
      const current = this.getCurrent();
      return this.id + (current ? `.${current.getPath()}` : "");
    });
    this.parent = parent ?? {};
    if (parent) {
      if (children && initial) {
        this.type = "branch";
        this.initial = initial;
        this.children = Object.fromEntries(
          children().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])
        );
        this._current.set(this.children[this.initial]);
      } else {
        this.type = "leaf";
      }
    } else {
      this.type = "root";
      if (children && initial) {
        this.initial = initial;
        this.children = Object.fromEntries(
          children().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])
        );
        this._current.set(this.children[this.initial]);
      }
    }
    this.isLockable = isLockable;
    this.useCoalescedEvents = useCoalescedEvents;
    this.performanceTracker = new PerformanceTracker();
  }
  performanceTracker;
  static id;
  static initial;
  static children;
  static isLockable = true;
  static useCoalescedEvents = false;
  id;
  type;
  shapeType;
  initial;
  children;
  isLockable;
  useCoalescedEvents;
  parent;
  /**
   * This node's path of active state nodes
   *
   * @public
   */
  getPath() {
    return this._path.get();
  }
  _path;
  /**
   * This node's current active child node, if any.
   *
   * @public
   */
  getCurrent() {
    return this._current.get();
  }
  _current;
  /**
   * Whether this node is active.
   *
   * @public
   */
  getIsActive() {
    return this._isActive.get();
  }
  _isActive;
  /**
   * Transition to a new active child state node.
   *
   * @example
   * ```ts
   * parentState.transition('childStateA')
   * parentState.transition('childStateB', { myData: 4 })
   *```
   *
   * @param id - The id of the child state node to transition to.
   * @param info - Any data to pass to the `onEnter` and `onExit` handlers.
   *
   * @public
   */
  transition(id, info = {}) {
    const path = id.split(".");
    let currState = this;
    for (let i = 0; i < path.length; i++) {
      const id2 = path[i];
      const prevChildState = currState.getCurrent();
      const nextChildState = currState.children?.[id2];
      if (!nextChildState) {
        throw Error(`${currState.id} - no child state exists with the id ${id2}.`);
      }
      if (prevChildState?.id !== nextChildState.id) {
        prevChildState?.exit(info, id2);
        currState._current.set(nextChildState);
        nextChildState.enter(info, prevChildState?.id || "initial");
        if (!nextChildState.getIsActive()) break;
      }
      currState = nextChildState;
    }
    return this;
  }
  handleEvent(info) {
    const cbName = EVENT_NAME_MAP[info.name];
    const currentActiveChild = this._current.__unsafe__getWithoutCapture();
    this[cbName]?.(info);
    if (this._isActive.__unsafe__getWithoutCapture() && currentActiveChild && currentActiveChild === this._current.__unsafe__getWithoutCapture()) {
      currentActiveChild.handleEvent(info);
    }
  }
  // todo: move this logic into transition
  enter(info, from2) {
    if (debugFlags.measurePerformance.get() && STATE_NODES_TO_MEASURE.includes(this.id)) {
      this.performanceTracker.start(this.id);
    }
    this._isActive.set(true);
    this.onEnter?.(info, from2);
    if (this.children && this.initial && this.getIsActive()) {
      const initial = this.children[this.initial];
      this._current.set(initial);
      initial.enter(info, from2);
    }
  }
  // todo: move this logic into transition
  exit(info, to) {
    if (debugFlags.measurePerformance.get() && this.performanceTracker.isStarted()) {
      this.performanceTracker.stop();
    }
    this._isActive.set(false);
    this.onExit?.(info, to);
    if (!this.getIsActive()) {
      this.getCurrent()?.exit(info, to);
    }
  }
  /**
   * This is a hack / escape hatch that will tell the editor to
   * report a different state as active (in `getCurrentToolId()`) when
   * this state is active. This is usually used when a tool transitions
   * to a child of a different state for a certain interaction and then
   * returns to the original tool when that interaction completes; and
   * where we would want to show the original tool as active in the UI.
   *
   * @public
   */
  _currentToolIdMask = atom("curent tool id mask", void 0);
  getCurrentToolIdMask() {
    return this._currentToolIdMask.get();
  }
  setCurrentToolIdMask(id) {
    this._currentToolIdMask.set(id);
  }
  /**
   * Add a child node to this state node.
   *
   * @public
   */
  addChild(childConstructor) {
    if (this.type === "leaf") {
      throw new Error("StateNode.addChild: cannot add child to a leaf node");
    }
    if (!this.children) {
      this.children = {};
    }
    const child = new childConstructor(this.editor, this);
    if (this.children[child.id]) {
      throw new Error(`StateNode.addChild: a child with id '${child.id}' already exists`);
    }
    this.children[child.id] = child;
    return this;
  }
}
class RootState extends StateNode {
  static id = "root";
  static initial = "";
  static children() {
    return [];
  }
  onKeyDown(info) {
    switch (info.code) {
      case "KeyZ": {
        if (!(info.shiftKey || info.ctrlKey)) {
          const currentTool = this.getCurrent();
          if (currentTool && currentTool.getCurrent()?.id === "idle" && this.children["zoom"]) {
            this.editor.setCurrentTool("zoom", { ...info, onInteractionEnd: currentTool.id });
          }
        }
        break;
      }
    }
  }
}
var __create$3 = Object.create;
var __defProp$7 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __knownSymbol$3 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$3 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$3 = (base2) => [, , , __create$3(base2?.[__knownSymbol$3("metadata")] ?? null)];
var __decoratorStrings$3 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$3 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$3("Function expected") : fn;
var __decoratorContext$3 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings$3[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError$3("Already initialized") : fns.push(__expectFn$3(fn || null)) });
var __decoratorMetadata$3 = (array2, target) => __defNormalProp$3(target, __knownSymbol$3("metadata"), array2[3]);
var __runInitializers$4 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$3 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings$3[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$3(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$3(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$3(it) && (desc[key] = it);
  }
  return desc && __defProp$7(target, name, desc), target;
};
var __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
var __setMetaKeyTimeout_dec, __setCtrlKeyTimeout_dec, __setAltKeyTimeout_dec, __setShiftKeyTimeout_dec, _getIsReadonly_dec, _getIsFocused_dec, _getSharedOpacity_dec, _getSharedStyles_dec, __getSelectionSharedStyles_dec, __getBindingsIndexCache_dec, _getCurrentPageRenderingShapesSorted_dec, _getCurrentPageShapesSorted_dec, _getCurrentPageShapes_dec, _getCurrentPageBounds_dec, _getCulledShapes_dec, _getNotVisibleShapes_dec, __getShapeMaskedPageBoundsCache_dec, __getShapeMaskCache_dec, __getShapeClipPathCache_dec, __getShapePageBoundsCache_dec, __getShapePageTransformCache_dec, __getShapeHandlesCache_dec, __getAllAssetsQuery_dec, _getCurrentPageShapeIdsSorted_dec, _getCurrentPageId_dec, _getPages_dec, __getAllPagesQuery_dec, _getRenderingShapes_dec, _getCollaboratorsOnCurrentPage_dec, _getCollaborators_dec, __getCollaboratorsQuery_dec, _getViewportPageBounds_dec, _getViewportScreenCenter_dec, _getViewportScreenBounds_dec, _getZoomLevel_dec, _getCameraForFollowing_dec, _getViewportPageBoundsForFollowing_dec, _getCamera_dec, __unsafe_getCameraId_dec, _getErasingShapes_dec, _getErasingShapeIds_dec, _getHintingShape_dec, _getHintingShapeIds_dec, _getHoveredShape_dec, _getHoveredShapeId_dec, _getRichTextEditor_dec, _getEditingShape_dec, _getEditingShapeId_dec, _getFocusedGroup_dec, _getFocusedGroupId_dec, _getSelectionRotatedScreenBounds_dec, _getSelectionRotatedPageBounds_dec, _getSelectionRotation_dec, _getSelectionPageBounds_dec, _getOnlySelectedShape_dec, _getOnlySelectedShapeId_dec, _getCurrentPageShapesInReadingOrder_dec, _getSelectedShapes_dec, _getSelectedShapeIds_dec, __getCurrentPageStateId_dec, _getCurrentPageState_dec, __getPageStatesQuery_dec, _getPageStates_dec, _getInstanceState_dec, _getDocumentSettings_dec, _getCurrentToolId_dec, _getCurrentTool_dec, _getPath_dec, _getCanRedo_dec, _getCanUndo_dec, _getIsShapeHiddenCache_dec, _a$1, _init$3;
let Editor$1 = class Editor extends (_a$1 = EventEmitter$1, _getIsShapeHiddenCache_dec = [computed], _getCanUndo_dec = [computed], _getCanRedo_dec = [computed], _getPath_dec = [computed], _getCurrentTool_dec = [computed], _getCurrentToolId_dec = [computed], _getDocumentSettings_dec = [computed], _getInstanceState_dec = [computed], _getPageStates_dec = [computed], __getPageStatesQuery_dec = [computed], _getCurrentPageState_dec = [computed], __getCurrentPageStateId_dec = [computed], _getSelectedShapeIds_dec = [computed], _getSelectedShapes_dec = [computed], _getCurrentPageShapesInReadingOrder_dec = [computed], _getOnlySelectedShapeId_dec = [computed], _getOnlySelectedShape_dec = [computed], _getSelectionPageBounds_dec = [computed], _getSelectionRotation_dec = [computed], _getSelectionRotatedPageBounds_dec = [computed], _getSelectionRotatedScreenBounds_dec = [computed], _getFocusedGroupId_dec = [computed], _getFocusedGroup_dec = [computed], _getEditingShapeId_dec = [computed], _getEditingShape_dec = [computed], _getRichTextEditor_dec = [computed], _getHoveredShapeId_dec = [computed], _getHoveredShape_dec = [computed], _getHintingShapeIds_dec = [computed], _getHintingShape_dec = [computed], _getErasingShapeIds_dec = [computed], _getErasingShapes_dec = [computed], __unsafe_getCameraId_dec = [computed], _getCamera_dec = [computed], _getViewportPageBoundsForFollowing_dec = [computed], _getCameraForFollowing_dec = [computed], _getZoomLevel_dec = [computed], _getViewportScreenBounds_dec = [computed], _getViewportScreenCenter_dec = [computed], _getViewportPageBounds_dec = [computed], __getCollaboratorsQuery_dec = [computed], _getCollaborators_dec = [computed], _getCollaboratorsOnCurrentPage_dec = [computed], _getRenderingShapes_dec = [computed], __getAllPagesQuery_dec = [computed], _getPages_dec = [computed], _getCurrentPageId_dec = [computed], _getCurrentPageShapeIdsSorted_dec = [computed], __getAllAssetsQuery_dec = [computed], __getShapeHandlesCache_dec = [computed], __getShapePageTransformCache_dec = [computed], __getShapePageBoundsCache_dec = [computed], __getShapeClipPathCache_dec = [computed], __getShapeMaskCache_dec = [computed], __getShapeMaskedPageBoundsCache_dec = [computed], _getNotVisibleShapes_dec = [computed], _getCulledShapes_dec = [computed], _getCurrentPageBounds_dec = [computed], _getCurrentPageShapes_dec = [computed], _getCurrentPageShapesSorted_dec = [computed], _getCurrentPageRenderingShapesSorted_dec = [computed], __getBindingsIndexCache_dec = [computed], __getSelectionSharedStyles_dec = [computed], _getSharedStyles_dec = [computed({ isEqual: (a, b) => a.equals(b) })], _getSharedOpacity_dec = [computed], _getIsFocused_dec = [computed], _getIsReadonly_dec = [computed], __setShiftKeyTimeout_dec = [bind$1], __setAltKeyTimeout_dec = [bind$1], __setCtrlKeyTimeout_dec = [bind$1], __setMetaKeyTimeout_dec = [bind$1], _a$1) {
  constructor({
    store,
    user,
    shapeUtils,
    bindingUtils,
    tools,
    getContainer,
    cameraOptions,
    textOptions,
    initialState: initialState2,
    autoFocus,
    inferDarkMode,
    options,
    getShapeVisibility,
    fontAssetUrls
  }) {
    super();
    __runInitializers$4(_init$3, 5, this);
    __publicField$3(this, "id", uniqueId());
    __publicField$3(this, "_getShapeVisibility");
    __publicField$3(this, "options");
    __publicField$3(this, "contextId", uniqueId());
    __publicField$3(this, "store");
    __publicField$3(this, "root");
    __publicField$3(this, "disposables", /* @__PURE__ */ new Set());
    __publicField$3(this, "isDisposed", false);
    __publicField$3(this, "_tickManager");
    __publicField$3(this, "snaps");
    __publicField$3(this, "timers", tltime.forContext(this.contextId));
    __publicField$3(this, "user");
    __publicField$3(this, "textMeasure");
    __publicField$3(this, "fonts");
    __publicField$3(this, "scribbles");
    __publicField$3(this, "sideEffects");
    __publicField$3(this, "edgeScrollManager");
    __publicField$3(this, "focusManager");
    __publicField$3(this, "getContainer");
    __publicField$3(this, "shapeUtils");
    __publicField$3(this, "styleProps");
    __publicField$3(this, "bindingUtils");
    __publicField$3(this, "history");
    __publicField$3(this, "_shouldIgnoreShapeLock", false);
    __publicField$3(this, "_crashingError", null);
    __publicField$3(this, "_isChangingStyleTimeout", -1);
    __publicField$3(this, "menus", tlmenus.forContext(this.contextId));
    __publicField$3(this, "_currentRichTextEditor", atom("rich text editor", null));
    __publicField$3(this, "_textOptions");
    __publicField$3(this, "_cameraOptions", atom("camera options", DEFAULT_CAMERA_OPTIONS));
    __publicField$3(this, "_viewportAnimation", null);
    __publicField$3(this, "_willSetInitialBounds", true);
    __publicField$3(this, "_isLockedOnFollowingUser", atom("isLockedOnFollowingUser", false));
    __publicField$3(this, "_cameraState", atom("camera state", "idle"));
    __publicField$3(this, "_cameraStateTimeoutRemaining", 0);
    __publicField$3(this, "_currentPageShapeIds");
    __publicField$3(this, "_shapeGeometryCaches", {});
    __publicField$3(this, "_notVisibleShapes", notVisibleShapes(this));
    __publicField$3(this, "_parentIdsToChildIds");
    __publicField$3(this, "animatingShapes", /* @__PURE__ */ new Map());
    __publicField$3(this, "externalAssetContentHandlers", {
      file: null,
      url: null
    });
    __publicField$3(this, "temporaryAssetPreview", /* @__PURE__ */ new Map());
    __publicField$3(this, "externalContentHandlers", {
      text: null,
      files: null,
      "file-replace": null,
      embed: null,
      "svg-text": null,
      url: null,
      tldraw: null,
      excalidraw: null
    });
    __publicField$3(this, "inputs", {
      /** The most recent pointer down's position in the current page space. */
      originPagePoint: new Vec(),
      /** The most recent pointer down's position in screen space. */
      originScreenPoint: new Vec(),
      /** The previous pointer position in the current page space. */
      previousPagePoint: new Vec(),
      /** The previous pointer position in screen space. */
      previousScreenPoint: new Vec(),
      /** The most recent pointer position in the current page space. */
      currentPagePoint: new Vec(),
      /** The most recent pointer position in screen space. */
      currentScreenPoint: new Vec(),
      /** A set containing the currently pressed keys. */
      keys: /* @__PURE__ */ new Set(),
      /** A set containing the currently pressed buttons. */
      buttons: /* @__PURE__ */ new Set(),
      /** Whether the input is from a pe. */
      isPen: false,
      /** Whether the shift key is currently pressed. */
      shiftKey: false,
      /** Whether the meta key is currently pressed. */
      metaKey: false,
      /** Whether the control or command key is currently pressed. */
      ctrlKey: false,
      /** Whether the alt or option key is currently pressed. */
      altKey: false,
      /** Whether the user is dragging. */
      isDragging: false,
      /** Whether the user is pointing. */
      isPointing: false,
      /** Whether the user is pinching. */
      isPinching: false,
      /** Whether the user is editing. */
      isEditing: false,
      /** Whether the user is panning. */
      isPanning: false,
      /** Whether the user is spacebar panning. */
      isSpacebarPanning: false,
      /** Velocity of mouse pointer, in pixels per millisecond */
      pointerVelocity: new Vec()
    });
    __publicField$3(this, "_clickManager", new ClickManager(this));
    __publicField$3(this, "_prevCursor", "default");
    __publicField$3(this, "_shiftKeyTimeout", -1);
    __publicField$3(this, "_altKeyTimeout", -1);
    __publicField$3(this, "_ctrlKeyTimeout", -1);
    __publicField$3(this, "_metaKeyTimeout", -1);
    __publicField$3(this, "_restoreToolId", "select");
    __publicField$3(this, "_pinchStart", 1);
    __publicField$3(this, "_didPinch", false);
    __publicField$3(this, "_selectedShapeIdsAtPointerDown", []);
    __publicField$3(this, "_longPressTimeout", -1);
    __publicField$3(this, "capturedPointerId", null);
    __publicField$3(this, "performanceTracker");
    __publicField$3(this, "performanceTrackerTimeout", -1);
    __publicField$3(this, "handledEvents", /* @__PURE__ */ new WeakSet());
    __publicField$3(this, "_pendingEventsForNextTick", []);
    this._getShapeVisibility = getShapeVisibility;
    this.options = { ...defaultTldrawOptions, ...options };
    this.store = store;
    this.history = new HistoryManager({
      store,
      annotateError: (error) => {
        this.annotateError(error, { origin: "history.batch", willCrashApp: true });
        this.crash(error);
      }
    });
    this.snaps = new SnapManager(this);
    this.disposables.add(this.timers.dispose);
    this._cameraOptions.set({ ...DEFAULT_CAMERA_OPTIONS, ...cameraOptions });
    this._textOptions = atom("text options", textOptions ?? null);
    this.user = new UserPreferencesManager(user ?? createTLUser(), inferDarkMode ?? false);
    this.disposables.add(() => this.user.dispose());
    this.getContainer = getContainer;
    this.textMeasure = new TextManager(this);
    this.disposables.add(() => this.textMeasure.dispose());
    this.fonts = new FontManager(this, fontAssetUrls);
    this._tickManager = new TickManager(this);
    class NewRoot extends RootState {
      static initial = initialState2 ?? "";
    }
    this.root = new NewRoot(this);
    this.root.children = {};
    this.markEventAsHandled = this.markEventAsHandled.bind(this);
    const allShapeUtils = checkShapesAndAddCore(shapeUtils);
    const _shapeUtils = {};
    const _styleProps = {};
    const allStylesById = /* @__PURE__ */ new Map();
    for (const Util of allShapeUtils) {
      const util = new Util(this);
      _shapeUtils[Util.type] = util;
      const propKeysByStyle = getShapePropKeysByStyle(Util.props ?? {});
      _styleProps[Util.type] = propKeysByStyle;
      for (const style2 of propKeysByStyle.keys()) {
        if (!allStylesById.has(style2.id)) {
          allStylesById.set(style2.id, style2);
        } else if (allStylesById.get(style2.id) !== style2) {
          throw Error(
            `Multiple style props with id "${style2.id}" in use. Style prop IDs must be unique.`
          );
        }
      }
    }
    this.shapeUtils = _shapeUtils;
    this.styleProps = _styleProps;
    const allBindingUtils = checkBindings(bindingUtils);
    const _bindingUtils = {};
    for (const Util of allBindingUtils) {
      const util = new Util(this);
      _bindingUtils[Util.type] = util;
    }
    this.bindingUtils = _bindingUtils;
    for (const Tool of [...tools]) {
      if (hasOwnProperty(this.root.children, Tool.id)) {
        throw Error(`Can't override tool with id "${Tool.id}"`);
      }
      this.root.children[Tool.id] = new Tool(this, this.root);
    }
    this.scribbles = new ScribbleManager(this);
    const cleanupInstancePageState = (prevPageState, shapesNoLongerInPage) => {
      let nextPageState = null;
      const selectedShapeIds = prevPageState.selectedShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (selectedShapeIds.length !== prevPageState.selectedShapeIds.length) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.selectedShapeIds = selectedShapeIds;
      }
      const erasingShapeIds = prevPageState.erasingShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (erasingShapeIds.length !== prevPageState.erasingShapeIds.length) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.erasingShapeIds = erasingShapeIds;
      }
      if (prevPageState.hoveredShapeId && shapesNoLongerInPage.has(prevPageState.hoveredShapeId)) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.hoveredShapeId = null;
      }
      if (prevPageState.editingShapeId && shapesNoLongerInPage.has(prevPageState.editingShapeId)) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.editingShapeId = null;
      }
      const hintingShapeIds = prevPageState.hintingShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (hintingShapeIds.length !== prevPageState.hintingShapeIds.length) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.hintingShapeIds = hintingShapeIds;
      }
      if (prevPageState.focusedGroupId && shapesNoLongerInPage.has(prevPageState.focusedGroupId)) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.focusedGroupId = null;
      }
      return nextPageState;
    };
    this.sideEffects = this.store.sideEffects;
    let deletedBindings = /* @__PURE__ */ new Map();
    const deletedShapeIds = /* @__PURE__ */ new Set();
    const invalidParents = /* @__PURE__ */ new Set();
    let invalidBindingTypes = /* @__PURE__ */ new Set();
    this.disposables.add(
      this.sideEffects.registerOperationCompleteHandler(() => {
        deletedShapeIds.clear();
        for (const parentId of invalidParents) {
          invalidParents.delete(parentId);
          const parent = this.getShape(parentId);
          if (!parent) continue;
          const util = this.getShapeUtil(parent);
          const changes = util.onChildrenChange?.(parent);
          if (changes?.length) {
            this.updateShapes(changes);
          }
        }
        if (invalidBindingTypes.size) {
          const t2 = invalidBindingTypes;
          invalidBindingTypes = /* @__PURE__ */ new Set();
          for (const type of t2) {
            const util = this.getBindingUtil(type);
            util.onOperationComplete?.();
          }
        }
        if (deletedBindings.size) {
          const t2 = deletedBindings;
          deletedBindings = /* @__PURE__ */ new Map();
          for (const opts of t2.values()) {
            this.getBindingUtil(opts.binding).onAfterDelete?.(opts);
          }
        }
        this.emit("update");
      })
    );
    this.disposables.add(
      this.sideEffects.register({
        shape: {
          afterChange: (shapeBefore, shapeAfter) => {
            for (const binding of this.getBindingsInvolvingShape(shapeAfter)) {
              invalidBindingTypes.add(binding.type);
              if (binding.fromId === shapeAfter.id) {
                this.getBindingUtil(binding).onAfterChangeFromShape?.({
                  binding,
                  shapeBefore,
                  shapeAfter,
                  reason: "self"
                });
              }
              if (binding.toId === shapeAfter.id) {
                this.getBindingUtil(binding).onAfterChangeToShape?.({
                  binding,
                  shapeBefore,
                  shapeAfter,
                  reason: "self"
                });
              }
            }
            if (shapeBefore.parentId !== shapeAfter.parentId) {
              const notifyBindingAncestryChange = (id) => {
                const descendantShape = this.getShape(id);
                if (!descendantShape) return;
                for (const binding of this.getBindingsInvolvingShape(descendantShape)) {
                  invalidBindingTypes.add(binding.type);
                  if (binding.fromId === descendantShape.id) {
                    this.getBindingUtil(binding).onAfterChangeFromShape?.({
                      binding,
                      shapeBefore: descendantShape,
                      shapeAfter: descendantShape,
                      reason: "ancestry"
                    });
                  }
                  if (binding.toId === descendantShape.id) {
                    this.getBindingUtil(binding).onAfterChangeToShape?.({
                      binding,
                      shapeBefore: descendantShape,
                      shapeAfter: descendantShape,
                      reason: "ancestry"
                    });
                  }
                }
              };
              notifyBindingAncestryChange(shapeAfter.id);
              this.visitDescendants(shapeAfter.id, notifyBindingAncestryChange);
            }
            if (shapeBefore.parentId !== shapeAfter.parentId && isPageId(shapeAfter.parentId)) {
              const allMovingIds = /* @__PURE__ */ new Set([shapeBefore.id]);
              this.visitDescendants(shapeBefore.id, (id) => {
                allMovingIds.add(id);
              });
              for (const instancePageState of this.getPageStates()) {
                if (instancePageState.pageId === shapeAfter.parentId) continue;
                const nextPageState = cleanupInstancePageState(instancePageState, allMovingIds);
                if (nextPageState) {
                  this.store.put([nextPageState]);
                }
              }
            }
            if (shapeBefore.parentId && isShapeId(shapeBefore.parentId)) {
              invalidParents.add(shapeBefore.parentId);
            }
            if (shapeAfter.parentId !== shapeBefore.parentId && isShapeId(shapeAfter.parentId)) {
              invalidParents.add(shapeAfter.parentId);
            }
          },
          beforeDelete: (shape) => {
            if (deletedShapeIds.has(shape.id)) return;
            if (shape.parentId && isShapeId(shape.parentId)) {
              invalidParents.add(shape.parentId);
            }
            deletedShapeIds.add(shape.id);
            const deleteBindingIds = [];
            for (const binding of this.getBindingsInvolvingShape(shape)) {
              invalidBindingTypes.add(binding.type);
              deleteBindingIds.push(binding.id);
              const util = this.getBindingUtil(binding);
              if (binding.fromId === shape.id) {
                util.onBeforeIsolateToShape?.({ binding, removedShape: shape });
                util.onBeforeDeleteFromShape?.({ binding, shape });
              } else {
                util.onBeforeIsolateFromShape?.({ binding, removedShape: shape });
                util.onBeforeDeleteToShape?.({ binding, shape });
              }
            }
            if (deleteBindingIds.length) {
              this.deleteBindings(deleteBindingIds);
            }
            const deletedIds = /* @__PURE__ */ new Set([shape.id]);
            const updates = compact(
              this.getPageStates().map((pageState) => {
                return cleanupInstancePageState(pageState, deletedIds);
              })
            );
            if (updates.length) {
              this.store.put(updates);
            }
          }
        },
        binding: {
          beforeCreate: (binding) => {
            const next = this.getBindingUtil(binding).onBeforeCreate?.({ binding });
            if (next) return next;
            return binding;
          },
          afterCreate: (binding) => {
            invalidBindingTypes.add(binding.type);
            this.getBindingUtil(binding).onAfterCreate?.({ binding });
          },
          beforeChange: (bindingBefore, bindingAfter) => {
            const updated = this.getBindingUtil(bindingAfter).onBeforeChange?.({
              bindingBefore,
              bindingAfter
            });
            if (updated) return updated;
            return bindingAfter;
          },
          afterChange: (bindingBefore, bindingAfter) => {
            invalidBindingTypes.add(bindingAfter.type);
            this.getBindingUtil(bindingAfter).onAfterChange?.({ bindingBefore, bindingAfter });
          },
          beforeDelete: (binding) => {
            this.getBindingUtil(binding).onBeforeDelete?.({ binding });
          },
          afterDelete: (binding) => {
            this.getBindingUtil(binding).onAfterDelete?.({ binding });
            invalidBindingTypes.add(binding.type);
          }
        },
        page: {
          afterCreate: (record) => {
            const cameraId = CameraRecordType.createId(record.id);
            const _pageStateId = InstancePageStateRecordType.createId(record.id);
            if (!this.store.has(cameraId)) {
              this.store.put([CameraRecordType.create({ id: cameraId })]);
            }
            if (!this.store.has(_pageStateId)) {
              this.store.put([
                InstancePageStateRecordType.create({ id: _pageStateId, pageId: record.id })
              ]);
            }
          },
          afterDelete: (record, source) => {
            if (this.getInstanceState()?.currentPageId === record.id) {
              const backupPageId = this.getPages().find((p) => p.id !== record.id)?.id;
              if (backupPageId) {
                this.store.put([{ ...this.getInstanceState(), currentPageId: backupPageId }]);
              } else if (source === "user") {
                this.store.ensureStoreIsUsable();
              }
            }
            const cameraId = CameraRecordType.createId(record.id);
            const instance_PageStateId = InstancePageStateRecordType.createId(record.id);
            this.store.remove([cameraId, instance_PageStateId]);
          }
        },
        instance: {
          afterChange: (prev, next, source) => {
            if (!this.store.has(next.currentPageId)) {
              const backupPageId = this.store.has(prev.currentPageId) ? prev.currentPageId : this.getPages()[0]?.id;
              if (backupPageId) {
                this.store.update(next.id, (instance) => ({
                  ...instance,
                  currentPageId: backupPageId
                }));
              } else if (source === "user") {
                this.store.ensureStoreIsUsable();
              }
            }
          }
        },
        instance_page_state: {
          afterChange: (prev, next) => {
            if (prev?.selectedShapeIds !== next?.selectedShapeIds) {
              const filtered = next.selectedShapeIds.filter((id) => {
                let parentId = this.getShape(id)?.parentId;
                while (isShapeId(parentId)) {
                  if (next.selectedShapeIds.includes(parentId)) {
                    return false;
                  }
                  parentId = this.getShape(parentId)?.parentId;
                }
                return true;
              });
              let nextFocusedGroupId = null;
              if (filtered.length > 0) {
                const commonGroupAncestor = this.findCommonAncestor(
                  compact(filtered.map((id) => this.getShape(id))),
                  (shape) => this.isShapeOfType(shape, "group")
                );
                if (commonGroupAncestor) {
                  nextFocusedGroupId = commonGroupAncestor;
                }
              } else {
                if (next?.focusedGroupId) {
                  nextFocusedGroupId = next.focusedGroupId;
                }
              }
              if (filtered.length !== next.selectedShapeIds.length || nextFocusedGroupId !== next.focusedGroupId) {
                this.store.put([
                  {
                    ...next,
                    selectedShapeIds: filtered,
                    focusedGroupId: nextFocusedGroupId ?? null
                  }
                ]);
              }
            }
          }
        }
      })
    );
    this._currentPageShapeIds = deriveShapeIdsInCurrentPage(
      this.store,
      () => this.getCurrentPageId()
    );
    this._parentIdsToChildIds = parentsToChildren(this.store);
    this.disposables.add(
      this.store.listen((changes) => {
        this.emit("change", changes);
      })
    );
    this.disposables.add(this.history.dispose);
    this.run(
      () => {
        this.store.ensureStoreIsUsable();
        this._updateCurrentPageState({
          editingShapeId: null,
          hoveredShapeId: null,
          erasingShapeIds: []
        });
      },
      { history: "ignore" }
    );
    if (initialState2 && this.root.children[initialState2] === void 0) {
      throw Error(`No state found for initialState "${initialState2}".`);
    }
    this.root.enter(void 0, "initial");
    this.edgeScrollManager = new EdgeScrollManager(this);
    this.focusManager = new FocusManager(this, autoFocus);
    this.disposables.add(this.focusManager.dispose.bind(this.focusManager));
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    this.on("tick", this._flushEventsForTick);
    this.timers.requestAnimationFrame(() => {
      this._tickManager.start();
    });
    this.performanceTracker = new PerformanceTracker();
    if (this.store.props.collaboration?.mode) {
      const mode = this.store.props.collaboration.mode;
      this.disposables.add(
        react("update collaboration mode", () => {
          this.store.put([{ ...this.getInstanceState(), isReadonly: mode.get() === "readonly" }]);
        })
      );
    }
  }
  getIsShapeHiddenCache() {
    if (!this._getShapeVisibility) return null;
    return this.store.createComputedCache("isShapeHidden", (shape) => {
      const visibility = this._getShapeVisibility(shape, this);
      const isParentHidden = PageRecordType.isId(shape.parentId) ? false : this.isShapeHidden(shape.parentId);
      if (isParentHidden) return visibility !== "visible";
      return visibility === "hidden";
    });
  }
  isShapeHidden(shapeOrId) {
    if (!this._getShapeVisibility) return false;
    return !!this.getIsShapeHiddenCache().get(
      typeof shapeOrId === "string" ? shapeOrId : shapeOrId.id
    );
  }
  /**
   * Set a tool. Useful if you need to add a tool to the state chart on demand,
   * after the editor has already been initialized.
   *
   * @param Tool - The tool to set.
   * @param parent - The parent state node to set the tool on.
   *
   * @public
   */
  setTool(Tool, parent) {
    parent ??= this.root;
    if (hasOwnProperty(parent.children, Tool.id)) {
      throw Error(`Can't override tool with id "${Tool.id}"`);
    }
    parent.children[Tool.id] = new Tool(this, parent);
  }
  /**
   * Remove a tool. Useful if you need to remove a tool from the state chart on demand,
   * after the editor has already been initialized.
   *
   * @param Tool - The tool to delete.
   * @param parent - The parent state node to remove the tool from.
   *
   * @public
   */
  removeTool(Tool, parent) {
    parent ??= this.root;
    if (hasOwnProperty(parent.children, Tool.id)) {
      delete parent.children[Tool.id];
    }
  }
  /**
   * Dispose the editor.
   *
   * @public
   */
  dispose() {
    this.disposables.forEach((dispose) => dispose());
    this.disposables.clear();
    this.store.dispose();
    this.isDisposed = true;
  }
  getShapeUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    const shapeUtil = getOwnProperty(this.shapeUtils, type);
    assert(shapeUtil, `No shape util found for type "${type}"`);
    return shapeUtil;
  }
  hasShapeUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    return hasOwnProperty(this.shapeUtils, type);
  }
  getBindingUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    const bindingUtil = getOwnProperty(this.bindingUtils, type);
    assert(bindingUtil, `No binding util found for type "${type}"`);
    return bindingUtil;
  }
  /**
   * Undo to the last mark.
   *
   * @example
   * ```ts
   * editor.undo()
   * ```
   *
   * @public
   */
  undo() {
    this._flushEventsForTick(0);
    this.complete();
    this.history.undo();
    return this;
  }
  getCanUndo() {
    return this.history.getNumUndos() > 0;
  }
  /**
   * Redo to the next mark.
   *
   * @example
   * ```ts
   * editor.redo()
   * ```
   *
   * @public
   */
  redo() {
    this._flushEventsForTick(0);
    this.complete();
    this.history.redo();
    return this;
  }
  clearHistory() {
    this.history.clear();
    return this;
  }
  getCanRedo() {
    return this.history.getNumRedos() > 0;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos. You typically want to do this just before a user interaction begins or is handled.
   *
   * @example
   * ```ts
   * editor.markHistoryStoppingPoint()
   * editor.flipShapes(editor.getSelectedShapes())
   * ```
   * @example
   * ```ts
   * const beginRotateMark = editor.markHistoryStoppingPoint()
   * // if the use cancels the rotation, you can bail back to this mark
   * editor.bailToMark(beginRotateMark)
   * ```
   *
   * @public
   * @param name - The name of the mark, useful for debugging the undo/redo stacks
   * @returns a unique id for the mark that can be used with `squashToMark` or `bailToMark`.
   */
  markHistoryStoppingPoint(name) {
    const id = `[${name ?? "stop"}]_${uniqueId()}`;
    this.history._mark(id);
    return id;
  }
  /**
   * @internal this is only used to implement some backwards-compatibility logic. Should be fine to delete after 6 months or whatever.
   */
  getMarkIdMatching(idSubstring) {
    return this.history.getMarkIdMatching(idSubstring);
  }
  /**
   * Coalesces all changes since the given mark into a single change, removing any intermediate marks.
   *
   * This is useful if you need to 'compress' the recent history to simplify the undo/redo experience of a complex interaction.
   *
   * @example
   * ```ts
   * const bumpShapesMark = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.squashToMark(bumpShapesMark)
   * ```
   *
   * @param markId - The mark id to squash to.
   */
  squashToMark(markId) {
    this.history.squashToMark(markId);
    return this;
  }
  /**
   * Undo to the closest mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * editor.bail()
   * ```
   *
   * @public
   */
  bail() {
    this.history.bail();
    return this;
  }
  /**
   * Undo to the given mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * const beginDrag = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.bailToMark(beginDrag)
   * ```
   *
   * @public
   */
  bailToMark(id) {
    this.history.bailToMark(id);
    return this;
  }
  /**
   * Run a function in a transaction with optional options for context.
   * You can use the options to change the way that history is treated
   * or allow changes to locked shapes.
   *
   * @example
   * ```ts
   * // updating with
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * }, { history: "ignore" })
   *
   * // forcing changes / deletions for locked shapes
   * editor.toggleLock([myShape])
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * 	editor.deleteShape(myShape)
   * }, { ignoreShapeLock: true }, )
   * ```
   *
   * @param fn - The callback function to run.
   * @param opts - The options for the batch.
   *
   *
   * @public
   */
  run(fn, opts) {
    const previousIgnoreShapeLock = this._shouldIgnoreShapeLock;
    this._shouldIgnoreShapeLock = opts?.ignoreShapeLock ?? previousIgnoreShapeLock;
    try {
      this.history.batch(fn, opts);
    } finally {
      this._shouldIgnoreShapeLock = previousIgnoreShapeLock;
    }
    return this;
  }
  /* --------------------- Errors --------------------- */
  /** @internal */
  annotateError(error, {
    origin,
    willCrashApp,
    tags,
    extras
  }) {
    const defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp);
    annotateError(error, {
      tags: { ...defaultAnnotations.tags, ...tags },
      extras: { ...defaultAnnotations.extras, ...extras }
    });
    if (willCrashApp) {
      this.store.markAsPossiblyCorrupted();
    }
    return this;
  }
  /** @internal */
  createErrorAnnotations(origin, willCrashApp) {
    try {
      const editingShapeId = this.getEditingShapeId();
      return {
        tags: {
          origin,
          willCrashApp
        },
        extras: {
          activeStateNode: this.root.getPath(),
          selectedShapes: this.getSelectedShapes().map((s) => {
            const { props, ...rest } = s;
            const { text: _text, richText: _richText, ...restProps } = props;
            return {
              ...rest,
              props: restProps
            };
          }),
          selectionCount: this.getSelectedShapes().length,
          editingShape: editingShapeId ? this.getShape(editingShapeId) : void 0,
          inputs: this.inputs,
          pageState: this.getCurrentPageState(),
          instanceState: this.getInstanceState(),
          collaboratorCount: this.getCollaboratorsOnCurrentPage().length
        }
      };
    } catch {
      return {
        tags: {
          origin,
          willCrashApp
        },
        extras: {}
      };
    }
  }
  /**
   * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,
   * we're in a transaction that's about to be rolled back due to the same error we're currently
   * reporting.
   *
   * Instead, to listen to changes to this value, you need to listen to app's `crash` event.
   *
   * @internal
   */
  getCrashingError() {
    return this._crashingError;
  }
  /** @internal */
  crash(error) {
    this._crashingError = error;
    this.store.markAsPossiblyCorrupted();
    this.emit("crash", { error });
    return this;
  }
  getPath() {
    return this.root.getPath().split("root.")[1];
  }
  /**
   * Get whether a certain tool (or other state node) is currently active.
   *
   * @example
   * ```ts
   * editor.isIn('select')
   * editor.isIn('select.brushing')
   * ```
   *
   * @param path - The path of active states, separated by periods.
   *
   * @public
   */
  isIn(path) {
    const ids = path.split(".").reverse();
    let state = this.root;
    while (ids.length > 0) {
      const id = ids.pop();
      if (!id) return true;
      const current = state.getCurrent();
      if (current?.id === id) {
        if (ids.length === 0) return true;
        state = current;
        continue;
      } else return false;
    }
    return false;
  }
  /**
   * Get whether the state node is in any of the given active paths.
   *
   * @example
   * ```ts
   * state.isInAny('select', 'erase')
   * state.isInAny('select.brushing', 'erase.idle')
   * ```
   *
   * @public
   */
  isInAny(...paths) {
    return paths.some((path) => this.isIn(path));
  }
  /**
   * Set the selected tool.
   *
   * @example
   * ```ts
   * editor.setCurrentTool('hand')
   * editor.setCurrentTool('hand', { date: Date.now() })
   * ```
   *
   * @param id - The id of the tool to select.
   * @param info - Arbitrary data to pass along into the transition.
   *
   * @public
   */
  setCurrentTool(id, info = {}) {
    this.root.transition(id, info);
    return this;
  }
  getCurrentTool() {
    return this.root.getCurrent();
  }
  getCurrentToolId() {
    const currentTool = this.getCurrentTool();
    if (!currentTool) return "";
    return currentTool.getCurrentToolIdMask() ?? currentTool.id;
  }
  /**
   * Get a descendant by its path.
   *
   * @example
   * ```ts
   * editor.getStateDescendant('select')
   * editor.getStateDescendant('select.brushing')
   * ```
   *
   * @param path - The descendant's path of state ids, separated by periods.
   *
   * @public
   */
  getStateDescendant(path) {
    const ids = path.split(".").reverse();
    let state = this.root;
    while (ids.length > 0) {
      const id = ids.pop();
      if (!id) return state;
      const childState = state.children?.[id];
      if (!childState) return void 0;
      state = childState;
    }
    return state;
  }
  getDocumentSettings() {
    return this.store.get(TLDOCUMENT_ID);
  }
  /**
   * Update the global document settings that apply to all users.
   *
   * @public
   **/
  updateDocumentSettings(settings) {
    this.run(
      () => {
        this.store.put([{ ...this.getDocumentSettings(), ...settings }]);
      },
      { history: "ignore" }
    );
    return this;
  }
  getInstanceState() {
    return this.store.get(TLINSTANCE_ID);
  }
  /**
   * Update the instance's state.
   *
   * @param partial - A partial object to update the instance state with.
   * @param historyOptions - History batch options.
   *
   * @public
   */
  updateInstanceState(partial, historyOptions) {
    this._updateInstanceState(partial, { history: "ignore", ...historyOptions });
    if (partial.isChangingStyle !== void 0) {
      clearTimeout(this._isChangingStyleTimeout);
      if (partial.isChangingStyle === true) {
        this._isChangingStyleTimeout = this.timers.setTimeout(() => {
          this._updateInstanceState({ isChangingStyle: false }, { history: "ignore" });
        }, 1e3);
      }
    }
    return this;
  }
  /** @internal */
  _updateInstanceState(partial, opts) {
    this.run(() => {
      this.store.put([
        {
          ...this.getInstanceState(),
          ...partial
        }
      ]);
    }, opts);
  }
  /* --------------------- Cursor --------------------- */
  /**
   * Set the cursor.
   *
   * @param cursor - The cursor to set.
   * @public
   */
  setCursor(cursor) {
    this.updateInstanceState({ cursor: { ...this.getInstanceState().cursor, ...cursor } });
    return this;
  }
  getPageStates() {
    return this._getPageStatesQuery().get();
  }
  _getPageStatesQuery() {
    return this.store.query.records("instance_page_state");
  }
  getCurrentPageState() {
    return this.store.get(this._getCurrentPageStateId());
  }
  _getCurrentPageStateId() {
    return InstancePageStateRecordType.createId(this.getCurrentPageId());
  }
  /**
   * Update this instance's page state.
   *
   * @example
   * ```ts
   * editor.updateCurrentPageState({ id: 'page1', editingShapeId: 'shape:123' })
   * ```
   *
   * @param partial - The partial of the page state object containing the changes.
   *
   * @public
   */
  updateCurrentPageState(partial) {
    this._updateCurrentPageState(partial);
    return this;
  }
  _updateCurrentPageState(partial) {
    this.store.update(partial.id ?? this.getCurrentPageState().id, (state) => ({
      ...state,
      ...partial
    }));
  }
  getSelectedShapeIds() {
    return this.getCurrentPageState().selectedShapeIds;
  }
  getSelectedShapes() {
    return compact(this.getSelectedShapeIds().map((id) => this.store.get(id)));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.setSelectedShapes(['id1'])
   * editor.setSelectedShapes(['id1', 'id2'])
   * ```
   *
   * @param shapes - The shape (or shape ids) to select.
   *
   * @public
   */
  setSelectedShapes(shapes) {
    return this.run(
      () => {
        const ids = shapes.map((shape) => typeof shape === "string" ? shape : shape.id);
        const { selectedShapeIds: prevSelectedShapeIds } = this.getCurrentPageState();
        const prevSet = new Set(prevSelectedShapeIds);
        if (ids.length === prevSet.size && ids.every((id) => prevSet.has(id))) return null;
        this.store.put([{ ...this.getCurrentPageState(), selectedShapeIds: ids }]);
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Determine whether or not any of a shape's ancestors are selected.
   *
   * @param shape - The shape (or shape id) of the shape to check.
   *
   * @public
   */
  isAncestorSelected(shape) {
    const id = typeof shape === "string" ? shape : shape?.id ?? null;
    const _shape = this.getShape(id);
    if (!_shape) return false;
    const selectedShapeIds = this.getSelectedShapeIds();
    return !!this.findShapeAncestor(_shape, (parent) => selectedShapeIds.includes(parent.id));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.select('id1')
   * editor.select('id1', 'id2')
   * ```
   *
   * @param shapes - The shape (or the shape ids) to select.
   *
   * @public
   */
  select(...shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    this.setSelectedShapes(ids);
    return this;
  }
  /**
   * Remove a shape from the existing set of selected shapes.
   *
   * @example
   * ```ts
   * editor.deselect(shape.id)
   * ```
   *
   * @public
   */
  deselect(...shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    const selectedShapeIds = this.getSelectedShapeIds();
    if (selectedShapeIds.length > 0 && ids.length > 0) {
      this.setSelectedShapes(selectedShapeIds.filter((id) => !ids.includes(id)));
    }
    return this;
  }
  /**
   * Select all shapes. If the user has selected shapes that share a parent,
   * select all shapes within that parent. If the user has not selected any shapes,
   * or if the shapes shapes are only on select all shapes on the current page.
   *
   * @example
   * ```ts
   * editor.selectAll()
   * ```
   *
   * @public
   */
  selectAll() {
    let parentToSelectWithinId = null;
    const selectedShapeIds = this.getSelectedShapeIds();
    if (selectedShapeIds.length > 0) {
      for (const id of selectedShapeIds) {
        const shape = this.getShape(id);
        if (!shape) continue;
        if (parentToSelectWithinId === null) {
          parentToSelectWithinId = shape.parentId;
        } else if (parentToSelectWithinId !== shape.parentId) {
          return this;
        }
      }
    }
    if (!parentToSelectWithinId) {
      parentToSelectWithinId = this.getCurrentPageId();
    }
    const ids = this.getSortedChildIdsForParent(parentToSelectWithinId);
    if (ids.length <= 0) return this;
    this.setSelectedShapes(this._getUnlockedShapeIds(ids));
    return this;
  }
  /**
   * Select the next shape in the reading order or in cardinal order.
   *
   * @example
   * ```ts
   * editor.selectAdjacentShape('next')
   * ```
   *
   * @public
   */
  selectAdjacentShape(direction) {
    const selectedShapeIds = this.getSelectedShapeIds();
    const firstParentId = selectedShapeIds[0] ? this.getShape(selectedShapeIds[0])?.parentId : null;
    const isSelectedWithinContainer = firstParentId && selectedShapeIds.every((shapeId) => this.getShape(shapeId)?.parentId === firstParentId) && !isPageId(firstParentId);
    const filteredShapes = isSelectedWithinContainer ? this.getCurrentPageShapes().filter((shape2) => shape2.parentId === firstParentId) : this.getCurrentPageShapes().filter((shape2) => isPageId(shape2.parentId));
    const readingOrderShapes = isSelectedWithinContainer ? this._getShapesInReadingOrder(filteredShapes) : this.getCurrentPageShapesInReadingOrder();
    const currentShapeId = selectedShapeIds.length === 1 ? selectedShapeIds[0] : readingOrderShapes.find((shape2) => selectedShapeIds.includes(shape2.id))?.id;
    let adjacentShapeId;
    if (direction === "next" || direction === "prev") {
      const shapeIds = readingOrderShapes.map((shape2) => shape2.id);
      const currentIndex = currentShapeId ? shapeIds.indexOf(currentShapeId) : -1;
      const adjacentIndex = (currentIndex + (direction === "next" ? 1 : -1) + shapeIds.length) % shapeIds.length;
      adjacentShapeId = shapeIds[adjacentIndex];
    } else {
      if (!currentShapeId) return;
      adjacentShapeId = this.getNearestAdjacentShape(filteredShapes, currentShapeId, direction);
    }
    const shape = this.getShape(adjacentShapeId);
    if (!shape) return;
    this._selectShapesAndZoom([shape.id]);
  }
  getCurrentPageShapesInReadingOrder() {
    const shapes = this.getCurrentPageShapes().filter((shape) => isPageId(shape.parentId));
    return this._getShapesInReadingOrder(shapes);
  }
  _getShapesInReadingOrder(shapes) {
    const SHALLOW_ANGLE = 20;
    const ROW_THRESHOLD = 100;
    const tabbableShapes = shapes.filter((shape) => this.getShapeUtil(shape).canTabTo(shape));
    if (tabbableShapes.length <= 1) return tabbableShapes;
    const shapesWithCenters = tabbableShapes.map((shape) => ({
      shape,
      center: this.getShapePageBounds(shape).center
    }));
    shapesWithCenters.sort((a, b) => a.center.y - b.center.y);
    const rows = [];
    for (const shapeWithCenter of shapesWithCenters) {
      let rowIndex = -1;
      for (let i = rows.length - 1; i >= 0; i--) {
        const row = rows[i];
        const lastShapeInRow = row[row.length - 1];
        if (Math.abs(shapeWithCenter.center.y - lastShapeInRow.center.y) < ROW_THRESHOLD) {
          rowIndex = i;
          break;
        }
      }
      if (rowIndex === -1) {
        rows.push([shapeWithCenter]);
      } else {
        rows[rowIndex].push(shapeWithCenter);
      }
    }
    for (const row of rows) {
      row.sort((a, b) => a.center.x - b.center.x);
    }
    for (const row of rows) {
      if (row.length <= 2) continue;
      for (let i = 0; i < row.length - 2; i++) {
        const currentShape = row[i];
        const nextShape = row[i + 1];
        const nextNextShape = row[i + 2];
        const dist1 = Vec.Dist2(currentShape.center, nextShape.center);
        const dist2 = Vec.Dist2(currentShape.center, nextNextShape.center);
        if (dist2 < dist1 * 0.9) {
          const angle = Math.abs(
            Vec.Angle(currentShape.center, nextNextShape.center) * (180 / Math.PI)
          );
          if (angle <= SHALLOW_ANGLE) {
            [row[i + 1], row[i + 2]] = [row[i + 2], row[i + 1]];
          }
        }
      }
    }
    return rows.flat().map((item) => item.shape);
  }
  /**
   * Find the nearest adjacent shape in a specific direction.
   *
   * @public
   */
  getNearestAdjacentShape(shapes, currentShapeId, direction) {
    const directionToAngle = { right: 0, left: 180, down: 90, up: 270 };
    const currentShape = this.getShape(currentShapeId);
    if (!currentShape) return currentShapeId;
    const tabbableShapes = shapes.filter(
      (shape) => this.getShapeUtil(shape).canTabTo(shape) && shape.id !== currentShapeId
    );
    if (!tabbableShapes.length) return currentShapeId;
    const currentCenter = this.getShapePageBounds(currentShape).center;
    const shapesWithCenters = tabbableShapes.map((shape) => ({
      shape,
      center: this.getShapePageBounds(shape).center
    }));
    const shapesInDirection = shapesWithCenters.filter(({ center }) => {
      const isRight = center.x > currentCenter.x;
      const isDown = center.y > currentCenter.y;
      const xDist = center.x - currentCenter.x;
      const yDist = center.y - currentCenter.y;
      const isInXDirection = Math.abs(yDist) < Math.abs(xDist) * 2;
      const isInYDirection = Math.abs(xDist) < Math.abs(yDist) * 2;
      if (direction === "left" || direction === "right") {
        return isInXDirection && (direction === "right" ? isRight : !isRight);
      }
      if (direction === "up" || direction === "down") {
        return isInYDirection && (direction === "down" ? isDown : !isDown);
      }
    });
    if (shapesInDirection.length === 0) return currentShapeId;
    const lowestScoringShape = minBy(shapesInDirection, ({ center }) => {
      const distance = Vec.Dist2(currentCenter, center);
      const dirProp = ["left", "right"].includes(direction) ? "x" : "y";
      const directionalDistance = Math.abs(center[dirProp] - currentCenter[dirProp]);
      const offProp = ["left", "right"].includes(direction) ? "y" : "x";
      const offAxisDeviation = Math.abs(center[offProp] - currentCenter[offProp]);
      const angle = Math.abs(Vec.Angle(currentCenter, center) * (180 / Math.PI));
      const angleDeviation = Math.abs(angle - directionToAngle[direction]);
      return distance * 1 + // Base distance
      offAxisDeviation * 2 + // Heavy penalty for off-axis deviation
      (distance - directionalDistance) * 1.5 + // Penalty for diagonal distance
      angleDeviation * 0.5;
    });
    return lowestScoringShape.shape.id;
  }
  selectParentShape() {
    const selectedShape = this.getOnlySelectedShape();
    if (!selectedShape) return;
    const parentShape = this.getShape(selectedShape.parentId);
    if (!parentShape) return;
    this._selectShapesAndZoom([parentShape.id]);
  }
  selectFirstChildShape() {
    const selectedShapes = this.getSelectedShapes();
    if (!selectedShapes.length) return;
    const selectedShape = selectedShapes[0];
    const children = this.getSortedChildIdsForParent(selectedShape.id).map((id) => this.getShape(id)).filter((i) => i);
    const sortedChildren = this._getShapesInReadingOrder(children);
    if (sortedChildren.length === 0) return;
    this._selectShapesAndZoom([sortedChildren[0].id]);
  }
  _selectShapesAndZoom(ids) {
    this.setSelectedShapes(ids);
    this.zoomToSelectionIfOffscreen(256, {
      animation: {
        duration: this.options.animationMediumMs
      },
      inset: 0
    });
  }
  /**
   * Clear the selection.
   *
   * @example
   * ```ts
   * editor.selectNone()
   * ```
   *
   * @public
   */
  selectNone() {
    if (this.getSelectedShapeIds().length > 0) {
      this.setSelectedShapes([]);
    }
    return this;
  }
  getOnlySelectedShapeId() {
    return this.getOnlySelectedShape()?.id ?? null;
  }
  getOnlySelectedShape() {
    const selectedShapes = this.getSelectedShapes();
    return selectedShapes.length === 1 ? selectedShapes[0] : null;
  }
  /**
   * Get the page bounds of all the provided shapes.
   *
   * @public
   */
  getShapesPageBounds(shapeIds) {
    const bounds = compact(shapeIds.map((id) => this.getShapePageBounds(id)));
    if (bounds.length === 0) return null;
    return Box.Common(bounds);
  }
  getSelectionPageBounds() {
    return this.getShapesPageBounds(this.getSelectedShapeIds());
  }
  /**
   * The bounds of the selection bounding box in the current page space.
   *
   * @readonly
   * @public
   */
  getSelectionScreenBounds() {
    const bounds = this.getSelectionPageBounds();
    if (!bounds) return void 0;
    const { x, y } = this.pageToScreen(bounds.point);
    const zoom = this.getZoomLevel();
    return new Box(x, y, bounds.width * zoom, bounds.height * zoom);
  }
  /**
   * @internal
   */
  getShapesSharedRotation(shapeIds) {
    let foundFirst = false;
    let rotation = 0;
    for (let i = 0, n = shapeIds.length; i < n; i++) {
      const pageTransform = this.getShapePageTransform(shapeIds[i]);
      if (!pageTransform) continue;
      if (foundFirst) {
        if (pageTransform.rotation() !== rotation) {
          return 0;
        }
      } else {
        foundFirst = true;
        rotation = pageTransform.rotation();
      }
    }
    return rotation;
  }
  getSelectionRotation() {
    return this.getShapesSharedRotation(this.getSelectedShapeIds());
  }
  /**
   * @internal
   */
  getShapesRotatedPageBounds(shapeIds) {
    if (shapeIds.length === 0) {
      return void 0;
    }
    const selectionRotation = this.getShapesSharedRotation(shapeIds);
    if (selectionRotation === 0) {
      return this.getShapesPageBounds(shapeIds) ?? void 0;
    }
    if (shapeIds.length === 1) {
      const bounds = this.getShapeGeometry(shapeIds[0]).bounds.clone();
      const pageTransform = this.getShapePageTransform(shapeIds[0]);
      bounds.point = pageTransform.applyToPoint(bounds.point);
      return bounds;
    }
    const boxFromRotatedVertices = Box.FromPoints(
      shapeIds.flatMap((id) => {
        const pageTransform = this.getShapePageTransform(id);
        if (!pageTransform) return [];
        return pageTransform.applyToPoints(this.getShapeGeometry(id).bounds.corners);
      }).map((p) => p.rot(-selectionRotation))
    );
    boxFromRotatedVertices.point = boxFromRotatedVertices.point.rot(selectionRotation);
    return boxFromRotatedVertices;
  }
  getSelectionRotatedPageBounds() {
    return this.getShapesRotatedPageBounds(this.getSelectedShapeIds());
  }
  getSelectionRotatedScreenBounds() {
    const bounds = this.getSelectionRotatedPageBounds();
    if (!bounds) return void 0;
    const { x, y } = this.pageToScreen(bounds.point);
    const zoom = this.getZoomLevel();
    return new Box(x, y, bounds.width * zoom, bounds.height * zoom);
  }
  getFocusedGroupId() {
    return this.getCurrentPageState().focusedGroupId ?? this.getCurrentPageId();
  }
  getFocusedGroup() {
    const focusedGroupId = this.getFocusedGroupId();
    return focusedGroupId ? this.getShape(focusedGroupId) : void 0;
  }
  /**
   * Set the current focused group shape.
   *
   * @param shape - The group shape id (or group shape's id) to set as the focused group shape.
   *
   * @public
   */
  setFocusedGroup(shape) {
    const id = typeof shape === "string" ? shape : shape?.id ?? null;
    if (id !== null) {
      const shape2 = this.getShape(id);
      if (!shape2) {
        throw Error(`Editor.setFocusedGroup: Shape with id ${id} does not exist`);
      }
      if (!this.isShapeOfType(shape2, "group")) {
        throw Error(
          `Editor.setFocusedGroup: Cannot set focused group to shape of type ${shape2.type}`
        );
      }
    }
    if (id === this.getFocusedGroupId()) return this;
    return this.run(
      () => {
        this.store.update(this.getCurrentPageState().id, (s) => ({ ...s, focusedGroupId: id }));
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Exit the current focused group, moving up to the next parent group if there is one.
   *
   * @public
   */
  popFocusedGroupId() {
    const focusedGroup = this.getFocusedGroup();
    if (focusedGroup) {
      const match = this.findShapeAncestor(
        focusedGroup,
        (shape) => this.isShapeOfType(shape, "group")
      );
      this.setFocusedGroup(match?.id ?? null);
      this.select(focusedGroup.id);
    } else {
      this.setFocusedGroup(null);
      this.selectNone();
    }
    return this;
  }
  getEditingShapeId() {
    return this.getCurrentPageState().editingShapeId;
  }
  getEditingShape() {
    const editingShapeId = this.getEditingShapeId();
    return editingShapeId ? this.getShape(editingShapeId) : void 0;
  }
  /**
   * Set the current editing shape.
   *
   * @example
   * ```ts
   * editor.setEditingShape(myShape)
   * editor.setEditingShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as editing.
   *
   * @public
   */
  setEditingShape(shape) {
    const id = typeof shape === "string" ? shape : shape?.id ?? null;
    this.setRichTextEditor(null);
    const prevEditingShapeId = this.getEditingShapeId();
    if (id !== prevEditingShapeId) {
      if (id) {
        const shape2 = this.getShape(id);
        if (shape2 && this.getShapeUtil(shape2).canEdit(shape2)) {
          this.run(
            () => {
              this._updateCurrentPageState({ editingShapeId: id });
              if (prevEditingShapeId) {
                const prevEditingShape = this.getShape(prevEditingShapeId);
                if (prevEditingShape) {
                  this.getShapeUtil(prevEditingShape).onEditEnd?.(prevEditingShape);
                }
              }
              this.getShapeUtil(shape2).onEditStart?.(shape2);
            },
            { history: "ignore" }
          );
          return this;
        }
      }
      this.run(
        () => {
          this._updateCurrentPageState({ editingShapeId: null });
          this._currentRichTextEditor.set(null);
          if (prevEditingShapeId) {
            const prevEditingShape = this.getShape(prevEditingShapeId);
            if (prevEditingShape) {
              this.getShapeUtil(prevEditingShape).onEditEnd?.(prevEditingShape);
            }
          }
        },
        { history: "ignore" }
      );
    }
    return this;
  }
  getRichTextEditor() {
    return this._currentRichTextEditor.get();
  }
  /**
   * Set the current editing shape's rich text editor.
   *
   * @example
   * ```ts
   * editor.setRichTextEditor(richTextEditorView)
   * ```
   *
   * @param textEditor - The text editor to set as the current editing shape's text editor.
   *
   * @public
   */
  setRichTextEditor(textEditor) {
    this._currentRichTextEditor.set(textEditor);
    return this;
  }
  getHoveredShapeId() {
    return this.getCurrentPageState().hoveredShapeId;
  }
  getHoveredShape() {
    const hoveredShapeId = this.getHoveredShapeId();
    return hoveredShapeId ? this.getShape(hoveredShapeId) : void 0;
  }
  /**
   * Set the editor's current hovered shape.
   *
   * @example
   * ```ts
   * editor.setHoveredShape(myShape)
   * editor.setHoveredShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as hovered.
   *
   * @public
   */
  setHoveredShape(shape) {
    const id = typeof shape === "string" ? shape : shape?.id ?? null;
    if (id === this.getHoveredShapeId()) return this;
    this.run(
      () => {
        this.updateCurrentPageState({ hoveredShapeId: id });
      },
      { history: "ignore" }
    );
    return this;
  }
  getHintingShapeIds() {
    return this.getCurrentPageState().hintingShapeIds;
  }
  getHintingShape() {
    const hintingShapeIds = this.getHintingShapeIds();
    return compact(hintingShapeIds.map((id) => this.getShape(id)));
  }
  /**
   * Set the editor's current hinting shapes.
   *
   * @example
   * ```ts
   * editor.setHintingShapes([myShape])
   * editor.setHintingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setHintingShapes(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    this.run(
      () => {
        this._updateCurrentPageState({ hintingShapeIds: dedupe(ids) });
      },
      { history: "ignore" }
    );
    return this;
  }
  getErasingShapeIds() {
    return this.getCurrentPageState().erasingShapeIds;
  }
  getErasingShapes() {
    const erasingShapeIds = this.getErasingShapeIds();
    return compact(erasingShapeIds.map((id) => this.getShape(id)));
  }
  /**
   * Set the editor's current erasing shapes.
   *
   * @example
   * ```ts
   * editor.setErasingShapes([myShape])
   * editor.setErasingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setErasingShapes(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    ids.sort();
    const erasingShapeIds = this.getErasingShapeIds();
    this.run(
      () => {
        if (ids.length === erasingShapeIds.length) {
          for (let i = 0; i < ids.length; i++) {
            if (ids[i] !== erasingShapeIds[i]) {
              this._updateCurrentPageState({ erasingShapeIds: ids });
              break;
            }
          }
        } else {
          this._updateCurrentPageState({ erasingShapeIds: ids });
        }
      },
      { history: "ignore" }
    );
    return this;
  }
  // Cropping
  /**
   * The current cropping shape's id.
   *
   * @public
   */
  getCroppingShapeId() {
    return this.getCurrentPageState().croppingShapeId;
  }
  /**
   * Set the current cropping shape.
   *
   * @example
   * ```ts
   * editor.setCroppingShape(myShape)
   * editor.setCroppingShape(myShape.id)
   * ```
   *
   *
   * @param shape - The shape (or shape id) to set as cropping.
   *
   * @public
   */
  setCroppingShape(shape) {
    const id = typeof shape === "string" ? shape : shape?.id ?? null;
    if (id !== this.getCroppingShapeId()) {
      this.run(
        () => {
          if (!id) {
            this.updateCurrentPageState({ croppingShapeId: null });
          } else {
            const shape2 = this.getShape(id);
            const util = this.getShapeUtil(shape2);
            if (shape2 && util.canCrop(shape2)) {
              this.updateCurrentPageState({ croppingShapeId: id });
            }
          }
        },
        { history: "ignore" }
      );
    }
    return this;
  }
  /**
   * Get the current text options.
   *
   * @example
   * ```ts
   * editor.getTextOptions()
   * ```
   *
   *  @public */
  getTextOptions() {
    return assertExists(this._textOptions.get(), "Cannot use text without setting textOptions");
  }
  _unsafe_getCameraId() {
    return CameraRecordType.createId(this.getCurrentPageId());
  }
  getCamera() {
    const baseCamera = this.store.get(this._unsafe_getCameraId());
    if (this._isLockedOnFollowingUser.get()) {
      const followingCamera = this.getCameraForFollowing();
      if (followingCamera) {
        return { ...baseCamera, ...followingCamera };
      }
    }
    return baseCamera;
  }
  _getFollowingPresence(targetUserId) {
    const visited = [this.user.getId()];
    const collaborators = this.getCollaborators();
    let leaderPresence = null;
    while (targetUserId && !visited.includes(targetUserId)) {
      leaderPresence = collaborators.find((c) => c.userId === targetUserId) ?? null;
      targetUserId = leaderPresence?.followingUserId ?? null;
      if (leaderPresence) {
        visited.push(leaderPresence.userId);
      }
    }
    return leaderPresence;
  }
  getViewportPageBoundsForFollowing() {
    const leaderPresence = this._getFollowingPresence(this.getInstanceState().followingUserId);
    if (!leaderPresence?.camera || !leaderPresence?.screenBounds) return null;
    const { w: lw, h: lh } = leaderPresence.screenBounds;
    const { x: lx, y: ly, z: lz2 } = leaderPresence.camera;
    const theirViewport = new Box(-lx, -ly, lw / lz2, lh / lz2);
    const ourViewport = this.getViewportScreenBounds().clone();
    const ourAspectRatio = ourViewport.width / ourViewport.height;
    ourViewport.width = theirViewport.width;
    ourViewport.height = ourViewport.width / ourAspectRatio;
    if (ourViewport.height < theirViewport.height) {
      ourViewport.height = theirViewport.height;
      ourViewport.width = ourViewport.height * ourAspectRatio;
    }
    ourViewport.center = theirViewport.center;
    return ourViewport;
  }
  getCameraForFollowing() {
    const viewport = this.getViewportPageBoundsForFollowing();
    if (!viewport) return null;
    return {
      x: -viewport.x,
      y: -viewport.y,
      z: this.getViewportScreenBounds().w / viewport.width
    };
  }
  getZoomLevel() {
    return this.getCamera().z;
  }
  /**
   * Get the camera's initial or reset zoom level.
   *
   * @example
   * ```ts
   * editor.getInitialZoom()
   * ```
   *
   * @public */
  getInitialZoom() {
    const cameraOptions = this.getCameraOptions();
    if (!cameraOptions.constraints) return 1;
    if (cameraOptions.constraints.initialZoom === "default") return 1;
    const { zx, zy } = getCameraFitXFitY(this, cameraOptions);
    switch (cameraOptions.constraints.initialZoom) {
      case "fit-min": {
        return Math.max(zx, zy);
      }
      case "fit-max": {
        return Math.min(zx, zy);
      }
      case "fit-x": {
        return zx;
      }
      case "fit-y": {
        return zy;
      }
      case "fit-min-100": {
        return Math.min(1, Math.max(zx, zy));
      }
      case "fit-max-100": {
        return Math.min(1, Math.min(zx, zy));
      }
      case "fit-x-100": {
        return Math.min(1, zx);
      }
      case "fit-y-100": {
        return Math.min(1, zy);
      }
      default: {
        throw exhaustiveSwitchError(cameraOptions.constraints.initialZoom);
      }
    }
  }
  /**
   * Get the camera's base level for calculating actual zoom levels based on the zoom steps.
   *
   * @example
   * ```ts
   * editor.getBaseZoom()
   * ```
   *
   * @public */
  getBaseZoom() {
    const cameraOptions = this.getCameraOptions();
    if (!cameraOptions.constraints) return 1;
    if (cameraOptions.constraints.baseZoom === "default") return 1;
    const { zx, zy } = getCameraFitXFitY(this, cameraOptions);
    switch (cameraOptions.constraints.baseZoom) {
      case "fit-min": {
        return Math.max(zx, zy);
      }
      case "fit-max": {
        return Math.min(zx, zy);
      }
      case "fit-x": {
        return zx;
      }
      case "fit-y": {
        return zy;
      }
      case "fit-min-100": {
        return Math.min(1, Math.max(zx, zy));
      }
      case "fit-max-100": {
        return Math.min(1, Math.min(zx, zy));
      }
      case "fit-x-100": {
        return Math.min(1, zx);
      }
      case "fit-y-100": {
        return Math.min(1, zy);
      }
      default: {
        throw exhaustiveSwitchError(cameraOptions.constraints.baseZoom);
      }
    }
  }
  /**
   * Get the current camera options.
   *
   * @example
   * ```ts
   * editor.getCameraOptions()
   * ```
   *
   *  @public */
  getCameraOptions() {
    return this._cameraOptions.get();
  }
  /**
   * Set the camera options. Changing the options won't immediately change the camera itself, so you may want to call `setCamera` after changing the options.
   *
   * @example
   * ```ts
   * editor.setCameraOptions(myCameraOptions)
   * editor.setCamera(editor.getCamera())
   * ```
   *
   * @param opts - The camera options to set.
   *
   * @public */
  setCameraOptions(opts) {
    const next = structuredClone({
      ...this._cameraOptions.__unsafe__getWithoutCapture(),
      ...opts
    });
    if (next.zoomSteps?.length < 1) next.zoomSteps = [1];
    this._cameraOptions.set(next);
    this.setCamera(this.getCamera());
    return this;
  }
  /** @internal */
  getConstrainedCamera(point, opts) {
    const currentCamera = this.getCamera();
    let { x, y, z = currentCamera.z } = point;
    if (!opts?.force) {
      const cameraOptions = this.getCameraOptions();
      const zoomMin = cameraOptions.zoomSteps[0];
      const zoomMax = last(cameraOptions.zoomSteps);
      const vsb = this.getViewportScreenBounds();
      if (cameraOptions.constraints) {
        const { constraints } = cameraOptions;
        const py = Math.min(constraints.padding.y, vsb.w / 2);
        const px = Math.min(constraints.padding.x, vsb.h / 2);
        const bounds = Box.From(cameraOptions.constraints.bounds);
        const zx = (vsb.w - px * 2) / bounds.w;
        const zy = (vsb.h - py * 2) / bounds.h;
        const baseZoom = this.getBaseZoom();
        const maxZ = zoomMax * baseZoom;
        const minZ = zoomMin * baseZoom;
        if (opts?.reset) {
          z = this.getInitialZoom();
        }
        if (z < minZ || z > maxZ) {
          const { x: cx, y: cy, z: cz } = currentCamera;
          const cxA = -cx + vsb.w / cz / 2;
          const cyA = -cy + vsb.h / cz / 2;
          z = clamp$3(z, minZ, maxZ);
          const cxB = -cx + vsb.w / z / 2;
          const cyB = -cy + vsb.h / z / 2;
          x = cx + cxB - cxA;
          y = cy + cyB - cyA;
        }
        const minX = px / z - bounds.x;
        const minY = py / z - bounds.y;
        const freeW = (vsb.w - px * 2) / z - bounds.w;
        const freeH = (vsb.h - py * 2) / z - bounds.h;
        const originX = minX + freeW * constraints.origin.x;
        const originY = minY + freeH * constraints.origin.y;
        const behaviorX = typeof constraints.behavior === "string" ? constraints.behavior : constraints.behavior.x;
        const behaviorY = typeof constraints.behavior === "string" ? constraints.behavior : constraints.behavior.y;
        if (opts?.reset) {
          x = originX;
          y = originY;
        } else {
          switch (behaviorX) {
            case "fixed": {
              x = originX;
              break;
            }
            case "contain": {
              if (z < zx) x = originX;
              else x = clamp$3(x, minX + freeW, minX);
              break;
            }
            case "inside": {
              if (z < zx) x = clamp$3(x, minX, (vsb.w - px) / z - bounds.w);
              else x = clamp$3(x, minX + freeW, minX);
              break;
            }
            case "outside": {
              x = clamp$3(x, px / z - bounds.w, (vsb.w - px) / z);
              break;
            }
            case "free": {
              break;
            }
            default: {
              throw exhaustiveSwitchError(behaviorX);
            }
          }
          switch (behaviorY) {
            case "fixed": {
              y = originY;
              break;
            }
            case "contain": {
              if (z < zy) y = originY;
              else y = clamp$3(y, minY + freeH, minY);
              break;
            }
            case "inside": {
              if (z < zy) y = clamp$3(y, minY, (vsb.h - py) / z - bounds.h);
              else y = clamp$3(y, minY + freeH, minY);
              break;
            }
            case "outside": {
              y = clamp$3(y, py / z - bounds.h, (vsb.h - py) / z);
              break;
            }
            case "free": {
              break;
            }
            default: {
              throw exhaustiveSwitchError(behaviorY);
            }
          }
        }
      } else {
        if (z > zoomMax || z < zoomMin) {
          const { x: cx, y: cy, z: cz } = currentCamera;
          z = clamp$3(z, zoomMin, zoomMax);
          x = cx + (-cx + vsb.w / z / 2) - (-cx + vsb.w / cz / 2);
          y = cy + (-cy + vsb.h / z / 2) - (-cy + vsb.h / cz / 2);
        }
      }
    }
    return { x, y, z };
  }
  /** @internal */
  _setCamera(point, opts) {
    const currentCamera = this.getCamera();
    const { x, y, z } = this.getConstrainedCamera(point, opts);
    if (currentCamera.x === x && currentCamera.y === y && currentCamera.z === z) {
      return this;
    }
    transact(() => {
      const camera = { ...currentCamera, x, y, z };
      this.run(
        () => {
          this.store.put([camera]);
        },
        { history: "ignore" }
      );
      const { currentScreenPoint, currentPagePoint } = this.inputs;
      if (currentScreenPoint.x / z - x !== currentPagePoint.x || currentScreenPoint.y / z - y !== currentPagePoint.y) {
        this.updatePointer({
          immediate: opts?.immediate,
          pointerId: INTERNAL_POINTER_IDS.CAMERA_MOVE
        });
      }
      this._tickCameraState();
    });
    return this;
  }
  /**
   * Set the current camera.
   *
   * @example
   * ```ts
   * editor.setCamera({ x: 0, y: 0})
   * editor.setCamera({ x: 0, y: 0, z: 1.5})
   * editor.setCamera({ x: 0, y: 0, z: 1.5}, { animation: { duration: 1000, easing: (t) => t * t } })
   * ```
   *
   * @param point - The new camera position.
   * @param opts - The camera move options.
   *
   * @public
   */
  setCamera(point, opts) {
    const { isLocked } = this._cameraOptions.__unsafe__getWithoutCapture();
    if (isLocked && !opts?.force) return this;
    this.stopCameraAnimation();
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    const _point = Vec.Cast(point);
    if (!Number.isFinite(_point.x)) _point.x = 0;
    if (!Number.isFinite(_point.y)) _point.y = 0;
    if (_point.z === void 0 || !Number.isFinite(_point.z)) point.z = this.getZoomLevel();
    const camera = this.getConstrainedCamera(_point, opts);
    if (opts?.animation) {
      const { width, height } = this.getViewportScreenBounds();
      this._animateToViewport(
        new Box(-camera.x, -camera.y, width / camera.z, height / camera.z),
        opts
      );
    } else {
      this._setCamera(camera, {
        ...opts,
        // we already did the constraining, so we don't need to do it again
        force: true
      });
    }
    return this;
  }
  /**
   * Center the camera on a point (in the current page space).
   *
   * @example
   * ```ts
   * editor.centerOnPoint({ x: 100, y: 100 })
   * editor.centerOnPoint({ x: 100, y: 100 }, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The point in the current page space to center on.
   * @param opts - The camera move options.
   *
   * @public
   */
  centerOnPoint(point, opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const { width: pw, height: ph } = this.getViewportPageBounds();
    this.setCamera(new Vec(-(point.x - pw / 2), -(point.y - ph / 2), this.getCamera().z), opts);
    return this;
  }
  /**
   * Zoom the camera to fit the current page's content in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToFit()
   * editor.zoomToFit({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToFit(opts) {
    const ids = [...this.getCurrentPageShapeIds()];
    if (ids.length <= 0) return this;
    const pageBounds = Box.Common(compact(ids.map((id) => this.getShapePageBounds(id))));
    this.zoomToBounds(pageBounds, opts);
    return this;
  }
  /**
   * Set the zoom back to 100%.
   *
   * @example
   * ```ts
   * editor.resetZoom()
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  resetZoom(point = this.getViewportScreenCenter(), opts) {
    const { isLocked, constraints } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const currentCamera = this.getCamera();
    const { x: cx, y: cy, z: cz } = currentCamera;
    const { x, y } = point;
    let z = 1;
    if (constraints) {
      const initialZoom = this.getInitialZoom();
      if (cz !== initialZoom) {
        z = initialZoom;
      }
    }
    this.setCamera(
      new Vec(cx + (x / z - x) - (x / cz - x), cy + (y / z - y) - (y / cz - y), z),
      opts
    );
    return this;
  }
  /**
   * Zoom the camera in.
   *
   * @example
   * ```ts
   * editor.zoomIn()
   * editor.zoomIn(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.zoomIn(editor.inputs.currentScreenPoint, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom in on. Defaults to the screen center
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomIn(point = this.getViewportScreenCenter(), opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const { x: cx, y: cy, z: cz } = this.getCamera();
    const { zoomSteps } = this.getCameraOptions();
    if (zoomSteps !== null && zoomSteps.length > 1) {
      const baseZoom = this.getBaseZoom();
      let zoom = last(zoomSteps) * baseZoom;
      for (let i = 1; i < zoomSteps.length; i++) {
        const z1 = zoomSteps[i - 1] * baseZoom;
        const z2 = zoomSteps[i] * baseZoom;
        if (z2 - cz <= (z2 - z1) / 2) continue;
        zoom = z2;
        break;
      }
      this.setCamera(
        new Vec(
          cx + (point.x / zoom - point.x) - (point.x / cz - point.x),
          cy + (point.y / zoom - point.y) - (point.y / cz - point.y),
          zoom
        ),
        opts
      );
    }
    return this;
  }
  /**
   * Zoom the camera out.
   *
   * @example
   * ```ts
   * editor.zoomOut()
   * editor.zoomOut(editor.getViewportScreenCenter(), { animation: { duration: 120 } })
   * editor.zoomOut(editor.inputs.currentScreenPoint, { animation: { duration: 120 } })
   * ```
   *
   * @param point - The point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomOut(point = this.getViewportScreenCenter(), opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const { zoomSteps } = this.getCameraOptions();
    if (zoomSteps !== null && zoomSteps.length > 1) {
      const baseZoom = this.getBaseZoom();
      const { x: cx, y: cy, z: cz } = this.getCamera();
      let zoom = zoomSteps[0] * baseZoom;
      for (let i = zoomSteps.length - 1; i > 0; i--) {
        const z1 = zoomSteps[i - 1] * baseZoom;
        const z2 = zoomSteps[i] * baseZoom;
        if (z2 - cz >= (z2 - z1) / 2) continue;
        zoom = z1;
        break;
      }
      this.setCamera(
        new Vec(
          cx + (point.x / zoom - point.x) - (point.x / cz - point.x),
          cy + (point.y / zoom - point.y) - (point.y / cz - point.y),
          zoom
        ),
        opts
      );
    }
    return this;
  }
  /**
   * Zoom the camera to fit the current selection in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToSelection()
   * editor.zoomToSelection({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToSelection(opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const selectionPageBounds = this.getSelectionPageBounds();
    if (selectionPageBounds) {
      this.zoomToBounds(selectionPageBounds, {
        targetZoom: Math.max(1, this.getZoomLevel()),
        ...opts
      });
    }
    return this;
  }
  /**
   * Zoom the camera to the current selection if offscreen.
   *
   * @public
   */
  zoomToSelectionIfOffscreen(padding = 16, opts) {
    const selectionPageBounds = this.getSelectionPageBounds();
    const viewportPageBounds = this.getViewportPageBounds();
    if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
      const eb = selectionPageBounds.clone().expandBy(padding / this.getZoomLevel()).expand(viewportPageBounds);
      const nextBounds = viewportPageBounds.clone().translate({
        x: (eb.center.x - viewportPageBounds.center.x) * 2,
        y: (eb.center.y - viewportPageBounds.center.y) * 2
      });
      this.zoomToBounds(nextBounds, opts);
    }
  }
  /**
   * Zoom the camera to fit a bounding box (in the current page space).
   *
   * @example
   * ```ts
   * editor.zoomToBounds(myBounds)
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 } })
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 }, inset: 0, targetZoom: 1 })
   * ```
   *
   * @param bounds - The bounding box.
   * @param opts - The camera move options, target zoom, or custom inset amount.
   *
   * @public
   */
  zoomToBounds(bounds, opts) {
    const cameraOptions = this._cameraOptions.__unsafe__getWithoutCapture();
    if (cameraOptions.isLocked && !opts?.force) return this;
    const viewportScreenBounds = this.getViewportScreenBounds();
    const inset = opts?.inset ?? Math.min(ZOOM_TO_FIT_PADDING, viewportScreenBounds.width * 0.28);
    const baseZoom = this.getBaseZoom();
    const zoomMin = cameraOptions.zoomSteps[0];
    const zoomMax = last(cameraOptions.zoomSteps);
    let zoom = clamp$3(
      Math.min(
        (viewportScreenBounds.width - inset) / bounds.w,
        (viewportScreenBounds.height - inset) / bounds.h
      ),
      zoomMin * baseZoom,
      zoomMax * baseZoom
    );
    if (opts?.targetZoom !== void 0) {
      zoom = Math.min(opts.targetZoom, zoom);
    }
    this.setCamera(
      new Vec(
        -bounds.x + (viewportScreenBounds.width - bounds.w * zoom) / 2 / zoom,
        -bounds.y + (viewportScreenBounds.height - bounds.h * zoom) / 2 / zoom,
        zoom
      ),
      opts
    );
    return this;
  }
  /**
   * Stop the current camera animation, if any.
   *
   * @example
   * ```ts
   * editor.stopCameraAnimation()
   * ```
   *
   * @public
   */
  stopCameraAnimation() {
    this.emit("stop-camera-animation");
    return this;
  }
  /** @internal */
  _animateViewport(ms) {
    if (!this._viewportAnimation) return;
    this._viewportAnimation.elapsed += ms;
    const { elapsed, easing, duration, start, end } = this._viewportAnimation;
    if (elapsed > duration) {
      this.off("tick", this._animateViewport);
      this._viewportAnimation = null;
      this._setCamera(new Vec(-end.x, -end.y, this.getViewportScreenBounds().width / end.width));
      return;
    }
    const remaining = duration - elapsed;
    const t2 = easing(1 - remaining / duration);
    const left = start.minX + (end.minX - start.minX) * t2;
    const top = start.minY + (end.minY - start.minY) * t2;
    const right = start.maxX + (end.maxX - start.maxX) * t2;
    this._setCamera(new Vec(-left, -top, this.getViewportScreenBounds().width / (right - left)), {
      force: true
    });
  }
  /** @internal */
  _animateToViewport(targetViewportPage, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    const { animation, ...rest } = opts;
    if (!animation) return;
    const { duration = 0, easing = EASINGS.easeInOutCubic } = animation;
    const animationSpeed = this.user.getAnimationSpeed();
    const viewportPageBounds = this.getViewportPageBounds();
    this.stopCameraAnimation();
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    if (duration === 0 || animationSpeed === 0) {
      return this._setCamera(
        new Vec(
          -targetViewportPage.x,
          -targetViewportPage.y,
          this.getViewportScreenBounds().width / targetViewportPage.width
        ),
        { ...rest }
      );
    }
    this._viewportAnimation = {
      elapsed: 0,
      duration: duration / animationSpeed,
      easing,
      start: viewportPageBounds.clone(),
      end: targetViewportPage.clone()
    };
    this.once("stop-camera-animation", () => {
      this.off("tick", this._animateViewport);
      this._viewportAnimation = null;
    });
    this.on("tick", this._animateViewport);
    return this;
  }
  /**
   * Slide the camera in a certain direction.
   *
   * @example
   * ```ts
   * editor.slideCamera({ speed: 1, direction: { x: 1, y: 0 }, friction: 0.1 })
   * ```
   *
   * @param opts - Options for the slide
   * @public
   */
  slideCamera(opts = {}) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const animationSpeed = this.user.getAnimationSpeed();
    if (animationSpeed === 0) return this;
    this.stopCameraAnimation();
    const {
      speed,
      friction = this.options.cameraSlideFriction,
      direction,
      speedThreshold = 0.01
    } = opts;
    let currentSpeed = Math.min(speed, 1);
    const cancel = () => {
      this.off("tick", moveCamera);
      this.off("stop-camera-animation", cancel);
    };
    this.once("stop-camera-animation", cancel);
    const moveCamera = (elapsed) => {
      const { x: cx, y: cy, z: cz } = this.getCamera();
      const movementVec = Vec.Mul(direction, currentSpeed * elapsed / cz);
      currentSpeed *= 1 - friction;
      if (currentSpeed < speedThreshold) {
        cancel();
      } else {
        this._setCamera(new Vec(cx + movementVec.x, cy + movementVec.y, cz));
      }
    };
    this.on("tick", moveCamera);
    return this;
  }
  /**
   * Animate the camera to a user's cursor position. This also briefly show the user's cursor if it's not currently visible.
   *
   * @example
   * ```ts
   * editor.zoomToUser(myUserId)
   * editor.zoomToUser(myUserId, { animation: { duration: 200 } })
   * ```
   *
   * @param userId - The id of the user to animate to.
   * @param opts - The camera move options.
   * @public
   */
  zoomToUser(userId, opts = { animation: { duration: 500 } }) {
    const presence = this.getCollaborators().find((c) => c.userId === userId);
    if (!presence) return this;
    const cursor = presence.cursor;
    if (!cursor) return this;
    this.run(() => {
      if (this.getInstanceState().followingUserId !== null) {
        this.stopFollowingUser();
      }
      const isOnSamePage = presence.currentPageId === this.getCurrentPageId();
      if (!isOnSamePage) {
        this.setCurrentPage(presence.currentPageId);
      }
      if (opts && opts.animation && !isOnSamePage) {
        opts.animation = void 0;
      }
      this.centerOnPoint(cursor, opts);
      const { highlightedUserIds } = this.getInstanceState();
      this.updateInstanceState({ highlightedUserIds: [...highlightedUserIds, userId] });
      this.timers.setTimeout(() => {
        const highlightedUserIds2 = [...this.getInstanceState().highlightedUserIds];
        const index2 = highlightedUserIds2.indexOf(userId);
        if (index2 < 0) return;
        highlightedUserIds2.splice(index2, 1);
        this.updateInstanceState({ highlightedUserIds: highlightedUserIds2 });
      }, this.options.collaboratorIdleTimeoutMs);
    });
    return this;
  }
  /**
   * Update the viewport. The viewport will measure the size and screen position of its container
   * element. This should be done whenever the container's position on the screen changes.
   *
   * @example
   * ```ts
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024))
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024), true)
   * ```
   *
   * @param screenBounds - The new screen bounds of the viewport.
   * @param center - Whether to preserve the viewport page center as the viewport changes.
   *
   * @public
   */
  updateViewportScreenBounds(screenBounds, center = false) {
    if (!(screenBounds instanceof Box)) {
      const rect = screenBounds.getBoundingClientRect();
      screenBounds = new Box(
        rect.left || rect.x,
        rect.top || rect.y,
        Math.max(rect.width, 1),
        Math.max(rect.height, 1)
      );
    } else {
      screenBounds.width = Math.max(screenBounds.width, 1);
      screenBounds.height = Math.max(screenBounds.height, 1);
    }
    const insets = [
      // top
      screenBounds.minY !== 0,
      // right
      !approximately(document.body.scrollWidth, screenBounds.maxX, 1),
      // bottom
      !approximately(document.body.scrollHeight, screenBounds.maxY, 1),
      // left
      screenBounds.minX !== 0
    ];
    const { _willSetInitialBounds } = this;
    this._willSetInitialBounds = false;
    const { screenBounds: prevScreenBounds, insets: prevInsets } = this.getInstanceState();
    if (screenBounds.equals(prevScreenBounds) && insets.every((v, i) => v === prevInsets[i])) {
      return this;
    }
    if (_willSetInitialBounds) {
      this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
      this.setCamera(this.getCamera());
    } else {
      if (center && !this.getInstanceState().followingUserId) {
        const before = this.getViewportPageBounds().center;
        this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
        this.centerOnPoint(before);
      } else {
        this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
        this._setCamera(Vec.From({ ...this.getCamera() }));
      }
    }
    this._tickCameraState();
    return this;
  }
  getViewportScreenBounds() {
    const { x, y, w, h: h2 } = this.getInstanceState().screenBounds;
    return new Box(x, y, w, h2);
  }
  getViewportScreenCenter() {
    const viewportScreenBounds = this.getViewportScreenBounds();
    return new Vec(viewportScreenBounds.w / 2, viewportScreenBounds.h / 2);
  }
  getViewportPageBounds() {
    const { w, h: h2 } = this.getViewportScreenBounds();
    const { x: cx, y: cy, z: cz } = this.getCamera();
    return new Box(-cx, -cy, w / cz, h2 / cz);
  }
  /**
   * Convert a point in screen space to a point in the current page space.
   *
   * @example
   * ```ts
   * editor.screenToPage({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in screen space.
   *
   * @public
   */
  screenToPage(point) {
    const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec(
      (point.x - screenBounds.x) / cz - cx,
      (point.y - screenBounds.y) / cz - cy,
      point.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current screen space.
   *
   * @example
   * ```ts
   * editor.pageToScreen({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToScreen(point) {
    const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec(
      (point.x + cx) * cz + screenBounds.x,
      (point.y + cy) * cz + screenBounds.y,
      point.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current viewport space.
   *
   * @example
   * ```ts
   * editor.pageToViewport({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToViewport(point) {
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec((point.x + cx) * cz, (point.y + cy) * cz, point.z ?? 0.5);
  }
  _getCollaboratorsQuery() {
    return this.store.query.records("instance_presence", () => ({
      userId: { neq: this.user.getId() }
    }));
  }
  getCollaborators() {
    const allPresenceRecords = this._getCollaboratorsQuery().get();
    if (!allPresenceRecords.length) return EMPTY_ARRAY;
    const userIds = [...new Set(allPresenceRecords.map((c) => c.userId))].sort();
    return userIds.map((id) => {
      const latestPresence = maxBy(
        allPresenceRecords.filter((c) => c.userId === id),
        (p) => p.lastActivityTimestamp ?? 0
      );
      return latestPresence;
    });
  }
  getCollaboratorsOnCurrentPage() {
    const currentPageId = this.getCurrentPageId();
    return this.getCollaborators().filter((c) => c.currentPageId === currentPageId);
  }
  /**
   * Start viewport-following a user.
   *
   * @example
   * ```ts
   * editor.startFollowingUser(myUserId)
   * ```
   *
   * @param userId - The id of the user to follow.
   *
   * @public
   */
  startFollowingUser(userId) {
    this.stopFollowingUser();
    const thisUserId = this.user.getId();
    if (!thisUserId) {
      console.warn("You should set the userId for the current instance before following a user");
    }
    const leaderPresence = this._getFollowingPresence(userId);
    if (!leaderPresence) {
      return this;
    }
    const latestLeaderPresence = computed("latestLeaderPresence", () => {
      return this._getFollowingPresence(userId);
    });
    transact(() => {
      this.updateInstanceState({ followingUserId: userId }, { history: "ignore" });
      const dispose = react("update current page", () => {
        const leaderPresence2 = latestLeaderPresence.get();
        if (!leaderPresence2) {
          this.stopFollowingUser();
          return;
        }
        if (leaderPresence2.currentPageId !== this.getCurrentPageId() && this.getPage(leaderPresence2.currentPageId)) {
          this.run(
            () => {
              this.store.put([
                { ...this.getInstanceState(), currentPageId: leaderPresence2.currentPageId }
              ]);
              this._isLockedOnFollowingUser.set(true);
            },
            { history: "ignore" }
          );
        }
      });
      const cancel = () => {
        dispose();
        this._isLockedOnFollowingUser.set(false);
        this.off("frame", moveTowardsUser);
        this.off("stop-following", cancel);
      };
      const moveTowardsUser = () => {
        const leaderPresence2 = latestLeaderPresence.get();
        if (!leaderPresence2) {
          this.stopFollowingUser();
          return;
        }
        if (this._isLockedOnFollowingUser.get()) return;
        const animationSpeed = this.user.getAnimationSpeed();
        if (animationSpeed === 0) {
          this._isLockedOnFollowingUser.set(true);
          return;
        }
        const targetViewport = this.getViewportPageBoundsForFollowing();
        if (!targetViewport) {
          this.stopFollowingUser();
          return;
        }
        const currentViewport = this.getViewportPageBounds();
        const diffX = Math.abs(targetViewport.minX - currentViewport.minX) + Math.abs(targetViewport.maxX - currentViewport.maxX);
        const diffY = Math.abs(targetViewport.minY - currentViewport.minY) + Math.abs(targetViewport.maxY - currentViewport.maxY);
        if (diffX < this.options.followChaseViewportSnap && diffY < this.options.followChaseViewportSnap) {
          this._isLockedOnFollowingUser.set(true);
          return;
        }
        const t2 = clamp$3(animationSpeed * 0.5, 0.1, 0.8);
        const nextViewport = new Box(
          lerp(currentViewport.minX, targetViewport.minX, t2),
          lerp(currentViewport.minY, targetViewport.minY, t2),
          lerp(currentViewport.width, targetViewport.width, t2),
          lerp(currentViewport.height, targetViewport.height, t2)
        );
        const nextCamera = new Vec(
          -nextViewport.x,
          -nextViewport.y,
          this.getViewportScreenBounds().width / nextViewport.width
        );
        this.stopCameraAnimation();
        this._setCamera(nextCamera);
      };
      this.once("stop-following", cancel);
      this.addListener("frame", moveTowardsUser);
      moveTowardsUser();
    });
    return this;
  }
  /**
   * Stop viewport-following a user.
   *
   * @example
   * ```ts
   * editor.stopFollowingUser()
   * ```
   * @public
   */
  stopFollowingUser() {
    this.run(
      () => {
        this.store.put([this.getCamera()]);
        this._isLockedOnFollowingUser.set(false);
        this.updateInstanceState({ followingUserId: null });
        this.emit("stop-following");
      },
      { history: "ignore" }
    );
    return this;
  }
  /** @internal */
  getUnorderedRenderingShapes(useEditorState) {
    const renderingShapes = [];
    let nextIndex = this.options.maxShapesPerPage * 2;
    let nextBackgroundIndex = this.options.maxShapesPerPage;
    const erasingShapeIds = this.getErasingShapeIds();
    const addShapeById = (id, opacity, isAncestorErasing) => {
      const shape = this.getShape(id);
      if (!shape) return;
      if (this.isShapeHidden(shape)) {
        const isErasing = isAncestorErasing || erasingShapeIds.includes(id);
        for (const childId of this.getSortedChildIdsForParent(id)) {
          addShapeById(childId, opacity, isErasing);
        }
        return;
      }
      opacity *= shape.opacity;
      let isShapeErasing = false;
      const util = this.getShapeUtil(shape);
      if (useEditorState) {
        isShapeErasing = !isAncestorErasing && erasingShapeIds.includes(id);
        if (isShapeErasing) {
          opacity *= 0.32;
        }
      }
      renderingShapes.push({
        id,
        shape,
        util,
        index: nextIndex,
        backgroundIndex: nextBackgroundIndex,
        opacity
      });
      nextIndex += 1;
      nextBackgroundIndex += 1;
      const childIds = this.getSortedChildIdsForParent(id);
      if (!childIds.length) return;
      let backgroundIndexToRestore = null;
      if (util.providesBackgroundForChildren(shape)) {
        backgroundIndexToRestore = nextBackgroundIndex;
        nextBackgroundIndex = nextIndex;
        nextIndex += this.options.maxShapesPerPage;
      }
      for (const childId of childIds) {
        addShapeById(childId, opacity, isAncestorErasing || isShapeErasing);
      }
      if (backgroundIndexToRestore !== null) {
        nextBackgroundIndex = backgroundIndexToRestore;
      }
    };
    const pages = useEditorState ? [this.getCurrentPage()] : this.getPages();
    for (const page of pages) {
      for (const childId of this.getSortedChildIdsForParent(page.id)) {
        addShapeById(childId, 1, false);
      }
    }
    return renderingShapes;
  }
  _decayCameraStateTimeout(elapsed) {
    this._cameraStateTimeoutRemaining -= elapsed;
    if (this._cameraStateTimeoutRemaining > 0) return;
    this.off("tick", this._decayCameraStateTimeout);
    this._cameraState.set("idle");
  }
  _tickCameraState() {
    this._cameraStateTimeoutRemaining = this.options.cameraMovingTimeoutMs;
    if (this._cameraState.__unsafe__getWithoutCapture() !== "idle") return;
    this._cameraState.set("moving");
    this.on("tick", this._decayCameraStateTimeout);
  }
  /**
   * Whether the camera is moving or idle.
   *
   * @example
   * ```ts
   * editor.getCameraState()
   * ```
   *
   * @public
   */
  getCameraState() {
    return this._cameraState.get();
  }
  getRenderingShapes() {
    const renderingShapes = this.getUnorderedRenderingShapes(true);
    return renderingShapes.sort(sortById);
  }
  _getAllPagesQuery() {
    return this.store.query.records("page");
  }
  getPages() {
    return Array.from(this._getAllPagesQuery().get()).sort(sortByIndex);
  }
  /**
   * The current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPage()
   * ```
   *
   * @public
   */
  getCurrentPage() {
    return this.getPage(this.getCurrentPageId());
  }
  getCurrentPageId() {
    return this.getInstanceState().currentPageId;
  }
  /**
   * Get a page.
   *
   * @example
   * ```ts
   * editor.getPage(myPage.id)
   * editor.getPage(myPage)
   * ```
   *
   * @param page - The page (or the page id) to get.
   *
   * @public
   */
  getPage(page) {
    return this.store.get(typeof page === "string" ? page : page.id);
  }
  /**
   * An array of all of the shapes on the current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPageIds()
   * ```
   *
   * @public
   */
  getCurrentPageShapeIds() {
    return this._currentPageShapeIds.get();
  }
  getCurrentPageShapeIdsSorted() {
    return Array.from(this.getCurrentPageShapeIds()).sort();
  }
  /**
   * Get the ids of shapes on a page.
   *
   * @example
   * ```ts
   * const idsOnPage1 = editor.getPageShapeIds('page1')
   * const idsOnPage2 = editor.getPageShapeIds(myPage2)
   * ```
   *
   * @param page - The page (or the page id) to get the shape ids for.
   *
   * @public
   **/
  getPageShapeIds(page) {
    const pageId = typeof page === "string" ? page : page.id;
    const result = this.store.query.exec("shape", { parentId: { eq: pageId } });
    return this.getShapeAndDescendantIds(result.map((s) => s.id));
  }
  /**
   * Set the current page.
   *
   * @example
   * ```ts
   * editor.setCurrentPage('page1')
   * editor.setCurrentPage(myPage1)
   * ```
   *
   * @param page - The page (or the page id) to set as the current page.
   *
   * @public
   */
  setCurrentPage(page) {
    const pageId = typeof page === "string" ? page : page.id;
    if (!this.store.has(pageId)) {
      console.error("Tried to set the current page id to a page that doesn't exist.");
      return this;
    }
    this.stopFollowingUser();
    this.complete();
    return this.run(
      () => {
        this.store.put([{ ...this.getInstanceState(), currentPageId: pageId }]);
        this.setCamera(this.getCamera());
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Update a page.
   *
   * @example
   * ```ts
   * editor.updatePage({ id: 'page2', name: 'Page 2' })
   * ```
   *
   * @param partial - The partial of the shape to update.
   *
   * @public
   */
  updatePage(partial) {
    if (this.getIsReadonly()) return this;
    const prev = this.getPage(partial.id);
    if (!prev) return this;
    return this.run(() => this.store.update(partial.id, (page) => ({ ...page, ...partial })));
  }
  /**
   * Create a page whilst ensuring that the page name is unique.
   *
   * @example
   * ```ts
   * editor.createPage(myPage)
   * editor.createPage({ name: 'Page 2' })
   * ```
   *
   * @param page - The page (or page partial) to create.
   *
   * @public
   */
  createPage(page) {
    this.run(() => {
      if (this.getIsReadonly()) return;
      if (this.getPages().length >= this.options.maxPages) return;
      const pages = this.getPages();
      const name = getIncrementedName(
        page.name ?? "Page 1",
        pages.map((p) => p.name)
      );
      let index2 = page.index;
      if (!index2 || pages.some((p) => p.index === index2)) {
        index2 = getIndexAbove(pages[pages.length - 1].index);
      }
      const newPage = PageRecordType.create({
        meta: {},
        ...page,
        name,
        index: index2
      });
      this.store.put([newPage]);
    });
    return this;
  }
  /**
   * Delete a page.
   *
   * @example
   * ```ts
   * editor.deletePage('page1')
   * ```
   *
   * @param page - The page (or the page id) to delete.
   *
   * @public
   */
  deletePage(page) {
    const id = typeof page === "string" ? page : page.id;
    this.run(
      () => {
        if (this.getIsReadonly()) return;
        const pages = this.getPages();
        if (pages.length === 1) return;
        const deletedPage = this.getPage(id);
        if (!deletedPage) return;
        if (id === this.getCurrentPageId()) {
          const index2 = pages.findIndex((page2) => page2.id === id);
          const next = pages[index2 - 1] ?? pages[index2 + 1];
          this.setCurrentPage(next.id);
        }
        const shapes = this.getSortedChildIdsForParent(deletedPage.id);
        this.deleteShapes(shapes);
        this.store.remove([deletedPage.id]);
      },
      { ignoreShapeLock: true }
    );
    return this;
  }
  /**
   * Duplicate a page.
   *
   * @param page - The page (or the page id) to duplicate. Defaults to the current page.
   * @param createId - The id of the new page. Defaults to a new id.
   *
   * @public
   */
  duplicatePage(page, createId = PageRecordType.createId()) {
    if (this.getPages().length >= this.options.maxPages) return this;
    const id = typeof page === "string" ? page : page.id;
    const freshPage = this.getPage(id);
    if (!freshPage) return this;
    const prevCamera = { ...this.getCamera() };
    const content = this.getContentFromCurrentPage(this.getSortedChildIdsForParent(freshPage.id));
    this.run(() => {
      const pages = this.getPages();
      const index2 = getIndexBetween(freshPage.index, pages[pages.indexOf(freshPage) + 1]?.index);
      this.createPage({ name: freshPage.name + " Copy", id: createId, index: index2 });
      this.setCurrentPage(createId);
      this.setCamera(prevCamera);
      if (content) {
        return this.putContentOntoCurrentPage(content);
      }
    });
    return this;
  }
  /**
   * Rename a page.
   *
   * @example
   * ```ts
   * editor.renamePage('page1', 'My Page')
   * ```
   *
   * @param page - The page (or the page id) to rename.
   * @param name - The new name.
   *
   * @public
   */
  renamePage(page, name) {
    const id = typeof page === "string" ? page : page.id;
    if (this.getIsReadonly()) return this;
    this.updatePage({ id, name });
    return this;
  }
  _getAllAssetsQuery() {
    return this.store.query.records("asset");
  }
  /**
   * Get all assets in the editor.
   *
   * @public
   */
  getAssets() {
    return this._getAllAssetsQuery().get();
  }
  /**
   * Create one or more assets.
   *
   * @example
   * ```ts
   * editor.createAssets([...myAssets])
   * ```
   *
   * @param assets - The assets to create.
   *
   * @public
   */
  createAssets(assets) {
    if (this.getIsReadonly()) return this;
    if (assets.length <= 0) return this;
    this.run(() => this.store.put(assets), { history: "ignore" });
    return this;
  }
  /**
   * Update one or more assets.
   *
   * @example
   * ```ts
   * editor.updateAssets([{ id: 'asset1', name: 'New name' }])
   * ```
   *
   * @param assets - The assets to update.
   *
   * @public
   */
  updateAssets(assets) {
    if (this.getIsReadonly()) return this;
    if (assets.length <= 0) return this;
    this.run(
      () => {
        this.store.put(
          assets.map((partial) => ({
            ...this.store.get(partial.id),
            ...partial
          }))
        );
      },
      { history: "ignore" }
    );
    return this;
  }
  /**
   * Delete one or more assets.
   *
   * @example
   * ```ts
   * editor.deleteAssets(['asset1', 'asset2'])
   * ```
   *
   * @param assets - The assets (or asset ids) to delete.
   *
   * @public
   */
  deleteAssets(assets) {
    if (this.getIsReadonly()) return this;
    const ids = typeof assets[0] === "string" ? assets : assets.map((a) => a.id);
    if (ids.length <= 0) return this;
    this.run(
      () => {
        this.store.props.assets.remove?.(ids);
        this.store.remove(ids);
      },
      { history: "ignore" }
    );
    return this;
  }
  /**
   * Get an asset by its id.
   *
   * @example
   * ```ts
   * editor.getAsset('asset1')
   * ```
   *
   * @param asset - The asset (or asset id) to get.
   *
   * @public
   */
  getAsset(asset) {
    return this.store.get(typeof asset === "string" ? asset : asset.id);
  }
  async resolveAssetUrl(assetId, context) {
    if (!assetId) return null;
    const asset = this.getAsset(assetId);
    if (!asset) return null;
    const {
      screenScale = 1,
      shouldResolveToOriginal = false,
      dpr = this.getInstanceState().devicePixelRatio
    } = context;
    const zoomStepFunction = (zoom) => Math.pow(2, Math.ceil(Math.log2(zoom)));
    const steppedScreenScale = zoomStepFunction(screenScale);
    const networkEffectiveType = "connection" in navigator ? navigator.connection.effectiveType : null;
    return await this.store.props.assets.resolve(asset, {
      screenScale: screenScale || 1,
      steppedScreenScale,
      dpr,
      networkEffectiveType,
      shouldResolveToOriginal
    });
  }
  /**
   * Upload an asset to the store's asset service, returning a URL that can be used to resolve the
   * asset.
   */
  async uploadAsset(asset, file, abortSignal) {
    return await this.store.props.assets.upload(asset, file, abortSignal);
  }
  /**
   * Get the geometry of a shape in shape-space.
   *
   * @example
   * ```ts
   * editor.getShapeGeometry(myShape)
   * editor.getShapeGeometry(myShapeId)
   * editor.getShapeGeometry(myShapeId, { context: "arrow" })
   * ```
   *
   * @param shape - The shape (or shape id) to get the geometry for.
   * @param opts - Additional options about the request for geometry. Passed to {@link ShapeUtil.getGeometry}.
   *
   * @public
   */
  getShapeGeometry(shape, opts) {
    const context = opts?.context ?? "none";
    if (!this._shapeGeometryCaches[context]) {
      this._shapeGeometryCaches[context] = this.store.createComputedCache(
        "bounds",
        (shape2) => {
          this.fonts.trackFontsForShape(shape2);
          return this.getShapeUtil(shape2).getGeometry(shape2, opts);
        },
        { areRecordsEqual: areShapesContentEqual }
      );
    }
    return this._shapeGeometryCaches[context].get(
      typeof shape === "string" ? shape : shape.id
    );
  }
  _getShapeHandlesCache() {
    return this.store.createComputedCache(
      "handles",
      (shape) => {
        return this.getShapeUtil(shape).getHandles?.(shape);
      },
      {
        areRecordsEqual: areShapesContentEqual
      }
    );
  }
  /**
   * Get the handles (if any) for a shape.
   *
   * @example
   * ```ts
   * editor.getShapeHandles(myShape)
   * editor.getShapeHandles(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the handles for.
   * @public
   */
  getShapeHandles(shape) {
    return this._getShapeHandlesCache().get(typeof shape === "string" ? shape : shape.id);
  }
  /**
   * Get the local transform for a shape as a matrix model. This transform reflects both its
   * translation (x, y) from from either its parent's top left corner, if the shape's parent is
   * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
   * shape's rotation.
   *
   * @example
   * ```ts
   * editor.getShapeLocalTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the local transform for.
   *
   * @public
   */
  getShapeLocalTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) throw Error("Editor.getTransform: shape not found");
    return Mat.Identity().translate(freshShape.x, freshShape.y).rotate(freshShape.rotation);
  }
  _getShapePageTransformCache() {
    return this.store.createComputedCache("pageTransformCache", (shape) => {
      if (isPageId(shape.parentId)) {
        return this.getShapeLocalTransform(shape);
      }
      const parentTransform = this._getShapePageTransformCache().get(shape.parentId) ?? Mat.Identity();
      return Mat.Compose(parentTransform, this.getShapeLocalTransform(shape));
    });
  }
  /**
   * Get the local transform of a shape's parent as a matrix model.
   *
   * @example
   * ```ts
   * editor.getShapeParentTransform(myShape)
   * ```
   *
   * @param shape - The shape (or shape id) to get the parent transform for.
   *
   * @public
   */
  getShapeParentTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape || isPageId(freshShape.parentId)) return Mat.Identity();
    return this._getShapePageTransformCache().get(freshShape.parentId) ?? Mat.Identity();
  }
  /**
   * Get the transform of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageTransform(myShape)
   * editor.getShapePageTransform(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the page transform for.
   *
   * @public
   */
  getShapePageTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this._getShapePageTransformCache().get(id) ?? Mat.Identity();
  }
  _getShapePageBoundsCache() {
    return this.store.createComputedCache("pageBoundsCache", (shape) => {
      const pageTransform = this.getShapePageTransform(shape);
      if (!pageTransform) return void 0;
      return Box.FromPoints(
        pageTransform.applyToPoints(this.getShapeGeometry(shape).boundsVertices)
      );
    });
  }
  /**
   * Get the bounds of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageBounds(myShape)
   * editor.getShapePageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the bounds for.
   *
   * @public
   */
  getShapePageBounds(shape) {
    return this._getShapePageBoundsCache().get(typeof shape === "string" ? shape : shape.id);
  }
  _getShapeClipPathCache() {
    return this.store.createComputedCache("clipPathCache", (shape) => {
      const pageMask = this._getShapeMaskCache().get(shape.id);
      if (!pageMask) return void 0;
      if (pageMask.length === 0) {
        return `polygon(0px 0px, 0px 0px, 0px 0px)`;
      }
      const pageTransform = this._getShapePageTransformCache().get(shape.id);
      if (!pageTransform) return void 0;
      const localMask = Mat.applyToPoints(Mat.Inverse(pageTransform), pageMask);
      return `polygon(${localMask.map((p) => `${p.x}px ${p.y}px`).join(",")})`;
    });
  }
  /**
   * Get the clip path for a shape.
   *
   * @example
   * ```ts
   * const clipPath = editor.getShapeClipPath(shape)
   * const clipPath = editor.getShapeClipPath(shape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to get the clip path for.
   *
   * @returns The clip path or undefined.
   *
   * @public
   */
  getShapeClipPath(shape) {
    return this._getShapeClipPathCache().get(typeof shape === "string" ? shape : shape.id);
  }
  _getShapeMaskCache() {
    return this.store.createComputedCache("pageMaskCache", (shape) => {
      if (isPageId(shape.parentId)) return void 0;
      const clipPaths = [];
      for (const ancestor of this.getShapeAncestors(shape.id)) {
        const util = this.getShapeUtil(ancestor);
        const clipPath = util.getClipPath?.(ancestor);
        if (!clipPath) continue;
        if (util.shouldClipChild?.(shape) === false) continue;
        const pageTransform = this.getShapePageTransform(ancestor.id);
        clipPaths.push(pageTransform.applyToPoints(clipPath));
      }
      if (clipPaths.length === 0) return void 0;
      const pageMask = clipPaths.reduce((acc, b) => {
        const intersection = intersectPolygonPolygon(acc, b);
        if (intersection) {
          return intersection.map(Vec.Cast);
        }
        return [];
      });
      return pageMask;
    });
  }
  /**
   * Get the mask (in the current page space) for a shape.
   *
   * @example
   * ```ts
   * const pageMask = editor.getShapeMask(shape.id)
   * ```
   *
   * @param shape - The shape (or the shape id) of the shape to get the mask for.
   *
   * @returns The mask for the shape.
   *
   * @public
   */
  getShapeMask(shape) {
    return this._getShapeMaskCache().get(typeof shape === "string" ? shape : shape.id);
  }
  /**
   * Get the bounds of a shape in the current page space, incorporating any masks. For example, if the
   * shape were the child of a frame and was half way out of the frame, the bounds would be the half
   * of the shape that was in the frame.
   *
   * @example
   * ```ts
   * editor.getShapeMaskedPageBounds(myShape)
   * editor.getShapeMaskedPageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape to get the masked bounds for.
   *
   * @public
   */
  getShapeMaskedPageBounds(shape) {
    if (typeof shape !== "string") shape = shape.id;
    return this._getShapeMaskedPageBoundsCache().get(shape);
  }
  _getShapeMaskedPageBoundsCache() {
    return this.store.createComputedCache("shapeMaskedPageBoundsCache", (shape) => {
      const pageBounds = this._getShapePageBoundsCache().get(shape.id);
      if (!pageBounds) return;
      const pageMask = this._getShapeMaskCache().get(shape.id);
      if (pageMask) {
        if (pageMask.length === 0) return void 0;
        const { corners } = pageBounds;
        if (corners.every((p, i) => p && Vec.Equals(p, pageMask[i]))) return pageBounds.clone();
        const intersection = intersectPolygonPolygon(pageMask, corners);
        if (!intersection) return;
        return Box.FromPoints(intersection);
      }
      return pageBounds;
    });
  }
  /**
   * Get the ancestors of a shape.
   *
   * @example
   * ```ts
   * const ancestors = editor.getShapeAncestors(myShape)
   * const ancestors = editor.getShapeAncestors(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the ancestors for.
   * @param acc - The accumulator.
   *
   * @public
   */
  getShapeAncestors(shape, acc = []) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) return acc;
    const parentId = freshShape.parentId;
    if (isPageId(parentId)) {
      acc.reverse();
      return acc;
    }
    const parent = this.store.get(parentId);
    if (!parent) return acc;
    acc.push(parent);
    return this.getShapeAncestors(parent, acc);
  }
  /**
   * Find the first ancestor matching the given predicate
   *
   * @example
   * ```ts
   * const ancestor = editor.findShapeAncestor(myShape)
   * const ancestor = editor.findShapeAncestor(myShape.id)
   * const ancestor = editor.findShapeAncestor(myShape.id, (shape) => shape.type === 'frame')
   * ```
   *
   * @param shape - The shape to check the ancestors for.
   * @param predicate - The predicate to match.
   *
   * @public
   */
  findShapeAncestor(shape, predicate) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) return;
    const parentId = freshShape.parentId;
    if (isPageId(parentId)) return;
    const parent = this.getShape(parentId);
    if (!parent) return;
    return predicate(parent) ? parent : this.findShapeAncestor(parent, predicate);
  }
  /**
   * Returns true if the the given shape has the given ancestor.
   *
   * @param shape - The shape.
   * @param ancestorId - The id of the ancestor.
   *
   * @public
   */
  hasAncestor(shape, ancestorId) {
    const id = typeof shape === "string" ? shape : shape?.id;
    const freshShape = id && this.getShape(id);
    if (!freshShape) return false;
    if (freshShape.parentId === ancestorId) return true;
    return this.hasAncestor(this.getShapeParent(freshShape), ancestorId);
  }
  /**
   * Get the common ancestor of two or more shapes that matches a predicate.
   *
   * @param shapes - The shapes (or shape ids) to check.
   * @param predicate - The predicate to match.
   */
  findCommonAncestor(shapes, predicate) {
    if (shapes.length === 0) {
      return;
    }
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const freshShapes = compact(ids.map((id) => this.getShape(id)));
    if (freshShapes.length === 1) {
      const parentId = freshShapes[0].parentId;
      if (isPageId(parentId)) {
        return;
      }
      return predicate ? this.findShapeAncestor(freshShapes[0], predicate)?.id : parentId;
    }
    const [nodeA, ...others] = freshShapes;
    let ancestor = this.getShapeParent(nodeA);
    while (ancestor) {
      if (predicate && !predicate(ancestor)) {
        ancestor = this.getShapeParent(ancestor);
        continue;
      }
      if (others.every((shape) => this.hasAncestor(shape, ancestor.id))) {
        return ancestor.id;
      }
      ancestor = this.getShapeParent(ancestor);
    }
    return void 0;
  }
  /**
   * Check whether a shape or its parent is locked.
   *
   * @param shape - The shape (or shape id) to check.
   *
   * @public
   */
  isShapeOrAncestorLocked(shape) {
    const _shape = shape && this.getShape(shape);
    if (_shape === void 0) return false;
    if (_shape.isLocked) return true;
    return this.isShapeOrAncestorLocked(this.getShapeParent(_shape));
  }
  getNotVisibleShapes() {
    return this._notVisibleShapes.get();
  }
  getCulledShapes() {
    const notVisibleShapes2 = this.getNotVisibleShapes();
    const selectedShapeIds = this.getSelectedShapeIds();
    const editingId = this.getEditingShapeId();
    const culledShapes = new Set(notVisibleShapes2);
    if (editingId) {
      culledShapes.delete(editingId);
    }
    selectedShapeIds.forEach((id) => {
      culledShapes.delete(id);
    });
    return culledShapes;
  }
  getCurrentPageBounds() {
    let commonBounds;
    this.getCurrentPageShapeIdsSorted().forEach((shapeId) => {
      const bounds = this.getShapeMaskedPageBounds(shapeId);
      if (!bounds) return;
      if (!commonBounds) {
        commonBounds = bounds.clone();
      } else {
        commonBounds = commonBounds.expand(bounds);
      }
    });
    return commonBounds;
  }
  /**
   * Get the top-most selected shape at the given point, ignoring groups.
   *
   * @param point - The point to check.
   *
   * @returns The top-most selected shape at the given point, or undefined if there is no shape at the point.
   */
  getSelectedShapeAtPoint(point) {
    const selectedShapeIds = this.getSelectedShapeIds();
    return this.getCurrentPageShapesSorted().filter((shape) => shape.type !== "group" && selectedShapeIds.includes(shape.id)).reverse().find((shape) => this.isPointInShape(shape, point, { hitInside: true, margin: 0 }));
  }
  /**
   * Get the shape at the current point.
   *
   * @param point - The point to check.
   * @param opts - Options for the check: `hitInside` to check if the point is inside the shape, `margin` to check if the point is within a margin of the shape, `hitFrameInside` to check if the point is inside the frame, and `filter` to filter the shapes to check.
   *
   * @returns The shape at the given point, or undefined if there is no shape at the point.
   */
  getShapeAtPoint(point, opts = {}) {
    const zoomLevel = this.getZoomLevel();
    const viewportPageBounds = this.getViewportPageBounds();
    const {
      filter: filter2,
      margin = 0,
      hitLocked = false,
      hitLabels = false,
      hitInside = false,
      hitFrameInside = false
    } = opts;
    const [innerMargin, outerMargin] = Array.isArray(margin) ? margin : [margin, margin];
    let inHollowSmallestArea = Infinity;
    let inHollowSmallestAreaHit = null;
    let inMarginClosestToEdgeDistance = Infinity;
    let inMarginClosestToEdgeHit = null;
    const shapesToCheck = (opts.renderingOnly ? this.getCurrentPageRenderingShapesSorted() : this.getCurrentPageShapesSorted()).filter((shape) => {
      if (shape.isLocked && !hitLocked || this.isShapeHidden(shape) || this.isShapeOfType(shape, "group"))
        return false;
      const pageMask = this.getShapeMask(shape);
      if (pageMask && !pointInPolygon(point, pageMask)) return false;
      if (filter2 && !filter2(shape)) return false;
      return true;
    });
    for (let i = shapesToCheck.length - 1; i >= 0; i--) {
      const shape = shapesToCheck[i];
      const geometry = this.getShapeGeometry(shape);
      const isGroup = geometry instanceof Group2d;
      const pointInShapeSpace = this.getPointInShapeSpace(shape, point);
      if (this.isShapeOfType(shape, "frame") || (this.isShapeOfType(shape, "note") || this.isShapeOfType(shape, "arrow") || this.isShapeOfType(shape, "geo") && shape.props.fill === "none") && this.getShapeUtil(shape).getText(shape)?.trim()) {
        for (const childGeometry of geometry.children) {
          if (childGeometry.isLabel && childGeometry.isPointInBounds(pointInShapeSpace)) {
            return shape;
          }
        }
      }
      if (this.isShapeOfType(shape, "frame")) {
        const distance2 = geometry.distanceToPoint(pointInShapeSpace, hitFrameInside);
        if (hitFrameInside ? distance2 > 0 && distance2 <= outerMargin || distance2 <= 0 && distance2 > -innerMargin : distance2 > 0 && distance2 <= outerMargin) {
          return inMarginClosestToEdgeHit || shape;
        }
        if (geometry.hitTestPoint(pointInShapeSpace, 0, true)) {
          return inMarginClosestToEdgeHit || inHollowSmallestAreaHit || (hitFrameInside ? shape : void 0);
        }
        continue;
      }
      let distance;
      if (isGroup) {
        let minDistance = Infinity;
        for (const childGeometry of geometry.children) {
          if (childGeometry.isLabel && !hitLabels) continue;
          const tDistance = childGeometry.distanceToPoint(pointInShapeSpace, hitInside);
          if (tDistance < minDistance) {
            minDistance = tDistance;
          }
        }
        distance = minDistance;
      } else {
        if (outerMargin === 0 && (geometry.bounds.w < 1 || geometry.bounds.h < 1)) {
          distance = geometry.distanceToPoint(pointInShapeSpace, hitInside);
        } else {
          if (geometry.bounds.containsPoint(pointInShapeSpace, outerMargin)) {
            distance = geometry.distanceToPoint(pointInShapeSpace, hitInside);
          } else {
            distance = Infinity;
          }
        }
      }
      if (geometry.isClosed) {
        if (distance <= outerMargin || hitInside && distance <= 0 && distance > -innerMargin) {
          if (geometry.isFilled || isGroup && geometry.children[0].isFilled) {
            return inMarginClosestToEdgeHit || shape;
          } else {
            if (this.getShapePageBounds(shape).contains(viewportPageBounds)) continue;
            if (hitInside ? (
              // On hitInside, the distance will be negative for hits inside
              // If the distance is positive, check against the outer margin
              // If the distance is negative, check against the inner margin
              distance > 0 && distance <= outerMargin || distance <= 0 && distance > -innerMargin
            ) : (
              // If hitInside is false, then sadly _we do not know_ whether the
              // point is inside or outside of the shape, so we check against
              // the max of the two margins
              Math.abs(distance) <= Math.max(innerMargin, outerMargin)
            )) {
              if (Math.abs(distance) < inMarginClosestToEdgeDistance) {
                inMarginClosestToEdgeDistance = Math.abs(distance);
                inMarginClosestToEdgeHit = shape;
              }
            } else if (!inMarginClosestToEdgeHit) {
              const { area } = geometry;
              if (area < inHollowSmallestArea) {
                inHollowSmallestArea = area;
                inHollowSmallestAreaHit = shape;
              }
            }
          }
        }
      } else {
        if (distance < this.options.hitTestMargin / zoomLevel) {
          return shape;
        }
      }
    }
    return inMarginClosestToEdgeHit || inHollowSmallestAreaHit || void 0;
  }
  /**
   * Get the shapes, if any, at a given page point.
   *
   * @example
   * ```ts
   * editor.getShapesAtPoint({ x: 100, y: 100 })
   * editor.getShapesAtPoint({ x: 100, y: 100 }, { hitInside: true, margin: 8 })
   * ```
   *
   * @param point - The page point to test.
   * @param opts - The options for the hit point testing.
   *
   * @returns An array of shapes at the given point, sorted in reverse order of their absolute z-index (top-most shape first).
   *
   * @public
   */
  getShapesAtPoint(point, opts = {}) {
    return this.getCurrentPageShapesSorted().filter((shape) => !this.isShapeHidden(shape) && this.isPointInShape(shape, point, opts)).reverse();
  }
  /**
   * Test whether a point (in the current page space) will will a shape. This method takes into account masks,
   * such as when a shape is the child of a frame and is partially clipped by the frame.
   *
   * @example
   * ```ts
   * editor.isPointInShape({ x: 100, y: 100 }, myShape)
   * ```
   *
   * @param shape - The shape to test against.
   * @param point - The page point to test (in the current page space).
   * @param opts - The options for the hit point testing.
   *
   * @public
   */
  isPointInShape(shape, point, opts = {}) {
    const { hitInside = false, margin = 0 } = opts;
    const id = typeof shape === "string" ? shape : shape.id;
    const pageMask = this.getShapeMask(id);
    if (pageMask && !pointInPolygon(point, pageMask)) return false;
    return this.getShapeGeometry(id).hitTestPoint(
      this.getPointInShapeSpace(shape, point),
      margin,
      hitInside
    );
  }
  /**
   * Convert a point in the current page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInShapeSpace(shape, point) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this._getShapePageTransformCache().get(id).clone().invert().applyToPoint(point);
  }
  /**
   * Convert a delta in the current page space to a point in the local space of a shape's parent.
   *
   * @example
   * ```ts
   * editor.getPointInParentSpace(myShape.id, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInParentSpace(shape, point) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) return new Vec(0, 0);
    if (isPageId(freshShape.parentId)) return Vec.From(point);
    const parentTransform = this.getShapePageTransform(freshShape.parentId);
    if (!parentTransform) return Vec.From(point);
    return parentTransform.clone().invert().applyToPoint(point);
  }
  getCurrentPageShapes() {
    return Array.from(this.getCurrentPageShapeIds(), (id) => this.store.get(id));
  }
  getCurrentPageShapesSorted() {
    const result = [];
    const topLevelShapes = this.getSortedChildIdsForParent(this.getCurrentPageId());
    for (let i = 0, n = topLevelShapes.length; i < n; i++) {
      pushShapeWithDescendants(this, topLevelShapes[i], result);
    }
    return result;
  }
  getCurrentPageRenderingShapesSorted() {
    const culledShapes = this.getCulledShapes();
    return this.getCurrentPageShapesSorted().filter(
      ({ id }) => !culledShapes.has(id) && !this.isShapeHidden(id)
    );
  }
  isShapeOfType(arg, type) {
    const shape = typeof arg === "string" ? this.getShape(arg) : arg;
    if (!shape) return false;
    return shape.type === type;
  }
  /**
   * Get a shape by its id.
   *
   * @example
   * ```ts
   * editor.getShape('box1')
   * ```
   *
   * @param shape - The shape (or the id of the shape) to get.
   *
   * @public
   */
  getShape(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    if (!isShapeId(id)) return void 0;
    return this.store.get(id);
  }
  /**
   * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
   * the page.
   *
   * @example
   * ```ts
   * editor.getShapeParent(myShape)
   * ```
   *
   * @public
   */
  getShapeParent(shape) {
    const id = typeof shape === "string" ? shape : shape?.id;
    if (!id) return void 0;
    const freshShape = this.getShape(id);
    if (freshShape === void 0 || !isShapeId(freshShape.parentId)) return void 0;
    return this.getShape(freshShape.parentId);
  }
  /**
   * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an
   * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns
   * undefined.
   *
   * @internal
   */
  getShapeNearestSibling(siblingShape, targetShape) {
    if (!targetShape) {
      return void 0;
    }
    if (targetShape.parentId === siblingShape.parentId) {
      return targetShape;
    }
    const ancestor = this.findShapeAncestor(
      targetShape,
      (ancestor2) => ancestor2.parentId === siblingShape.parentId
    );
    return ancestor;
  }
  /**
   * Get whether the given shape is the descendant of the given page.
   *
   * @example
   * ```ts
   * editor.isShapeInPage(myShape)
   * editor.isShapeInPage(myShape, 'page1')
   * ```
   *
   * @param shape - The shape to check.
   * @param pageId - The id of the page to check against. Defaults to the current page.
   *
   * @public
   */
  isShapeInPage(shape, pageId = this.getCurrentPageId()) {
    const id = typeof shape === "string" ? shape : shape.id;
    const shapeToCheck = this.getShape(id);
    if (!shapeToCheck) return false;
    let shapeIsInPage = false;
    if (shapeToCheck.parentId === pageId) {
      shapeIsInPage = true;
    } else {
      let parent = this.getShape(shapeToCheck.parentId);
      isInPageSearch: while (parent) {
        if (parent.parentId === pageId) {
          shapeIsInPage = true;
          break isInPageSearch;
        }
        parent = this.getShape(parent.parentId);
      }
    }
    return shapeIsInPage;
  }
  /**
   * Get the id of the containing page for a given shape.
   *
   * @param shape - The shape to get the page id for.
   *
   * @returns The id of the page that contains the shape, or undefined if the shape is undefined.
   *
   * @public
   */
  getAncestorPageId(shape) {
    const id = typeof shape === "string" ? shape : shape?.id;
    const _shape = id && this.getShape(id);
    if (!_shape) return void 0;
    if (isPageId(_shape.parentId)) {
      return _shape.parentId;
    } else {
      return this.getAncestorPageId(this.getShape(_shape.parentId));
    }
  }
  /**
   * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
   * rotations.
   *
   * @example
   * ```ts
   * editor.reparentShapes([box1, box2], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1', 4)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to reparent.
   * @param parentId - The id of the new parent shape.
   * @param insertIndex - The index to insert the children.
   *
   * @public
   */
  reparentShapes(shapes, parentId, insertIndex) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length === 0) return this;
    const changes = [];
    const parentTransform = isPageId(parentId) ? Mat.Identity() : this.getShapePageTransform(parentId);
    const parentPageRotation = parentTransform.rotation();
    let indices = [];
    const sibs = compact(this.getSortedChildIdsForParent(parentId).map((id) => this.getShape(id)));
    if (insertIndex) {
      const sibWithInsertIndex = sibs.find((s) => s.index === insertIndex);
      if (sibWithInsertIndex) {
        const sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1];
        if (sibAbove) {
          indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length);
        } else {
          indices = getIndicesAbove(insertIndex, ids.length);
        }
      } else {
        const sibAbove = sibs.sort(sortByIndex).find((s) => s.index > insertIndex);
        if (sibAbove) {
          indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length);
        } else {
          indices = getIndicesAbove(insertIndex, ids.length);
        }
      }
    } else {
      const sib = sibs.length && sibs[sibs.length - 1];
      indices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length);
    }
    const invertedParentTransform = parentTransform.clone().invert();
    const shapesToReparent = compact(ids.map((id) => this.getShape(id))).sort(sortByIndex);
    this.run(
      () => {
        for (let i = 0; i < shapesToReparent.length; i++) {
          const shape = shapesToReparent[i];
          const pageTransform = this.getShapePageTransform(shape);
          if (!pageTransform) continue;
          const pagePoint = pageTransform.point();
          if (!pagePoint) continue;
          const newPoint = invertedParentTransform.applyToPoint(pagePoint);
          const newRotation = pageTransform.rotation() - parentPageRotation;
          if (shape.id === parentId) {
            throw Error("Attempted to reparent a shape to itself!");
          }
          changes.push({
            id: shape.id,
            type: shape.type,
            parentId,
            x: newPoint.x,
            y: newPoint.y,
            rotation: newRotation,
            index: indices[i]
          });
        }
        this.updateShapes(changes);
      },
      { ignoreShapeLock: true }
    );
    return this;
  }
  /**
   * Get the index above the highest child of a given parent.
   *
   * @param parent - The parent (or the id) of the parent.
   *
   * @returns The index.
   *
   * @public
   */
  getHighestIndexForParent(parent) {
    const parentId = typeof parent === "string" ? parent : parent.id;
    const children = this._parentIdsToChildIds.get()[parentId];
    if (!children || children.length === 0) {
      return getIndexAbove(ZERO_INDEX_KEY);
    }
    const shape = this.getShape(children[children.length - 1]);
    return getIndexAbove(shape.index);
  }
  /**
   * Get an array of all the children of a shape.
   *
   * @example
   * ```ts
   * editor.getSortedChildIdsForParent('frame1')
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   *
   * @public
   */
  getSortedChildIdsForParent(parent) {
    const parentId = typeof parent === "string" ? parent : parent.id;
    const ids = this._parentIdsToChildIds.get()[parentId];
    if (!ids) return EMPTY_ARRAY;
    return ids;
  }
  /**
   * Run a visitor function for all descendants of a shape.
   *
   * @example
   * ```ts
   * editor.visitDescendants('frame1', myCallback)
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   * @param visitor - The visitor function.
   *
   * @public
   */
  visitDescendants(parent, visitor) {
    const children = this.getSortedChildIdsForParent(parent);
    for (const id of children) {
      if (visitor(id) === false) continue;
      this.visitDescendants(id, visitor);
    }
    return this;
  }
  /**
   * Get the shape ids of all descendants of the given shapes (including the shapes themselves). IDs are returned in z-index order.
   *
   * @param ids - The ids of the shapes to get descendants of.
   *
   * @returns The descendant ids.
   *
   * @public
   */
  getShapeAndDescendantIds(ids) {
    const shapeIds = /* @__PURE__ */ new Set();
    for (const shape of ids.map((id) => this.getShape(id)).sort(sortByIndex)) {
      shapeIds.add(shape.id);
      this.visitDescendants(shape, (descendantId) => {
        shapeIds.add(descendantId);
      });
    }
    return shapeIds;
  }
  /**
   * Get the shape that some shapes should be dropped on at a given point.
   *
   * @param point - The point to find the parent for.
   * @param droppingShapes - The shapes that are being dropped.
   *
   * @returns The shape to drop on.
   *
   * @public
   */
  getDraggingOverShape(point, droppingShapes) {
    const draggingShapes = compact(droppingShapes.map((s) => this.getShape(s))).filter(
      (s) => !s.isLocked && !this.isShapeHidden(s)
    );
    const maybeDraggingOverShapes = this.getShapesAtPoint(point, {
      hitInside: true,
      margin: 0
    }).filter(
      (s) => !droppingShapes.includes(s) && !s.isLocked && !this.isShapeHidden(s) && !draggingShapes.includes(s)
    );
    for (const maybeDraggingOverShape of maybeDraggingOverShapes) {
      const shapeUtil = this.getShapeUtil(maybeDraggingOverShape);
      if (shapeUtil.onDragShapesOver || shapeUtil.onDragShapesIn || shapeUtil.onDragShapesOut || shapeUtil.onDropShapesOver) {
        return maybeDraggingOverShape;
      }
    }
  }
  /**
   * Get the shape that should be selected when you click on a given shape, assuming there is
   * nothing already selected. It will not return anything higher than or including the current
   * focus layer.
   *
   * @param shape - The shape to get the outermost selectable shape for.
   * @param filter - A function to filter the selectable shapes.
   *
   * @returns The outermost selectable shape.
   *
   * @public
   */
  getOutermostSelectableShape(shape, filter2) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    let match = freshShape;
    let node = freshShape;
    const focusedGroup = this.getFocusedGroup();
    while (node) {
      if (this.isShapeOfType(node, "group") && focusedGroup?.id !== node.id && !this.hasAncestor(focusedGroup, node.id) && (filter2?.(node) ?? true)) {
        match = node;
      } else if (focusedGroup?.id === node.id) {
        break;
      }
      node = this.getShapeParent(node);
    }
    return match;
  }
  _getBindingsIndexCache() {
    const index2 = bindingsIndex(this);
    return this.store.createComputedCache(
      "bindingsIndex",
      (shape) => {
        return index2.get().get(shape.id);
      },
      // we can ignore the shape equality check here because the index is
      // computed incrementally based on what bindings are in the store
      { areRecordsEqual: () => true }
    );
  }
  /**
   * Get a binding from the store by its ID if it exists.
   */
  getBinding(id) {
    return this.store.get(id);
  }
  /**
   * Get all bindings of a certain type _from_ a particular shape. These are the bindings whose
   * `fromId` matched the shape's ID.
   */
  getBindingsFromShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this.getBindingsInvolvingShape(id).filter(
      (b) => b.fromId === id && b.type === type
    );
  }
  /**
   * Get all bindings of a certain type _to_ a particular shape. These are the bindings whose
   * `toId` matches the shape's ID.
   */
  getBindingsToShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this.getBindingsInvolvingShape(id).filter(
      (b) => b.toId === id && b.type === type
    );
  }
  /**
   * Get all bindings involving a particular shape. This includes bindings where the shape is the
   * `fromId` or `toId`. If a type is provided, only bindings of that type are returned.
   */
  getBindingsInvolvingShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    const result = this._getBindingsIndexCache().get(id) ?? EMPTY_ARRAY;
    if (!type) return result;
    return result.filter((b) => b.type === type);
  }
  /**
   * Create bindings from a list of partial bindings. You can omit the ID and most props of a
   * binding, but the `type`, `toId`, and `fromId` must all be provided.
   */
  createBindings(partials) {
    const bindings = [];
    for (const partial of partials) {
      const fromShape = this.getShape(partial.fromId);
      const toShape = this.getShape(partial.toId);
      if (!fromShape || !toShape) continue;
      if (!this.canBindShapes({ fromShape, toShape, binding: partial })) continue;
      const util = this.getBindingUtil(partial.type);
      const defaultProps = util.getDefaultProps();
      const binding = this.store.schema.types.binding.create({
        ...partial,
        id: partial.id ?? createBindingId(),
        props: {
          ...defaultProps,
          ...partial.props
        }
      });
      bindings.push(binding);
    }
    this.store.put(bindings);
    return this;
  }
  /**
   * Create a single binding from a partial. You can omit the ID and most props of a binding, but
   * the `type`, `toId`, and `fromId` must all be provided.
   */
  createBinding(partial) {
    return this.createBindings([partial]);
  }
  /**
   * Update bindings from a list of partial bindings. Each partial must include an ID, which will
   * be used to match the binding to it's existing record. If there is no existing record, that
   * binding is skipped. The changes from the partial are merged into the existing record.
   */
  updateBindings(partials) {
    const updated = [];
    for (const partial of partials) {
      if (!partial) continue;
      const current = this.getBinding(partial.id);
      if (!current) continue;
      const updatedBinding = applyPartialToRecordWithProps(current, partial);
      if (updatedBinding === current) continue;
      const fromShape = this.getShape(updatedBinding.fromId);
      const toShape = this.getShape(updatedBinding.toId);
      if (!fromShape || !toShape) continue;
      if (!this.canBindShapes({ fromShape, toShape, binding: updatedBinding })) continue;
      updated.push(updatedBinding);
    }
    this.store.put(updated);
    return this;
  }
  /**
   * Update a binding from a partial binding. Each partial must include an ID, which will be used
   * to match the binding to it's existing record. If there is no existing record, that binding is
   * skipped. The changes from the partial are merged into the existing record.
   */
  updateBinding(partial) {
    return this.updateBindings([partial]);
  }
  /**
   * Delete several bindings by their IDs. If a binding ID doesn't exist, it's ignored.
   */
  deleteBindings(bindings, { isolateShapes = false } = {}) {
    const ids = bindings.map((binding) => typeof binding === "string" ? binding : binding.id);
    if (isolateShapes) {
      this.store.atomic(() => {
        for (const id of ids) {
          const binding = this.getBinding(id);
          if (!binding) continue;
          const util = this.getBindingUtil(binding);
          util.onBeforeIsolateFromShape?.({ binding, removedShape: this.getShape(binding.toId) });
          util.onBeforeIsolateToShape?.({ binding, removedShape: this.getShape(binding.fromId) });
          this.store.remove([id]);
        }
      });
    } else {
      this.store.remove(ids);
    }
    return this;
  }
  /**
   * Delete a binding by its ID. If the binding doesn't exist, it's ignored.
   */
  deleteBinding(binding, opts) {
    return this.deleteBindings([binding], opts);
  }
  canBindShapes({
    fromShape,
    toShape,
    binding
  }) {
    const fromShapeType = typeof fromShape === "string" ? fromShape : fromShape.type;
    const toShapeType = typeof toShape === "string" ? toShape : toShape.type;
    const bindingType = typeof binding === "string" ? binding : binding.type;
    const canBindOpts = { fromShapeType, toShapeType, bindingType };
    if (fromShapeType === toShapeType) {
      return this.getShapeUtil(fromShapeType).canBind(canBindOpts);
    }
    return this.getShapeUtil(fromShapeType).canBind(canBindOpts) && this.getShapeUtil(toShapeType).canBind(canBindOpts);
  }
  /* -------------------- Commands -------------------- */
  /**
   * Rotate shapes by a delta in radians.
   *
   * @example
   * ```ts
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI)
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param delta - The delta in radians to apply to the selection rotation.
   * @param opts - The options for the rotation.
   */
  rotateShapesBy(shapes, delta, opts) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length <= 0) return this;
    const snapshot = getRotationSnapshot({ editor: this, ids });
    if (!snapshot) return this;
    applyRotationToSnapshotShapes({
      delta,
      snapshot,
      editor: this,
      stage: "one-off",
      centerOverride: opts?.center
    });
    return this;
  }
  // Gets a shape partial that includes life cycle changes: on translate start, on translate, on translate end
  getChangesToTranslateShape(initialShape, newShapeCoords) {
    let workingShape = initialShape;
    const util = this.getShapeUtil(initialShape);
    const afterTranslateStart = util.onTranslateStart?.(workingShape);
    if (afterTranslateStart) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslateStart);
    }
    workingShape = applyPartialToRecordWithProps(workingShape, {
      id: initialShape.id,
      type: initialShape.type,
      x: newShapeCoords.x,
      y: newShapeCoords.y
    });
    const afterTranslate = util.onTranslate?.(initialShape, workingShape);
    if (afterTranslate) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslate);
    }
    const afterTranslateEnd = util.onTranslateEnd?.(initialShape, workingShape);
    if (afterTranslateEnd) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslateEnd);
    }
    return workingShape;
  }
  /**
   * Move shapes by a delta.
   *
   * @example
   * ```ts
   * editor.nudgeShapes(['box1', 'box2'], { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param offset - The offset to apply to the shapes.
   */
  nudgeShapes(shapes, offset2) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length <= 0) return this;
    const changes = [];
    for (const id of ids) {
      const shape = this.getShape(id);
      const localDelta = Vec.From(offset2);
      const parentTransform = this.getShapeParentTransform(shape);
      if (parentTransform) localDelta.rot(-parentTransform.rotation());
      changes.push(this.getChangesToTranslateShape(shape, localDelta.add(shape)));
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Duplicate shapes.
   *
   * @example
   * ```ts
   * editor.duplicateShapes(['box1', 'box2'], { x: 8, y: 8 })
   * editor.duplicateShapes(editor.getSelectedShapes(), { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to duplicate.
   * @param offset - The offset (in pixels) to apply to the duplicated shapes.
   *
   * @public
   */
  duplicateShapes(shapes, offset2) {
    this.run(() => {
      const _ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
      const ids = this._shouldIgnoreShapeLock ? _ids : this._getUnlockedShapeIds(_ids);
      if (ids.length <= 0) return this;
      const initialIds = new Set(ids);
      const shapeIdSet = this.getShapeAndDescendantIds(ids);
      const orderedShapeIds = [...shapeIdSet].reverse();
      const shapeIds = /* @__PURE__ */ new Map();
      for (const shapeId of shapeIdSet) {
        shapeIds.set(shapeId, createShapeId());
      }
      const { shapesToCreateWithOriginals, bindingsToCreate } = withIsolatedShapes(
        this,
        shapeIdSet,
        (bindingIdsToMaintain) => {
          const bindingsToCreate2 = [];
          for (const originalId of bindingIdsToMaintain) {
            const originalBinding = this.getBinding(originalId);
            if (!originalBinding) continue;
            const duplicatedId = createBindingId();
            bindingsToCreate2.push({
              ...originalBinding,
              id: duplicatedId,
              fromId: assertExists(shapeIds.get(originalBinding.fromId)),
              toId: assertExists(shapeIds.get(originalBinding.toId))
            });
          }
          const shapesToCreateWithOriginals2 = [];
          for (const originalId of orderedShapeIds) {
            const duplicatedId = assertExists(shapeIds.get(originalId));
            const originalShape = this.getShape(originalId);
            if (!originalShape) continue;
            let ox = 0;
            let oy = 0;
            if (offset2 && initialIds.has(originalId)) {
              const parentTransform = this.getShapeParentTransform(originalShape);
              const vec = new Vec(offset2.x, offset2.y).rot(-parentTransform.rotation());
              ox = vec.x;
              oy = vec.y;
            }
            shapesToCreateWithOriginals2.push({
              shape: {
                ...originalShape,
                id: duplicatedId,
                x: originalShape.x + ox,
                y: originalShape.y + oy,
                // Use a dummy index for now, it will get updated outside of the `withIsolatedShapes`
                index: "a1",
                parentId: shapeIds.get(originalShape.parentId) ?? originalShape.parentId
              },
              originalShape
            });
          }
          return { shapesToCreateWithOriginals: shapesToCreateWithOriginals2, bindingsToCreate: bindingsToCreate2 };
        }
      );
      shapesToCreateWithOriginals.forEach(({ shape, originalShape }) => {
        const parentId = originalShape.parentId;
        const siblings = this.getSortedChildIdsForParent(parentId);
        const currentIndex = siblings.indexOf(originalShape.id);
        const siblingAboveId = siblings[currentIndex + 1];
        const siblingAbove = siblingAboveId ? this.getShape(siblingAboveId) : void 0;
        const index2 = getIndexBetween(originalShape.index, siblingAbove?.index);
        shape.index = index2;
      });
      const shapesToCreate = shapesToCreateWithOriginals.map(({ shape }) => shape);
      if (!this.canCreateShapes(shapesToCreate)) {
        alertMaxShapes(this);
        return;
      }
      this.createShapes(shapesToCreate);
      this.createBindings(bindingsToCreate);
      this.setSelectedShapes(
        compact(
          ids.map((oldId) => {
            const newId = shapeIds.get(oldId);
            if (!newId) return null;
            if (!this.getShape(newId)) return null;
            return newId;
          })
        )
      );
      if (offset2 !== void 0) {
        const selectionPageBounds = this.getSelectionPageBounds();
        const viewportPageBounds = this.getViewportPageBounds();
        if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
          this.centerOnPoint(selectionPageBounds.center, {
            animation: { duration: this.options.animationMediumMs }
          });
        }
      }
    });
    return this;
  }
  /**
   * Move shapes to page.
   *
   * @example
   * ```ts
   * editor.moveShapesToPage(['box1', 'box2'], 'page1')
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param pageId - The id of the page where the shapes will be moved.
   *
   * @public
   */
  moveShapesToPage(shapes, pageId) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length === 0) return this;
    if (this.getIsReadonly()) return this;
    const currentPageId = this.getCurrentPageId();
    if (pageId === currentPageId) return this;
    if (!this.store.has(pageId)) return this;
    const content = this.getContentFromCurrentPage(ids);
    if (!content) return this;
    if (this.getPageShapeIds(pageId).size + content.shapes.length > this.options.maxShapesPerPage) {
      alertMaxShapes(this, pageId);
      return this;
    }
    const fromPageZ = this.getCamera().z;
    this.run(() => {
      this.deleteShapes(ids);
      this.setCurrentPage(pageId);
      this.setFocusedGroup(null);
      this.selectNone();
      this.putContentOntoCurrentPage(content, {
        select: true,
        preserveIds: true,
        preservePosition: true
      });
      this.setCamera({ ...this.getCamera(), z: fromPageZ });
      this.centerOnPoint(this.getSelectionRotatedPageBounds().center);
    });
    return this;
  }
  /**
   * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.
   *
   * @param shapes - The shapes (or shape ids) to toggle.
   *
   * @public
   */
  toggleLock(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (this.getIsReadonly() || ids.length === 0) return this;
    let allLocked = true, allUnlocked = true;
    const shapesToToggle = [];
    for (const id of ids) {
      const shape = this.getShape(id);
      if (shape) {
        shapesToToggle.push(shape);
        if (shape.isLocked) {
          allUnlocked = false;
        } else {
          allLocked = false;
        }
      }
    }
    this.run(() => {
      if (allUnlocked) {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))
        );
        this.setSelectedShapes([]);
      } else if (allLocked) {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: false }))
        );
      } else {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))
        );
      }
    });
    return this;
  }
  /**
   * Send shapes to the back of the page's object list.
   *
   * @example
   * ```ts
   * editor.sendToBack(['id1', 'id2'])
   * editor.sendToBack(box1, box2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  sendToBack(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "toBack", ids, {
      considerAllShapes: true
    });
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * Send shapes backward in the page's object list.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'])
   * editor.sendBackward([box1, box2])
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the backward operation.
   *
   * @public
   */
  sendBackward(shapes, opts = {}) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "backward", ids, opts);
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * Bring shapes forward in the page's object list.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'])
   * editor.bringForward(box1,  box2)
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the forward operation.
   *
   * @public
   */
  bringForward(shapes, opts = {}) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "forward", ids, opts);
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * Bring shapes to the front of the page's object list.
   *
   * @example
   * ```ts
   * editor.bringToFront(['id1', 'id2'])
   * editor.bringToFront([box1, box2])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  bringToFront(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "toFront", ids);
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * @internal
   */
  collectShapesViaArrowBindings(info) {
    const { initialShapes, resultShapes, resultBounds, bindings, visited } = info;
    for (const binding of bindings) {
      for (const id of [binding.fromId, binding.toId]) {
        if (!visited.has(id)) {
          const aligningShape = initialShapes.find((s) => s.id === id);
          if (aligningShape && !visited.has(aligningShape.id)) {
            visited.add(aligningShape.id);
            const shapePageBounds = this.getShapePageBounds(aligningShape);
            if (!shapePageBounds) continue;
            resultShapes.push(aligningShape);
            resultBounds.push(shapePageBounds);
            this.collectShapesViaArrowBindings({
              ...info,
              bindings: this.getBindingsInvolvingShape(aligningShape, "arrow")
            });
          }
        }
      }
    }
  }
  /**
   * Flip shape positions.
   *
   * @example
   * ```ts
   * editor.flipShapes([box1, box2], 'horizontal', 32)
   * editor.flipShapes(editor.getSelectedShapeIds(), 'horizontal', 32)
   * ```
   *
   * @param shapes - The ids of the shapes to flip.
   * @param operation - Whether to flip horizontally or vertically.
   *
   * @public
   */
  flipShapes(shapes, operation) {
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToFlipFirstPass = compact(ids.map((id) => this.getShape(id)));
    for (const shape of shapesToFlipFirstPass) {
      if (this.isShapeOfType(shape, "group")) {
        const childrenOfGroups = compact(
          this.getSortedChildIdsForParent(shape.id).map((id) => this.getShape(id))
        );
        shapesToFlipFirstPass.push(...childrenOfGroups);
      }
    }
    const shapesToFlip = [];
    const allBounds = [];
    for (const shape of shapesToFlipFirstPass) {
      const util = this.getShapeUtil(shape);
      if (!util.canBeLaidOut(shape, {
        type: "flip",
        shapes: shapesToFlipFirstPass
      })) {
        continue;
      }
      const pageBounds = this.getShapePageBounds(shape);
      const localBounds = this.getShapeGeometry(shape).bounds;
      const pageTransform = this.getShapePageTransform(shape.id);
      if (!(pageBounds && localBounds && pageTransform)) continue;
      shapesToFlip.push({
        shape,
        localBounds,
        pageTransform,
        isAspectRatioLocked: util.isAspectRatioLocked(shape)
      });
      allBounds.push(pageBounds);
    }
    if (!shapesToFlip.length) return this;
    const scaleOriginPage = Box.Common(allBounds).center;
    this.run(() => {
      for (const { shape, localBounds, pageTransform, isAspectRatioLocked } of shapesToFlip) {
        this.resizeShape(
          shape.id,
          { x: operation === "horizontal" ? -1 : 1, y: operation === "vertical" ? -1 : 1 },
          {
            initialBounds: localBounds,
            initialPageTransform: pageTransform,
            initialShape: shape,
            isAspectRatioLocked,
            mode: "scale_shape",
            scaleOrigin: scaleOriginPage,
            scaleAxisRotation: 0
          }
        );
      }
    });
    return this;
  }
  /**
   * Stack shape.
   *
   * @example
   * ```ts
   * editor.stackShapes([box1, box2], 'horizontal')
   * editor.stackShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stack.
   * @param operation - Whether to stack horizontally or vertically.
   * @param gap - The gap to leave between shapes. By default, uses the editor's `adjacentShapeMargin` option.
   *
   * @public
   */
  stackShapes(shapes, operation, gap) {
    const _gap = gap ?? this.options.adjacentShapeMargin;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (this.getIsReadonly()) return this;
    const shapesToStackFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToStack = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToStackFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!this.getShapeUtil(shape).canBeLaidOut?.(shape, {
        type: "stack",
        shapes: shapesToStackFirstPass
      })) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToStackFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToStack.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
    }
    const len = shapeClustersToStack.length;
    if (_gap === 0 && len < 3 || len < 2) return this;
    let val;
    let min2;
    let max2;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min2 = "minX";
      max2 = "maxX";
      dim = "width";
    } else {
      val = "y";
      min2 = "minY";
      max2 = "maxY";
      dim = "height";
    }
    let shapeGap = 0;
    if (_gap === 0) {
      const gaps = {};
      shapeClustersToStack.sort((a, b) => a.pageBounds[min2] - b.pageBounds[min2]);
      for (let i = 0; i < len - 1; i++) {
        const currCluster = shapeClustersToStack[i];
        const nextCluster = shapeClustersToStack[i + 1];
        const gap2 = nextCluster.pageBounds[min2] - currCluster.pageBounds[max2];
        if (!gaps[gap2]) {
          gaps[gap2] = 0;
        }
        gaps[gap2]++;
      }
      let maxCount = 1;
      for (const [gap2, count2] of Object.entries(gaps)) {
        if (count2 > maxCount) {
          maxCount = count2;
          shapeGap = parseFloat(gap2);
        }
      }
      if (maxCount === 1) {
        let totalCount = 0;
        for (const [gap2, count2] of Object.entries(gaps)) {
          shapeGap += parseFloat(gap2) * count2;
          totalCount += count2;
        }
        shapeGap /= totalCount;
      }
    } else {
      shapeGap = _gap;
    }
    const changes = [];
    let v = shapeClustersToStack[0].pageBounds[max2];
    for (let i = 1; i < shapeClustersToStack.length; i++) {
      const { shapes: shapes2, pageBounds } = shapeClustersToStack[i];
      const delta = new Vec();
      delta[val] = v + shapeGap - pageBounds[val];
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
      v += pageBounds[dim] + shapeGap;
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Pack shapes into a grid centered on their current position. Based on potpack (https://github.com/mapbox/potpack).
   *
   * @example
   * ```ts
   * editor.packShapes([box1, box2])
   * editor.packShapes(editor.getSelectedShapeIds(), 32)
   * ```
   *
   *
   * @param shapes - The shapes (or shape ids) to pack.
   * @param gap - The padding to apply to the packed shapes. Defaults to the editor's `adjacentShapeMargin` option.
   */
  packShapes(shapes, _gap) {
    if (this.getIsReadonly()) return this;
    const gap = _gap ?? this.options.adjacentShapeMargin;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToPackFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToPack = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToPackFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!this.getShapeUtil(shape).canBeLaidOut?.(shape, {
        type: "pack",
        shapes: shapesToPackFirstPass
      })) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToPackFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToPack.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds,
        nextPageBounds: commonPageBounds.clone()
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToPack.length < 2) return this;
    let area = 0;
    for (const { pageBounds } of shapeClustersToPack) {
      area += pageBounds.width * pageBounds.height;
    }
    const commonBounds = Box.Common(allBounds);
    const maxWidth = commonBounds.width;
    shapeClustersToPack.sort((a, b) => a.pageBounds.width - b.pageBounds.width).sort((a, b) => a.pageBounds.height - b.pageBounds.height);
    const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);
    const spaces = [new Box(commonBounds.x, commonBounds.y, startWidth, Infinity)];
    let width = 0;
    let height = 0;
    let space;
    let last2;
    for (const { nextPageBounds } of shapeClustersToPack) {
      for (let i = spaces.length - 1; i >= 0; i--) {
        space = spaces[i];
        if (nextPageBounds.width > space.width || nextPageBounds.height > space.height) continue;
        nextPageBounds.x = space.x;
        nextPageBounds.y = space.y;
        height = Math.max(height, nextPageBounds.maxY);
        width = Math.max(width, nextPageBounds.maxX);
        if (nextPageBounds.width === space.width && nextPageBounds.height === space.height) {
          last2 = spaces.pop();
          if (i < spaces.length) spaces[i] = last2;
        } else if (nextPageBounds.height === space.height) {
          space.x += nextPageBounds.width + gap;
          space.width -= nextPageBounds.width + gap;
        } else if (nextPageBounds.width === space.width) {
          space.y += nextPageBounds.height + gap;
          space.height -= nextPageBounds.height + gap;
        } else {
          spaces.push(
            new Box(
              space.x + (nextPageBounds.width + gap),
              space.y,
              space.width - (nextPageBounds.width + gap),
              nextPageBounds.height
            )
          );
          space.y += nextPageBounds.height + gap;
          space.height -= nextPageBounds.height + gap;
        }
        break;
      }
    }
    const commonAfter = Box.Common(shapeClustersToPack.map((s) => s.nextPageBounds));
    const centerDelta = Vec.Sub(commonBounds.center, commonAfter.center);
    const changes = [];
    for (const { shapes: shapes2, pageBounds, nextPageBounds } of shapeClustersToPack) {
      const delta = Vec.Sub(nextPageBounds.point, pageBounds.point).add(centerDelta);
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapeParentTransform(shape);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
    }
    if (changes.length) {
      this.updateShapes(changes);
    }
    return this;
  }
  /**
   * Align shape positions.
   *
   * @example
   * ```ts
   * editor.alignShapes([box1, box2], 'left')
   * editor.alignShapes(editor.getSelectedShapeIds(), 'left')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to align.
   * @param operation - The align operation to apply.
   *
   * @public
   */
  alignShapes(shapes, operation) {
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToAlignFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToAlign = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToAlignFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!this.getShapeUtil(shape).canBeLaidOut?.(shape, {
        type: "align",
        shapes: shapesToAlignFirstPass
      })) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToAlignFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToAlign.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToAlign.length < 2) return this;
    const commonBounds = Box.Common(allBounds);
    const changes = [];
    shapeClustersToAlign.forEach(({ shapes: shapes2, pageBounds }) => {
      const delta = new Vec();
      switch (operation) {
        case "top": {
          delta.y = commonBounds.minY - pageBounds.minY;
          break;
        }
        case "center-vertical": {
          delta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2;
          break;
        }
        case "bottom": {
          delta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height;
          break;
        }
        case "left": {
          delta.x = commonBounds.minX - pageBounds.minX;
          break;
        }
        case "center-horizontal": {
          delta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2;
          break;
        }
        case "right": {
          delta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width;
          break;
        }
      }
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
    });
    this.updateShapes(changes);
    return this;
  }
  /**
   * Distribute shape positions.
   *
   * @example
   * ```ts
   * editor.distributeShapes([box1, box2], 'horizontal')
   * editor.distributeShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to distribute.
   * @param operation - Whether to distribute shapes horizontally or vertically.
   *
   * @public
   */
  distributeShapes(shapes, operation) {
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToDistributeFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToDistribute = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToDistributeFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!this.getShapeUtil(shape).canBeLaidOut?.(shape, {
        type: "distribute",
        shapes: shapesToDistributeFirstPass
      })) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToDistributeFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToDistribute.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
    }
    if (shapeClustersToDistribute.length < 3) return this;
    let val;
    let min2;
    let max2;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min2 = "minX";
      max2 = "maxX";
      dim = "width";
    } else {
      val = "y";
      min2 = "minY";
      max2 = "maxY";
      dim = "height";
    }
    const changes = [];
    const first2 = shapeClustersToDistribute.sort((a, b) => a.pageBounds[min2] - b.pageBounds[min2])[0];
    const last2 = shapeClustersToDistribute.sort((a, b) => b.pageBounds[max2] - a.pageBounds[max2])[0];
    if (first2 === last2) {
      const excludedShapeIds = new Set(first2.shapes.map((s) => s.id));
      return this.distributeShapes(
        ids.filter((id) => !excludedShapeIds.has(id)),
        operation
      );
    }
    const shapeClustersToMove = shapeClustersToDistribute.filter((shape) => shape !== first2 && shape !== last2).sort((a, b) => {
      if (a.pageBounds[min2] === b.pageBounds[min2]) {
        return a.shapes[0].id < b.shapes[0].id ? -1 : 1;
      }
      return a.pageBounds[min2] - b.pageBounds[min2];
    });
    const maxFirst = first2.pageBounds[max2];
    const range = last2.pageBounds[min2] - maxFirst;
    const summedShapeDimensions = shapeClustersToMove.reduce((acc, s) => acc + s.pageBounds[dim], 0);
    const gap = (range - summedShapeDimensions) / (shapeClustersToMove.length + 1);
    for (let v = maxFirst + gap, i = 0; i < shapeClustersToMove.length; i++) {
      const { shapes: shapes2, pageBounds } = shapeClustersToMove[i];
      const delta = new Vec();
      delta[val] = v - pageBounds[val];
      if (v + pageBounds[dim] > last2.pageBounds[max2] - 1) {
        delta[val] = last2.pageBounds[max2] - pageBounds[max2] - 1;
      }
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
      v += pageBounds[dim] + gap;
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Stretch shape sizes and positions to fill their common bounding box.
   *
   * @example
   * ```ts
   * editor.stretchShapes([box1, box2], 'horizontal')
   * editor.stretchShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stretch.
   * @param operation - Whether to stretch shapes horizontally or vertically.
   *
   * @public
   */
  stretchShapes(shapes, operation) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (this.getIsReadonly()) return this;
    const shapesToStretchFirstPass = compact(ids.map((id) => this.getShape(id))).filter(
      (s) => this.getShapePageTransform(s)?.rotation() % (PI$1 / 2) === 0
    );
    const shapeClustersToStretch = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToStretchFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      if (!this.getShapeUtil(shape).canBeLaidOut?.(shape, {
        type: "stretch"
      })) {
        continue;
      }
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToStretchFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToStretch.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToStretch.length < 2) return this;
    const commonBounds = Box.Common(allBounds);
    let val;
    let min2;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min2 = "minX";
      dim = "width";
    } else {
      val = "y";
      min2 = "minY";
      dim = "height";
    }
    this.run(() => {
      shapeClustersToStretch.forEach(({ shapes: shapes2, pageBounds }) => {
        const localOffset = new Vec();
        localOffset[val] = commonBounds[min2] - pageBounds[min2];
        const scaleOrigin = pageBounds.center.clone();
        scaleOrigin[val] = commonBounds[min2];
        const scale = new Vec(1, 1);
        scale[val] = commonBounds[dim] / pageBounds[dim];
        for (const shape of shapes2) {
          const shapeLocalOffset = localOffset.clone();
          const parentTransform = this.getShapeParentTransform(shape);
          if (parentTransform) localOffset.rot(-parentTransform.rotation());
          shapeLocalOffset.add(shape);
          const changes = this.getChangesToTranslateShape(shape, shapeLocalOffset);
          this.updateShape(changes);
          this.resizeShape(shape.id, scale, {
            initialBounds: this.getShapeGeometry(shape).bounds,
            scaleOrigin,
            isAspectRatioLocked: this.getShapeUtil(shape).isAspectRatioLocked(shape),
            scaleAxisRotation: 0
          });
        }
      });
    });
    return this;
  }
  /**
   * Resize a shape.
   *
   * @param shape - The shape (or the shape id of the shape) to resize.
   * @param scale - The scale factor to apply to the shape.
   * @param opts - Additional options.
   *
   * @public
   */
  resizeShape(shape, scale, opts = {}) {
    const id = typeof shape === "string" ? shape : shape.id;
    if (this.getIsReadonly()) return this;
    if (!Number.isFinite(scale.x)) scale = new Vec(1, scale.y);
    if (!Number.isFinite(scale.y)) scale = new Vec(scale.x, 1);
    const initialShape = opts.initialShape ?? this.getShape(id);
    if (!initialShape) return this;
    const scaleOrigin = opts.scaleOrigin ?? this.getShapePageBounds(id)?.center;
    if (!scaleOrigin) return this;
    const pageTransform = opts.initialPageTransform ? Mat.Cast(opts.initialPageTransform) : this.getShapePageTransform(id);
    if (!pageTransform) return this;
    const pageRotation = pageTransform.rotation();
    if (pageRotation == null) return this;
    const scaleAxisRotation = opts.scaleAxisRotation ?? pageRotation;
    const initialBounds = opts.initialBounds ?? this.getShapeGeometry(id).bounds;
    if (!initialBounds) return this;
    const isAspectRatioLocked = opts.isAspectRatioLocked ?? this.getShapeUtil(initialShape).isAspectRatioLocked(initialShape);
    if (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {
      return this._resizeUnalignedShape(id, scale, {
        ...opts,
        initialBounds,
        scaleOrigin,
        scaleAxisRotation,
        initialPageTransform: pageTransform,
        isAspectRatioLocked,
        initialShape
      });
    }
    const util = this.getShapeUtil(initialShape);
    if (isAspectRatioLocked) {
      if (Math.abs(scale.x) > Math.abs(scale.y)) {
        scale = new Vec(scale.x, Math.sign(scale.y) * Math.abs(scale.x));
      } else {
        scale = new Vec(Math.sign(scale.x) * Math.abs(scale.y), scale.y);
      }
    }
    let didResize = false;
    if (util.onResize && util.canResize(initialShape)) {
      const newPagePoint = this._scalePagePoint(
        Mat.applyToPoint(pageTransform, new Vec(0, 0)),
        scaleOrigin,
        scale,
        scaleAxisRotation
      );
      const newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint);
      const myScale = new Vec(scale.x, scale.y);
      const areWidthAndHeightAlignedWithCorrectAxis = approximately(
        (pageRotation - scaleAxisRotation) % Math.PI,
        0
      );
      myScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y;
      myScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x;
      const initialPagePoint = Mat.applyToPoint(pageTransform, new Vec());
      const { x, y } = this.getPointInParentSpace(initialShape.id, initialPagePoint);
      let workingShape = initialShape;
      if (!opts.skipStartAndEndCallbacks) {
        workingShape = applyPartialToRecordWithProps(
          initialShape,
          util.onResizeStart?.(initialShape) ?? void 0
        );
      }
      const resizedShape = util.onResize(
        { ...initialShape, x, y },
        {
          newPoint: newLocalPoint,
          handle: opts.dragHandle ?? "bottom_right",
          // don't set isSingle to true for children
          mode: opts.mode ?? "scale_shape",
          scaleX: myScale.x,
          scaleY: myScale.y,
          initialBounds,
          initialShape
        }
      );
      if (resizedShape) {
        didResize = true;
      }
      workingShape = applyPartialToRecordWithProps(workingShape, {
        id,
        type: initialShape.type,
        x: newLocalPoint.x,
        y: newLocalPoint.y,
        ...resizedShape
      });
      if (!opts.skipStartAndEndCallbacks) {
        workingShape = applyPartialToRecordWithProps(
          workingShape,
          util.onResizeEnd?.(initialShape, workingShape) ?? void 0
        );
      }
      this.updateShapes([workingShape]);
    }
    if (!didResize) {
      const initialPageCenter = Mat.applyToPoint(pageTransform, initialBounds.center);
      const newPageCenter = this._scalePagePoint(
        initialPageCenter,
        scaleOrigin,
        scale,
        scaleAxisRotation
      );
      const initialPageCenterInParentSpace = this.getPointInParentSpace(
        initialShape.id,
        initialPageCenter
      );
      const newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter);
      const delta = Vec.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace);
      this.updateShapes([
        {
          id,
          type: initialShape.type,
          x: initialShape.x + delta.x,
          y: initialShape.y + delta.y
        }
      ]);
    }
    return this;
  }
  /** @internal */
  _scalePagePoint(point, scaleOrigin, scale, scaleAxisRotation) {
    const relativePoint = Vec.RotWith(point, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin);
    const newRelativePagePoint = Vec.MulV(relativePoint, scale);
    const destination = Vec.Add(newRelativePagePoint, scaleOrigin).rotWith(
      scaleOrigin,
      scaleAxisRotation
    );
    return destination;
  }
  /** @internal */
  _resizeUnalignedShape(id, scale, options) {
    const { type } = options.initialShape;
    const shapeScale = new Vec(scale.x, scale.y);
    if (Math.abs(scale.x) > Math.abs(scale.y)) {
      shapeScale.x = Math.sign(scale.x) * Math.abs(scale.y);
    } else {
      shapeScale.y = Math.sign(scale.y) * Math.abs(scale.x);
    }
    this.resizeShape(id, shapeScale, {
      initialShape: options.initialShape,
      initialBounds: options.initialBounds,
      isAspectRatioLocked: options.isAspectRatioLocked
    });
    if (Math.sign(scale.x) * Math.sign(scale.y) < 0) {
      let { rotation } = Mat.Decompose(options.initialPageTransform);
      rotation -= 2 * rotation;
      this.updateShapes([{ id, type, rotation }]);
    }
    const preScaleShapePageCenter = Mat.applyToPoint(
      options.initialPageTransform,
      options.initialBounds.center
    );
    const postScaleShapePageCenter = this._scalePagePoint(
      preScaleShapePageCenter,
      options.scaleOrigin,
      scale,
      options.scaleAxisRotation
    );
    const pageBounds = this.getShapePageBounds(id);
    const pageTransform = this.getShapePageTransform(id);
    const currentPageCenter = pageBounds.center;
    const shapePageTransformOrigin = pageTransform.point();
    if (!currentPageCenter || !shapePageTransformOrigin) return this;
    const pageDelta = Vec.Sub(postScaleShapePageCenter, currentPageCenter);
    const postScaleShapePagePoint = Vec.Add(shapePageTransformOrigin, pageDelta);
    const { x, y } = this.getPointInParentSpace(id, postScaleShapePagePoint);
    this.updateShapes([{ id, type, x, y }]);
    return this;
  }
  /**
   * Get the initial meta value for a shape.
   *
   * @example
   * ```ts
   * editor.getInitialMetaForShape = (shape) => {
   *   if (shape.type === 'note') {
   *     return { createdBy: myCurrentUser.id }
   *   }
   * }
   * ```
   *
   * @param shape - The shape to get the initial meta for.
   *
   * @public
   */
  getInitialMetaForShape(_shape) {
    return {};
  }
  /**
   * Get whether the provided shape can be created.
   *
   * @param shape - The shape or shape IDs to check.
   *
   * @public
   */
  canCreateShape(shape) {
    return this.canCreateShapes([shape]);
  }
  /**
   * Get whether the provided shapes can be created.
   *
   * @param shapes - The shapes or shape IDs to create.
   *
   * @public
   */
  canCreateShapes(shapes) {
    return shapes.length + this.getCurrentPageShapeIds().size <= this.options.maxShapesPerPage;
  }
  /**
   * Create a single shape.
   *
   * @example
   * ```ts
   * editor.createShape(myShape)
   * editor.createShape({ id: 'box1', type: 'text', props: { richText: toRichText("ok") } })
   * ```
   *
   * @param shape - The shape (or shape partial) to create.
   *
   * @public
   */
  createShape(shape) {
    this.createShapes([shape]);
    return this;
  }
  /**
   * Create shapes.
   *
   * @example
   * ```ts
   * editor.createShapes([myShape])
   * editor.createShapes([{ id: 'box1', type: 'text', props: { richText: toRichText("ok") } }])
   * ```
   *
   * @param shapes - The shapes (or shape partials) to create.
   *
   * @public
   */
  createShapes(shapes) {
    if (!Array.isArray(shapes)) {
      throw Error("Editor.createShapes: must provide an array of shapes or shape partials");
    }
    if (this.getIsReadonly()) return this;
    if (shapes.length <= 0) return this;
    const currentPageShapeIds = this.getCurrentPageShapeIds();
    const maxShapesReached = shapes.length + currentPageShapeIds.size > this.options.maxShapesPerPage;
    if (maxShapesReached) {
      alertMaxShapes(this);
      return this;
    }
    const focusedGroupId = this.getFocusedGroupId();
    this.run(() => {
      const currentPageShapesSorted = this.getCurrentPageShapesSorted();
      const partials = shapes.map((partial) => {
        if (!partial.id) {
          partial = { id: createShapeId(), ...partial };
        }
        if (!partial.parentId || !(this.store.has(partial.parentId) || shapes.some((p) => p.id === partial.parentId))) {
          let parentId = this.getFocusedGroupId();
          const isPositioned = partial.x !== void 0 && partial.y !== void 0;
          if (isPositioned) {
            for (let i = currentPageShapesSorted.length - 1; i >= 0; i--) {
              const parent = currentPageShapesSorted[i];
              const util = this.getShapeUtil(parent);
              if (util.canReceiveNewChildrenOfType(parent, partial.type) && !this.isShapeHidden(parent) && this.isPointInShape(
                parent,
                // If no parent is provided, then we can treat the
                // shape's provided x/y as being in the page's space.
                { x: partial.x ?? 0, y: partial.y ?? 0 },
                {
                  margin: 0,
                  hitInside: true
                }
              )) {
                parentId = parent.id;
                break;
              }
            }
          }
          const prevParentId = partial.parentId;
          if (parentId === partial.id) {
            parentId = focusedGroupId;
          }
          if (parentId !== prevParentId) {
            partial = { ...partial };
            partial.parentId = parentId;
            if (isShapeId(parentId)) {
              const point = this.getPointInShapeSpace(this.getShape(parentId), {
                x: partial.x ?? 0,
                y: partial.y ?? 0
              });
              partial.x = point.x;
              partial.y = point.y;
              partial.rotation = -this.getShapePageTransform(parentId).rotation() + (partial.rotation ?? 0);
            }
          }
        }
        return partial;
      });
      const parentIndices = /* @__PURE__ */ new Map();
      const shapeRecordsToCreate = [];
      const { opacityForNextShape } = this.getInstanceState();
      for (const partial of partials) {
        const util = this.getShapeUtil(partial);
        let index2 = partial.index;
        if (!index2) {
          const parentId = partial.parentId ?? focusedGroupId;
          if (!parentIndices.has(parentId)) {
            parentIndices.set(parentId, this.getHighestIndexForParent(parentId));
          }
          index2 = parentIndices.get(parentId);
          parentIndices.set(parentId, getIndexAbove(index2));
        }
        const initialProps = util.getDefaultProps();
        for (const [style2, propKey] of this.styleProps[partial.type]) {
          initialProps[propKey] = this.getStyleForNextShape(style2);
        }
        let shapeRecordToCreate = this.store.schema.types.shape.create({
          ...partial,
          index: index2,
          opacity: partial.opacity ?? opacityForNextShape,
          parentId: partial.parentId ?? focusedGroupId,
          props: "props" in partial ? { ...initialProps, ...partial.props } : initialProps
        });
        if (shapeRecordToCreate.index === void 0) {
          throw Error("no index!");
        }
        const next = this.getShapeUtil(shapeRecordToCreate).onBeforeCreate?.(shapeRecordToCreate);
        if (next) {
          shapeRecordToCreate = next;
        }
        shapeRecordsToCreate.push(shapeRecordToCreate);
      }
      shapeRecordsToCreate.forEach((shape) => {
        shape.meta = {
          ...this.getInitialMetaForShape(shape),
          ...shape.meta
        };
      });
      this.emit("created-shapes", shapeRecordsToCreate);
      this.emit("edit");
      this.store.put(shapeRecordsToCreate);
    });
    return this;
  }
  /**
   * Animate a shape.
   *
   * @example
   * ```ts
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 })
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 }, { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partial - The shape partial to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShape(partial, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    return this.animateShapes([partial], opts);
  }
  /**
   * Animate shapes.
   *
   * @example
   * ```ts
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }], { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partials - The shape partials to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShapes(partials, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    if (!opts.animation) return this;
    const { duration = 500, easing = EASINGS.linear } = opts.animation;
    const animationId = uniqueId();
    let remaining = duration;
    let t2;
    const animations = [];
    let partial, result;
    for (let i = 0, n = partials.length; i < n; i++) {
      partial = partials[i];
      if (!partial) continue;
      const shape = this.getShape(partial.id);
      if (!shape) continue;
      result = {
        start: structuredClone(shape),
        end: applyPartialToRecordWithProps(structuredClone(shape), partial)
      };
      animations.push(result);
      this.animatingShapes.set(shape.id, animationId);
    }
    const handleTick = (elapsed) => {
      remaining -= elapsed;
      if (remaining < 0) {
        const { animatingShapes: animatingShapes2 } = this;
        const partialsToUpdate = partials.filter(
          (p) => p && animatingShapes2.get(p.id) === animationId
        );
        if (partialsToUpdate.length) {
          this.updateShapes(partialsToUpdate);
        }
        this.off("tick", handleTick);
        return;
      }
      t2 = easing(1 - remaining / duration);
      const { animatingShapes } = this;
      const updates = [];
      let animationIdForShape;
      for (let i = 0, n = animations.length; i < n; i++) {
        const { start, end } = animations[i];
        animationIdForShape = animatingShapes.get(start.id);
        if (animationIdForShape !== animationId) continue;
        updates.push({
          ...end,
          x: start.x + (end.x - start.x) * t2,
          y: start.y + (end.y - start.y) * t2,
          opacity: start.opacity + (end.opacity - start.opacity) * t2,
          rotation: start.rotation + (end.rotation - start.rotation) * t2,
          props: this.getShapeUtil(end).getInterpolatedProps?.(start, end, t2) ?? end.props
        });
      }
      this._updateShapes(updates);
    };
    this.on("tick", handleTick);
    return this;
  }
  groupShapes(shapes, opts = {}) {
    const { groupId = createShapeId(), select = true } = opts;
    if (!Array.isArray(shapes)) {
      throw Error("Editor.groupShapes: must provide an array of shapes or shape ids");
    }
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length <= 1) return this;
    const shapesToGroup = compact(
      (this._shouldIgnoreShapeLock ? ids : this._getUnlockedShapeIds(ids)).map(
        (id) => this.getShape(id)
      )
    );
    const sortedShapeIds = shapesToGroup.sort(sortByIndex).map((s) => s.id);
    const pageBounds = Box.Common(compact(shapesToGroup.map((id) => this.getShapePageBounds(id))));
    const { x, y } = pageBounds.point;
    const parentId = this.findCommonAncestor(shapesToGroup) ?? this.getCurrentPageId();
    if (this.getCurrentToolId() !== "select") return this;
    if (!this.isIn("select.idle")) {
      this.cancel();
    }
    const shapesWithRootParent = shapesToGroup.filter((shape) => shape.parentId === parentId).sort(sortByIndex);
    const highestIndex = shapesWithRootParent[shapesWithRootParent.length - 1]?.index;
    this.run(() => {
      this.createShapes([
        {
          id: groupId,
          type: "group",
          parentId,
          index: highestIndex,
          x,
          y,
          opacity: 1,
          props: {}
        }
      ]);
      this.reparentShapes(sortedShapeIds, groupId);
      if (select) {
        this.select(groupId);
      }
    });
    return this;
  }
  ungroupShapes(shapes, opts = {}) {
    if (this.getIsReadonly()) return this;
    const { select = true } = opts;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToUngroup = compact(
      (this._shouldIgnoreShapeLock ? ids : this._getUnlockedShapeIds(ids)).map(
        (id) => this.getShape(id)
      )
    );
    if (shapesToUngroup.length === 0) return this;
    if (this.getCurrentToolId() !== "select") return this;
    if (!this.isIn("select.idle")) {
      this.cancel();
    }
    const idsToSelect = /* @__PURE__ */ new Set();
    const groups = [];
    shapesToUngroup.forEach((shape) => {
      if (this.isShapeOfType(shape, "group")) {
        groups.push(shape);
      } else {
        idsToSelect.add(shape.id);
      }
    });
    if (groups.length === 0) return this;
    this.run(() => {
      let group;
      for (let i = 0, n = groups.length; i < n; i++) {
        group = groups[i];
        const childIds = this.getSortedChildIdsForParent(group.id);
        for (let j = 0, n2 = childIds.length; j < n2; j++) {
          idsToSelect.add(childIds[j]);
        }
        this.reparentShapes(childIds, group.parentId, group.index);
      }
      this.deleteShapes(groups.map((group2) => group2.id));
      if (select) {
        this.select(...idsToSelect);
      }
    });
    return this;
  }
  /**
   * Update a shape using a partial of the shape.
   *
   * @example
   * ```ts
   * editor.updateShape({ id: 'box1', type: 'geo', props: { w: 100, h: 100 } })
   * ```
   *
   * @param partial - The shape partial to update.
   *
   * @public
   */
  updateShape(partial) {
    this.updateShapes([partial]);
    return this;
  }
  /**
   * Update shapes using partials of each shape.
   *
   * @example
   * ```ts
   * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])
   * ```
   *
   * @param partials - The shape partials to update.
   *
   * @public
   */
  updateShapes(partials) {
    const compactedPartials = Array(partials.length);
    for (let i = 0, n = partials.length; i < n; i++) {
      const partial = partials[i];
      if (!partial) continue;
      const shape = this.getShape(partial.id);
      if (!shape) continue;
      if (!this._shouldIgnoreShapeLock) {
        if (shape.isLocked) {
          if (!(Object.hasOwn(partial, "isLocked") && !partial.isLocked)) {
            continue;
          }
        } else if (this.isShapeOrAncestorLocked(shape)) {
          continue;
        }
      }
      this.animatingShapes.delete(partial.id);
      compactedPartials.push(partial);
    }
    this._updateShapes(compactedPartials);
    return this;
  }
  /** @internal */
  _updateShapes(_partials) {
    if (this.getIsReadonly()) return;
    this.run(() => {
      const updates = [];
      let shape;
      let updated;
      for (let i = 0, n = _partials.length; i < n; i++) {
        const partial = _partials[i];
        if (!partial) continue;
        shape = this.getShape(partial.id);
        if (!shape) continue;
        updated = applyPartialToRecordWithProps(shape, partial);
        if (updated === shape) continue;
        updated = this.getShapeUtil(shape).onBeforeUpdate?.(shape, updated) ?? updated;
        updates.push(updated);
      }
      this.emit("edited-shapes", updates);
      this.emit("edit");
      this.store.put(updates);
    });
  }
  /** @internal */
  _getUnlockedShapeIds(ids) {
    return ids.filter((id) => !this.getShape(id)?.isLocked);
  }
  deleteShapes(_ids) {
    if (this.getIsReadonly()) return this;
    if (!Array.isArray(_ids)) {
      throw Error("Editor.deleteShapes: must provide an array of shapes or shapeIds");
    }
    const shapeIds = typeof _ids[0] === "string" ? _ids : _ids.map((s) => s.id);
    const shapeIdsToDelete = this._shouldIgnoreShapeLock ? shapeIds : this._getUnlockedShapeIds(shapeIds);
    if (shapeIdsToDelete.length === 0) return this;
    const allShapeIdsToDelete = new Set(shapeIdsToDelete);
    for (const id of shapeIdsToDelete) {
      this.visitDescendants(id, (childId) => {
        allShapeIdsToDelete.add(childId);
      });
    }
    this.emit("deleted-shapes", [...allShapeIdsToDelete]);
    this.emit("edit");
    return this.run(() => this.store.remove([...allShapeIdsToDelete]));
  }
  deleteShape(_id) {
    this.deleteShapes([typeof _id === "string" ? _id : _id.id]);
    return this;
  }
  /* --------------------- Styles --------------------- */
  /**
   * Get all the current styles among the users selected shapes
   *
   * @internal
   */
  _extractSharedStyles(shape, sharedStyleMap) {
    if (this.isShapeOfType(shape, "group")) {
      const childIds = this._parentIdsToChildIds.get()[shape.id];
      if (!childIds) return;
      for (let i = 0, n = childIds.length; i < n; i++) {
        this._extractSharedStyles(this.getShape(childIds[i]), sharedStyleMap);
      }
    } else {
      for (const [style2, propKey] of this.styleProps[shape.type]) {
        sharedStyleMap.applyValue(style2, getOwnProperty(shape.props, propKey));
      }
    }
  }
  _getSelectionSharedStyles() {
    const selectedShapes = this.getSelectedShapes();
    const sharedStyles = new SharedStyleMap();
    for (const selectedShape of selectedShapes) {
      this._extractSharedStyles(selectedShape, sharedStyles);
    }
    return sharedStyles;
  }
  /**
   * Get the style for the next shape.
   *
   * @example
   * ```ts
   * const color = editor.getStyleForNextShape(DefaultColorStyle)
   * ```
   *
   * @param style - The style to get.
   *
   * @public */
  getStyleForNextShape(style2) {
    const value = this.getInstanceState().stylesForNextShape[style2.id];
    return value === void 0 ? style2.defaultValue : value;
  }
  getShapeStyleIfExists(shape, style2) {
    const styleKey = this.styleProps[shape.type].get(style2);
    if (styleKey === void 0) return void 0;
    return getOwnProperty(shape.props, styleKey);
  }
  getSharedStyles() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      return this._getSelectionSharedStyles();
    }
    const currentTool = this.root.getCurrent();
    const styles = new SharedStyleMap();
    if (!currentTool) return styles;
    if (currentTool.shapeType) {
      if (currentTool.shapeType === "frame" && !this.getShapeUtil("frame").options.showColors) {
        for (const style2 of this.styleProps[currentTool.shapeType].keys()) {
          if (style2.id === "tldraw:color") continue;
          styles.applyValue(style2, this.getStyleForNextShape(style2));
        }
      } else {
        for (const style2 of this.styleProps[currentTool.shapeType].keys()) {
          styles.applyValue(style2, this.getStyleForNextShape(style2));
        }
      }
    }
    return styles;
  }
  getSharedOpacity() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      const shapesToCheck = [];
      const addShape = (shapeId) => {
        const shape = this.getShape(shapeId);
        if (!shape) return;
        if (this.isShapeOfType(shape, "group")) {
          for (const childId of this.getSortedChildIdsForParent(shape.id)) {
            addShape(childId);
          }
        } else {
          shapesToCheck.push(shape);
        }
      };
      for (const shapeId of this.getSelectedShapeIds()) {
        addShape(shapeId);
      }
      let opacity = null;
      for (const shape of shapesToCheck) {
        if (opacity === null) {
          opacity = shape.opacity;
        } else if (opacity !== shape.opacity) {
          return { type: "mixed" };
        }
      }
      if (opacity !== null) return { type: "shared", value: opacity };
    }
    return { type: "shared", value: this.getInstanceState().opacityForNextShape };
  }
  /**
   * Set the opacity for the next shapes. This will effect subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForNextShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   * @param historyOptions - The history options for the change.
   */
  setOpacityForNextShapes(opacity, historyOptions) {
    this.updateInstanceState({ opacityForNextShape: opacity }, historyOptions);
    return this;
  }
  /**
   * Set the current opacity. This will effect any selected shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForSelectedShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   */
  setOpacityForSelectedShapes(opacity) {
    const selectedShapes = this.getSelectedShapes();
    if (selectedShapes.length > 0) {
      const shapesToUpdate = [];
      const addShapeById = (shape) => {
        if (this.isShapeOfType(shape, "group")) {
          const childIds = this.getSortedChildIdsForParent(shape);
          for (const childId of childIds) {
            addShapeById(this.getShape(childId));
          }
        } else {
          shapesToUpdate.push(shape);
        }
      };
      for (const id of selectedShapes) {
        addShapeById(id);
      }
      this.updateShapes(
        shapesToUpdate.map((shape) => {
          return {
            id: shape.id,
            type: shape.type,
            opacity
          };
        })
      );
    }
    return this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp} for the next shapes. This change will be applied to subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red')
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red', { ephemeral: true })
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   * @param historyOptions - The history options for the change.
   *
   * @public
   */
  setStyleForNextShapes(style2, value, historyOptions) {
    const stylesForNextShape = this.getInstanceState().stylesForNextShape;
    this.updateInstanceState(
      { stylesForNextShape: { ...stylesForNextShape, [style2.id]: value } },
      historyOptions
    );
    return this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp}. This change will be applied to the currently selected shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   *
   * @public
   */
  setStyleForSelectedShapes(style2, value) {
    const selectedShapes = this.getSelectedShapes();
    if (selectedShapes.length > 0) {
      const updates = [];
      const addShapeById = (shape) => {
        if (this.isShapeOfType(shape, "group")) {
          const childIds = this.getSortedChildIdsForParent(shape.id);
          for (const childId of childIds) {
            addShapeById(this.getShape(childId));
          }
        } else {
          const util = this.getShapeUtil(shape);
          const stylePropKey = this.styleProps[shape.type].get(style2);
          if (stylePropKey) {
            const shapePartial = {
              id: shape.id,
              type: shape.type,
              props: { [stylePropKey]: value }
            };
            updates.push({
              util,
              originalShape: shape,
              updatePartial: shapePartial
            });
          }
        }
      };
      for (const shape of selectedShapes) {
        addShapeById(shape);
      }
      this.updateShapes(updates.map(({ updatePartial }) => updatePartial));
    }
    return this;
  }
  /**
   * Register an external asset handler. This handler will be called when the editor needs to
   * create an asset for some external content, like an image/video file or a bookmark URL. For
   * example, the 'file' type handler will be called when a user drops an image onto the canvas.
   *
   * The handler should extract any relevant metadata for the asset, upload it to blob storage
   * using {@link Editor.uploadAsset} if needed, and return the asset with the metadata & uploaded
   * URL.
   *
   * @example
   * ```ts
   * editor.registerExternalAssetHandler('file', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalAssetHandler(type, handler) {
    this.externalAssetContentHandlers[type] = handler;
    return this;
  }
  /**
   * Register a temporary preview of an asset. This is useful for showing a ghost image of
   * something that is being uploaded. Retrieve the placeholder with
   * {@link Editor.getTemporaryAssetPreview}. Placeholders last for 3 minutes by default, but this
   * can be configured using
   *
   * @example
   * ```ts
   * editor.createTemporaryAssetPreview(assetId, file)
   * ```
   *
   * @param assetId - The asset's id.
   * @param file - The raw file.
   *
   * @public
   */
  createTemporaryAssetPreview(assetId, file) {
    if (this.temporaryAssetPreview.has(assetId)) {
      return this.temporaryAssetPreview.get(assetId);
    }
    const objectUrl = URL.createObjectURL(file);
    this.temporaryAssetPreview.set(assetId, objectUrl);
    setTimeout(() => {
      this.temporaryAssetPreview.delete(assetId);
      URL.revokeObjectURL(objectUrl);
    }, this.options.temporaryAssetPreviewLifetimeMs);
    return objectUrl;
  }
  /**
   * Get temporary preview of an asset. This is useful for showing a ghost
   * image of something that is being uploaded.
   *
   * @example
   * ```ts
   * editor.getTemporaryAssetPreview('someId')
   * ```
   *
   * @param assetId - The asset's id.
   *
   * @public
   */
  getTemporaryAssetPreview(assetId) {
    return this.temporaryAssetPreview.get(assetId);
  }
  /**
   * Get an asset for an external asset content type.
   *
   * @example
   * ```ts
   * const asset = await editor.getAssetForExternalContent({ type: 'file', file: myFile })
   * const asset = await editor.getAssetForExternalContent({ type: 'url', url: myUrl })
   * ```
   *
   * @param info - Info about the external content.
   * @returns The asset.
   */
  async getAssetForExternalContent(info) {
    return await this.externalAssetContentHandlers[info.type]?.(info);
  }
  hasExternalAssetHandler(type) {
    return !!this.externalAssetContentHandlers[type];
  }
  /**
   * Register an external content handler. This handler will be called when the editor receives
   * external content of the provided type. For example, the 'image' type handler will be called
   * when a user drops an image onto the canvas.
   *
   * @example
   * ```ts
   * editor.registerExternalContentHandler('text', myHandler)
   * ```
   * @example
   * ```ts
   * editor.registerExternalContentHandler<'embed', MyEmbedType>('embed', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalContentHandler(type, handler) {
    this.externalContentHandlers[type] = handler;
    return this;
  }
  /**
   * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.
   *
   * @param info - Info about the external content.
   * @param opts - Options for handling external content, including force flag to bypass readonly checks.
   */
  async putExternalContent(info, opts = {}) {
    if (!opts.force && this.getIsReadonly()) return;
    return this.externalContentHandlers[info.type]?.(info);
  }
  /**
   * Handle replacing external content.
   *
   * @param info - Info about the external content.
   * @param opts - Options for handling external content, including force flag to bypass readonly checks.
   */
  async replaceExternalContent(info, opts = {}) {
    if (!opts.force && this.getIsReadonly()) return;
    return this.externalContentHandlers[info.type]?.(info);
  }
  /**
   * Get content that can be exported for the given shape ids.
   *
   * @param shapes - The shapes (or shape ids) to get content for.
   *
   * @returns The exported content.
   *
   * @public
   */
  getContentFromCurrentPage(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (!ids) return;
    if (ids.length === 0) return;
    const shapeIds = this.getShapeAndDescendantIds(ids);
    return withIsolatedShapes(this, shapeIds, (bindingIdsToKeep) => {
      const bindings = [];
      for (const id of bindingIdsToKeep) {
        const binding = this.getBinding(id);
        if (!binding) continue;
        bindings.push(binding);
      }
      const rootShapeIds = [];
      const shapes2 = [];
      for (const shapeId of shapeIds) {
        const shape = this.getShape(shapeId);
        if (!shape) continue;
        const isRootShape = !shapeIds.has(shape.parentId);
        if (isRootShape) {
          const pageTransform = this.getShapePageTransform(shape.id);
          const pagePoint = pageTransform.point();
          shapes2.push({
            ...shape,
            x: pagePoint.x,
            y: pagePoint.y,
            rotation: pageTransform.rotation(),
            parentId: this.getCurrentPageId()
          });
          rootShapeIds.push(shape.id);
        } else {
          shapes2.push(shape);
        }
      }
      const assets = [];
      const seenAssetIds = /* @__PURE__ */ new Set();
      for (const shape of shapes2) {
        if (!("assetId" in shape.props)) continue;
        const assetId = shape.props.assetId;
        if (!assetId || seenAssetIds.has(assetId)) continue;
        seenAssetIds.add(assetId);
        const asset = this.getAsset(assetId);
        if (!asset) continue;
        assets.push(asset);
      }
      return {
        schema: this.store.schema.serialize(),
        shapes: shapes2,
        rootShapeIds,
        bindings,
        assets
      };
    });
  }
  async resolveAssetsInContent(content) {
    if (!content) return void 0;
    const assets = [];
    await Promise.allSettled(
      content.assets.map(async (asset) => {
        if ((asset.type === "image" || asset.type === "video") && !asset.props.src?.startsWith("data:image") && !asset.props.src?.startsWith("data:video") && !asset.props.src?.startsWith("http")) {
          const assetWithDataUrl = structuredClone(asset);
          const objectUrl = await this.store.props.assets.resolve(asset, {
            screenScale: 1,
            steppedScreenScale: 1,
            dpr: 1,
            networkEffectiveType: null,
            shouldResolveToOriginal: true
          });
          assetWithDataUrl.props.src = await FileHelpers.blobToDataUrl(
            await fetch$1(objectUrl).then((r) => r.blob())
          );
          assets.push(assetWithDataUrl);
        } else {
          assets.push(asset);
        }
      })
    );
    content.assets = assets;
    return content;
  }
  /**
   * Place content into the editor.
   *
   * @param content - The content.
   * @param opts - Options for placing the content.
   *
   * @public
   */
  putContentOntoCurrentPage(content, opts = {}) {
    if (this.getIsReadonly()) return this;
    if (!content.schema) {
      throw Error("Could not put content:\ncontent is missing a schema.");
    }
    const { select = false, preserveIds = false, preservePosition = false } = opts;
    let { point = void 0 } = opts;
    const currentPageId = this.getCurrentPageId();
    const { rootShapeIds } = content;
    const assets = [];
    const shapes = [];
    const bindings = [];
    const store = {
      store: {
        ...Object.fromEntries(content.assets.map((asset) => [asset.id, asset])),
        ...Object.fromEntries(content.shapes.map((shape) => [shape.id, shape])),
        ...Object.fromEntries(
          content.bindings?.map((bindings2) => [bindings2.id, bindings2]) ?? []
        )
      },
      schema: content.schema
    };
    const result = this.store.schema.migrateStoreSnapshot(store);
    if (result.type === "error") {
      throw Error("Could not put content: could not migrate content");
    }
    for (const record of Object.values(result.value)) {
      switch (record.typeName) {
        case "asset": {
          assets.push(record);
          break;
        }
        case "shape": {
          shapes.push(record);
          break;
        }
        case "binding": {
          bindings.push(record);
          break;
        }
      }
    }
    const shapeIdMap = new Map(
      preserveIds ? shapes.map((shape) => [shape.id, shape.id]) : shapes.map((shape) => [shape.id, createShapeId()])
    );
    const bindingIdMap = new Map(
      preserveIds ? bindings.map((binding) => [binding.id, binding.id]) : bindings.map((binding) => [binding.id, createBindingId()])
    );
    let pasteParentId = this.getCurrentPageId();
    let lowestDepth = Infinity;
    let lowestAncestors = [];
    for (const shape of this.getSelectedShapes()) {
      if (lowestDepth === 0) break;
      const isFrame = this.isShapeOfType(shape, "frame");
      const ancestors = this.getShapeAncestors(shape);
      if (isFrame) ancestors.push(shape);
      const depth = isFrame ? ancestors.length + 1 : ancestors.length;
      if (depth < lowestDepth) {
        lowestDepth = depth;
        lowestAncestors = ancestors;
        pasteParentId = isFrame ? shape.id : shape.parentId;
      } else if (depth === lowestDepth) {
        if (lowestAncestors.length !== ancestors.length) {
          throw Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`);
        }
        if (lowestAncestors.length === 0) {
          pasteParentId = currentPageId;
          break;
        } else {
          pasteParentId = currentPageId;
          for (let i = 0; i < lowestAncestors.length; i++) {
            if (ancestors[i] !== lowestAncestors[i]) break;
            pasteParentId = ancestors[i].id;
          }
        }
      }
    }
    let isDuplicating = false;
    if (!isPageId(pasteParentId)) {
      const parent = this.getShape(pasteParentId);
      if (parent) {
        if (!this.getViewportPageBounds().includes(this.getShapePageBounds(parent))) {
          pasteParentId = currentPageId;
        } else {
          if (rootShapeIds.length === 1) {
            const rootShape = shapes.find((s) => s.id === rootShapeIds[0]);
            if (this.isShapeOfType(parent, "frame") && this.isShapeOfType(rootShape, "frame") && rootShape.props.w === parent?.props.w && rootShape.props.h === parent?.props.h) {
              isDuplicating = true;
            }
          }
        }
      } else {
        pasteParentId = currentPageId;
      }
    }
    if (!isDuplicating) {
      isDuplicating = shapeIdMap.has(pasteParentId);
    }
    if (isDuplicating) {
      pasteParentId = this.getShape(pasteParentId).parentId;
    }
    let index2 = this.getHighestIndexForParent(pasteParentId);
    const rootShapes = [];
    const newShapes = shapes.map((oldShape) => {
      const newId = shapeIdMap.get(oldShape.id);
      const newShape = { ...oldShape, id: newId };
      if (rootShapeIds.includes(oldShape.id)) {
        newShape.parentId = currentPageId;
        rootShapes.push(newShape);
      }
      if (shapeIdMap.has(newShape.parentId)) {
        newShape.parentId = shapeIdMap.get(oldShape.parentId);
      } else {
        rootShapeIds.push(newShape.id);
        newShape.index = index2;
        index2 = getIndexAbove(index2);
      }
      return newShape;
    });
    if (newShapes.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage) {
      alertMaxShapes(this);
      return this;
    }
    const newBindings = bindings.map(
      (oldBinding) => ({
        ...oldBinding,
        id: assertExists(bindingIdMap.get(oldBinding.id)),
        fromId: assertExists(shapeIdMap.get(oldBinding.fromId)),
        toId: assertExists(shapeIdMap.get(oldBinding.toId))
      })
    );
    const assetsToCreate = [];
    const assetsToUpdate = [];
    for (const asset of assets) {
      if (this.store.has(asset.id)) {
        continue;
      }
      if (asset.type === "image" && asset.props.src?.startsWith("data:image") || asset.type === "video" && asset.props.src?.startsWith("data:video")) {
        assetsToUpdate.push(structuredClone(asset));
        asset.props.src = null;
      }
      assetsToCreate.push(asset);
    }
    Promise.allSettled(
      assetsToUpdate.map(async (asset) => {
        const file = await dataUrlToFile(
          asset.props.src,
          asset.props.name,
          asset.props.mimeType ?? "image/png"
        );
        const newAsset = await this.getAssetForExternalContent({
          type: "file",
          file,
          assetId: asset.id
        });
        if (!newAsset) {
          this.deleteAssets([asset.id]);
          return;
        }
        this.updateAssets([{ ...newAsset, id: asset.id }]);
      })
    );
    this.run(() => {
      if (assetsToCreate.length > 0) {
        this.createAssets(assetsToCreate);
      }
      this.createShapes(newShapes);
      this.createBindings(newBindings);
      if (select) {
        this.select(...rootShapes.map((s) => s.id));
      }
      if (pasteParentId !== currentPageId) {
        this.reparentShapes(
          rootShapes.map((s) => s.id),
          pasteParentId
        );
      }
      const newCreatedShapes = newShapes.map((s) => this.getShape(s.id));
      const bounds = Box.Common(newCreatedShapes.map((s) => this.getShapePageBounds(s)));
      if (point === void 0) {
        if (!isPageId(pasteParentId)) {
          const shape = this.getShape(pasteParentId);
          point = Mat.applyToPoint(
            this.getShapePageTransform(shape),
            this.getShapeGeometry(shape).bounds.center
          );
        } else {
          const viewportPageBounds = this.getViewportPageBounds();
          if (preservePosition || viewportPageBounds.includes(Box.From(bounds))) {
            point = bounds.center;
          } else {
            point = viewportPageBounds.center;
          }
        }
      }
      if (rootShapes.length === 1) {
        const onlyRoot = rootShapes[0];
        if (this.isShapeOfType(onlyRoot, "frame")) {
          while (this.getShapesAtPoint(point).some(
            (shape) => this.isShapeOfType(shape, "frame") && shape.props.w === onlyRoot.props.w && shape.props.h === onlyRoot.props.h
          )) {
            point.x += bounds.w + 16;
          }
        }
      }
      const pageCenter = Box.Common(
        compact(rootShapes.map(({ id }) => this.getShapePageBounds(id)))
      ).center;
      const offset2 = Vec.Sub(point, pageCenter);
      this.updateShapes(
        rootShapes.map(({ id }) => {
          const s = this.getShape(id);
          const localRotation = this.getShapeParentTransform(id).decompose().rotation;
          const localDelta = Vec.Rot(offset2, -localRotation);
          return { id: s.id, type: s.type, x: s.x + localDelta.x, y: s.y + localDelta.y };
        })
      );
    });
    return this;
  }
  /**
   * Get an exported SVG element of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgElement(shapes, opts = {}) {
    const ids = shapes.length === 0 ? this.getCurrentPageShapeIdsSorted() : typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length === 0) return void 0;
    return exportToSvg(this, ids, opts);
  }
  /**
   * Get an exported SVG string of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgString(shapes, opts = {}) {
    const result = await this.getSvgElement(shapes, opts);
    if (!result) return void 0;
    const serializer = new XMLSerializer();
    return {
      svg: serializer.serializeToString(result.svg),
      width: result.width,
      height: result.height
    };
  }
  /**
   * Get an exported image of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns A blob of the image.
   * @public
   */
  async toImage(shapes, opts = {}) {
    const withDefaults = {
      format: "png",
      scale: 1,
      pixelRatio: opts.format === "svg" ? void 0 : 2,
      ...opts
    };
    const result = await this.getSvgString(shapes, withDefaults);
    if (!result) throw new Error("Could not create SVG");
    switch (withDefaults.format) {
      case "svg":
        return {
          blob: new Blob([result.svg], { type: "image/svg+xml" }),
          width: result.width,
          height: result.height
        };
      case "jpeg":
      case "png":
      case "webp": {
        const blob = await getSvgAsImage(result.svg, {
          type: withDefaults.format,
          quality: withDefaults.quality,
          pixelRatio: withDefaults.pixelRatio,
          width: result.width,
          height: result.height
        });
        if (!blob) {
          throw new Error("Could not construct image.");
        }
        return {
          blob,
          width: result.width,
          height: result.height
        };
      }
      default: {
        exhaustiveSwitchError(withDefaults.format);
      }
    }
  }
  /**
   * Get an exported image of the given shapes as a data URL.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns A data URL of the image.
   * @public
   */
  async toImageDataUrl(shapes, opts = {}) {
    const { blob, width, height } = await this.toImage(shapes, opts);
    return {
      url: await FileHelpers.blobToDataUrl(blob),
      width,
      height
    };
  }
  /**
   * Update the input points from a pointer, pinch, or wheel event.
   *
   * @param info - The event info.
   */
  _updateInputsFromEvent(info) {
    const {
      pointerVelocity,
      previousScreenPoint,
      previousPagePoint,
      currentScreenPoint,
      currentPagePoint,
      originScreenPoint,
      originPagePoint
    } = this.inputs;
    const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
    const sx = info.point.x - screenBounds.x;
    const sy = info.point.y - screenBounds.y;
    const sz = info.point.z ?? 0.5;
    previousScreenPoint.setTo(currentScreenPoint);
    previousPagePoint.setTo(currentPagePoint);
    currentScreenPoint.set(sx, sy);
    const nx = sx / cz - cx;
    const ny = sy / cz - cy;
    if (isFinite(nx) && isFinite(ny)) {
      currentPagePoint.set(nx, ny, sz);
    }
    this.inputs.isPen = info.type === "pointer" && info.isPen;
    if (info.name === "pointer_down" || this.inputs.isPinching) {
      pointerVelocity.set(0, 0);
      originScreenPoint.setTo(currentScreenPoint);
      originPagePoint.setTo(currentPagePoint);
    }
    this.run(
      () => {
        this.store.put([
          {
            id: TLPOINTER_ID,
            typeName: "pointer",
            x: currentPagePoint.x,
            y: currentPagePoint.y,
            lastActivityTimestamp: (
              // If our pointer moved only because we're following some other user, then don't
              // update our last activity timestamp; otherwise, update it to the current timestamp.
              info.type === "pointer" && info.pointerId === INTERNAL_POINTER_IDS.CAMERA_MOVE ? this.store.unsafeGetWithoutCapture(TLPOINTER_ID)?.lastActivityTimestamp ?? this._tickManager.now : this._tickManager.now
            ),
            meta: {}
          }
        ]);
      },
      { history: "ignore" }
    );
  }
  /**
   * Dispatch a cancel event.
   *
   * @example
   * ```ts
   * editor.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    this.dispatch({ type: "misc", name: "cancel" });
    return this;
  }
  /**
   * Dispatch an interrupt event.
   *
   * @example
   * ```ts
   * editor.interrupt()
   * ```
   *
   * @public
   */
  interrupt() {
    this.dispatch({ type: "misc", name: "interrupt" });
    return this;
  }
  /**
   * Dispatch a complete event.
   *
   * @example
   * ```ts
   * editor.complete()
   * ```
   *
   * @public
   */
  complete() {
    this.dispatch({ type: "misc", name: "complete" });
    return this;
  }
  /**
   * Dispatch a pointer move event in the current position of the pointer. This is useful when
   * external circumstances have changed (e.g. the camera moved or a shape was moved) and you want
   * the current interaction to respond to that change.
   *
   * @example
   * ```ts
   * editor.updatePointer()
   * ```
   *
   * @param options - The options for updating the pointer.
   * @returns The editor instance.
   * @public
   */
  updatePointer(options) {
    const event = {
      type: "pointer",
      target: "canvas",
      name: "pointer_move",
      point: options?.point ?? // weird but true: what `inputs` calls screen-space is actually viewport space. so
      // we need to convert back into true screen space first. we should fix this...
      Vec.Add(
        this.inputs.currentScreenPoint,
        this.store.unsafeGetWithoutCapture(TLINSTANCE_ID).screenBounds
      ),
      pointerId: options?.pointerId ?? 0,
      button: options?.button ?? 0,
      isPen: options?.isPen ?? this.inputs.isPen,
      shiftKey: options?.shiftKey ?? this.inputs.shiftKey,
      altKey: options?.altKey ?? this.inputs.altKey,
      ctrlKey: options?.ctrlKey ?? this.inputs.ctrlKey,
      metaKey: options?.metaKey ?? this.inputs.metaKey,
      accelKey: options?.accelKey ?? isAccelKey(this.inputs)
    };
    if (options?.immediate) {
      this._flushEventForTick(event);
    } else {
      this.dispatch(event);
    }
    return this;
  }
  /**
   * Puts the editor into focused mode.
   *
   * This makes the editor eligible to receive keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.focus()
   * ```
   *
   * By default this also dispatches a 'focus' event to the container element. To prevent this, pass `focusContainer: false`.
   *
   * @example
   * ```ts
   * editor.focus({ focusContainer: false })
   * ```
   *
   * @public
   */
  focus({ focusContainer = true } = {}) {
    if (this.getIsFocused()) return this;
    if (focusContainer) this.focusManager.focus();
    this.updateInstanceState({ isFocused: true });
    return this;
  }
  /**
   * Switches off the editor's focused mode.
   *
   * This makes the editor ignore keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.blur()
   * ```
   * By default this also dispatches a 'blur' event to the container element. To prevent this, pass `blurContainer: false`.
   *
   * @example
   * ```ts
   * editor.blur({ blurContainer: false })
   * ```
   *
   * @public
   */
  blur({ blurContainer = true } = {}) {
    if (!this.getIsFocused()) return this;
    if (blurContainer) {
      this.focusManager.blur();
    } else {
      this.complete();
    }
    this.updateInstanceState({ isFocused: false });
    return this;
  }
  getIsFocused() {
    return this.getInstanceState().isFocused;
  }
  getIsReadonly() {
    return this.getInstanceState().isReadonly;
  }
  /**
   * @public
   * @returns a snapshot of the store's UI and document state
   */
  getSnapshot() {
    return getSnapshot(this.store);
  }
  /**
   * Loads a snapshot into the editor.
   * @param snapshot - The snapshot to load.
   * @param opts - The options for loading the snapshot.
   * @returns
   */
  loadSnapshot(snapshot, opts) {
    loadSnapshot(this.store, snapshot, opts);
    return this;
  }
  _zoomToFitPageContentAt100Percent() {
    const bounds = this.getCurrentPageBounds();
    if (bounds) {
      this.zoomToBounds(bounds, { immediate: true, targetZoom: this.getBaseZoom() });
    }
  }
  _navigateToDeepLink(deepLink) {
    this.run(() => {
      switch (deepLink.type) {
        case "page": {
          const page = this.getPage(deepLink.pageId);
          if (page) {
            this.setCurrentPage(page);
          }
          this._zoomToFitPageContentAt100Percent();
          return;
        }
        case "shapes": {
          const allShapes = compact(deepLink.shapeIds.map((id) => this.getShape(id)));
          const byPage = {};
          for (const shape of allShapes) {
            const pageId2 = this.getAncestorPageId(shape);
            if (!pageId2) continue;
            byPage[pageId2] ??= [];
            byPage[pageId2].push(shape);
          }
          const [pageId, shapes] = Object.entries(byPage).sort(
            ([_, a], [__, b]) => b.length - a.length
          )[0] ?? ["", []];
          if (!pageId || !shapes.length) {
            this._zoomToFitPageContentAt100Percent();
          } else {
            this.setCurrentPage(pageId);
            const bounds = Box.Common(shapes.map((s) => this.getShapePageBounds(s)));
            this.zoomToBounds(bounds, { immediate: true, targetZoom: this.getBaseZoom() });
          }
          return;
        }
        case "viewport": {
          if (deepLink.pageId) {
            if (!this.getPage(deepLink.pageId)) {
              this._zoomToFitPageContentAt100Percent();
              return;
            }
            this.setCurrentPage(deepLink.pageId);
          }
          this.zoomToBounds(deepLink.bounds, { immediate: true, inset: 0 });
          return;
        }
        default:
          exhaustiveSwitchError(deepLink);
      }
    });
  }
  /**
   * Handles navigating to the content specified by the query param in the given URL.
   *
   * Use {@link Editor#createDeepLink} to create a URL with a deep link query param.
   *
   * If no URL is provided, it will look for the param in the current `window.location.href`.
   *
   * @example
   * ```ts
   * editor.navigateToDeepLink()
   * ```
   *
   * The default parameter name is 'd'. You can override this by providing the `param` option.
   *
   * @example
   * ```ts
   * // disable page parameter and change viewport parameter to 'c'
   * editor.navigateToDeepLink({
   *   param: 'x',
   *   url: 'https://my-app.com/my-document?x=200.12.454.23.xyz123',
   * })
   * ```
   *
   * @param opts - Options for loading the state from the URL.
   */
  navigateToDeepLink(opts) {
    if (opts && "type" in opts) {
      this._navigateToDeepLink(opts);
      return this;
    }
    const url = new URL(opts?.url ?? window.location.href);
    const deepLinkString = url.searchParams.get(opts?.param ?? "d");
    if (!deepLinkString) {
      this._zoomToFitPageContentAt100Percent();
      return this;
    }
    try {
      this._navigateToDeepLink(parseDeepLinkString(deepLinkString));
    } catch (e) {
      console.warn(e);
      this._zoomToFitPageContentAt100Percent();
    }
    return this;
  }
  /**
   * Turns the given URL into a deep link by adding a query parameter.
   *
   * e.g. `https://my-app.com/my-document?d=100.100.200.200.xyz123`
   *
   * If no URL is provided, it will use the current `window.location.href`.
   *
   * @example
   * ```ts
   * // create a deep link to the current page + viewport
   * navigator.clipboard.writeText(editor.createDeepLink())
   * ```
   *
   * You can link to a particular set of shapes by providing a `to` parameter.
   *
   * @example
   * ```ts
   * // create a deep link to the set of currently selected shapes
   * navigator.clipboard.writeText(editor.createDeepLink({
   *   to: { type: 'selection', shapeIds: editor.getSelectedShapeIds() }
   * }))
   * ```
   *
   * The default query param is 'd'. You can override this by providing a `param` parameter.
   *
   * @example
   * ```ts
   * // Use `x` as the param name instead
   * editor.createDeepLink({ param: 'x' })
   * ```
   *
   * @param opts - Options for adding the state to the URL.
   * @returns the updated URL
   */
  createDeepLink(opts) {
    const url = new URL(opts?.url ?? window.location.href);
    url.searchParams.set(
      opts?.param ?? "d",
      createDeepLinkString(
        opts?.to ?? {
          type: "viewport",
          pageId: this.options.maxPages === 1 ? void 0 : this.getCurrentPageId(),
          bounds: this.getViewportPageBounds()
        }
      )
    );
    return url;
  }
  /**
   * Register a listener for changes to a deep link for the current document.
   *
   * You'll typically want to use this indirectly via the {@link TldrawEditorBaseProps.deepLinks} prop on the `<Tldraw />` component.
   *
   * By default this will update `window.location` in place, but you can provide a custom callback
   * to handle state changes on your own.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   onChange(url) {
   *     window.history.replaceState({}, document.title, url.toString())
   *   }
   * })
   * ```
   *
   * You can also provide a custom URL to update, in which case you must also provide `onChange`.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   getUrl: () => `https://my-app.com/my-document`,
   *   onChange(url) {
   *     setShareUrl(url.toString())
   *   }
   * })
   * ```
   *
   * By default this will update with a debounce interval of 500ms, but you can provide a custom interval.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ debounceMs: 1000 })
   * ```
   * The default parameter name is `d`. You can override this by providing a `param` option.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ param: 'x' })
   * ```
   * @param opts - Options for setting up the listener.
   * @returns a function that will stop the listener.
   */
  registerDeepLinkListener(opts) {
    if (opts?.getUrl && !opts?.onChange) {
      throw Error(
        "[tldraw:urlStateSync] If you specify getUrl, you must also specify the onChange callback."
      );
    }
    const url$ = computed("url with state", () => {
      const url = opts?.getUrl?.(this) ?? window.location.href;
      const urlWithState = this.createDeepLink({
        param: opts?.param,
        url,
        to: opts?.getTarget?.(this)
      });
      return urlWithState.toString();
    });
    const announceChange = opts?.onChange ?? (() => {
      const url = this.createDeepLink({
        param: opts?.param,
        to: opts?.getTarget?.(this)
      });
      window.history.replaceState({}, document.title, url.toString());
    });
    const scheduleEffect = debounce((execute) => execute(), opts?.debounceMs ?? 500);
    const unlisten = react(
      "update url on state change",
      () => announceChange(new URL(url$.get()), this),
      { scheduleEffect }
    );
    return () => {
      unlisten();
      scheduleEffect.cancel();
    };
  }
  /**
   * Prevent a double click event from firing the next time the user clicks
   *
   * @public
   */
  cancelDoubleClick() {
    this._clickManager.cancelDoubleClickTimeout();
  }
  _setShiftKeyTimeout() {
    this.inputs.shiftKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Shift",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "ShiftLeft"
    });
  }
  _setAltKeyTimeout() {
    this.inputs.altKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Alt",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "AltLeft"
    });
  }
  _setCtrlKeyTimeout() {
    this.inputs.ctrlKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Ctrl",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "ControlLeft"
    });
  }
  _setMetaKeyTimeout() {
    this.inputs.metaKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Meta",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "MetaLeft"
    });
  }
  /**
   * In tldraw, events are sometimes handled by multiple components. For example, the shapes might
   * have events, but the canvas handles events too. The way that the canvas handles events can
   * interfere with the with the shapes event handlers - for example, it calls `.preventDefault()`
   * on `pointerDown`, which also prevents `click` events from firing on the shapes.
   *
   * You can use `.stopPropagation()` to prevent the event from propagating to the rest of the
   * DOM, but that can impact non-tldraw event handlers set up elsewhere. By using
   * `markEventAsHandled`, you'll stop other parts of tldraw from handling the event without
   * impacting other, non-tldraw event handlers. See also {@link Editor.wasEventAlreadyHandled}.
   *
   * @public
   */
  markEventAsHandled(e) {
    const nativeEvent = "nativeEvent" in e ? e.nativeEvent : e;
    this.handledEvents.add(nativeEvent);
  }
  /**
   * Checks if an event has already been handled. See {@link Editor.markEventAsHandled}.
   *
   * @public
   */
  wasEventAlreadyHandled(e) {
    const nativeEvent = "nativeEvent" in e ? e.nativeEvent : e;
    return this.handledEvents.has(nativeEvent);
  }
  /**
   * Dispatch an event to the editor.
   *
   * @example
   * ```ts
   * editor.dispatch(myPointerEvent)
   * ```
   *
   * @param info - The event info.
   *
   * @public
   */
  dispatch(info) {
    this._pendingEventsForNextTick.push(info);
    if (!(info.type === "pointer" && info.name === "pointer_move" || info.type === "wheel" || info.type === "pinch")) {
      this._flushEventsForTick(0);
    }
    return this;
  }
  _flushEventsForTick(elapsed) {
    this.run(() => {
      if (this._pendingEventsForNextTick.length > 0) {
        const events = [...this._pendingEventsForNextTick];
        this._pendingEventsForNextTick.length = 0;
        for (const info of events) {
          this._flushEventForTick(info);
        }
      }
      if (elapsed > 0) {
        this.root.handleEvent({ type: "misc", name: "tick", elapsed });
      }
      this.scribbles.tick(elapsed);
    });
  }
  _flushEventForTick(info) {
    if (this.getCrashingError()) return this;
    this.emit("before-event", info);
    const { inputs } = this;
    const { type } = info;
    if (info.type === "misc") {
      if (info.name === "cancel" || info.name === "complete") {
        this.inputs.isDragging = false;
        if (this.inputs.isPanning) {
          this.inputs.isPanning = false;
          this.inputs.isSpacebarPanning = false;
          this.setCursor({ type: this._prevCursor, rotation: 0 });
        }
      }
      this.root.handleEvent(info);
      return;
    }
    if (info.shiftKey) {
      clearTimeout(this._shiftKeyTimeout);
      this._shiftKeyTimeout = -1;
      inputs.shiftKey = true;
    } else if (!info.shiftKey && inputs.shiftKey && this._shiftKeyTimeout === -1) {
      this._shiftKeyTimeout = this.timers.setTimeout(this._setShiftKeyTimeout, 150);
    }
    if (info.altKey) {
      clearTimeout(this._altKeyTimeout);
      this._altKeyTimeout = -1;
      inputs.altKey = true;
    } else if (!info.altKey && inputs.altKey && this._altKeyTimeout === -1) {
      this._altKeyTimeout = this.timers.setTimeout(this._setAltKeyTimeout, 150);
    }
    if (info.ctrlKey) {
      clearTimeout(this._ctrlKeyTimeout);
      this._ctrlKeyTimeout = -1;
      inputs.ctrlKey = true;
    } else if (!info.ctrlKey && inputs.ctrlKey && this._ctrlKeyTimeout === -1) {
      this._ctrlKeyTimeout = this.timers.setTimeout(this._setCtrlKeyTimeout, 150);
    }
    if (info.metaKey) {
      clearTimeout(this._metaKeyTimeout);
      this._metaKeyTimeout = -1;
      inputs.metaKey = true;
    } else if (!info.metaKey && inputs.metaKey && this._metaKeyTimeout === -1) {
      this._metaKeyTimeout = this.timers.setTimeout(this._setMetaKeyTimeout, 150);
    }
    const { originPagePoint, currentPagePoint } = inputs;
    if (!inputs.isPointing) {
      inputs.isDragging = false;
    }
    const instanceState = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const pageState = this.store.get(this._getCurrentPageStateId());
    const cameraOptions = this._cameraOptions.__unsafe__getWithoutCapture();
    switch (type) {
      case "pinch": {
        if (cameraOptions.isLocked) return;
        clearTimeout(this._longPressTimeout);
        this._updateInputsFromEvent(info);
        switch (info.name) {
          case "pinch_start": {
            if (inputs.isPinching) return;
            if (!inputs.isEditing) {
              this._pinchStart = this.getCamera().z;
              if (!this._selectedShapeIdsAtPointerDown.length) {
                this._selectedShapeIdsAtPointerDown = [...pageState.selectedShapeIds];
              }
              this._didPinch = true;
              inputs.isPinching = true;
              this.interrupt();
            }
            return;
          }
          case "pinch": {
            if (!inputs.isPinching) return;
            const {
              point: { z = 1 },
              delta: { x: dx, y: dy }
            } = info;
            const { x, y } = Vec.SubXY(
              info.point,
              instanceState.screenBounds.x,
              instanceState.screenBounds.y
            );
            this.stopCameraAnimation();
            if (instanceState.followingUserId) {
              this.stopFollowingUser();
            }
            const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
            const { panSpeed } = cameraOptions;
            this._setCamera(
              new Vec(
                cx + dx * panSpeed / cz - x / cz + x / z,
                cy + dy * panSpeed / cz - y / cz + y / z,
                z
              ),
              { immediate: true }
            );
            return;
          }
          case "pinch_end": {
            if (!inputs.isPinching) return this;
            inputs.isPinching = false;
            const { _selectedShapeIdsAtPointerDown: shapesToReselect } = this;
            this.setSelectedShapes(this._selectedShapeIdsAtPointerDown);
            this._selectedShapeIdsAtPointerDown = [];
            if (this._didPinch) {
              this._didPinch = false;
              if (shapesToReselect.length > 0) {
                this.once("tick", () => {
                  if (!this._didPinch) {
                    this.setSelectedShapes(shapesToReselect);
                  }
                });
              }
            }
            return;
          }
        }
      }
      case "wheel": {
        if (cameraOptions.isLocked) return;
        this._updateInputsFromEvent(info);
        const { panSpeed, zoomSpeed } = cameraOptions;
        let wheelBehavior = cameraOptions.wheelBehavior;
        const inputMode = this.user.getUserPreferences().inputMode;
        if (inputMode !== null) {
          wheelBehavior = inputMode === "trackpad" ? "pan" : "zoom";
        }
        if (wheelBehavior !== "none") {
          this.stopCameraAnimation();
          if (instanceState.followingUserId) {
            this.stopFollowingUser();
          }
          const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
          const { x: dx, y: dy, z: dz = 0 } = info.delta;
          let behavior = wheelBehavior;
          if (info.ctrlKey) behavior = wheelBehavior === "pan" ? "zoom" : "pan";
          switch (behavior) {
            case "zoom": {
              const { x, y } = this.inputs.currentScreenPoint;
              let delta = dz;
              if (wheelBehavior === "zoom") {
                if (Math.abs(dy) > 10) {
                  delta = 10 * Math.sign(dy) / 100;
                } else {
                  delta = dy / 100;
                }
              }
              const zoom = cz + (delta ?? 0) * zoomSpeed * cz;
              this._setCamera(new Vec(cx + x / zoom - x / cz, cy + y / zoom - y / cz, zoom), {
                immediate: true
              });
              this.maybeTrackPerformance("Zooming");
              return;
            }
            case "pan": {
              this._setCamera(new Vec(cx + dx * panSpeed / cz, cy + dy * panSpeed / cz, cz), {
                immediate: true
              });
              this.maybeTrackPerformance("Panning");
              return;
            }
          }
        }
        break;
      }
      case "pointer": {
        if (inputs.isPinching) return;
        this._updateInputsFromEvent(info);
        const { isPen } = info;
        const { isPenMode } = instanceState;
        switch (info.name) {
          case "pointer_down": {
            if (isPenMode && !isPen) return;
            if (!this.inputs.isPanning) {
              this._longPressTimeout = this.timers.setTimeout(() => {
                const vsb = this.getViewportScreenBounds();
                this.dispatch({
                  ...info,
                  // important! non-obvious!! the screenpoint was adjusted using the
                  // viewport bounds, and will be again when this event is handled...
                  // so we need to counter-adjust from the stored value so that the
                  // new value is set correctly.
                  point: this.inputs.originScreenPoint.clone().addXY(vsb.x, vsb.y),
                  name: "long_press"
                });
              }, this.options.longPressDurationMs);
            }
            this._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds();
            if (info.button === LEFT_MOUSE_BUTTON) this.capturedPointerId = info.pointerId;
            inputs.buttons.add(info.button);
            inputs.isPointing = true;
            inputs.isDragging = false;
            if (!isPenMode && isPen) this.updateInstanceState({ isPenMode: true });
            if (info.button === STYLUS_ERASER_BUTTON) {
              this._restoreToolId = this.getCurrentToolId();
              this.complete();
              this.setCurrentTool("eraser");
            } else if (info.button === MIDDLE_MOUSE_BUTTON) {
              if (!this.inputs.isPanning) {
                this._prevCursor = this.getInstanceState().cursor.type;
              }
              this.inputs.isPanning = true;
              clearTimeout(this._longPressTimeout);
            }
            if (this.inputs.isPanning) {
              this.stopCameraAnimation();
              this.setCursor({ type: "grabbing", rotation: 0 });
              return this;
            }
            break;
          }
          case "pointer_move": {
            if (!isPen && isPenMode) return;
            const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
            if (this.inputs.isPanning && this.inputs.isPointing) {
              const { currentScreenPoint, previousScreenPoint } = this.inputs;
              const offset2 = Vec.Sub(currentScreenPoint, previousScreenPoint);
              this.setCamera(new Vec(cx + offset2.x / cz, cy + offset2.y / cz, cz), {
                immediate: true
              });
              this.maybeTrackPerformance("Panning");
              return;
            }
            if (inputs.isPointing && !inputs.isDragging && Vec.Dist2(originPagePoint, currentPagePoint) * this.getZoomLevel() > (instanceState.isCoarsePointer ? this.options.coarseDragDistanceSquared : this.options.dragDistanceSquared) / cz) {
              inputs.isDragging = true;
              clearTimeout(this._longPressTimeout);
            }
            break;
          }
          case "pointer_up": {
            inputs.isDragging = false;
            inputs.isPointing = false;
            clearTimeout(this._longPressTimeout);
            inputs.buttons.delete(info.button);
            if (instanceState.isPenMode && !isPen) return;
            if (this.capturedPointerId === info.pointerId) {
              this.capturedPointerId = null;
              info.button = 0;
            }
            if (inputs.isPanning) {
              if (!inputs.keys.has("Space")) {
                inputs.isPanning = false;
                inputs.isSpacebarPanning = false;
              }
              const slideDirection = this.inputs.pointerVelocity;
              const slideSpeed = Math.min(2, slideDirection.len());
              switch (info.button) {
                case LEFT_MOUSE_BUTTON: {
                  this.setCursor({ type: "grab", rotation: 0 });
                  break;
                }
                case MIDDLE_MOUSE_BUTTON: {
                  if (this.inputs.keys.has(" ")) {
                    this.setCursor({ type: "grab", rotation: 0 });
                  } else {
                    this.setCursor({ type: this._prevCursor, rotation: 0 });
                  }
                }
              }
              if (slideSpeed > 0) {
                this.slideCamera({ speed: slideSpeed, direction: slideDirection });
              }
            } else {
              if (info.button === STYLUS_ERASER_BUTTON) {
                this.complete();
                this.setCurrentTool(this._restoreToolId);
              }
            }
            break;
          }
        }
        break;
      }
      case "keyboard": {
        if (info.key === "ShiftRight") info.key = "ShiftLeft";
        if (info.key === "AltRight") info.key = "AltLeft";
        if (info.code === "ControlRight") info.code = "ControlLeft";
        if (info.code === "MetaRight") info.code = "MetaLeft";
        switch (info.name) {
          case "key_down": {
            inputs.keys.add(info.code);
            if (info.code === "Space" && !info.ctrlKey) {
              if (!this.inputs.isPanning) {
                this._prevCursor = instanceState.cursor.type;
              }
              this.inputs.isPanning = true;
              this.inputs.isSpacebarPanning = true;
              clearTimeout(this._longPressTimeout);
              this.setCursor({ type: this.inputs.isPointing ? "grabbing" : "grab", rotation: 0 });
            }
            if (this.inputs.isSpacebarPanning) {
              let offset2;
              switch (info.code) {
                case "ArrowUp": {
                  offset2 = new Vec(0, -1);
                  break;
                }
                case "ArrowRight": {
                  offset2 = new Vec(1, 0);
                  break;
                }
                case "ArrowDown": {
                  offset2 = new Vec(0, 1);
                  break;
                }
                case "ArrowLeft": {
                  offset2 = new Vec(-1, 0);
                  break;
                }
              }
              if (offset2) {
                const bounds = this.getViewportPageBounds();
                const next = bounds.clone().translate(offset2.mulV({ x: bounds.w, y: bounds.h }));
                this._animateToViewport(next, { animation: { duration: 320 } });
              }
            }
            break;
          }
          case "key_up": {
            inputs.keys.delete(info.code);
            if (info.code === "Space") {
              if (this.inputs.buttons.has(MIDDLE_MOUSE_BUTTON)) ;
              else {
                this.inputs.isPanning = false;
                this.inputs.isSpacebarPanning = false;
                this.setCursor({ type: this._prevCursor, rotation: 0 });
              }
            }
            break;
          }
        }
        break;
      }
    }
    if (info.type === "pointer") {
      if (info.button === MIDDLE_MOUSE_BUTTON) {
        info.name = "middle_click";
      } else if (info.button === RIGHT_MOUSE_BUTTON) {
        info.name = "right_click";
      }
      const { isPenMode } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
      if (info.isPen === isPenMode) {
        const clickInfo = this._clickManager.handlePointerEvent(info);
        if (info.name !== clickInfo.name) {
          this.root.handleEvent(info);
          this.emit("event", info);
          this.root.handleEvent(clickInfo);
          this.emit("event", clickInfo);
          return;
        }
      }
    }
    this.root.handleEvent(info);
    this.emit("event", info);
    if (info.type === "pointer" && info.name === "pointer_down") {
      this.menus.clearOpenMenus();
    }
    return this;
  }
  /** @internal */
  maybeTrackPerformance(name) {
    if (debugFlags.measurePerformance.get()) {
      if (this.performanceTracker.isStarted()) {
        clearTimeout(this.performanceTrackerTimeout);
      } else {
        this.performanceTracker.start(name);
      }
      this.performanceTrackerTimeout = this.timers.setTimeout(() => {
        this.performanceTracker.stop();
      }, 50);
    }
  }
};
_init$3 = __decoratorStart$3(_a$1);
__decorateElement$3(_init$3, 1, "getIsShapeHiddenCache", _getIsShapeHiddenCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCanUndo", _getCanUndo_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCanRedo", _getCanRedo_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getPath", _getPath_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentTool", _getCurrentTool_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentToolId", _getCurrentToolId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getDocumentSettings", _getDocumentSettings_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getInstanceState", _getInstanceState_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getPageStates", _getPageStates_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getPageStatesQuery", __getPageStatesQuery_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageState", _getCurrentPageState_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getCurrentPageStateId", __getCurrentPageStateId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectedShapeIds", _getSelectedShapeIds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectedShapes", _getSelectedShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageShapesInReadingOrder", _getCurrentPageShapesInReadingOrder_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getOnlySelectedShapeId", _getOnlySelectedShapeId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getOnlySelectedShape", _getOnlySelectedShape_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectionPageBounds", _getSelectionPageBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectionRotation", _getSelectionRotation_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectionRotatedPageBounds", _getSelectionRotatedPageBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectionRotatedScreenBounds", _getSelectionRotatedScreenBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getFocusedGroupId", _getFocusedGroupId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getFocusedGroup", _getFocusedGroup_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getEditingShapeId", _getEditingShapeId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getEditingShape", _getEditingShape_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getRichTextEditor", _getRichTextEditor_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getHoveredShapeId", _getHoveredShapeId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getHoveredShape", _getHoveredShape_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getHintingShapeIds", _getHintingShapeIds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getHintingShape", _getHintingShape_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getErasingShapeIds", _getErasingShapeIds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getErasingShapes", _getErasingShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_unsafe_getCameraId", __unsafe_getCameraId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCamera", _getCamera_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getViewportPageBoundsForFollowing", _getViewportPageBoundsForFollowing_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCameraForFollowing", _getCameraForFollowing_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getZoomLevel", _getZoomLevel_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getViewportScreenBounds", _getViewportScreenBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getViewportScreenCenter", _getViewportScreenCenter_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getViewportPageBounds", _getViewportPageBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getCollaboratorsQuery", __getCollaboratorsQuery_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCollaborators", _getCollaborators_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCollaboratorsOnCurrentPage", _getCollaboratorsOnCurrentPage_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getRenderingShapes", _getRenderingShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getAllPagesQuery", __getAllPagesQuery_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getPages", _getPages_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageId", _getCurrentPageId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageShapeIdsSorted", _getCurrentPageShapeIdsSorted_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getAllAssetsQuery", __getAllAssetsQuery_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapeHandlesCache", __getShapeHandlesCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapePageTransformCache", __getShapePageTransformCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapePageBoundsCache", __getShapePageBoundsCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapeClipPathCache", __getShapeClipPathCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapeMaskCache", __getShapeMaskCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapeMaskedPageBoundsCache", __getShapeMaskedPageBoundsCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getNotVisibleShapes", _getNotVisibleShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCulledShapes", _getCulledShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageBounds", _getCurrentPageBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageShapes", _getCurrentPageShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageShapesSorted", _getCurrentPageShapesSorted_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageRenderingShapesSorted", _getCurrentPageRenderingShapesSorted_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getBindingsIndexCache", __getBindingsIndexCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getSelectionSharedStyles", __getSelectionSharedStyles_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSharedStyles", _getSharedStyles_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSharedOpacity", _getSharedOpacity_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getIsFocused", _getIsFocused_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getIsReadonly", _getIsReadonly_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_setShiftKeyTimeout", __setShiftKeyTimeout_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_setAltKeyTimeout", __setAltKeyTimeout_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_setCtrlKeyTimeout", __setCtrlKeyTimeout_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_setMetaKeyTimeout", __setMetaKeyTimeout_dec, Editor$1);
__decoratorMetadata$3(_init$3, Editor$1);
function alertMaxShapes(editor, pageId = editor.getCurrentPageId()) {
  const name = editor.getPage(pageId).name;
  editor.emit("max-shapes", { name, pageId, count: editor.options.maxShapesPerPage });
}
function applyPartialToRecordWithProps(prev, partial) {
  if (!partial) return prev;
  let next = null;
  const entries = Object.entries(partial);
  for (let i = 0, n = entries.length; i < n; i++) {
    const [k, v] = entries[i];
    if (v === void 0) continue;
    if (k === "id" || k === "type" || k === "typeName") continue;
    if (v === prev[k]) continue;
    if (!next) next = { ...prev };
    if (k === "props" || k === "meta") {
      next[k] = { ...prev[k] };
      for (const [nextKey, nextValue] of Object.entries(v)) {
        next[k][nextKey] = nextValue;
      }
      continue;
    }
    next[k] = v;
  }
  if (!next) return prev;
  return next;
}
function pushShapeWithDescendants(editor, id, result) {
  const shape = editor.getShape(id);
  if (!shape) return;
  result.push(shape);
  const childIds = editor.getSortedChildIdsForParent(id);
  for (let i = 0, n = childIds.length; i < n; i++) {
    pushShapeWithDescendants(editor, childIds[i], result);
  }
}
function withIsolatedShapes(editor, shapeIds, callback) {
  let result;
  editor.run(
    () => {
      const changes = editor.store.extractingChanges(() => {
        const bindingsWithBoth = /* @__PURE__ */ new Set();
        const bindingsToRemove = /* @__PURE__ */ new Set();
        for (const shapeId of shapeIds) {
          const shape = editor.getShape(shapeId);
          if (!shape) continue;
          for (const binding of editor.getBindingsInvolvingShape(shapeId)) {
            const hasFrom = shapeIds.has(binding.fromId);
            const hasTo = shapeIds.has(binding.toId);
            if (hasFrom && hasTo) {
              bindingsWithBoth.add(binding.id);
              continue;
            }
            if (!hasFrom || !hasTo) {
              bindingsToRemove.add(binding.id);
            }
          }
        }
        editor.deleteBindings([...bindingsToRemove], { isolateShapes: true });
        try {
          result = Result.ok(callback(bindingsWithBoth));
        } catch (error) {
          result = Result.err(error);
        }
      });
      editor.store.applyDiff(reverseRecordsDiff(changes), { runCallbacks: false });
    },
    { history: "ignore" }
  );
  if (result.ok) {
    return result.value;
  } else {
    throw result.error;
  }
}
function getCameraFitXFitY(editor, cameraOptions) {
  if (!cameraOptions.constraints) throw Error("Should have constraints here");
  const {
    padding: { x: px, y: py }
  } = cameraOptions.constraints;
  const vsb = editor.getViewportScreenBounds();
  const bounds = Box.From(cameraOptions.constraints.bounds);
  const zx = (vsb.w - px * 2) / bounds.w;
  const zy = (vsb.h - py * 2) / bounds.h;
  return { zx, zy };
}
function useIsDarkMode() {
  const editor = useEditor();
  const exportContext = useSvgExportContext();
  return useValue("isDarkMode", () => exportContext?.isDarkMode ?? editor.user.getIsDarkMode(), [
    exportContext,
    editor
  ]);
}
const CORNER_SVG = `<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>`;
const EDGE_SVG = `<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>`;
const ROTATE_CORNER_SVG = `<path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/>`;
function getCursorCss(svg, r, tr2, f, color, hotspotX = 16, hotspotY = 16) {
  const a = (-tr2 - r) * (PI$1 / 180);
  const s = Math.sin(a);
  const c = Math.cos(a);
  const dx = 1 * c - 1 * s;
  const dy = 1 * s + 1 * c;
  return `url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${color};'><defs><filter id='shadow' y='-40%' x='-40%' width='180px' height='180%' color-interpolation-filters='sRGB'><feDropShadow dx='${dx}' dy='${dy}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${r + tr2} 16 16)${f ? ` scale(-1,-1) translate(0, -32)` : ""}' filter='url(%23shadow)'>` + svg.replaceAll(`"`, `'`) + `</g></svg>") ${hotspotX} ${hotspotY}, pointer`;
}
const STATIC_CURSORS = [
  "default",
  "pointer",
  "cross",
  "move",
  "grab",
  "grabbing",
  "text",
  "zoom-in",
  "zoom-out"
];
const CURSORS = {
  none: () => "none",
  "ew-resize": (r, f, c) => getCursorCss(EDGE_SVG, r, 0, f, c),
  "ns-resize": (r, f, c) => getCursorCss(EDGE_SVG, r, 90, f, c),
  "nesw-resize": (r, f, c) => getCursorCss(CORNER_SVG, r, 0, f, c),
  "nwse-resize": (r, f, c) => getCursorCss(CORNER_SVG, r, 90, f, c),
  "nwse-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 0, f, c),
  "nesw-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 90, f, c),
  "senw-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 180, f, c),
  "swne-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 270, f, c)
};
function getCursor(cursor, rotation = 0, color = "black") {
  return CURSORS[cursor](radiansToDegrees(rotation), false, color);
}
function useCursor() {
  const editor = useEditor();
  const container = useContainer();
  const isDarkMode = useIsDarkMode();
  useQuickReactor(
    "useCursor",
    () => {
      const { type, rotation } = editor.getInstanceState().cursor;
      if (STATIC_CURSORS.includes(type)) {
        container.style.setProperty("--tl-cursor", `var(--tl-cursor-${type})`);
        return;
      }
      container.style.setProperty(
        "--tl-cursor",
        getCursor(type, rotation, isDarkMode ? "white" : "black")
      );
    },
    [editor, container, isDarkMode]
  );
}
function useDarkMode() {
  const editor = useEditor();
  const container = useContainer();
  const isDarkMode = useIsDarkMode();
  const forceSrgb = useValue(debugFlags.forceSrgb);
  React.useEffect(() => {
    if (isDarkMode) {
      container.setAttribute("data-color-mode", "dark");
      container.classList.remove("tl-theme__light");
      container.classList.add("tl-theme__dark");
    } else {
      container.setAttribute("data-color-mode", "light");
      container.classList.remove("tl-theme__dark");
      container.classList.add("tl-theme__light");
    }
    if (forceSrgb) {
      container.classList.add("tl-theme__force-sRGB");
    } else {
      container.classList.remove("tl-theme__force-sRGB");
    }
  }, [editor, container, forceSrgb, isDarkMode]);
}
function useForceUpdate() {
  const [_, ss] = reactExports.useState(0);
  reactExports.useEffect(() => ss((s) => s + 1), []);
}
const defaultAssetResolve = (asset) => asset.props.src;
const inlineBase64AssetStore = {
  upload: async (_, file) => {
    return { src: await FileHelpers.blobToDataUrl(file) };
  }
};
function createTLSchemaFromUtils(opts) {
  if ("schema" in opts && opts.schema) return opts.schema;
  return createTLSchema({
    shapes: "shapeUtils" in opts && opts.shapeUtils ? utilsToMap(checkShapesAndAddCore(opts.shapeUtils)) : void 0,
    bindings: "bindingUtils" in opts && opts.bindingUtils ? utilsToMap(checkBindings(opts.bindingUtils)) : void 0,
    migrations: "migrations" in opts ? opts.migrations : void 0
  });
}
function createTLStore({
  initialData,
  defaultName = "",
  id,
  assets = inlineBase64AssetStore,
  onMount,
  collaboration,
  ...rest
} = {}) {
  const schema = createTLSchemaFromUtils(rest);
  const store = new Store({
    id,
    schema,
    initialData,
    props: {
      defaultName,
      assets: {
        upload: assets.upload,
        resolve: assets.resolve ?? defaultAssetResolve,
        remove: assets.remove ?? (() => Promise.resolve())
      },
      onMount: (editor) => {
        assert(editor instanceof Editor$1);
        onMount?.(editor);
      },
      collaboration
    }
  });
  if (rest.snapshot) {
    if (initialData) throw new Error("Cannot provide both initialData and snapshot");
    loadSnapshot(store, rest.snapshot, { forceOverwriteSessionState: true });
  }
  return store;
}
function utilsToMap(utils) {
  return Object.fromEntries(
    utils.map((s) => [
      s.type,
      {
        props: s.props,
        migrations: s.migrations
      }
    ])
  );
}
const instanceOfAny = (object2, constructors) => constructors.some((c) => object2 instanceof c);
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const cursorRequestMap = /* @__PURE__ */ new WeakMap();
const transactionDoneMap = /* @__PURE__ */ new WeakMap();
const transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
const transformCache = /* @__PURE__ */ new WeakMap();
const reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap$1(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap$1(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap$1(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap$1(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap$1(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap$1(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);
function openDB(name, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version2);
  const openPromise = wrap$1(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap$1(request.result), event.oldVersion, event.newVersion, wrap$1(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
function deleteDB(name, { blocked } = {}) {
  const request = indexedDB.deleteDatabase(name);
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event
    ));
  }
  return wrap$1(request).then(() => void 0);
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
const writeMethods = ["put", "add", "delete", "clear"];
const cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
const STORE_PREFIX = "TLDRAW_DOCUMENT_v2";
const LEGACY_ASSET_STORE_PREFIX = "TLDRAW_ASSET_STORE_v1";
const dbNameIndexKey = "TLDRAW_DB_NAME_INDEX_v2";
const Table = {
  Records: "records",
  Schema: "schema",
  SessionState: "session_state",
  Assets: "assets"
};
async function openLocalDb(persistenceKey) {
  const storeId = STORE_PREFIX + persistenceKey;
  addDbName(storeId);
  return await openDB(storeId, 4, {
    upgrade(database) {
      if (!database.objectStoreNames.contains(Table.Records)) {
        database.createObjectStore(Table.Records);
      }
      if (!database.objectStoreNames.contains(Table.Schema)) {
        database.createObjectStore(Table.Schema);
      }
      if (!database.objectStoreNames.contains(Table.SessionState)) {
        database.createObjectStore(Table.SessionState);
      }
      if (!database.objectStoreNames.contains(Table.Assets)) {
        database.createObjectStore(Table.Assets);
      }
    }
  });
}
async function migrateLegacyAssetDbIfNeeded(persistenceKey) {
  const databases = window.indexedDB.databases ? (await window.indexedDB.databases()).map((db) => db.name) : getAllIndexDbNames();
  const oldStoreId = LEGACY_ASSET_STORE_PREFIX + persistenceKey;
  const existing = databases.find((dbName) => dbName === oldStoreId);
  if (!existing) return;
  const oldAssetDb = await openDB(oldStoreId, 1, {
    upgrade(database) {
      if (!database.objectStoreNames.contains("assets")) {
        database.createObjectStore("assets");
      }
    }
  });
  if (!oldAssetDb.objectStoreNames.contains("assets")) return;
  const oldTx = oldAssetDb.transaction(["assets"], "readonly");
  const oldAssetStore = oldTx.objectStore("assets");
  const oldAssetsKeys = await oldAssetStore.getAllKeys();
  const oldAssets = await Promise.all(
    oldAssetsKeys.map(async (key) => [key, await oldAssetStore.get(key)])
  );
  await oldTx.done;
  const newDb = await openLocalDb(persistenceKey);
  const newTx = newDb.transaction([Table.Assets], "readwrite");
  const newAssetTable = newTx.objectStore(Table.Assets);
  for (const [key, value] of oldAssets) {
    newAssetTable.put(value, key);
  }
  await newTx.done;
  oldAssetDb.close();
  newDb.close();
  await deleteDB(oldStoreId);
}
class LocalIndexedDb {
  getDbPromise;
  isClosed = false;
  pendingTransactionSet = /* @__PURE__ */ new Set();
  /** @internal */
  static connectedInstances = /* @__PURE__ */ new Set();
  constructor(persistenceKey) {
    LocalIndexedDb.connectedInstances.add(this);
    this.getDbPromise = (async () => {
      await migrateLegacyAssetDbIfNeeded(persistenceKey);
      return await openLocalDb(persistenceKey);
    })();
  }
  getDb() {
    return this.getDbPromise;
  }
  /**
   * Wait for any pending transactions to be completed. Useful for tests.
   *
   * @internal
   */
  pending() {
    return Promise.allSettled([this.getDbPromise, ...this.pendingTransactionSet]).then(noop$3);
  }
  async close() {
    if (this.isClosed) return;
    this.isClosed = true;
    await this.pending();
    (await this.getDb()).close();
    LocalIndexedDb.connectedInstances.delete(this);
  }
  tx(mode, names, cb) {
    const txPromise = (async () => {
      assert(!this.isClosed, "db is closed");
      const db = await this.getDb();
      const tx = db.transaction(names, mode);
      const done = tx.done.catch((e) => {
        if (!this.isClosed) {
          throw e;
        }
      });
      try {
        return await cb(tx);
      } finally {
        if (!this.isClosed) {
          await done;
        } else {
          tx.abort();
        }
      }
    })();
    this.pendingTransactionSet.add(txPromise);
    txPromise.finally(() => this.pendingTransactionSet.delete(txPromise));
    return txPromise;
  }
  async load({ sessionId } = {}) {
    return await this.tx(
      "readonly",
      [Table.Records, Table.Schema, Table.SessionState],
      async (tx) => {
        const recordsStore = tx.objectStore(Table.Records);
        const schemaStore = tx.objectStore(Table.Schema);
        const sessionStateStore = tx.objectStore(Table.SessionState);
        let sessionStateSnapshot = sessionId ? (await sessionStateStore.get(sessionId))?.snapshot : null;
        if (!sessionStateSnapshot) {
          const all = await sessionStateStore.getAll();
          sessionStateSnapshot = all.sort((a, b) => a.updatedAt - b.updatedAt).pop()?.snapshot;
        }
        const result = {
          records: await recordsStore.getAll(),
          schema: await schemaStore.get(Table.Schema),
          sessionStateSnapshot
        };
        return result;
      }
    );
  }
  async storeChanges({
    schema,
    changes,
    sessionId,
    sessionStateSnapshot
  }) {
    await this.tx("readwrite", [Table.Records, Table.Schema, Table.SessionState], async (tx) => {
      const recordsStore = tx.objectStore(Table.Records);
      const schemaStore = tx.objectStore(Table.Schema);
      const sessionStateStore = tx.objectStore(Table.SessionState);
      for (const [id, record] of Object.entries(changes.added)) {
        await recordsStore.put(record, id);
      }
      for (const [_prev, updated] of Object.values(changes.updated)) {
        await recordsStore.put(updated, updated.id);
      }
      for (const id of Object.keys(changes.removed)) {
        await recordsStore.delete(id);
      }
      schemaStore.put(schema.serialize(), Table.Schema);
      if (sessionStateSnapshot && sessionId) {
        sessionStateStore.put(
          {
            snapshot: sessionStateSnapshot,
            updatedAt: Date.now(),
            id: sessionId
          },
          sessionId
        );
      } else if (sessionStateSnapshot || sessionId) {
        console.error("sessionStateSnapshot and instanceId must be provided together");
      }
    });
  }
  async storeSnapshot({
    schema,
    snapshot,
    sessionId,
    sessionStateSnapshot
  }) {
    await this.tx("readwrite", [Table.Records, Table.Schema, Table.SessionState], async (tx) => {
      const recordsStore = tx.objectStore(Table.Records);
      const schemaStore = tx.objectStore(Table.Schema);
      const sessionStateStore = tx.objectStore(Table.SessionState);
      await recordsStore.clear();
      for (const [id, record] of Object.entries(snapshot)) {
        await recordsStore.put(record, id);
      }
      schemaStore.put(schema.serialize(), Table.Schema);
      if (sessionStateSnapshot && sessionId) {
        sessionStateStore.put(
          {
            snapshot: sessionStateSnapshot,
            updatedAt: Date.now(),
            id: sessionId
          },
          sessionId
        );
      } else if (sessionStateSnapshot || sessionId) {
        console.error("sessionStateSnapshot and instanceId must be provided together");
      }
    });
  }
  async pruneSessions() {
    await this.tx("readwrite", [Table.SessionState], async (tx) => {
      const sessionStateStore = tx.objectStore(Table.SessionState);
      const all = (await sessionStateStore.getAll()).sort((a, b) => a.updatedAt - b.updatedAt);
      if (all.length < 10) {
        await tx.done;
        return;
      }
      const toDelete = all.slice(0, all.length - 10);
      for (const { id } of toDelete) {
        await sessionStateStore.delete(id);
      }
    });
  }
  async getAsset(assetId) {
    return await this.tx("readonly", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      return await assetsStore.get(assetId);
    });
  }
  async storeAsset(assetId, blob) {
    await this.tx("readwrite", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      await assetsStore.put(blob, assetId);
    });
  }
  async removeAssets(assetId) {
    await this.tx("readwrite", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      for (const id of assetId) {
        await assetsStore.delete(id);
      }
    });
  }
}
function getAllIndexDbNames() {
  const result = JSON.parse(getFromLocalStorage(dbNameIndexKey) || "[]") ?? [];
  if (!Array.isArray(result)) {
    return [];
  }
  return result;
}
function addDbName(name) {
  const all = new Set(getAllIndexDbNames());
  all.add(name);
  setInLocalStorage(dbNameIndexKey, JSON.stringify([...all]));
}
function showCantWriteToIndexDbAlert() {
  window.alert(
    `Oops! We could not save changes to your browser's storage. We now need to reload the page and try again.

Keep seeing this message?
 If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.
 If your hard disk is full, try clearing up some space and then reload the page.`
  );
}
function showCantReadFromIndexDbAlert() {
  window.alert(
    `Oops! We could not access your browser's storageand the app won't work correctly without that. We now need to reload the page and try again.

Keep seeing this message?
 If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.`
  );
}
const PERSIST_THROTTLE_MS = 350;
const PERSIST_RETRY_THROTTLE_MS = 1e4;
const UPDATE_INSTANCE_STATE = Symbol("UPDATE_INSTANCE_STATE");
const msg = (msg2) => msg2;
class BroadcastChannelMock {
  onmessage;
  constructor(_name) {
  }
  postMessage(_msg) {
  }
  close() {
  }
}
const BC = typeof BroadcastChannel === "undefined" ? BroadcastChannelMock : BroadcastChannel;
class TLLocalSyncClient {
  constructor(store, {
    persistenceKey,
    sessionId = TAB_ID,
    onLoad,
    onLoadError
  }, channel2 = new BC(`tldraw-tab-sync-${persistenceKey}`)) {
    this.store = store;
    this.channel = channel2;
    if (typeof window !== "undefined") {
      window.tlsync = this;
    }
    this.persistenceKey = persistenceKey;
    this.sessionId = sessionId;
    this.db = new LocalIndexedDb(persistenceKey);
    this.disposables.add(() => this.db.close());
    this.serializedSchema = this.store.schema.serialize();
    this.$sessionStateSnapshot = createSessionStateSnapshotSignal(this.store);
    this.disposables.add(
      // Set up a subscription to changes from the store: When
      // the store changes (and if the change was made by the user)
      // then immediately send the diff to other tabs via postMessage
      // and schedule a persist.
      store.listen(
        ({ changes }) => {
          this.diffQueue.push(changes);
          this.channel.postMessage(
            msg({
              type: "diff",
              storeId: this.store.id,
              changes,
              schema: this.serializedSchema
            })
          );
          this.schedulePersist();
        },
        { source: "user", scope: "document" }
      )
    );
    this.disposables.add(
      store.listen(
        () => {
          this.diffQueue.push(UPDATE_INSTANCE_STATE);
          this.schedulePersist();
        },
        { scope: "session" }
      )
    );
    this.connect(onLoad, onLoadError);
    this.documentTypes = new Set(
      Object.values(this.store.schema.types).filter((t2) => t2.scope === "document").map((t2) => t2.typeName)
    );
  }
  disposables = /* @__PURE__ */ new Set();
  diffQueue = [];
  didDispose = false;
  shouldDoFullDBWrite = true;
  isReloading = false;
  persistenceKey;
  sessionId;
  serializedSchema;
  isDebugging = false;
  documentTypes;
  $sessionStateSnapshot;
  /** @internal */
  db;
  initTime = Date.now();
  debug(...args) {
    if (this.isDebugging) {
      console.debug(...args);
    }
  }
  async connect(onLoad, onLoadError) {
    this.debug("connecting");
    let data;
    try {
      data = await this.db.load({ sessionId: this.sessionId });
    } catch (error) {
      onLoadError(error);
      showCantReadFromIndexDbAlert();
      return;
    }
    this.debug("loaded data from store", data, "didDispose", this.didDispose);
    if (this.didDispose) return;
    try {
      if (data) {
        const documentSnapshot = Object.fromEntries(data.records.map((r) => [r.id, r]));
        const sessionStateSnapshot = data.sessionStateSnapshot ?? extractSessionStateFromLegacySnapshot(documentSnapshot);
        const migrationResult = this.store.schema.migrateStoreSnapshot({
          store: documentSnapshot,
          // eslint-disable-next-line @typescript-eslint/no-deprecated
          schema: data.schema ?? this.store.schema.serializeEarliestVersion()
        });
        if (migrationResult.type === "error") {
          console.error("failed to migrate store", migrationResult);
          onLoadError(new Error(`Failed to migrate store: ${migrationResult.reason}`));
          return;
        }
        const records = Object.values(migrationResult.value).filter(
          (r) => this.documentTypes.has(r.typeName)
        );
        if (records.length > 0) {
          this.store.mergeRemoteChanges(() => {
            this.store.put(records, "initialize");
          });
        }
        if (sessionStateSnapshot) {
          loadSessionStateSnapshotIntoStore(this.store, sessionStateSnapshot, {
            forceOverwrite: true
          });
        }
      }
      this.channel.onmessage = ({ data: data2 }) => {
        this.debug("got message", data2);
        const msg2 = data2;
        const res = this.store.schema.getMigrationsSince(msg2.schema);
        if (!res.ok) {
          const timeSinceInit = Date.now() - this.initTime;
          if (timeSinceInit < 5e3) {
            onLoadError(new Error("Schema mismatch, please close other tabs and reload the page"));
            return;
          }
          this.debug("reloading");
          this.isReloading = true;
          window?.location?.reload?.();
          return;
        } else if (res.value.length > 0) {
          this.debug("telling them to reload");
          this.channel.postMessage({ type: "announce", schema: this.serializedSchema });
          this.shouldDoFullDBWrite = true;
          this.persistIfNeeded();
          return;
        }
        if (msg2.type === "diff") {
          this.debug("applying diff");
          transact(() => {
            this.store.mergeRemoteChanges(() => {
              this.store.applyDiff(msg2.changes);
            });
          });
        }
      };
      this.channel.postMessage({ type: "announce", schema: this.serializedSchema });
      this.disposables.add(() => {
        this.channel.close();
      });
      onLoad(this);
    } catch (e) {
      this.debug("error loading data from store", e);
      if (this.didDispose) return;
      onLoadError(e);
      return;
    }
  }
  close() {
    this.debug("closing");
    this.didDispose = true;
    this.disposables.forEach((d) => d());
  }
  isPersisting = false;
  didLastWriteError = false;
  scheduledPersistTimeout = null;
  /**
   * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too
   * often, and will retry if failed.
   *
   * @internal
   */
  schedulePersist() {
    this.debug("schedulePersist", this.scheduledPersistTimeout);
    if (this.scheduledPersistTimeout) return;
    this.scheduledPersistTimeout = setTimeout(
      () => {
        this.scheduledPersistTimeout = null;
        this.persistIfNeeded();
      },
      this.didLastWriteError ? PERSIST_RETRY_THROTTLE_MS : PERSIST_THROTTLE_MS
    );
  }
  /**
   * Persist to IndexedDB only under certain circumstances:
   *
   * - If we're not already persisting
   * - If we're not reloading the page
   * - And we have something to persist (a full db write scheduled or changes in the diff queue)
   *
   * @internal
   */
  persistIfNeeded() {
    this.debug("persistIfNeeded", {
      isPersisting: this.isPersisting,
      isReloading: this.isReloading,
      shouldDoFullDBWrite: this.shouldDoFullDBWrite,
      diffQueueLength: this.diffQueue.length,
      storeIsPossiblyCorrupt: this.store.isPossiblyCorrupted()
    });
    if (this.scheduledPersistTimeout) {
      clearTimeout(this.scheduledPersistTimeout);
      this.scheduledPersistTimeout = null;
    }
    if (this.isPersisting) return;
    if (this.isReloading) return;
    if (this.store.isPossiblyCorrupted()) return;
    if (this.shouldDoFullDBWrite || this.diffQueue.length > 0) {
      this.doPersist();
    }
  }
  /**
   * Actually persist to IndexedDB. If the write fails, then we'll retry with a full db write after
   * a short delay.
   */
  async doPersist() {
    assert(!this.isPersisting, "persist already in progress");
    if (this.didDispose) return;
    this.isPersisting = true;
    this.debug("doPersist start");
    const diffQueue = this.diffQueue;
    this.diffQueue = [];
    try {
      if (this.shouldDoFullDBWrite) {
        this.shouldDoFullDBWrite = false;
        await this.db.storeSnapshot({
          schema: this.store.schema,
          snapshot: this.store.serialize(),
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      } else {
        const diffs = squashRecordDiffs(
          diffQueue.filter((d) => d !== UPDATE_INSTANCE_STATE)
        );
        await this.db.storeChanges({
          changes: diffs,
          schema: this.store.schema,
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      }
      this.didLastWriteError = false;
    } catch (e) {
      this.shouldDoFullDBWrite = true;
      this.didLastWriteError = true;
      console.error("failed to store changes in indexed db", e);
      showCantWriteToIndexDbAlert();
      if (typeof window !== "undefined") {
        window.location.reload();
      }
    }
    this.isPersisting = false;
    this.debug("doPersist end");
    this.schedulePersist();
  }
}
function useRefState(initialValue) {
  const ref = reactExports.useRef(initialValue);
  const [state, setState] = reactExports.useState(initialValue);
  if (state !== ref.current) {
    setState(ref.current);
  }
  const update = reactExports.useCallback((value) => {
    if (typeof value === "function") {
      ref.current = value(ref.current);
    } else {
      ref.current = value;
    }
    setState(ref.current);
  }, []);
  return [state, update];
}
function useLocalStore(options) {
  const [state, setState] = useRefState({ status: "loading" });
  options = useShallowObjectIdentity(options);
  reactExports.useEffect(() => {
    const { persistenceKey, sessionId, ...rest } = options;
    if (!persistenceKey) {
      setState({
        status: "not-synced",
        store: createTLStore(rest)
      });
      return;
    }
    setState({ status: "loading" });
    const objectURLCache = new WeakCache();
    const assets = {
      upload: async (asset, file) => {
        await client2.db.storeAsset(asset.id, file);
        return { src: asset.id };
      },
      resolve: async (asset) => {
        if (!asset.props.src) return null;
        if (asset.props.src.startsWith("asset:")) {
          return await objectURLCache.get(asset, async () => {
            const blob = await client2.db.getAsset(asset.id);
            if (!blob) return null;
            return URL.createObjectURL(blob);
          });
        }
        return asset.props.src;
      },
      remove: async (assetIds) => {
        await client2.db.removeAssets(assetIds);
      },
      ...rest.assets
    };
    const store = createTLStore({ ...rest, assets });
    let isClosed = false;
    const client2 = new TLLocalSyncClient(store, {
      sessionId,
      persistenceKey,
      onLoad() {
        if (isClosed) return;
        setState({ store, status: "synced-local" });
      },
      onLoadError(err) {
        if (isClosed) return;
        setState({ status: "error", error: err });
      }
    });
    return () => {
      isClosed = true;
      client2.close();
    };
  }, [options, setState]);
  return state;
}
function useStateAttribute() {
  const editor = useEditor();
  reactExports.useLayoutEffect(() => {
    return react("stateAttribute", () => {
      editor.getContainer().setAttribute("data-state", editor.getPath());
    });
  }, [editor]);
}
function useZoomCss() {
  const editor = useEditor();
  const container = useContainer();
  reactExports.useEffect(() => {
    const setScale = (s) => container.style.setProperty("--tl-zoom", s.toString());
    const setScaleDebounced = debounce(setScale, 100);
    const scheduler2 = new EffectScheduler("useZoomCss", () => {
      const numShapes = editor.getCurrentPageShapeIds().size;
      if (numShapes < 300) {
        setScale(editor.getZoomLevel());
      } else {
        setScaleDebounced(editor.getZoomLevel());
      }
    });
    scheduler2.attach();
    scheduler2.execute();
    return () => {
      scheduler2.detach();
      setScaleDebounced.cancel();
    };
  }, [editor, container]);
}
function str2ab(str) {
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}
function importPublicKey(pemContents) {
  const binaryDerString = atob(pemContents);
  const binaryDer = str2ab(binaryDerString);
  return crypto.subtle.importKey(
    "spki",
    new Uint8Array(binaryDer),
    {
      name: "ECDSA",
      namedCurve: "P-256"
    },
    true,
    ["verify"]
  );
}
const GRACE_PERIOD_DAYS = 30;
const FLAGS = {
  // -- MUTUALLY EXCLUSIVE FLAGS --
  // Annual means the license expires after a time period, usually 1 year.
  ANNUAL_LICENSE: 1,
  // Perpetual means the license never expires up to the max supported version.
  PERPETUAL_LICENSE: 1 << 1,
  // -- ADDITIVE FLAGS --
  // Internal means the license is for internal use only.
  INTERNAL_LICENSE: 1 << 2,
  // Watermark means the product is watermarked.
  WITH_WATERMARK: 1 << 3,
  // Evaluation means the license is for evaluation purposes only.
  EVALUATION_LICENSE: 1 << 4,
  // Native means the license is for native apps which switches
  // on special-case logic.
  NATIVE_LICENSE: 1 << 5
};
const HIGHEST_FLAG = Math.max(...Object.values(FLAGS));
const PROPERTIES = {
  ID: 0,
  HOSTS: 1,
  FLAGS: 2,
  EXPIRY_DATE: 3
};
const NUMBER_OF_KNOWN_PROPERTIES = Object.keys(PROPERTIES).length;
const LICENSE_EMAIL = "sales@tldraw.com";
const WATERMARK_TRACK_SRC = `${getDefaultCdnBaseUrl()}/watermarks/watermark-track.svg`;
class LicenseManager {
  publicKey = "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEHJh0uUfxHtCGyerXmmatE368Hd9rI6LH9oPDQihnaCryRFWEVeOvf9U/SPbyxX74LFyJs5tYeAHq5Nc0Ax25LQ";
  isDevelopment;
  isTest;
  isCryptoAvailable;
  state = atom("license state", "pending");
  verbose = true;
  constructor(licenseKey, testPublicKey) {
    this.isTest = false;
    this.isDevelopment = this.getIsDevelopment();
    this.publicKey = testPublicKey || this.publicKey;
    this.isCryptoAvailable = !!crypto.subtle;
    this.getLicenseFromKey(licenseKey).then((result) => {
      const licenseState = getLicenseState(
        result,
        (messages) => this.outputMessages(messages),
        this.isDevelopment
      );
      this.maybeTrack(result, licenseState);
      this.state.set(licenseState);
    }).catch((error) => {
      console.error("License validation failed:", error);
      this.state.set("unlicensed");
    });
  }
  getIsDevelopment() {
    return !["https:", "vscode-webview:"].includes(window.location.protocol) || window.location.hostname === "localhost" || false;
  }
  getTrackType(result, licenseState) {
    if (licenseState === "unlicensed-production") {
      return "unlicensed";
    }
    if (this.isDevelopment) {
      return null;
    }
    if (!result.isLicenseParseable) {
      return null;
    }
    if (result.isEvaluationLicense) {
      return "evaluation";
    }
    if (licenseState === "licensed-with-watermark") {
      return "with_watermark";
    }
    return null;
  }
  maybeTrack(result, licenseState) {
    const trackType = this.getTrackType(result, licenseState);
    if (!trackType) {
      return;
    }
    const url = new URL(WATERMARK_TRACK_SRC);
    url.searchParams.set("version", version);
    url.searchParams.set("license_type", trackType);
    if ("license" in result) {
      url.searchParams.set("license_id", result.license.id);
      const sku = this.isFlagEnabled(result.license.flags, FLAGS.EVALUATION_LICENSE) ? "evaluation" : this.isFlagEnabled(result.license.flags, FLAGS.ANNUAL_LICENSE) ? "annual" : this.isFlagEnabled(result.license.flags, FLAGS.PERPETUAL_LICENSE) ? "perpetual" : "unknown";
      url.searchParams.set("sku", sku);
    }
    url.searchParams.set("url", window.location.href);
    {
      url.searchParams.set("environment", "production");
    }
    fetch(url.toString());
  }
  async extractLicenseKey(licenseKey) {
    const [data, signature] = licenseKey.split(".");
    const [prefix, encodedData] = data.split("/");
    if (!prefix.startsWith("tldraw-")) {
      throw new Error(`Unsupported prefix '${prefix}'`);
    }
    const publicCryptoKey = await importPublicKey(this.publicKey);
    let isVerified;
    try {
      isVerified = await crypto.subtle.verify(
        {
          name: "ECDSA",
          hash: { name: "SHA-256" }
        },
        publicCryptoKey,
        new Uint8Array(str2ab(atob(signature))),
        new Uint8Array(str2ab(atob(encodedData)))
      );
    } catch (e) {
      console.error(e);
      throw new Error("Could not perform signature validation");
    }
    if (!isVerified) {
      throw new Error("Invalid signature");
    }
    let decodedData;
    try {
      decodedData = JSON.parse(atob(encodedData));
    } catch {
      throw new Error("Could not parse object");
    }
    if (decodedData.length > NUMBER_OF_KNOWN_PROPERTIES) {
      this.outputMessages([
        "License key contains some unknown properties.",
        "You may want to update tldraw packages to a newer version to get access to new functionality."
      ]);
    }
    return {
      id: decodedData[PROPERTIES.ID],
      hosts: decodedData[PROPERTIES.HOSTS],
      flags: decodedData[PROPERTIES.FLAGS],
      expiryDate: decodedData[PROPERTIES.EXPIRY_DATE]
    };
  }
  async getLicenseFromKey(licenseKey) {
    if (!licenseKey) {
      if (!this.isDevelopment) {
        this.outputNoLicenseKeyProvided();
      }
      return { isLicenseParseable: false, reason: "no-key-provided" };
    }
    if (this.isDevelopment && !this.isCryptoAvailable) {
      if (this.verbose) {
        console.log(
          "tldraw: you seem to be in a development environment that does not support crypto. License not verified."
        );
        console.log("You should check that this works in production separately.");
      }
      return { isLicenseParseable: false, reason: "has-key-development-mode" };
    }
    let cleanedLicenseKey = licenseKey.replace(/[\u200B-\u200D\uFEFF]/g, "");
    cleanedLicenseKey = cleanedLicenseKey.replace(/\r?\n|\r/g, "");
    try {
      const licenseInfo = await this.extractLicenseKey(cleanedLicenseKey);
      const expiryDate = new Date(licenseInfo.expiryDate);
      const isAnnualLicense = this.isFlagEnabled(licenseInfo.flags, FLAGS.ANNUAL_LICENSE);
      const isPerpetualLicense = this.isFlagEnabled(licenseInfo.flags, FLAGS.PERPETUAL_LICENSE);
      const isEvaluationLicense = this.isFlagEnabled(licenseInfo.flags, FLAGS.EVALUATION_LICENSE);
      const daysSinceExpiry = this.getDaysSinceExpiry(expiryDate);
      const result = {
        license: licenseInfo,
        isLicenseParseable: true,
        isDevelopment: this.isDevelopment,
        isDomainValid: this.isDomainValid(licenseInfo),
        expiryDate,
        isAnnualLicense,
        isAnnualLicenseExpired: isAnnualLicense && this.isAnnualLicenseExpired(expiryDate),
        isPerpetualLicense,
        isPerpetualLicenseExpired: isPerpetualLicense && this.isPerpetualLicenseExpired(expiryDate),
        isInternalLicense: this.isFlagEnabled(licenseInfo.flags, FLAGS.INTERNAL_LICENSE),
        isNativeLicense: this.isNativeLicense(licenseInfo),
        isLicensedWithWatermark: this.isFlagEnabled(licenseInfo.flags, FLAGS.WITH_WATERMARK),
        isEvaluationLicense,
        isEvaluationLicenseExpired: isEvaluationLicense && this.isEvaluationLicenseExpired(expiryDate),
        daysSinceExpiry
      };
      this.outputLicenseInfoIfNeeded(result);
      return result;
    } catch (e) {
      this.outputInvalidLicenseKey(e.message);
      return { isLicenseParseable: false, reason: "invalid-license-key" };
    }
  }
  isDomainValid(licenseInfo) {
    const currentHostname = window.location.hostname.toLowerCase();
    return licenseInfo.hosts.some((host) => {
      const normalizedHostOrUrlRegex = host.toLowerCase().trim();
      if (normalizedHostOrUrlRegex === currentHostname || `www.${normalizedHostOrUrlRegex}` === currentHostname || normalizedHostOrUrlRegex === `www.${currentHostname}`) {
        return true;
      }
      if (host === "*") {
        return true;
      }
      if (this.isNativeLicense(licenseInfo)) {
        return new RegExp(normalizedHostOrUrlRegex).test(window.location.href);
      }
      if (host.includes("*")) {
        const globToRegex = new RegExp(host.replace(/\*/g, ".*?"));
        return globToRegex.test(currentHostname) || globToRegex.test(`www.${currentHostname}`);
      }
      if (window.location.protocol === "vscode-webview:") {
        const currentUrl = new URL(window.location.href);
        const extensionId = currentUrl.searchParams.get("extensionId");
        if (normalizedHostOrUrlRegex === extensionId) {
          return true;
        }
      }
      return false;
    });
  }
  isNativeLicense(licenseInfo) {
    return this.isFlagEnabled(licenseInfo.flags, FLAGS.NATIVE_LICENSE);
  }
  getExpirationDateWithoutGracePeriod(expiryDate) {
    return new Date(expiryDate.getFullYear(), expiryDate.getMonth(), expiryDate.getDate());
  }
  getExpirationDateWithGracePeriod(expiryDate) {
    return new Date(
      expiryDate.getFullYear(),
      expiryDate.getMonth(),
      expiryDate.getDate() + GRACE_PERIOD_DAYS + 1
      // Add 1 day to include the expiration day
    );
  }
  isAnnualLicenseExpired(expiryDate) {
    const expiration = this.getExpirationDateWithGracePeriod(expiryDate);
    return /* @__PURE__ */ new Date() >= expiration;
  }
  isPerpetualLicenseExpired(expiryDate) {
    const expiration = this.getExpirationDateWithGracePeriod(expiryDate);
    const dates = {
      major: new Date(publishDates.major),
      minor: new Date(publishDates.minor)
    };
    return dates.major >= expiration || dates.minor >= expiration;
  }
  getDaysSinceExpiry(expiryDate) {
    const now = /* @__PURE__ */ new Date();
    const expiration = this.getExpirationDateWithoutGracePeriod(expiryDate);
    const diffTime = now.getTime() - expiration.getTime();
    const diffDays = Math.floor(diffTime / (1e3 * 60 * 60 * 24));
    return Math.max(0, diffDays);
  }
  isEvaluationLicenseExpired(expiryDate) {
    const now = /* @__PURE__ */ new Date();
    const expiration = this.getExpirationDateWithoutGracePeriod(expiryDate);
    return now >= expiration;
  }
  isFlagEnabled(flags, flag) {
    return (flags & flag) === flag;
  }
  outputNoLicenseKeyProvided() {
  }
  outputInvalidLicenseKey(msg2) {
    this.outputMessages(["Invalid tldraw license key", `Reason: ${msg2}`]);
  }
  outputLicenseInfoIfNeeded(result) {
    if (result.license.flags >= HIGHEST_FLAG * 2) {
      this.outputMessages(
        [
          "Warning: This tldraw license contains some unknown flags.",
          "This will still work, however, you may want to update tldraw packages to a newer version to get access to new functionality."
        ],
        "warning"
      );
    }
  }
  outputMessages(messages, type = "error") {
    if (this.isTest) return;
    if (this.verbose) {
      this.outputDelimiter();
      for (const message of messages) {
        const color = type === "warning" ? "orange" : "crimson";
        const bgColor = type === "warning" ? "orange" : "crimson";
        console.log(
          `%c${message}`,
          `color: ${color}; background: ${bgColor}; padding: 2px; border-radius: 3px;`
        );
      }
      this.outputDelimiter();
    }
  }
  outputDelimiter() {
    console.log(
      "%c-------------------------------------------------------------------",
      `color: white; background: crimson; padding: 2px; border-radius: 3px;`
    );
  }
  static className = "tl-watermark_SEE-LICENSE";
}
function getLicenseState(result, outputMessages, isDevelopment) {
  if (!result.isLicenseParseable) {
    if (isDevelopment) {
      return "unlicensed";
    }
    if (result.reason === "no-key-provided") {
      outputMessages([
        "No tldraw license key provided!",
        "A license is required for production deployments.",
        `Please reach out to ${LICENSE_EMAIL} to purchase a license.`
      ]);
    } else {
      outputMessages([
        "Invalid license key. tldraw requires a valid license for production use.",
        `Please reach out to ${LICENSE_EMAIL} to purchase a license.`
      ]);
    }
    return "unlicensed-production";
  }
  if (!result.isDomainValid && !result.isDevelopment) {
    outputMessages([
      "License key is not valid for this domain.",
      "A license is required for production deployments.",
      `Please reach out to ${LICENSE_EMAIL} to purchase a license.`
    ]);
    return "unlicensed-production";
  }
  if (result.isEvaluationLicense) {
    if (result.isEvaluationLicenseExpired) {
      outputMessages([
        "Your tldraw evaluation license has expired!",
        `Please reach out to ${LICENSE_EMAIL} to purchase a full license.`
      ]);
      return "expired";
    } else {
      return "licensed";
    }
  }
  if (result.isPerpetualLicenseExpired || result.isAnnualLicenseExpired) {
    outputMessages([
      "Your tldraw license has been expired for more than 30 days!",
      `Please reach out to ${LICENSE_EMAIL} to renew your license.`
    ]);
    return "expired";
  }
  const daysSinceExpiry = result.daysSinceExpiry;
  if (daysSinceExpiry > 0 && !result.isEvaluationLicense) {
    outputMessages([
      "Your tldraw license has expired.",
      `License expired ${daysSinceExpiry} days ago.`,
      `Please reach out to ${LICENSE_EMAIL} to renew your license.`
    ]);
    return "licensed";
  }
  if (result.isLicensedWithWatermark) {
    return "licensed-with-watermark";
  }
  return "licensed";
}
var define_process_env_default$1 = {};
const LicenseContext = reactExports.createContext({});
const useLicenseContext = () => reactExports.useContext(LicenseContext);
function shouldHideEditorAfterDelay(licenseState) {
  return licenseState === "expired" || licenseState === "unlicensed-production";
}
const LICENSE_TIMEOUT = 5e3;
function LicenseProvider({
  licenseKey = getLicenseKeyFromEnv() ?? void 0,
  children
}) {
  const [licenseManager] = reactExports.useState(() => new LicenseManager(licenseKey));
  const licenseState = useValue(licenseManager.state);
  const [showEditor, setShowEditor] = reactExports.useState(true);
  reactExports.useEffect(() => {
    if (shouldHideEditorAfterDelay(licenseState) && showEditor) {
      const timer = setTimeout(() => {
        setShowEditor(false);
      }, LICENSE_TIMEOUT);
      return () => clearTimeout(timer);
    }
  }, [licenseState, showEditor]);
  if (shouldHideEditorAfterDelay(licenseState) && !showEditor) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(LicenseGate, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LicenseContext.Provider, { value: licenseManager, children });
}
function LicenseGate() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-testid": "tl-license-expired", style: { display: "none" } });
}
let envLicenseKey = void 0;
function getLicenseKeyFromEnv() {
  if (envLicenseKey !== void 0) {
    return envLicenseKey;
  }
  envLicenseKey = getEnv(() => define_process_env_default$1.TLDRAW_LICENSE_KEY) || getEnv(() => define_process_env_default$1.NEXT_PUBLIC_TLDRAW_LICENSE_KEY) || getEnv(() => define_process_env_default$1.REACT_APP_TLDRAW_LICENSE_KEY) || getEnv(() => define_process_env_default$1.GATSBY_TLDRAW_LICENSE_KEY) || getEnv(() => define_process_env_default$1.VITE_TLDRAW_LICENSE_KEY) || getEnv(() => define_process_env_default$1.PUBLIC_TLDRAW_LICENSE_KEY) || getEnv(() => void 0) || getEnv(() => void 0) || getEnv(() => void 0) || getEnv(() => void 0) || getEnv(() => void 0) || getEnv(() => void 0) || null;
  return envLicenseKey;
}
function getEnv(cb) {
  try {
    return cb();
  } catch {
    return void 0;
  }
}
function usePassThroughWheelEvents(ref) {
  if (!ref) throw Error("usePassThroughWheelEvents must be passed a ref");
  const container = useContainer();
  const editor = useMaybeEditor();
  reactExports.useEffect(() => {
    function onWheel(e) {
      if (!editor?.getInstanceState().isFocused) return;
      if (e.isSpecialRedispatchedEvent) return;
      const elm2 = ref.current;
      if (elm2 && elm2.scrollHeight > elm2.clientHeight) {
        return;
      }
      preventDefault(e);
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs) return;
      const newEvent = new WheelEvent("wheel", e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    const elm = ref.current;
    if (!elm) return;
    elm.addEventListener("wheel", onWheel, { passive: false });
    return () => {
      elm.removeEventListener("wheel", onWheel);
    };
  }, [container, editor, ref]);
}
const watermarkDesktopSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="3001" height="1000" fill="none"><path fill="#000" d="M590.656 300.449c0 49.706-40.294 90-90 90-49.705 0-90-40.294-90-90 0-49.705 40.295-90 90-90 49.706 0 90 40.295 90 90M569.431 719.011c-15.247 32.821-56.006 91.589-98.338 91.438-32.004-.115-38.642-30.904-17.414-50.856 17.381-16.337 28.246-48.075 31.995-72.719.415-2.728-1.556-5.197-4.272-5.679-39.666-7.04-70.746-40.877-70.746-83.417 0-48.23 38.983-87.329 87.07-87.329 39.936 0 70.172 22.237 83.369 52.397 18.839 43.055 7.117 115.733-11.664 156.165M2613.29 385.681V239.319c0-11.363 9.22-20.569 20.59-20.569h8.26c11.37 0 20.59 9.206 20.59 20.569v36.911c0 8.629 7 15.625 15.63 15.625h35.25c8.63 0 15.63-6.996 15.63-15.625v-36.911c0-11.363 9.22-20.569 20.59-20.569h8.17c11.37 0 20.59 9.206 20.59 20.569v146.362c0 11.363-9.22 20.569-20.59 20.569h-8.17c-11.37 0-20.59-9.206-20.59-20.569v-36.999c0-8.63-7-15.625-15.63-15.625h-35.25c-8.63 0-15.63 6.995-15.63 15.625v36.999c0 11.363-9.22 20.569-20.59 20.569h-8.26c-11.37 0-20.59-9.206-20.59-20.569M2391.97 239.319v146.362c0 11.348-9.16 20.569-20.49 20.569h-8.2c-11.33 0-20.49-9.221-20.49-20.569V239.319c0-11.348 9.16-20.569 20.49-20.569h8.2c11.33 0 20.49 9.221 20.49 20.569M2098.23 391.43l-42.69-146.361c-3.85-13.171 6.06-26.319 19.79-26.319h10.6c9.59 0 17.93 6.611 20.08 15.952l17.01 73.045c1.48 6.348 10.47 6.478 12.14.176l19.47-73.838c2.38-9.04 10.57-15.335 19.93-15.335h12.1c9.37 0 17.56 6.3 19.94 15.346l19.49 74.067c1.66 6.305 10.65 6.178 12.13-.171l17.09-73.294c2.15-9.339 10.49-15.948 20.08-15.948h10.53c13.72 0 23.63 13.141 19.79 26.31l-42.63 146.361c-2.56 8.789-10.63 14.829-19.79 14.829h-15.68c-9.12 0-17.16-5.98-19.76-14.709l-21.17-71.059c-1.77-5.948-10.19-5.957-11.97-.012l-21.33 71.071c-2.6 8.729-10.64 14.709-19.76 14.709h-15.59c-9.17 0-17.23-6.035-19.8-14.82M2443.23 218.75h118.59c11.38 0 20.62 9.195 20.62 20.557s-9.24 20.556-20.62 20.556h-24.79c-5.53 0-10 4.477-10 10v115.818c0 11.368-9.25 20.569-20.63 20.569h-7.65c-11.39 0-20.63-9.201-20.63-20.569V269.863c0-5.523-4.48-10-10-10h-24.89c-11.37 0-20.61-9.195-20.61-20.556s9.24-20.557 20.61-20.557M1174.15 218.75h24.64c8.35 0 15.88 5.042 19.04 12.764l34.61 83.942c2.13 5.161 9.44 5.155 11.56-.01l34.43-83.932a20.58 20.58 0 0 1 19.04-12.764h24.64c11.37 0 20.58 9.208 20.58 20.569v146.362c0 11.361-9.21 20.569-20.58 20.569h-7.09c-11.36 0-20.58-9.208-20.58-20.569l-.12-50.645c-.01-6.888-9.53-8.688-12.06-2.283l-23.46 59.332a20.57 20.57 0 0 1-19.14 13.009h-3.03a20.57 20.57 0 0 1-19.15-13.046l-23.47-59.68c-2.52-6.416-12.05-4.623-12.06 2.271l-.13 51.042c0 11.361-9.21 20.569-20.57 20.569h-7.1c-11.36 0-20.57-9.208-20.57-20.569V239.319c0-11.361 9.21-20.569 20.57-20.569"/><path fill="#000" fill-rule="evenodd" d="m1449.94 391.836 6.12-19.392a6.255 6.255 0 0 1 5.96-4.369l50.22-.061a6.24 6.24 0 0 1 5.96 4.348l6.23 19.486c2.71 8.581 10.71 14.402 19.74 14.402h9.34c14.13 0 24.15-13.791 19.61-27.151l-49.74-146.361c-2.85-8.37-10.74-13.988-19.61-13.988h-33.16c-8.87 0-16.77 5.618-19.61 13.988l-49.74 146.361c-4.54 13.36 5.48 27.151 19.61 27.151h9.32c9.04 0 17.04-5.827 19.75-14.414m31.1-98.858c1.85-5.807 10.08-5.796 11.91.016l8.83 27.916c1.28 4.028-1.73 8.134-5.96 8.134h-17.74c-4.23 0-7.24-4.119-5.95-8.151zM1681.81 406.25c18.91 0 35.39-3.686 49.36-11.168 13.97-7.544 24.73-18.394 32.24-32.489 7.56-14.105 11.29-30.866 11.29-50.182 0-19.256-3.73-35.957-11.29-50.004-7.57-14.094-18.35-24.912-32.32-32.397-13.91-7.545-30.4-11.26-49.37-11.26h-49.5c-11.38 0-20.63 9.201-20.63 20.569v146.362c0 11.368 9.25 20.569 20.63 20.569zm23.13-47.701c-6.62 3.215-14.85 4.886-24.79 4.886-10.49 0-19-8.507-19-19v-64.34c0-10.149 8.23-18.376 18.38-18.376 10.18 0 18.56 1.703 25.23 4.974 6.59 3.149 11.63 8.315 15.08 15.633 3.45 7.269 5.28 17.268 5.28 30.162 0 12.891-1.82 22.951-5.28 30.347-3.39 7.319-8.36 12.509-14.9 15.714" clip-rule="evenodd"/><path fill="#000" d="M1804.21 385.681V239.319c0-11.361 9.21-20.569 20.58-20.569h91.28c11.36 0 20.57 9.202 20.57 20.557s-9.21 20.556-20.57 20.556h-54.64a7.807 7.807 0 0 0-7.81 7.813v16.366a7.806 7.806 0 0 0 7.81 7.812h48.13c11.37 0 20.58 9.246 20.58 20.602s-9.21 20.601-20.58 20.601h-48.13a7.806 7.806 0 0 0-7.81 7.812v16.455a7.807 7.807 0 0 0 7.81 7.813h54.64c11.36 0 20.57 9.202 20.57 20.556s-9.21 20.557-20.57 20.557h-91.28c-11.37 0-20.58-9.208-20.58-20.569"/><path fill="#000" fill-rule="evenodd" d="M2875.5 68.75h-2750c-31.066 0-56.25 25.184-56.25 56.25v750c0 31.066 25.184 56.25 56.25 56.25h2750c31.07 0 56.25-25.184 56.25-56.25V125c0-31.066-25.18-56.25-56.25-56.25M125.5 0C56.464 0 .5 55.964.5 125v750c0 69.036 55.965 125 125 125h2750c69.04 0 125-55.964 125-125V125c0-69.036-55.96-125-125-125z" clip-rule="evenodd"/><path fill="#000" d="M2476.06 804.813c-10.54 0-19.82-6.947-22.81-17.068L2390.79 575.7c-4.49-15.248 6.92-30.534 22.8-30.534h27.75c11.1 0 20.72 7.686 23.18 18.52L2489 671.402c2.07 9.093 14.93 9.321 17.32.308l28.83-108.844c2.76-10.435 12.19-17.7 22.98-17.7h25.17c10.8 0 20.25 7.293 22.99 17.755l28.27 107.739c2.36 9.001 15.18 8.829 17.3-.232l25.01-106.888c2.51-10.763 12.1-18.374 23.14-18.374h27.87c15.88 0 27.29 15.286 22.8 30.534l-62.46 212.045a23.78 23.78 0 0 1-22.81 17.068h-32.12c-10.39 0-19.58-6.763-22.69-16.696l-32.08-102.694c-2.62-8.397-14.51-8.331-17.04.095l-30.74 102.346c-3.02 10.061-12.27 16.949-22.76 16.949zM1742.44 804.813h-75.81c-13.09 0-23.71-10.656-23.71-23.801V568.967c0-13.145 10.62-23.801 23.71-23.801h74.8c26.6 0 49.59 5.198 68.95 15.594 19.45 10.312 34.44 25.187 44.96 44.627 10.61 19.355 15.91 42.556 15.91 69.602q0 40.57-15.78 69.73c-10.53 19.355-25.43 34.231-44.71 44.627-19.28 10.311-42.05 15.467-68.32 15.467m-29.3-83.642c0 13.145 10.61 23.801 23.71 23.801h3.06c12.8 0 23.7-2.07 32.71-6.212 9.09-4.141 16-11.283 20.71-21.426q7.2-15.213 7.2-42.345 0-27.13-7.32-42.344c-4.8-10.143-11.87-17.285-21.22-21.426-9.26-4.142-20.63-6.212-34.1-6.212h-1.04c-13.1 0-23.71 10.656-23.71 23.801zM1460.86 804.813c-13.12 0-23.76-10.656-23.76-23.801V568.967c0-13.145 10.64-23.801 23.76-23.801h22.84c13.13 0 23.76 10.656 23.76 23.801v155.247c0 13.145 10.64 23.801 23.76 23.801h57.27c13.12 0 23.76 10.656 23.76 23.801v9.196c0 13.145-10.64 23.801-23.76 23.801zM1204.45 601.964c-13.13 0-23.77-10.656-23.77-23.801v-9.196c0-13.145 10.64-23.801 23.77-23.801h177.89c13.13 0 23.78 10.656 23.78 23.801v9.196c0 13.145-10.65 23.801-23.78 23.801h-39.38c-8.21 0-14.86 6.66-14.86 14.875v164.173c0 13.145-10.64 23.801-23.78 23.801h-21.85c-13.13 0-23.78-10.656-23.78-23.801V616.839c0-8.215-6.65-14.875-14.86-14.875z"/><path fill="#000" fill-rule="evenodd" d="M2223.05 787.891c-3.02 10.047-12.27 16.922-22.74 16.922h-25.43c-16.19 0-27.64-15.862-22.57-31.261l69.88-212.045c3.21-9.753 12.31-16.341 22.56-16.341h61.84c10.25 0 19.35 6.588 22.56 16.341l69.87 212.045c5.08 15.399-6.37 31.261-22.56 31.261h-25.43c-10.48 0-19.72-6.875-22.74-16.922l-6.7-22.2a14.84 14.84 0 0 0-14.21-10.576h-63.42c-6.55 0-12.32 4.296-14.22 10.576zm76.13-96.945-14.13-48.436c-2.46-8.451-14.36-8.602-17.04-.217l-15.46 48.436c-1.84 5.759 2.45 11.645 8.48 11.645h29.6c5.94 0 10.22-5.715 8.55-11.428" clip-rule="evenodd"/><path fill="#000" d="M1939.6 804.813c-13.13 0-23.77-10.656-23.77-23.801V568.967c0-13.145 10.64-23.801 23.77-23.801h88.13c19.24 0 36.08 3.508 50.51 10.523s25.65 17.115 33.67 30.3q12.03 19.779 12.03 47.416c0 18.595-4.14 34.273-12.41 47.036-7.64 11.913-18.18 21.101-31.63 27.564-16.98 8.159-36 11.104-54.7 11.104h-43.07c-76.56 0 4.08-135.84 4.08-84.706v7.996c0 12.117 9.81 21.941 21.91 21.941 8.12 0 16.3-.345 24.04-3.043 5.91-2.113 10.43-5.451 13.55-10.015 3.2-4.565 4.81-10.523 4.81-17.877 0-7.437-1.61-13.481-4.81-18.129-3.12-4.733-7.64-8.199-13.55-10.396-7.05-2.766-14.67-3.423-22.18-3.423-13.13 0-23.77 10.656-23.77 23.801v47.71c0 11.825 11.14 16.003 19.91 20.752 12.31 6.671 7.58 25.389-6.42 25.389-7.45 0-13.49 6.048-13.49 13.508v48.395c0 13.145-10.63 23.801-23.76 23.801zm134.89-106.758 5.41 9.95 33.51 61.622c8.62 15.86-2.84 35.186-20.87 35.186h-22.27c-8.74 0-16.77-4.798-20.92-12.496l-35.05-65.04a15.52 15.52 0 0 0-13.66-8.168c-42.24 0 40.62-82.154 73.85-21.054M931.652 0h68.748v1000h-68.748z"/></svg>';
const watermarkMobileSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="400" height="1601" fill="none"><path fill="#000" d="M72 1319.8c0-10.73 7.071-20.18 17.372-23.22l215.823-63.62c15.519-4.57 31.078 7.05 31.078 23.22v28.26c0 11.31-7.824 21.1-18.85 23.61l-109.636 24.94c-9.254 2.1-9.487 15.2-.313 17.63l110.784 29.37a24.21 24.21 0 0 1 18.015 23.4v25.64c0 11-7.423 20.62-18.071 23.41l-109.659 28.79c-9.162 2.41-8.986 15.47.236 17.63l108.792 25.46c10.955 2.56 18.702 12.33 18.702 23.57v28.39c0 16.17-15.559 27.79-31.078 23.22l-215.823-63.62c-10.3-3.04-17.372-12.49-17.372-23.22v-32.72c0-10.59 6.883-19.95 16.994-23.11l104.523-32.67c8.547-2.67 8.479-14.79-.096-17.36l-104.17-31.3C79.01 1372.42 72 1363 72 1352.31zM72 572.638V495.43c0-13.336 10.846-24.147 24.225-24.147h215.823c13.379 0 24.225 10.811 24.225 24.147v76.179q0 40.645-15.872 70.228-15.743 29.712-45.422 45.79-29.55 16.206-70.843 16.206-41.292 0-70.971-16.078-29.55-16.077-45.422-45.532Q72 612.767 72 572.638m85.132-29.84c-13.379 0-24.225 10.81-24.225 24.146v3.122q0 19.55 6.323 33.313 6.323 13.89 21.807 21.094 15.485 7.332 43.099 7.331t43.1-7.46q15.484-7.33 21.807-21.608 6.323-14.15 6.323-34.728v-1.064c0-13.336-10.846-24.146-24.225-24.146zM72 285.858c0-13.363 10.846-24.197 24.225-24.197h215.823c13.379 0 24.225 10.834 24.225 24.197v23.27c0 13.364-10.846 24.197-24.225 24.197H154.035c-13.379 0-24.225 10.834-24.225 24.197v58.328c0 13.364-10.846 24.197-24.225 24.197h-9.36C82.845 440.047 72 429.214 72 415.85zM278.463 24.72c0-13.374 10.846-24.216 24.225-24.216h9.36c13.379 0 24.225 10.842 24.225 24.216v181.174c0 13.374-10.846 24.216-24.225 24.216h-9.36c-13.379 0-24.225-10.842-24.225-24.216v-40.108c0-8.359-6.779-15.135-15.141-15.135H96.225c-13.38 0-24.225-10.842-24.225-24.216v-22.256c0-13.374 10.846-24.216 24.225-24.216h167.097c8.362 0 15.141-6.776 15.141-15.135z"/><path fill="#000" fill-rule="evenodd" d="M89.224 1062.13C78.997 1059.04 72 1049.63 72 1038.96v-25.9c0-16.486 16.145-28.147 31.818-22.979l215.823 71.169a24.19 24.19 0 0 1 16.632 22.98v62.97c0 10.45-6.706 19.71-16.632 22.98l-215.823 71.17C88.145 1246.51 72 1234.86 72 1218.37v-25.9c0-10.67 6.997-20.08 17.224-23.17l22.595-6.81a15.13 15.13 0 0 0 10.765-14.48v-64.59a15.13 15.13 0 0 0-10.765-14.48zm98.672 77.53 49.299-14.39c8.601-2.51 8.755-14.62.22-17.35l-49.299-15.75c-5.861-1.88-11.852 2.49-11.852 8.64v30.14c0 6.05 5.817 10.41 11.632 8.71" clip-rule="evenodd"/><path fill="#000" d="M72 773.439c0-13.367 10.846-24.203 24.225-24.203h215.823c13.379 0 24.225 10.836 24.225 24.203v89.762q0 29.395-10.711 51.439-10.71 22.046-30.84 34.293t-48.261 12.248q-28.388 0-47.873-12.635-18.187-11.672-28.056-32.218c-8.303-17.289-11.301-36.661-11.301-55.705v-43.867c0-77.976 138.26 4.16 86.215 4.16h-8.138c-12.334 0-22.332 9.989-22.332 22.311 0 8.269.351 16.6 3.097 24.487q3.225 9.024 10.194 13.794 6.968 4.899 18.194 4.899 11.356 0 18.453-4.899 7.226-4.77 10.581-13.794c2.815-7.188 3.484-14.944 3.484-22.596 0-13.366-10.846-24.202-24.225-24.202h-48.56c-12.036 0-16.288 11.345-21.122 20.272-6.79 12.539-25.841 7.72-25.841-6.536 0-7.586-6.156-13.736-13.749-13.736H96.225C82.845 820.916 72 810.08 72 796.714zm108.66 137.378-10.128 5.511-62.72 34.131C91.67 959.243 72 947.569 72 929.205V906.52a24.2 24.2 0 0 1 12.719-21.299l66.199-35.696a15.82 15.82 0 0 0 8.313-13.921c0-43.012 83.618 41.371 21.429 75.213"/></svg>';
function useLicenseManagerState(licenseManager) {
  return useValue("watermarkState", () => licenseManager.state.get(), [licenseManager]);
}
const WATERMARK_DESKTOP_LOCAL_SRC = `data:image/svg+xml;utf8,${encodeURIComponent(watermarkDesktopSvg)}`;
const WATERMARK_MOBILE_LOCAL_SRC = `data:image/svg+xml;utf8,${encodeURIComponent(watermarkMobileSvg)}`;
const Watermark = reactExports.memo(function Watermark2() {
  const licenseManager = useLicenseContext();
  const editor = useEditor();
  const isMobile = useValue("is mobile", () => editor.getViewportScreenBounds().width < 700, [
    editor
  ]);
  const licenseManagerState = useLicenseManagerState(licenseManager);
  if (!["licensed-with-watermark", "unlicensed"].includes(licenseManagerState)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(LicenseStyles, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      WatermarkInner,
      {
        src: isMobile ? WATERMARK_MOBILE_LOCAL_SRC : WATERMARK_DESKTOP_LOCAL_SRC,
        isUnlicensed: licenseManagerState === "unlicensed"
      }
    )
  ] });
});
const UnlicensedWatermark = reactExports.memo(function UnlicensedWatermark2({
  isDebugMode,
  isMobile
}) {
  const editor = useEditor();
  const events = useCanvasEvents();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const url = "https://tldraw.dev/pricing?utm_source=sdk&utm_medium=organic&utm_campaign=watermark";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: LicenseManager.className,
      "data-debug": isDebugMode,
      "data-mobile": isMobile,
      "data-unlicensed": true,
      "data-testid": "tl-watermark-unlicensed",
      draggable: false,
      ...events,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          draggable: false,
          role: "button",
          onPointerDown: (e) => {
            editor.markEventAsHandled(e);
            preventDefault(e);
          },
          title: "The tldraw SDK requires a license key to work in production. You can get a free 100-day trial license at tldraw.dev/pricing.",
          onClick: () => {
            runtime.openWindow(url, "_blank", true);
          },
          children: "Get a license for production"
        }
      )
    }
  );
});
const WatermarkInner = reactExports.memo(function WatermarkInner2({
  src,
  isUnlicensed
}) {
  const editor = useEditor();
  const isDebugMode = useValue("debug mode", () => editor.getInstanceState().isDebugMode, [editor]);
  const isMobile = useValue("is mobile", () => editor.getViewportScreenBounds().width < 700, [
    editor
  ]);
  const events = useCanvasEvents();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const maskCss = `url('${src}') center 100% / 100% no-repeat`;
  const url = "https://tldraw.dev/?utm_source=sdk&utm_medium=organic&utm_campaign=watermark";
  if (isUnlicensed) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(UnlicensedWatermark, { isDebugMode, isMobile });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: LicenseManager.className,
      "data-debug": isDebugMode,
      "data-mobile": isMobile,
      "data-testid": "tl-watermark-licensed",
      draggable: false,
      ...events,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          draggable: false,
          role: "button",
          onPointerDown: (e) => {
            editor.markEventAsHandled(e);
            preventDefault(e);
          },
          title: "Build infinite canvas applications with the tldraw SDK. Learn more at https://tldraw.dev.",
          onClick: () => {
            runtime.openWindow(url, "_blank");
          },
          style: { mask: maskCss, WebkitMask: maskCss }
        }
      )
    }
  );
});
const LicenseStyles = reactExports.memo(function LicenseStyles2() {
  const editor = useEditor();
  const className = LicenseManager.className;
  const CSS2 = `
/* ------------------- SEE LICENSE -------------------
The tldraw watermark is part of tldraw's license. It is shown for unlicensed
or "licensed-with-watermark" users. By using this library, you agree to
preserve the watermark's behavior, keeping it visible, unobscured, and
available to user-interaction.

To remove the watermark, please purchase a license at tldraw.dev.
*/

.${className} {
	position: absolute;
	bottom: max(var(--tl-space-2), env(safe-area-inset-bottom));
	right: max(var(--tl-space-2), env(safe-area-inset-right));
	width: 96px;
	height: 32px;
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: var(--tl-layer-watermark) !important;
	background-color: color-mix(in srgb, var(--tl-color-background) 62%, transparent);
	opacity: 1;
	border-radius: 5px;
	pointer-events: all;
	padding: 2px;
	box-sizing: content-box;
}

.${className} > button {
	position: absolute;
	width: 96px;
	height: 32px;
	pointer-events: all;
	cursor: inherit;
	color: var(--tl-color-text);
	opacity: .38;
	border: 0;
	padding: 0;
	background-color: currentColor;
}

.${className}[data-debug='true'] {
	bottom: max(46px, env(safe-area-inset-bottom));
}

.${className}[data-mobile='true'] {
	border-radius: 4px 0px 0px 4px;
	right: max(-2px, calc(env(safe-area-inset-right) - 2px));
	width: 8px;
	height: 48px;
}

.${className}[data-mobile='true'] > button {
	width: 8px;
	height: 32px;
}

.${className}[data-unlicensed='true'] > button {
	font-size: 100px;
	position: absolute;
	pointer-events: all;
	cursor: pointer;
	color: var(--tl-color-text);
	opacity: 0.8;
	border: 0;
	padding: 0;
	background-color: transparent;
	font-size: 11px;
	font-weight: 600;
	text-align: center;
}

.${className}[data-mobile='true'][data-unlicensed='true'] > button {
	display: none;
}

@media (hover: hover) {
	.${className} > button {
		pointer-events: none;
	}

	.${className}:hover {
		background-color: var(--tl-color-background);
		transition: background-color 0.2s ease-in-out;
		transition-delay: 0.32s;
	}

	.${className}:hover > button {
		animation: ${className}_delayed_link 0.2s forwards ease-in-out;
		animation-delay: 0.32s;
	}

	.${className} > button:focus-visible {
		opacity: 1;
	}
}

@keyframes ${className}_delayed_link {
	0% {
		cursor: inherit;
		opacity: .38;
		pointer-events: none;
	}
	100% {
		cursor: pointer;
		opacity: 1;
		pointer-events: all;
	}
}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("style", { nonce: editor.options.nonce, children: CSS2 });
});
const EMPTY_SHAPE_UTILS_ARRAY = [];
const EMPTY_BINDING_UTILS_ARRAY = [];
const EMPTY_TOOLS_ARRAY = [];
const TL_CONTAINER_CLASS = "tl-container";
const TldrawEditor = reactExports.memo(function TldrawEditor2({
  store,
  components,
  className,
  user: _user,
  options: _options,
  ...rest
}) {
  const [container, setContainer] = reactExports.useState(null);
  const user = reactExports.useMemo(() => _user ?? createTLUser(), [_user]);
  const ErrorFallback = components?.ErrorFallback === void 0 ? DefaultErrorFallback : components?.ErrorFallback;
  const withDefaults = {
    ...rest,
    shapeUtils: rest.shapeUtils ?? EMPTY_SHAPE_UTILS_ARRAY,
    bindingUtils: rest.bindingUtils ?? EMPTY_BINDING_UTILS_ARRAY,
    tools: rest.tools ?? EMPTY_TOOLS_ARRAY,
    components,
    options: useShallowObjectIdentity(_options)
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: setContainer,
      "data-tldraw": version,
      draggable: false,
      className: classNames(`${TL_CONTAINER_CLASS} tl-theme__light`, className),
      tabIndex: -1,
      role: "application",
      "aria-label": _options?.branding ?? "tldraw",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        OptionalErrorBoundary,
        {
          fallback: ErrorFallback,
          onError: (error) => annotateError(error, { tags: { origin: "react.tldraw-before-app" } }),
          children: container && /* @__PURE__ */ jsxRuntimeExports.jsx(LicenseProvider, { licenseKey: rest.licenseKey, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerProvider, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditorComponentsProvider, { overrides: components, children: store ? store instanceof Store ? (
            // Store is ready to go, whether externally synced or not
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawEditorWithReadyStore, { ...withDefaults, store, user })
          ) : (
            // Store is a synced store, so handle syncing stages internally
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawEditorWithLoadingStore, { ...withDefaults, store, user })
          ) : (
            // We have no store (it's undefined) so create one and possibly sync it
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawEditorWithOwnStore, { ...withDefaults, store, user })
          ) }) }) })
        }
      )
    }
  );
});
function TldrawEditorWithOwnStore(props) {
  const {
    defaultName,
    snapshot,
    initialData,
    shapeUtils,
    bindingUtils,
    persistenceKey,
    sessionId,
    user,
    assets,
    migrations
  } = props;
  const syncedStore = useLocalStore({
    shapeUtils,
    bindingUtils,
    initialData,
    persistenceKey,
    sessionId,
    defaultName,
    snapshot,
    assets,
    migrations
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawEditorWithLoadingStore, { ...props, store: syncedStore, user });
}
const TldrawEditorWithLoadingStore = reactExports.memo(function TldrawEditorBeforeLoading({
  store,
  user,
  ...rest
}) {
  const container = useContainer();
  reactExports.useLayoutEffect(() => {
    if (user.userPreferences.get().colorScheme === "dark") {
      container.classList.remove("tl-theme__light");
      container.classList.add("tl-theme__dark");
    }
  }, [container, user]);
  const { LoadingScreen: LoadingScreen2 } = useEditorComponents();
  switch (store.status) {
    case "error": {
      throw store.error;
    }
    case "loading": {
      return LoadingScreen2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingScreen2, {}) : null;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawEditorWithReadyStore, { ...rest, store: store.store, user });
});
const noAutoFocus = () => document.location.search.includes("tldraw_preserve_focus");
function TldrawEditorWithReadyStore({
  onMount,
  children,
  store,
  tools,
  shapeUtils,
  bindingUtils,
  user,
  initialState: initialState2,
  autoFocus = true,
  inferDarkMode,
  cameraOptions,
  textOptions,
  options,
  licenseKey,
  deepLinks: _deepLinks,
  getShapeVisibility,
  assetUrls
}) {
  const { ErrorFallback } = useEditorComponents();
  const container = useContainer();
  const [editor, setEditor] = useRefState(null);
  const canvasRef = reactExports.useRef(null);
  const deepLinks = useShallowObjectIdentity(_deepLinks === true ? {} : _deepLinks);
  const editorOptionsRef = reactExports.useRef({
    // for these, it's because they're only used when the editor first mounts:
    autoFocus: autoFocus && !noAutoFocus(),
    inferDarkMode,
    initialState: initialState2,
    // for these, it's because we keep them up to date in a separate effect:
    cameraOptions,
    deepLinks
  });
  reactExports.useLayoutEffect(() => {
    editorOptionsRef.current = {
      autoFocus: autoFocus && !noAutoFocus(),
      inferDarkMode,
      initialState: initialState2,
      cameraOptions,
      deepLinks
    };
  }, [autoFocus, inferDarkMode, initialState2, cameraOptions, deepLinks]);
  reactExports.useLayoutEffect(
    () => {
      const { autoFocus: autoFocus2, inferDarkMode: inferDarkMode2, initialState: initialState22, cameraOptions: cameraOptions2, deepLinks: deepLinks2 } = editorOptionsRef.current;
      const editor2 = new Editor$1({
        store,
        shapeUtils,
        bindingUtils,
        tools,
        getContainer: () => container,
        user,
        initialState: initialState22,
        // we should check for some kind of query parameter that turns off autofocus
        autoFocus: autoFocus2,
        inferDarkMode: inferDarkMode2,
        cameraOptions: cameraOptions2,
        textOptions,
        options,
        licenseKey,
        getShapeVisibility,
        fontAssetUrls: assetUrls?.fonts
      });
      editor2.updateViewportScreenBounds(canvasRef.current ?? container);
      if (deepLinks2) {
        if (!deepLinks2?.getUrl) {
          editor2.navigateToDeepLink(deepLinks2);
        } else {
          editor2.navigateToDeepLink({ ...deepLinks2, url: deepLinks2.getUrl(editor2) });
        }
      }
      setEditor(editor2);
      return () => {
        editor2.dispose();
      };
    },
    // if any of these change, we need to recreate the editor.
    [
      bindingUtils,
      container,
      options,
      shapeUtils,
      store,
      tools,
      user,
      setEditor,
      licenseKey,
      getShapeVisibility,
      textOptions,
      assetUrls
    ]
  );
  reactExports.useLayoutEffect(() => {
    if (!editor) return;
    if (deepLinks) {
      return editor.registerDeepLinkListener(deepLinks);
    }
  }, [editor, deepLinks]);
  reactExports.useLayoutEffect(() => {
    if (editor && cameraOptions) {
      editor.setCameraOptions(cameraOptions);
    }
  }, [editor, cameraOptions]);
  const crashingError = reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => {
        if (editor) {
          editor.on("crash", onStoreChange);
          return () => editor.off("crash", onStoreChange);
        }
        return () => {
        };
      },
      [editor]
    ),
    () => editor?.getCrashingError() ?? null
  );
  reactExports.useEffect(
    function handleFocusOnPointerDownForPreserveFocusMode() {
      if (!editor) return;
      function handleFocusOnPointerDown() {
        if (!editor) return;
        editor.focus();
      }
      function handleBlurOnPointerDown() {
        if (!editor) return;
        editor.blur();
      }
      if (autoFocus && noAutoFocus()) {
        editor.getContainer().addEventListener("pointerdown", handleFocusOnPointerDown);
        document.body.addEventListener("pointerdown", handleBlurOnPointerDown);
        return () => {
          editor.getContainer()?.removeEventListener("pointerdown", handleFocusOnPointerDown);
          document.body.removeEventListener("pointerdown", handleBlurOnPointerDown);
        };
      }
    },
    [editor, autoFocus]
  );
  const [_fontLoadingState, setFontLoadingState] = reactExports.useState(null);
  let fontLoadingState = _fontLoadingState;
  if (editor !== fontLoadingState?.editor) {
    fontLoadingState = null;
  }
  reactExports.useLayoutEffect(() => {
    if (!editor) return;
    if (editor.options.maxFontsToLoadBeforeRender === 0) {
      setFontLoadingState({ editor, isLoaded: true });
      return;
    }
    let isCancelled = false;
    setFontLoadingState({ editor, isLoaded: false });
    editor.fonts.loadRequiredFontsForCurrentPage(editor.options.maxFontsToLoadBeforeRender).finally(() => {
      if (isCancelled) return;
      setFontLoadingState({ editor, isLoaded: true });
    });
    return () => {
      isCancelled = true;
    };
  }, [editor]);
  const { Canvas, LoadingScreen: LoadingScreen2 } = useEditorComponents();
  if (!editor || !fontLoadingState?.isLoaded) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      LoadingScreen2 && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingScreen2, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-canvas", ref: canvasRef })
    ] });
  }
  return (
    // the top-level tldraw component also renders an error boundary almost
    // identical to this one. the reason we have two is because this one has
    // access to `App`, which means that here we can enrich errors with data
    // from app for reporting, and also still attempt to render the user's
    // document in the event of an error to reassure them that their work is
    // not lost.
    /* @__PURE__ */ jsxRuntimeExports.jsx(OptionalErrorBoundary, {
      fallback: ErrorFallback,
      onError: (error) => editor.annotateError(error, { origin: "react.tldraw", willCrashApp: true }),
      children: crashingError ? /* @__PURE__ */ jsxRuntimeExports.jsx(Crash, { crashingError }) : /* @__PURE__ */ jsxRuntimeExports.jsx(EditorProvider, { editor, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Layout, { onMount, children: [
        children ?? (Canvas ? /* @__PURE__ */ jsxRuntimeExports.jsx(Canvas, {}, editor.contextId) : null),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Watermark, {})
      ] }) })
    })
  );
}
function Layout({ children, onMount }) {
  useZoomCss();
  useCursor();
  useDarkMode();
  useForceUpdate();
  useStateAttribute();
  useOnMount((editor) => {
    const teardownStore = editor.store.props.onMount(editor);
    const teardownCallback = onMount?.(editor);
    return () => {
      teardownStore?.();
      teardownCallback?.();
    };
  });
  return children;
}
function Crash({ crashingError }) {
  throw crashingError;
}
function LoadingScreen$1({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-loading", "aria-busy": "true", tabIndex: 0, children });
}
function useOnMount(onMount) {
  const editor = useEditor();
  const onMountEvent = useEvent((editor2) => {
    let teardown = void 0;
    editor2.run(
      () => {
        teardown = onMount?.(editor2);
        editor2.emit("mount");
      },
      { history: "ignore" }
    );
    window.tldrawReady = true;
    return teardown;
  });
  React.useLayoutEffect(() => {
    if (editor) return onMountEvent?.(editor);
  }, [editor, onMountEvent]);
}
const DefaultLoadingScreen = () => {
  const { Spinner: Spinner2 } = useEditorComponents();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingScreen$1, { children: Spinner2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner2, {}) : null });
};
function getSvgPathFromPoints(points, closed = true) {
  const len = points.length;
  if (len < 2) {
    return "";
  }
  let a = points[0];
  let b = points[1];
  if (len === 2) {
    return `M${precise(a)}L${precise(b)}`;
  }
  let result = "";
  for (let i = 2, max2 = len - 1; i < max2; i++) {
    a = points[i];
    b = points[i + 1];
    result += average(a, b);
  }
  if (closed) {
    return `M${average(points[0], points[1])}Q${precise(points[1])}${average(
      points[1],
      points[2]
    )}T${result}${average(points[len - 1], points[0])}${average(points[0], points[1])}Z`;
  } else {
    return `M${precise(points[0])}Q${precise(points[1])}${average(points[1], points[2])}${points.length > 3 ? "T" : ""}${result}L${precise(points[len - 1])}`;
  }
}
function DefaultScribble({ scribble, zoom, color, opacity, className }) {
  if (!scribble.points.length) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: className ? classNames("tl-overlays__item", className) : className, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      className: "tl-scribble",
      d: getSvgPathFromPoints(scribble.points, false),
      stroke: color ?? `var(--tl-color-${scribble.color})`,
      fill: "none",
      strokeWidth: 8 / zoom,
      opacity: opacity ?? scribble.opacity
    }
  ) });
}
function DefaultSelectionForeground({ bounds, rotation }) {
  const editor = useEditor();
  const rSvg = reactExports.useRef(null);
  const onlyShape = useValue("only selected shape", () => editor.getOnlySelectedShape(), [editor]);
  const expandOutlineBy = onlyShape ? editor.getShapeUtil(onlyShape).expandSelectionOutlinePx(onlyShape) : 0;
  useTransform(rSvg, bounds?.x, bounds?.y, 1, rotation, {
    x: -expandOutlineBy,
    y: -expandOutlineBy
  });
  bounds = expandOutlineBy instanceof Box ? bounds.clone().expand(expandOutlineBy).zeroFix() : bounds.clone().expandBy(expandOutlineBy).zeroFix();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      ref: rSvg,
      className: "tl-overlays__item tl-selection__fg",
      "data-testid": "selection-foreground",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          className: classNames("tl-selection__fg__outline"),
          width: toDomPrecision(bounds.width),
          height: toDomPrecision(bounds.height)
        }
      )
    }
  );
}
const DefaultShapeErrorFallback = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-shape-error-boundary" });
};
const EvenInnererIndicator = reactExports.memo(
  ({ shape, util }) => {
    return useStateTracking(
      "Indicator: " + shape.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        util.indicator(util.editor.store.unsafeGetWithoutCapture(shape.id))
      )
    );
  },
  (prevProps, nextProps) => {
    return prevProps.shape.props === nextProps.shape.props && prevProps.shape.meta === nextProps.shape.meta;
  }
);
const InnerIndicator = reactExports.memo(({ editor, id }) => {
  const shape = useValue("shape for indicator", () => editor.store.get(id), [editor, id]);
  const { ShapeIndicatorErrorFallback } = useEditorComponents();
  if (!shape || shape.isLocked) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    OptionalErrorBoundary,
    {
      fallback: ShapeIndicatorErrorFallback,
      onError: (error) => editor.annotateError(error, { origin: "react.shapeIndicator", willCrashApp: false }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(EvenInnererIndicator, { shape, util: editor.getShapeUtil(shape) }, shape.id)
    }
  );
});
const DefaultShapeIndicator = reactExports.memo(function DefaultShapeIndicator2({
  shapeId,
  className,
  color,
  hidden,
  opacity
}) {
  const editor = useEditor();
  const rIndicator = reactExports.useRef(null);
  useQuickReactor(
    "indicator transform",
    () => {
      if (hidden) return;
      const elm = rIndicator.current;
      if (!elm) return;
      const pageTransform = editor.getShapePageTransform(shapeId);
      if (!pageTransform) return;
      elm.style.setProperty("transform", pageTransform.toCssString());
    },
    [editor, shapeId, hidden]
  );
  reactExports.useLayoutEffect(() => {
    const elm = rIndicator.current;
    if (!elm) return;
    elm.style.setProperty("display", hidden ? "none" : "block");
  }, [hidden]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { ref: rIndicator, className: classNames("tl-overlays__item", className), "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "g",
    {
      className: "tl-shape-indicator",
      stroke: color ?? "var(--tl-color-selected)",
      opacity,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(InnerIndicator, { editor, id: shapeId })
    }
  ) });
});
const DefaultShapeIndicatorErrorFallback = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: 4, cy: 4, r: 8, strokeWidth: "1", stroke: "red" });
};
const DefaultShapeIndicators = reactExports.memo(function DefaultShapeIndicators2({
  hideAll,
  showAll
}) {
  const editor = useEditor();
  if (hideAll && showAll)
    throw Error("You cannot set both hideAll and showAll props to true, cmon now");
  const rPreviousSelectedShapeIds = reactExports.useRef(/* @__PURE__ */ new Set());
  const idsToDisplay = useValue(
    "should display selected ids",
    () => {
      const prev = rPreviousSelectedShapeIds.current;
      const next = /* @__PURE__ */ new Set();
      const instanceState = editor.getInstanceState();
      const isChangingStyle = instanceState.isChangingStyle;
      const isIdleOrEditing = editor.isInAny("select.idle", "select.editing_shape");
      const isInSelectState = editor.isInAny(
        "select.brushing",
        "select.scribble_brushing",
        "select.pointing_shape",
        "select.pointing_selection",
        "select.pointing_handle"
      );
      if (isChangingStyle || !(isIdleOrEditing || isInSelectState)) {
        rPreviousSelectedShapeIds.current = next;
        return next;
      }
      for (const id of editor.getSelectedShapeIds()) {
        next.add(id);
      }
      if (isIdleOrEditing && instanceState.isHoveringCanvas && !instanceState.isCoarsePointer) {
        const hovered = editor.getHoveredShapeId();
        if (hovered) next.add(hovered);
      }
      if (prev.size !== next.size) {
        rPreviousSelectedShapeIds.current = next;
        return next;
      }
      for (const id of next) {
        if (!prev.has(id)) {
          rPreviousSelectedShapeIds.current = next;
          return next;
        }
      }
      return prev;
    },
    [editor]
  );
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  const { ShapeIndicator } = useEditorComponents();
  if (!ShapeIndicator) return null;
  return renderingShapes.map(({ id }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ShapeIndicator,
    {
      shapeId: id,
      hidden: !showAll && (hideAll || !idsToDisplay.has(id))
    },
    id + "_indicator"
  ));
});
const DefaultShapeWrapper = reactExports.forwardRef(function DefaultShapeWrapper2({ children, shape, isBackground, ...props }, ref) {
  const isFilledShape = "fill" in shape.props && shape.props.fill !== "none";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      "data-shape-type": shape.type,
      "data-shape-is-filled": isBackground ? void 0 : isFilledShape,
      "data-shape-id": shape.id,
      draggable: false,
      ...props,
      className: classNames("tl-shape", isBackground && "tl-shape-background", props.className),
      children
    }
  );
});
function PointsSnapIndicator({ points, zoom }) {
  const l = 2.5 / zoom;
  const minX = points.reduce((acc, p) => Math.min(acc, p.x), Infinity);
  const maxX = points.reduce((acc, p) => Math.max(acc, p.x), -Infinity);
  const minY = points.reduce((acc, p) => Math.min(acc, p.y), Infinity);
  const maxY = points.reduce((acc, p) => Math.max(acc, p.y), -Infinity);
  const useNWtoSEdireciton = points.some((p) => p.x === minX && p.y === minY);
  let firstX, firstY, secondX, secondY;
  if (useNWtoSEdireciton) {
    firstX = minX;
    firstY = minY;
    secondX = maxX;
    secondY = maxY;
  } else {
    firstX = minX;
    firstY = maxY;
    secondX = maxX;
    secondY = minY;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: "tl-snap-indicator", stroke: "lime", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: firstX, y1: firstY, x2: secondX, y2: secondY }),
    points.map((p, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `translate(${p.x},${p.y})`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        className: "tl-snap-point",
        d: `M ${-l},${-l} L ${l},${l} M ${-l},${l} L ${l},${-l}`
      }
    ) }, i))
  ] });
}
function GapsSnapIndicator({ gaps, direction, zoom }) {
  const l = 3.5 / zoom;
  let edgeIntersection = [-Infinity, Infinity];
  let nextEdgeIntersection = null;
  const horizontal = direction === "horizontal";
  for (const gap of gaps) {
    nextEdgeIntersection = rangeIntersection(
      edgeIntersection[0],
      edgeIntersection[1],
      horizontal ? gap.startEdge[0].y : gap.startEdge[0].x,
      horizontal ? gap.startEdge[1].y : gap.startEdge[1].x
    );
    if (nextEdgeIntersection) {
      edgeIntersection = nextEdgeIntersection;
    } else {
      continue;
    }
    nextEdgeIntersection = rangeIntersection(
      edgeIntersection[0],
      edgeIntersection[1],
      horizontal ? gap.endEdge[0].y : gap.endEdge[0].x,
      horizontal ? gap.endEdge[1].y : gap.endEdge[1].x
    );
    if (nextEdgeIntersection) {
      edgeIntersection = nextEdgeIntersection;
    } else {
      continue;
    }
  }
  if (edgeIntersection === null) {
    return null;
  }
  const midPoint = (edgeIntersection[0] + edgeIntersection[1]) / 2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "tl-snap-indicator", stroke: "cyan", children: gaps.map(({ startEdge, endEdge }, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: horizontal ? (
    // horizontal gap
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: startEdge[0].x,
          y1: midPoint - 2 * l,
          x2: startEdge[1].x,
          y2: midPoint + 2 * l
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: endEdge[0].x,
          y1: midPoint - 2 * l,
          x2: endEdge[1].x,
          y2: midPoint + 2 * l
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: startEdge[0].x, y1: midPoint, x2: endEdge[0].x, y2: midPoint }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: (startEdge[0].x + endEdge[0].x) / 2,
          y1: midPoint - l,
          x2: (startEdge[0].x + endEdge[0].x) / 2,
          y2: midPoint + l
        }
      )
    ] })
  ) : (
    // vertical gap
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: midPoint - 2 * l,
          y1: startEdge[0].y,
          x2: midPoint + 2 * l,
          y2: startEdge[1].y
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: midPoint - 2 * l,
          y1: endEdge[0].y,
          x2: midPoint + 2 * l,
          y2: endEdge[1].y
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: midPoint, y1: startEdge[0].y, x2: midPoint, y2: endEdge[0].y }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: midPoint - l,
          y1: (startEdge[0].y + endEdge[0].y) / 2,
          x2: midPoint + l,
          y2: (startEdge[0].y + endEdge[0].y) / 2
        }
      )
    ] })
  ) }, i)) });
}
function DefaultSnapIndicator({ className, line, zoom }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: classNames("tl-overlays__item", className), "aria-hidden": "true", children: line.type === "points" ? /* @__PURE__ */ jsxRuntimeExports.jsx(PointsSnapIndicator, { ...line, zoom }) : line.type === "gaps" ? /* @__PURE__ */ jsxRuntimeExports.jsx(GapsSnapIndicator, { ...line, zoom }) : null });
}
function DefaultSpinner(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      "aria-hidden": "false",
      ...props,
      className: classNames("tl-spinner", props.className),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor" })
      ] })
    }
  );
}
const DefaultSvgDefs = () => {
  return null;
};
const EditorComponentsContext = reactExports.createContext(null);
function EditorComponentsProvider({
  overrides = {},
  children
}) {
  const _overrides = useShallowObjectIdentity(overrides);
  const value = reactExports.useMemo(
    () => ({
      Background: DefaultBackground,
      Brush: DefaultBrush,
      Canvas: DefaultCanvas,
      CollaboratorBrush: DefaultBrush,
      CollaboratorCursor: DefaultCursor,
      CollaboratorHint: DefaultCollaboratorHint,
      CollaboratorScribble: DefaultScribble,
      CollaboratorShapeIndicator: DefaultShapeIndicator,
      Cursor: DefaultCursor,
      Grid: DefaultGrid,
      Handle: DefaultHandle,
      Handles: DefaultHandles,
      InFrontOfTheCanvas: null,
      LoadingScreen: DefaultLoadingScreen,
      OnTheCanvas: null,
      Overlays: null,
      Scribble: DefaultScribble,
      SelectionBackground: null,
      SelectionForeground: DefaultSelectionForeground,
      ShapeIndicator: DefaultShapeIndicator,
      ShapeIndicators: DefaultShapeIndicators,
      ShapeWrapper: DefaultShapeWrapper,
      SnapIndicator: DefaultSnapIndicator,
      Spinner: DefaultSpinner,
      SvgDefs: DefaultSvgDefs,
      ZoomBrush: DefaultBrush,
      ErrorFallback: DefaultErrorFallback,
      ShapeErrorFallback: DefaultShapeErrorFallback,
      ShapeIndicatorErrorFallback: DefaultShapeIndicatorErrorFallback,
      ..._overrides
    }),
    [_overrides]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EditorComponentsContext.Provider, { value, children });
}
function useEditorComponents() {
  const components = reactExports.useContext(EditorComponentsContext);
  if (!components) {
    throw new Error("useEditorComponents must be used inside of <EditorComponentsProvider />");
  }
  return components;
}
const IGNORED_TAGS = ["textarea", "input"];
function useFixSafariDoubleTapZoomPencilEvents(ref) {
  const editor = useEditor();
  reactExports.useEffect(() => {
    const elm = ref.current;
    if (!elm) return;
    const handleEvent = (e) => {
      if (e instanceof PointerEvent && e.pointerType === "pen") {
        editor.markEventAsHandled(e);
        const { target } = e;
        if (IGNORED_TAGS.includes(target.tagName?.toLocaleLowerCase()) || target.isContentEditable || editor.isIn("select.editing_shape")) {
          return;
        }
        preventDefault(e);
      }
    };
    elm.addEventListener("touchstart", handleEvent);
    elm.addEventListener("touchend", handleEvent);
    return () => {
      elm.removeEventListener("touchstart", handleEvent);
      elm.removeEventListener("touchend", handleEvent);
    };
  }, [editor, ref]);
}
function clamp$2(v, min2, max2) {
  return Math.max(min2, Math.min(v, max2));
}
const V = {
  toVector(v, fallback) {
    if (v === void 0) v = fallback;
    return Array.isArray(v) ? v : [v, v];
  },
  add(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
  },
  sub(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
  },
  addTo(v1, v2) {
    v1[0] += v2[0];
    v1[1] += v2[1];
  },
  subTo(v1, v2) {
    v1[0] -= v2[0];
    v1[1] -= v2[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min2, max2, constant = 0.15) {
  if (constant === 0) return clamp$2(position, min2, max2);
  if (position < min2) return -rubberband(min2 - position, max2 - min2, constant) + min2;
  if (position > max2) return +rubberband(position - max2, max2 - min2, constant) + max2;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint);
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$1(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t2), true).forEach(function(r2) {
      _defineProperty(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
const EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string2) {
  if (!string2) return "";
  return string2[0].toUpperCase() + string2.slice(1);
}
const actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
const pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive) eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture) eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event)) return "touch";
  if ("pointerType" in event) return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e) => {
    var _event$currentTarget, _event$currentTarget$;
    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));
  });
}
function distanceAngle(P1, P2) {
  try {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return {
      angle,
      distance,
      origin
    };
  } catch (_unused) {
  }
  return null;
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
const LINE_HEIGHT = 40;
const PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event) payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey: altKey2,
      metaKey,
      ctrlKey: ctrlKey2
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey: altKey2,
      metaKey,
      ctrlKey: ctrlKey2
    });
  }
  return payload;
}
function call(v, ...args) {
  if (typeof v === "function") {
    return v(...args);
  } else {
    return v;
  }
}
function noop$2() {
}
function chain(...fns) {
  if (fns.length === 0) return noop$2;
  if (fns.length === 1) return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
const BEFORE_LAST_KINEMATICS_DELAY = 32;
class Engine {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init) this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared: shared2,
      ingKey,
      args
    } = this;
    shared2[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = state.timeDelta = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
      state.startTime = state.timeStamp = event.timeStamp;
    }
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared: shared2
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable) state.event.preventDefault();
      state.type = event.type;
      shared2.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared2.locked = !!document.pointerLockElement;
      Object.assign(shared2, getEventDetails(event));
      shared2.down = shared2.pressed = shared2.buttons % 2 === 1 || shared2.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent) this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional) return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared2[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config) state._bounds = call(config.bounds, state);
          if (this.setup) this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt > 0) {
        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        state.timeDelta = dt;
      }
    }
  }
  emit() {
    const state = this.state;
    const shared2 = this.shared;
    const config = this.config;
    if (!state._active) this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;
    const memo2 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared2), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo2 !== void 0) state.memo = memo2;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
}
function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
class CoordinatesEngine extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config = this.config;
    if (!state.axis && event) {
      const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
  }
  restrictToAxis(v) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v[1] = 0;
          break;
        case "y":
          v[0] = 0;
          break;
      }
    }
  }
}
const identity = (v) => v;
const DEFAULT_RUBBERBAND = 0.15;
const commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config) {
    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function") return value;
    if (value != null) return V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
const DEFAULT_AXIS_THRESHOLD = 0;
const coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection) return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top, bottom]];
  }
});
const isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e) {
    return false;
  }
}
const SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: supportsTouchEvents(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
const DEFAULT_PREVENT_SCROLL_DELAY = 250;
const DEFAULT_DRAG_DELAY = 180;
const DEFAULT_SWIPE_VELOCITY = 0.5;
const DEFAULT_SWIPE_DISTANCE = 50;
const DEFAULT_SWIPE_DURATION = 250;
const DEFAULT_KEYBOARD_DISPLACEMENT = 10;
const DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
_objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device(_v, _k, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch) return "touch";
    if (this.pointerLock) return "mouse";
    if (SUPPORT.pointer && !mouse) return "pointer";
    if (SUPPORT.touch) return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false) return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1,
      keys: keys2 = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys2;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  },
  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
    return value;
  }
});
function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}
const SCALE_ANGLE_RATIO_INTENT_DEG = 30;
const PINCH_WHEEL_RATIO = 100;
class PinchEngine extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset: offset2,
      lastOffset
    } = this.state;
    this.state.movement = [offset2[0] / lastOffset[0], offset2[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0) state.axis = "angle";
      else if (axisMovementDifference > 0) state.axis = "scale";
    }
  }
  restrictToAxis(v) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale") v[1] = 0;
      else if (this.state.axis === "angle") v[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id))) return;
    }
    if (ctrlTouchIds.size < 2) return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id))) return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2) return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active) return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active) return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active) return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active) return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    if (state._active) return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable) event.preventDefault();
    if (!this.state._active) return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && (Array.isArray(modifierKey) ? !modifierKey.find((k) => event[k]) : !event[modifierKey])) return;
    if (!this.state._active) this.wheelStart(event);
    else this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
      bindFunction("lostPointerCapture", "", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
}
const pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device(_v, _k, {
    shared: shared2,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared2;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
    if (SUPPORT.touch && touch) return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer) return "pointer";
      if (SUPPORT.touch) return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };
    const _angleBounds = (state) => {
      const A = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function") return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0) return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});
_objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
class WheelEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active) this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
}
const wheelConfigResolver = coordinatesConfigResolver;
_objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
const EngineMap = /* @__PURE__ */ new Map();
const ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
const pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
const wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
const sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
const _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        {
          result[key] = resolver.call(result, config[key], key, config);
        }
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver) result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse$1(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig, {
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  _config.shared = resolveWith({
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      }
    }
  }
  return _config;
}
class EventStore {
  constructor(ctrl, gestureKey) {
    _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);
    element.addEventListener(type, handler, eventOptions);
    const remove2 = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove2);
    };
    listeners.add(remove2);
    return remove2;
  }
  clean() {
    this._listeners.forEach((remove2) => remove2());
    this._listeners.clear();
  }
}
class TimeoutStore {
  constructor() {
    _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout) window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
}
class Controller {
  constructor(handlers2) {
    _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers2);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel") this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown") this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers2, nativeHandlers) {
    this.handlers = handlers2;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse$1(config, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target) this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target) return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
          event,
          args
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target) return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
}
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag) setupGesture(ctrl, "drag");
  if (internalHandlers.wheel) setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll) setupGesture(ctrl, "scroll");
  if (internalHandlers.move) setupGesture(ctrl, "move");
  if (internalHandlers.pinch) setupGesture(ctrl, "pinch");
  if (internalHandlers.hover) setupGesture(ctrl, "hover");
}
const bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive) handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
const RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers2) {
  const native = {};
  const handlers2 = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers2) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers2[key] = _handlers2[key];
    } else {
      native[key] = _handlers2[key];
    }
  }
  return [handlers2, native, actions];
}
function registerGesture(actions, handlers2, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey)) return;
  if (!EngineMap.has(key)) {
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo2 = void 0;
    if (state.first && startKey in handlers2) handlers2[startKey](state);
    if (handlerKey in handlers2) memo2 = handlers2[handlerKey](state);
    if (state.last && endKey in handlers2) handlers2[endKey](state);
    return memo2;
  };
  internalHandlers[key] = fn;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers2, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers2, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}
function useRecognizers(handlers2, config = {}, gestureKey, nativeHandlers) {
  const ctrl = React.useMemo(() => new Controller(handlers2), []);
  ctrl.applyHandlers(handlers2, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  React.useEffect(ctrl.effect.bind(ctrl));
  React.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers2, _config) {
    const {
      handlers: handlers2,
      nativeHandlers,
      config
    } = parseMergedHandlers(_handlers2, _config || {});
    return useRecognizers(handlers2, config, void 0, nativeHandlers);
  };
}
const MAX_ZOOM_STEP = 10;
const IS_DARWIN = /Mac|iPod|iPhone|iPad/.test(
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  typeof window === "undefined" ? "node" : window.navigator.platform
);
function normalizeWheel(event) {
  let { deltaY, deltaX } = event;
  let deltaZ = 0;
  if (event.ctrlKey || event.altKey || event.metaKey) {
    deltaZ = (Math.abs(deltaY) > MAX_ZOOM_STEP ? MAX_ZOOM_STEP * Math.sign(deltaY) : deltaY) / 100;
  } else {
    if (event.shiftKey && !IS_DARWIN) {
      deltaX = deltaY;
      deltaY = 0;
    }
  }
  return { x: -deltaX, y: -deltaY, z: -deltaZ };
}
const useGesture = createUseGesture([wheelAction, pinchAction]);
let lastWheelTime = void 0;
const isWheelEndEvent = (time) => {
  if (lastWheelTime === void 0) {
    lastWheelTime = time;
    return false;
  }
  if (time - lastWheelTime > 120 && time - lastWheelTime < 160) {
    lastWheelTime = time;
    return true;
  }
  lastWheelTime = time;
  return false;
};
function useGestureEvents(ref) {
  const editor = useEditor();
  const events = reactExports.useMemo(() => {
    let pinchState = "not sure";
    const onWheel = ({ event }) => {
      if (!editor.getInstanceState().isFocused) {
        return;
      }
      pinchState = "not sure";
      if (isWheelEndEvent(Date.now())) {
        return;
      }
      const editingShapeId = editor.getEditingShapeId();
      if (editingShapeId) {
        const shape = editor.getShape(editingShapeId);
        if (shape) {
          const util = editor.getShapeUtil(shape);
          if (util.canScroll(shape)) {
            const bounds = editor.getShapePageBounds(editingShapeId);
            if (bounds?.containsPoint(editor.inputs.currentPagePoint)) {
              return;
            }
          }
        }
      }
      preventDefault(event);
      event.stopPropagation();
      const delta = normalizeWheel(event);
      if (delta.x === 0 && delta.y === 0) return;
      const info = {
        type: "wheel",
        name: "wheel",
        delta,
        point: new Vec(event.clientX, event.clientY),
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        ctrlKey: event.metaKey || event.ctrlKey,
        metaKey: event.metaKey,
        accelKey: isAccelKey(event)
      };
      editor.dispatch(info);
    };
    let initDistanceBetweenFingers = 1;
    let initZoom = 1;
    let currDistanceBetweenFingers = 0;
    const initPointBetweenFingers = new Vec();
    const prevPointBetweenFingers = new Vec();
    const onPinchStart = (gesture) => {
      const elm = ref.current;
      pinchState = "not sure";
      const { event, origin, da } = gesture;
      if (event instanceof WheelEvent) return;
      if (!(event.target === elm || elm?.contains(event.target))) return;
      prevPointBetweenFingers.x = origin[0];
      prevPointBetweenFingers.y = origin[1];
      initPointBetweenFingers.x = origin[0];
      initPointBetweenFingers.y = origin[1];
      initDistanceBetweenFingers = da[0];
      initZoom = editor.getZoomLevel();
      editor.dispatch({
        type: "pinch",
        name: "pinch_start",
        point: { x: origin[0], y: origin[1], z: editor.getZoomLevel() },
        delta: { x: 0, y: 0 },
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        ctrlKey: event.metaKey || event.ctrlKey,
        metaKey: event.metaKey,
        accelKey: isAccelKey(event)
      });
    };
    const updatePinchState = (isSafariTrackpadPinch) => {
      if (isSafariTrackpadPinch) {
        pinchState = "zooming";
      }
      if (pinchState === "zooming") {
        return;
      }
      const touchDistance = Math.abs(currDistanceBetweenFingers - initDistanceBetweenFingers);
      const originDistance = Vec.Dist(initPointBetweenFingers, prevPointBetweenFingers);
      switch (pinchState) {
        case "not sure": {
          if (touchDistance > 24) {
            pinchState = "zooming";
          } else if (originDistance > 16) {
            pinchState = "panning";
          }
          break;
        }
        case "panning": {
          if (touchDistance > 64) {
            pinchState = "zooming";
          }
          break;
        }
      }
    };
    const onPinch = (gesture) => {
      const elm = ref.current;
      const { event, origin, offset: offset2, da } = gesture;
      if (event instanceof WheelEvent) return;
      if (!(event.target === elm || elm?.contains(event.target))) return;
      const isSafariTrackpadPinch = gesture.type === "gesturechange" || gesture.type === "gestureend";
      currDistanceBetweenFingers = da[0];
      const dx = origin[0] - prevPointBetweenFingers.x;
      const dy = origin[1] - prevPointBetweenFingers.y;
      prevPointBetweenFingers.x = origin[0];
      prevPointBetweenFingers.y = origin[1];
      updatePinchState(isSafariTrackpadPinch);
      switch (pinchState) {
        case "zooming": {
          const currZoom = offset2[0] ** editor.getCameraOptions().zoomSpeed;
          editor.dispatch({
            type: "pinch",
            name: "pinch",
            point: { x: origin[0], y: origin[1], z: currZoom },
            delta: { x: dx, y: dy },
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            ctrlKey: event.metaKey || event.ctrlKey,
            metaKey: event.metaKey,
            accelKey: isAccelKey(event)
          });
          break;
        }
        case "panning": {
          editor.dispatch({
            type: "pinch",
            name: "pinch",
            point: { x: origin[0], y: origin[1], z: initZoom },
            delta: { x: dx, y: dy },
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            ctrlKey: event.metaKey || event.ctrlKey,
            metaKey: event.metaKey,
            accelKey: isAccelKey(event)
          });
          break;
        }
      }
    };
    const onPinchEnd = (gesture) => {
      const elm = ref.current;
      const { event, origin, offset: offset2 } = gesture;
      if (event instanceof WheelEvent) return;
      if (!(event.target === elm || elm?.contains(event.target))) return;
      const scale = offset2[0] ** editor.getCameraOptions().zoomSpeed;
      pinchState = "not sure";
      editor.timers.requestAnimationFrame(() => {
        editor.dispatch({
          type: "pinch",
          name: "pinch_end",
          point: { x: origin[0], y: origin[1], z: scale },
          delta: { x: origin[0], y: origin[1] },
          shiftKey: event.shiftKey,
          altKey: event.altKey,
          ctrlKey: event.metaKey || event.ctrlKey,
          metaKey: event.metaKey,
          accelKey: isAccelKey(event)
        });
      });
    };
    return {
      onWheel,
      onPinchStart,
      onPinchEnd,
      onPinch
    };
  }, [editor, ref]);
  useGesture(events, {
    target: ref,
    eventOptions: { passive: false },
    pinch: {
      from: () => {
        const { zoomSpeed } = editor.getCameraOptions();
        const level = editor.getZoomLevel() ** (1 / zoomSpeed);
        return [level, 0];
      },
      // Return the camera z to use when pinch starts
      scaleBounds: () => {
        const baseZoom = editor.getBaseZoom();
        const { zoomSteps, zoomSpeed } = editor.getCameraOptions();
        const zoomMin = zoomSteps[0] * baseZoom;
        const zoomMax = zoomSteps[zoomSteps.length - 1] * baseZoom;
        return {
          max: zoomMax ** (1 / zoomSpeed),
          min: zoomMin ** (1 / zoomSpeed)
        };
      }
    }
  });
}
function getHandle(editor, id, handleId) {
  const shape = editor.getShape(id);
  const handles = editor.getShapeHandles(shape);
  return { shape, handle: handles.find((h2) => h2.id === handleId) };
}
function useHandleEvents(id, handleId) {
  const editor = useEditor();
  return reactExports.useMemo(() => {
    const onPointerDown = (e) => {
      if (editor.wasEventAlreadyHandled(e)) return;
      const target = loopToHtmlElement(e.currentTarget);
      setPointerCapture(target, e);
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle) return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_down",
        ...getPointerInfo(editor, e)
      });
    };
    let lastX, lastY;
    const onPointerMove = (e) => {
      if (editor.wasEventAlreadyHandled(e)) return;
      if (e.clientX === lastX && e.clientY === lastY) return;
      lastX = e.clientX;
      lastY = e.clientY;
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle) return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_move",
        ...getPointerInfo(editor, e)
      });
    };
    const onPointerUp = (e) => {
      if (editor.wasEventAlreadyHandled(e)) return;
      const target = loopToHtmlElement(e.currentTarget);
      releasePointerCapture(target, e);
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle) return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_up",
        ...getPointerInfo(editor, e)
      });
    };
    return {
      onPointerDown,
      onPointerMove,
      onPointerUp
    };
  }, [editor, id, handleId]);
}
function useScreenBounds(ref) {
  const editor = useEditor();
  reactExports.useLayoutEffect(() => {
    const updateBounds = throttle(
      () => {
        if (!ref.current) return;
        editor.updateViewportScreenBounds(ref.current);
      },
      200,
      {
        trailing: true
      }
    );
    const interval = editor.timers.setInterval(updateBounds, 1e3);
    window.addEventListener("resize", updateBounds);
    const resizeObserver = new ResizeObserver((entries) => {
      if (!entries[0].contentRect) return;
      updateBounds();
    });
    const container = ref.current;
    let scrollingParent = null;
    if (container) {
      resizeObserver.observe(container);
      scrollingParent = getNearestScrollableContainer(container);
      scrollingParent.addEventListener("scroll", updateBounds);
    }
    return () => {
      clearInterval(interval);
      window.removeEventListener("resize", updateBounds);
      resizeObserver.disconnect();
      scrollingParent?.removeEventListener("scroll", updateBounds);
      updateBounds.cancel();
    };
  }, [editor, ref]);
}
const getNearestScrollableContainer = (element) => {
  let parent = element.parentElement;
  while (parent) {
    if (parent === document.body) {
      return document;
    }
    const { overflowY } = window.getComputedStyle(parent);
    const hasScrollableContent = parent.scrollHeight > parent.clientHeight;
    if (hasScrollableContent && (overflowY === "auto" || overflowY === "scroll" || overflowY === "overlay")) {
      return parent;
    }
    parent = parent.parentElement;
  }
  return document;
};
function useTick$1(isEnabled = true) {
  const [_, setTick] = reactExports.useState(0);
  const editor = useEditor();
  reactExports.useEffect(() => {
    if (!isEnabled) return;
    const update = () => setTick((tick2) => tick2 + 1);
    editor.on("tick", update);
    return () => {
      editor.off("tick", update);
    };
  }, [editor, isEnabled]);
}
const GeometryDebuggingView = track(function GeometryDebuggingView2({
  showStroke = true,
  showVertices = true,
  showClosestPointOnOutline = true
}) {
  const editor = useEditor();
  useTick$1(showClosestPointOnOutline);
  const zoomLevel = editor.getZoomLevel();
  const renderingShapes = editor.getRenderingShapes();
  const {
    inputs: { currentPagePoint }
  } = editor;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      style: {
        position: "absolute",
        pointerEvents: "none",
        zIndex: 999999999,
        top: 0,
        left: 0,
        overflow: "visible"
      },
      children: renderingShapes.map((result) => {
        const shape = editor.getShape(result.id);
        if (shape.type === "group") return null;
        const geometry = editor.getShapeGeometry(shape);
        const pageTransform = editor.getShapePageTransform(shape);
        const pointInShapeSpace = editor.getPointInShapeSpace(shape, currentPagePoint);
        const nearestPointOnShape = geometry.nearestPoint(pointInShapeSpace);
        const distanceToPoint = geometry.distanceToPoint(pointInShapeSpace, true);
        const dist = Math.abs(distanceToPoint) * zoomLevel;
        const hitInside = distanceToPoint < 0;
        const { vertices } = geometry;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "g",
          {
            transform: pageTransform.toCssString(),
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              showStroke && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  stroke: geometry.debugColor ?? "red",
                  opacity: "1",
                  strokeWidth: 2 / zoomLevel,
                  fill: "none",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(GeometryStroke, { geometry })
                }
              ),
              showVertices && vertices.map((v, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  cx: v.x,
                  cy: v.y,
                  r: 2 / zoomLevel,
                  fill: `hsl(${modulate(i, [0, vertices.length - 1], [120, 200])}, 100%, 50%)`,
                  stroke: "black",
                  strokeWidth: 1 / zoomLevel
                },
                `v${i}`
              )),
              showClosestPointOnOutline && dist < 150 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: nearestPointOnShape.x,
                  y1: nearestPointOnShape.y,
                  x2: pointInShapeSpace.x,
                  y2: pointInShapeSpace.y,
                  opacity: 1 - dist / 150,
                  stroke: hitInside ? "goldenrod" : "dodgerblue",
                  strokeWidth: 2 / zoomLevel
                }
              )
            ]
          },
          result.id + "_outline"
        );
      })
    }
  );
});
function GeometryStroke({ geometry }) {
  if (geometry instanceof Group2d) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { stroke: geometry.debugColor, children: [...geometry.children, ...geometry.ignoredChildren].map((child, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(GeometryStroke, { geometry: child }, i)) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: geometry.toSimpleSvgPath(), stroke: geometry.debugColor });
}
function uniq(array2) {
  return _uniq(array2);
}
function usePeerIds() {
  const editor = useEditor();
  const $userIds = useComputed(
    "userIds",
    () => uniq(editor.getCollaborators().map((p) => p.userId)).sort(),
    { isEqual: (a, b) => a.join(",") === b.join?.(",") },
    [editor]
  );
  return useValue($userIds);
}
function usePresence$1(userId) {
  const editor = useEditor();
  const latestPresence = useValue(
    `latestPresence:${userId}`,
    () => {
      return editor.getCollaborators().find((c) => c.userId === userId);
    },
    [editor, userId]
  );
  return latestPresence ?? null;
}
const LiveCollaborators = track(function Collaborators() {
  const peerIds = usePeerIds();
  return peerIds.map((id) => /* @__PURE__ */ jsxRuntimeExports.jsx(CollaboratorGuard, { collaboratorId: id }, id));
});
const CollaboratorGuard = track(function CollaboratorGuard2({
  collaboratorId
}) {
  const editor = useEditor();
  const presence = usePresence$1(collaboratorId);
  const collaboratorState = useCollaboratorState(editor, presence);
  if (!(presence && presence.currentPageId === editor.getCurrentPageId())) {
    return null;
  }
  switch (collaboratorState) {
    case "inactive": {
      const { followingUserId, highlightedUserIds } = editor.getInstanceState();
      if (!(followingUserId === presence.userId || highlightedUserIds.includes(presence.userId))) {
        return null;
      }
      break;
    }
    case "idle": {
      const { highlightedUserIds } = editor.getInstanceState();
      if (presence.followingUserId === editor.user.getId() && !(presence.chatMessage || highlightedUserIds.includes(presence.userId))) {
        return null;
      }
      break;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collaborator, { latestPresence: presence });
});
const Collaborator = track(function Collaborator2({
  latestPresence
}) {
  const editor = useEditor();
  const {
    CollaboratorBrush,
    CollaboratorScribble,
    CollaboratorCursor,
    CollaboratorHint,
    CollaboratorShapeIndicator
  } = useEditorComponents();
  const zoomLevel = editor.getZoomLevel();
  const viewportPageBounds = editor.getViewportPageBounds();
  const { userId, chatMessage, brush, scribbles, selectedShapeIds, userName, cursor, color } = latestPresence;
  if (!cursor) return null;
  const isCursorInViewport = !(cursor.x < viewportPageBounds.minX - 12 / zoomLevel || cursor.y < viewportPageBounds.minY - 16 / zoomLevel || cursor.x > viewportPageBounds.maxX - 12 / zoomLevel || cursor.y > viewportPageBounds.maxY - 16 / zoomLevel);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    brush && CollaboratorBrush ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollaboratorBrush,
      {
        className: "tl-collaborator__brush",
        userId,
        brush,
        color,
        opacity: 0.1
      },
      userId + "_brush"
    ) : null,
    isCursorInViewport && CollaboratorCursor ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollaboratorCursor,
      {
        className: "tl-collaborator__cursor",
        userId,
        point: cursor,
        color,
        zoom: zoomLevel,
        name: userName !== "New User" ? userName : null,
        chatMessage: chatMessage ?? ""
      },
      userId + "_cursor"
    ) : CollaboratorHint ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollaboratorHint,
      {
        className: "tl-collaborator__cursor-hint",
        userId,
        point: cursor,
        color,
        zoom: zoomLevel,
        viewport: viewportPageBounds
      },
      userId + "_cursor_hint"
    ) : null,
    CollaboratorScribble && scribbles.length ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: scribbles.map((scribble) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollaboratorScribble,
      {
        className: "tl-collaborator__scribble",
        userId,
        scribble,
        color,
        zoom: zoomLevel,
        opacity: scribble.color === "laser" ? 0.5 : 0.1
      },
      userId + "_scribble_" + scribble.id
    )) }) : null,
    CollaboratorShapeIndicator && selectedShapeIds.filter((id) => !editor.isShapeHidden(id)).map((shapeId) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollaboratorShapeIndicator,
      {
        className: "tl-collaborator__shape-indicator",
        userId,
        shapeId,
        color,
        opacity: 0.5
      },
      userId + "_" + shapeId
    ))
  ] });
});
function getStateFromElapsedTime(editor, elapsed) {
  return elapsed > editor.options.collaboratorInactiveTimeoutMs ? "inactive" : elapsed > editor.options.collaboratorIdleTimeoutMs ? "idle" : "active";
}
function useCollaboratorState(editor, latestPresence) {
  const rLastActivityTimestamp = reactExports.useRef(latestPresence?.lastActivityTimestamp ?? -1);
  const [state, setState] = reactExports.useState(
    () => getStateFromElapsedTime(editor, Date.now() - rLastActivityTimestamp.current)
  );
  reactExports.useEffect(() => {
    const interval = editor.timers.setInterval(() => {
      setState(getStateFromElapsedTime(editor, Date.now() - rLastActivityTimestamp.current));
    }, editor.options.collaboratorCheckIntervalMs);
    return () => clearInterval(interval);
  }, [editor]);
  if (latestPresence) {
    rLastActivityTimestamp.current = latestPresence.lastActivityTimestamp ?? Infinity;
  }
  return state;
}
function MenuClickCapture() {
  const editor = useEditor();
  const isMenuOpen = useValue("is menu open", () => editor.menus.hasAnyOpenMenus(), [editor]);
  const [isPointing, setIsPointing] = reactExports.useState(false);
  const showElement = isMenuOpen || isPointing;
  const canvasEvents = useCanvasEvents();
  const rPointerState = reactExports.useRef({
    isDown: false,
    isDragging: false,
    start: new Vec()
  });
  const handlePointerDown = reactExports.useCallback(
    (e) => {
      if (e.button === 0) {
        setIsPointing(true);
        rPointerState.current = {
          isDown: true,
          isDragging: false,
          start: new Vec(e.clientX, e.clientY)
        };
        rDidAPointerDownAndDragWhileMenuWasOpen.current = false;
      }
      editor.menus.clearOpenMenus();
    },
    [editor]
  );
  const rDidAPointerDownAndDragWhileMenuWasOpen = reactExports.useRef(false);
  const handlePointerMove = reactExports.useCallback(
    (e) => {
      if (!rPointerState.current.isDown) return;
      const { x, y } = rPointerState.current.start;
      if (!rDidAPointerDownAndDragWhileMenuWasOpen.current) {
        if (
          // We're pointing, but are we dragging?
          Vec.Dist2(rPointerState.current.start, new Vec(e.clientX, e.clientY)) > editor.options.dragDistanceSquared
        ) {
          rDidAPointerDownAndDragWhileMenuWasOpen.current = true;
          rPointerState.current = {
            ...rPointerState.current,
            isDown: true,
            isDragging: true
          };
          canvasEvents.onPointerDown?.({
            ...e,
            clientX: x,
            clientY: y,
            button: 0
          });
        }
      }
      if (rDidAPointerDownAndDragWhileMenuWasOpen.current) {
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          ...getPointerInfo(editor, e)
        });
      }
    },
    [canvasEvents, editor]
  );
  const handlePointerUp = reactExports.useCallback(
    (e) => {
      canvasEvents.onPointerUp?.(e);
      setIsPointing(false);
      rPointerState.current = {
        isDown: false,
        isDragging: false,
        start: new Vec(e.clientX, e.clientY)
      };
      rDidAPointerDownAndDragWhileMenuWasOpen.current = false;
    },
    [canvasEvents]
  );
  return showElement && /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "tlui-menu-click-capture",
      "data-testid": "menu-click-capture.content",
      ...canvasEvents,
      onPointerDown: handlePointerDown,
      onPointerMove: handlePointerMove,
      onPointerUp: handlePointerUp
    }
  );
}
function DefaultCanvas({ className }) {
  const editor = useEditor();
  const { SelectionBackground, Background, SvgDefs, ShapeIndicators } = useEditorComponents();
  const rCanvas = reactExports.useRef(null);
  const rHtmlLayer = reactExports.useRef(null);
  const rHtmlLayer2 = reactExports.useRef(null);
  const container = useContainer();
  useScreenBounds(rCanvas);
  useDocumentEvents();
  useCoarsePointer();
  useGestureEvents(rCanvas);
  useFixSafariDoubleTapZoomPencilEvents(rCanvas);
  const rMemoizedStuff = reactExports.useRef({ lodDisableTextOutline: false, allowTextOutline: true });
  useQuickReactor(
    "position layers",
    function positionLayersWhenCameraMoves() {
      const { x, y, z } = editor.getCamera();
      if (rMemoizedStuff.current.allowTextOutline && tlenv.isSafari) {
        container.style.setProperty("--tl-text-outline", "none");
        rMemoizedStuff.current.allowTextOutline = false;
      }
      if (rMemoizedStuff.current.allowTextOutline && z < editor.options.textShadowLod !== rMemoizedStuff.current.lodDisableTextOutline) {
        const lodDisableTextOutline = z < editor.options.textShadowLod;
        container.style.setProperty(
          "--tl-text-outline",
          lodDisableTextOutline ? "none" : `var(--tl-text-outline-reference)`
        );
        rMemoizedStuff.current.lodDisableTextOutline = lodDisableTextOutline;
      }
      const offset2 = z >= 1 ? modulate(z, [1, 8], [0.125, 0.5], true) : modulate(z, [0.1, 1], [-2, 0.125], true);
      const transform = `scale(${toDomPrecision(z)}) translate(${toDomPrecision(
        x + offset2
      )}px,${toDomPrecision(y + offset2)}px)`;
      setStyleProperty(rHtmlLayer.current, "transform", transform);
      setStyleProperty(rHtmlLayer2.current, "transform", transform);
    },
    [editor, container]
  );
  const events = useCanvasEvents();
  const shapeSvgDefs = useValue(
    "shapeSvgDefs",
    () => {
      const shapeSvgDefsByKey = /* @__PURE__ */ new Map();
      for (const util of objectMapValues(editor.shapeUtils)) {
        if (!util) return;
        const defs = util.getCanvasSvgDefs();
        for (const { key, component: Component } of defs) {
          if (shapeSvgDefsByKey.has(key)) continue;
          shapeSvgDefsByKey.set(key, /* @__PURE__ */ jsxRuntimeExports.jsx(Component, {}, key));
        }
      }
      return [...shapeSvgDefsByKey.values()];
    },
    [editor]
  );
  const hideShapes = useValue("debug_shapes", () => debugFlags.hideShapes.get(), [debugFlags]);
  const debugSvg = useValue("debug_svg", () => debugFlags.debugSvg.get(), [debugFlags]);
  const debugGeometry = useValue("debug_geometry", () => debugFlags.debugGeometry.get(), [
    debugFlags
  ]);
  const isEditingAnything = useValue(
    "isEditingAnything",
    () => editor.getEditingShapeId() !== null,
    [editor]
  );
  const isSelectingAnything = useValue(
    "isSelectingAnything",
    () => !!editor.getSelectedShapeIds().length,
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: rCanvas,
        draggable: false,
        "data-iseditinganything": isEditingAnything,
        "data-isselectinganything": isSelectingAnything,
        className: classNames("tl-canvas", className),
        "data-testid": "canvas",
        ...events,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "tl-svg-context", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
            shapeSvgDefs,
            /* @__PURE__ */ jsxRuntimeExports.jsx(CursorDef, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CollaboratorHintDef, {}),
            SvgDefs && /* @__PURE__ */ jsxRuntimeExports.jsx(SvgDefs, {})
          ] }) }),
          Background && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-background__wrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Background, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(GridWrapper, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: rHtmlLayer, className: "tl-html-layer tl-shapes", draggable: false, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(OnTheCanvasWrapper, {}),
            SelectionBackground && /* @__PURE__ */ jsxRuntimeExports.jsx(SelectionBackgroundWrapper, {}),
            hideShapes ? null : debugSvg ? /* @__PURE__ */ jsxRuntimeExports.jsx(ShapesWithSVGs, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ShapesToDisplay, {})
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-overlays", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: rHtmlLayer2, className: "tl-html-layer", children: [
            debugGeometry ? /* @__PURE__ */ jsxRuntimeExports.jsx(GeometryDebuggingView, {}) : null,
            /* @__PURE__ */ jsxRuntimeExports.jsx(BrushWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ScribbleWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomBrushWrapper, {}),
            ShapeIndicators && /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeIndicators, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(HintedShapeIndicator, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SnapIndicatorWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectionForegroundWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(HandlesWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(OverlaysWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(LiveCollaborators, {})
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MovingCameraHitTestBlocker, {})
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "tl-canvas__in-front",
        onPointerDown: editor.markEventAsHandled,
        onPointerUp: editor.markEventAsHandled,
        onTouchStart: editor.markEventAsHandled,
        onTouchEnd: editor.markEventAsHandled,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(InFrontOfTheCanvasWrapper, {})
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MenuClickCapture, {})
  ] });
}
function InFrontOfTheCanvasWrapper() {
  const { InFrontOfTheCanvas } = useEditorComponents();
  if (!InFrontOfTheCanvas) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InFrontOfTheCanvas, {});
}
function GridWrapper() {
  const editor = useEditor();
  const gridSize = useValue("gridSize", () => editor.getDocumentSettings().gridSize, [editor]);
  const { x, y, z } = useValue("camera", () => editor.getCamera(), [editor]);
  const isGridMode = useValue("isGridMode", () => editor.getInstanceState().isGridMode, [editor]);
  const { Grid } = useEditorComponents();
  if (!(Grid && isGridMode)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { x, y, z, size: gridSize });
}
function ScribbleWrapper() {
  const editor = useEditor();
  const scribbles = useValue("scribbles", () => editor.getInstanceState().scribbles, [editor]);
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const { Scribble } = useEditorComponents();
  if (!(Scribble && scribbles.length)) return null;
  return scribbles.map((scribble) => /* @__PURE__ */ jsxRuntimeExports.jsx(Scribble, { className: "tl-user-scribble", scribble, zoom: zoomLevel }, scribble.id));
}
function BrushWrapper() {
  const editor = useEditor();
  const brush = useValue("brush", () => editor.getInstanceState().brush, [editor]);
  const { Brush } = useEditorComponents();
  if (!(Brush && brush)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Brush, { className: "tl-user-brush", brush });
}
function ZoomBrushWrapper() {
  const editor = useEditor();
  const zoomBrush = useValue("zoomBrush", () => editor.getInstanceState().zoomBrush, [editor]);
  const { ZoomBrush } = useEditorComponents();
  if (!(ZoomBrush && zoomBrush)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomBrush, { className: "tl-user-brush tl-zoom-brush", brush: zoomBrush });
}
function SnapIndicatorWrapper() {
  const editor = useEditor();
  const lines = useValue("snapLines", () => editor.snaps.getIndicators(), [editor]);
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const { SnapIndicator } = useEditorComponents();
  if (!(SnapIndicator && lines.length > 0)) return null;
  return lines.map((line) => /* @__PURE__ */ jsxRuntimeExports.jsx(SnapIndicator, { className: "tl-user-snapline", line, zoom: zoomLevel }, line.id));
}
function HandlesWrapper() {
  const editor = useEditor();
  const shapeIdWithHandles = useValue(
    "handles shapeIdWithHandles",
    () => {
      const { isReadonly, isChangingStyle } = editor.getInstanceState();
      if (isReadonly || isChangingStyle) return false;
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      const handles = editor.getShapeHandles(onlySelectedShape);
      if (!handles) return false;
      return onlySelectedShape.id;
    },
    [editor]
  );
  if (!shapeIdWithHandles) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(HandlesWrapperInner, { shapeId: shapeIdWithHandles });
}
function HandlesWrapperInner({ shapeId }) {
  const editor = useEditor();
  const { Handles } = useEditorComponents();
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const isCoarse = useValue("coarse pointer", () => editor.getInstanceState().isCoarsePointer, [
    editor
  ]);
  const transform = useValue("handles transform", () => editor.getShapePageTransform(shapeId), [
    editor,
    shapeId
  ]);
  const handles = useValue(
    "handles",
    () => {
      const handles2 = editor.getShapeHandles(shapeId);
      if (!handles2) return null;
      const minDistBetweenVirtualHandlesAndRegularHandles = (isCoarse ? editor.options.coarseHandleRadius : editor.options.handleRadius) / zoomLevel * 2;
      return handles2.filter(
        (handle) => (
          // if the handle isn't a virtual handle, we'll display it
          // but for virtual handles, we'll only display them if they're far enough away from vertex handles
          handle.type !== "virtual" || !handles2.some(
            (h2) => (
              // skip the handle we're checking against
              // and check that their distance isn't below the minimum distance
              h2 !== handle && // only check against vertex handles
              h2.type === "vertex" && Vec.Dist(handle, h2) < minDistBetweenVirtualHandlesAndRegularHandles
            )
          )
        )
      ).sort((a) => a.type === "vertex" ? 1 : -1);
    },
    [editor, zoomLevel, isCoarse, shapeId]
  );
  const isHidden2 = useValue("isHidden", () => editor.isShapeHidden(shapeId), [editor, shapeId]);
  if (!Handles || !handles || !transform || isHidden2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Handles, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: Mat.toCssString(transform), children: handles.map((handle) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      HandleWrapper,
      {
        shapeId,
        handle,
        zoom: zoomLevel,
        isCoarse
      },
      handle.id
    );
  }) }) });
}
function HandleWrapper({
  shapeId,
  handle,
  zoom,
  isCoarse
}) {
  const events = useHandleEvents(shapeId, handle.id);
  const { Handle } = useEditorComponents();
  if (!Handle) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "g",
    {
      role: "button",
      "aria-label": handle.label || "handle",
      transform: `translate(${handle.x}, ${handle.y})`,
      ...events,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Handle, { shapeId, handle, zoom, isCoarse })
    }
  );
}
function OverlaysWrapper() {
  const { Overlays } = useEditorComponents();
  if (!Overlays) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-custom-overlays tl-overlays__item", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Overlays, {}) });
}
function ShapesWithSVGs() {
  const editor = useEditor();
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  return renderingShapes.map((result) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Shape, { ...result }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugSvgCopy, { id: result.id, mode: "iframe" })
  ] }, result.id + "_fragment"));
}
function ReflowIfNeeded() {
  const editor = useEditor();
  const culledShapesRef = reactExports.useRef(/* @__PURE__ */ new Set());
  useQuickReactor(
    "reflow for culled shapes",
    () => {
      const culledShapes = editor.getCulledShapes();
      if (culledShapesRef.current.size === culledShapes.size && [...culledShapes].every((id) => culledShapesRef.current.has(id)))
        return;
      culledShapesRef.current = culledShapes;
      const canvas = document.getElementsByClassName("tl-canvas");
      if (canvas.length === 0) return;
      canvas[0].offsetHeight;
    },
    [editor]
  );
  return null;
}
function ShapesToDisplay() {
  const editor = useEditor();
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    renderingShapes.map((result) => /* @__PURE__ */ jsxRuntimeExports.jsx(Shape, { ...result }, result.id + "_shape")),
    tlenv.isSafari && /* @__PURE__ */ jsxRuntimeExports.jsx(ReflowIfNeeded, {})
  ] });
}
function HintedShapeIndicator() {
  const editor = useEditor();
  const { ShapeIndicator } = useEditorComponents();
  const ids = useValue("hinting shape ids", () => dedupe(editor.getHintingShapeIds()), [editor]);
  if (!ids.length) return null;
  if (!ShapeIndicator) return null;
  return ids.map((id) => /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeIndicator, { className: "tl-user-indicator__hint", shapeId: id }, id + "_hinting"));
}
function CursorDef() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: useSharedSafeId("cursor"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "rgba(0,0,0,.2)", transform: "translate(-11,-11)", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "white", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "currentColor", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
    ] })
  ] });
}
function CollaboratorHintDef() {
  const cursorHintId = useSharedSafeId("cursor_hint");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: cursorHintId, fill: "currentColor", d: "M -2,-5 2,0 -2,5 Z" });
}
function DebugSvgCopy({ id, mode }) {
  const editor = useEditor();
  const [image, setImage] = reactExports.useState(null);
  const isInRoot = useValue(
    "is in root",
    () => {
      const shape = editor.getShape(id);
      return shape?.parentId === editor.getCurrentPageId();
    },
    [editor, id]
  );
  reactExports.useEffect(() => {
    if (!isInRoot) return;
    let latest = null;
    const unsubscribe = react("shape to svg", async () => {
      const renderId = Math.random();
      latest = renderId;
      const isSingleFrame = editor.isShapeOfType(id, "frame");
      const padding = isSingleFrame ? 0 : 10;
      let bounds = editor.getShapePageBounds(id);
      if (!bounds) return;
      bounds = bounds.clone().expandBy(padding);
      const result = await editor.getSvgString([id], { padding });
      if (latest !== renderId || !result) return;
      const svgDataUrl = `data:image/svg+xml;utf8,${encodeURIComponent(result.svg)}`;
      setImage({ src: svgDataUrl, bounds });
    });
    return () => {
      latest = null;
      unsubscribe();
    };
  }, [editor, id, isInRoot]);
  if (!isInRoot || !image) return null;
  if (mode === "iframe") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "iframe",
      {
        src: image.src,
        width: image.bounds.width,
        height: image.bounds.height,
        referrerPolicy: "no-referrer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          border: "none",
          transform: `translate(${image.bounds.x}px, ${image.bounds.maxY + 12}px)`,
          outline: "1px solid black",
          maxWidth: "none"
        }
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: image.src,
      width: image.bounds.width,
      height: image.bounds.height,
      referrerPolicy: "no-referrer",
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        transform: `translate(${image.bounds.x}px, ${image.bounds.maxY + 12}px)`,
        outline: "1px solid black",
        maxWidth: "none"
      }
    }
  );
}
function SelectionForegroundWrapper() {
  const editor = useEditor();
  const selectionRotation = useValue(
    "selection rotation",
    function getSelectionRotation() {
      return editor.getSelectionRotation();
    },
    [editor]
  );
  const selectionBounds = useValue(
    "selection bounds",
    () => editor.getSelectionRotatedPageBounds(),
    [editor]
  );
  const { SelectionForeground } = useEditorComponents();
  if (!selectionBounds || !SelectionForeground) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectionForeground, { bounds: selectionBounds, rotation: selectionRotation });
}
function SelectionBackgroundWrapper() {
  const editor = useEditor();
  const selectionRotation = useValue("selection rotation", () => editor.getSelectionRotation(), [
    editor
  ]);
  const selectionBounds = useValue(
    "selection bounds",
    () => editor.getSelectionRotatedPageBounds(),
    [editor]
  );
  const { SelectionBackground } = useEditorComponents();
  if (!selectionBounds || !SelectionBackground) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectionBackground, { bounds: selectionBounds, rotation: selectionRotation });
}
function OnTheCanvasWrapper() {
  const { OnTheCanvas } = useEditorComponents();
  if (!OnTheCanvas) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(OnTheCanvas, {});
}
function MovingCameraHitTestBlocker() {
  const editor = useEditor();
  const cameraState = useValue("camera state", () => editor.getCameraState(), [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classNames("tl-hit-test-blocker", {
        "tl-hit-test-blocker__hidden": cameraState === "idle"
      })
    }
  );
}
function HTMLContainer({ children, className = "", ...rest }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...rest, className: classNames("tl-html-container", className), children });
}
class BindingUtil {
  constructor(editor) {
    this.editor = editor;
  }
  static props;
  static migrations;
  /**
   * The type of the binding util, which should match the binding's type.
   *
   * @public
   */
  static type;
}
function resizeBox(shape, info, opts = {}) {
  const { newPoint, handle, scaleX, scaleY } = info;
  const { minWidth = 1, maxWidth = Infinity, minHeight = 1, maxHeight = Infinity } = opts;
  let w = shape.props.w * scaleX;
  let h2 = shape.props.h * scaleY;
  const offset2 = new Vec(0, 0);
  if (w > 0) {
    if (w < minWidth) {
      switch (handle) {
        case "top_left":
        case "left":
        case "bottom_left": {
          offset2.x = w - minWidth;
          break;
        }
        case "top":
        case "bottom": {
          offset2.x = (w - minWidth) / 2;
          break;
        }
        default: {
          offset2.x = 0;
        }
      }
      w = minWidth;
    }
  } else {
    offset2.x = w;
    w = -w;
    if (w < minWidth) {
      switch (handle) {
        case "top_left":
        case "left":
        case "bottom_left": {
          offset2.x = -w;
          break;
        }
        default: {
          offset2.x = -minWidth;
        }
      }
      w = minWidth;
    }
  }
  if (h2 > 0) {
    if (h2 < minHeight) {
      switch (handle) {
        case "top_left":
        case "top":
        case "top_right": {
          offset2.y = h2 - minHeight;
          break;
        }
        case "right":
        case "left": {
          offset2.y = (h2 - minHeight) / 2;
          break;
        }
        default: {
          offset2.y = 0;
        }
      }
      h2 = minHeight;
    }
  } else {
    offset2.y = h2;
    h2 = -h2;
    if (h2 < minHeight) {
      switch (handle) {
        case "top_left":
        case "top":
        case "top_right": {
          offset2.y = -h2;
          break;
        }
        default: {
          offset2.y = -minHeight;
        }
      }
      h2 = minHeight;
    }
  }
  const { x, y } = offset2.rot(shape.rotation).add(newPoint);
  return {
    ...shape,
    x,
    y,
    props: {
      w: Math.min(maxWidth, w),
      h: Math.min(maxHeight, h2)
    }
  };
}
class BaseBoxShapeUtil extends ShapeUtil {
  getGeometry(shape) {
    return new Rectangle2d({
      width: shape.props.w,
      height: shape.props.h,
      isFilled: true
    });
  }
  onResize(shape, info) {
    return resizeBox(shape, info);
  }
  getHandleSnapGeometry(shape) {
    return {
      points: this.getGeometry(shape).bounds.cornersAndCenter
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...endShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
}
function resizeScaled(shape, { initialBounds, scaleX, scaleY, newPoint, handle }) {
  let scaleDelta;
  switch (handle) {
    case "bottom_left":
    case "bottom_right":
    case "top_left":
    case "top_right": {
      scaleDelta = Math.max(0.01, Math.max(Math.abs(scaleX), Math.abs(scaleY)));
      break;
    }
    case "left":
    case "right": {
      scaleDelta = Math.max(0.01, Math.abs(scaleX));
      break;
    }
    case "bottom":
    case "top": {
      scaleDelta = Math.max(0.01, Math.abs(scaleY));
      break;
    }
    default: {
      throw exhaustiveSwitchError(handle);
    }
  }
  const offset2 = new Vec(0, 0);
  if (scaleX < 0) {
    offset2.x = -(initialBounds.width * scaleDelta);
  }
  if (scaleY < 0) {
    offset2.y = -(initialBounds.height * scaleDelta);
  }
  const { x, y } = Vec.Add(newPoint, offset2.rot(shape.rotation));
  return {
    x,
    y,
    props: {
      scale: scaleDelta * shape.props.scale
    }
  };
}
let Idle$c = class Idle extends StateNode {
  static id = "idle";
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
let Pointing$8 = class Pointing extends StateNode {
  static id = "pointing";
  onPointerMove(info) {
    const { editor } = this;
    if (editor.inputs.isDragging) {
      const { originPagePoint } = editor.inputs;
      const shapeType = this.parent.shapeType;
      const id = createShapeId();
      const creatingMarkId = editor.markHistoryStoppingPoint(`creating_box:${id}`);
      const newPoint = maybeSnapToGrid(originPagePoint, editor);
      this.editor.createShapes([
        {
          id,
          type: shapeType,
          x: newPoint.x,
          y: newPoint.y,
          props: {
            w: 1,
            h: 1
          }
        }
      ]);
      const shape = editor.getShape(id);
      if (!shape) {
        this.cancel();
        return;
      }
      editor.select(id);
      const parent = this.parent;
      this.editor.setCurrentTool(
        "select.resizing",
        {
          ...info,
          target: "selection",
          handle: "bottom_right",
          isCreating: true,
          creatingMarkId,
          creationCursorOffset: { x: 1, y: 1 },
          onInteractionEnd: this.parent.id,
          onCreate: parent.onCreate ? (shape2) => parent.onCreate?.(shape2) : void 0
        }
        /** satisfies ResizingInfo, defined in main tldraw package  */
      );
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { originPagePoint } = this.editor.inputs;
    const shapeType = this.parent.shapeType;
    const id = createShapeId();
    this.editor.markHistoryStoppingPoint(`creating_box:${id}`);
    this.editor.createShapes([
      {
        id,
        type: shapeType,
        x: originPagePoint.x,
        y: originPagePoint.y
      }
    ]);
    const shape = this.editor.getShape(id);
    if (!shape) {
      this.cancel();
      return;
    }
    let { w, h: h2 } = shape.props;
    const delta = new Vec(w / 2, h2 / 2);
    const parentTransform = this.editor.getShapeParentTransform(shape);
    if (parentTransform) delta.rot(-parentTransform.rotation());
    let scale = 1;
    if (this.editor.user.getIsDynamicResizeMode()) {
      scale = 1 / this.editor.getZoomLevel();
      w *= scale;
      h2 *= scale;
      delta.mul(scale);
    }
    const next = structuredClone(shape);
    const newPoint = maybeSnapToGrid(new Vec(shape.x - delta.x, shape.y - delta.y), this.editor);
    next.x = newPoint.x;
    next.y = newPoint.y;
    next.props.w = w;
    next.props.h = h2;
    if ("scale" in shape.props) {
      next.props.scale = scale;
    }
    this.editor.updateShape(next);
    this.editor.setSelectedShapes([id]);
    if (this.editor.getInstanceState().isToolLocked) {
      this.parent.transition("idle");
    } else {
      this.editor.setCurrentTool("select.idle");
    }
  }
  cancel() {
    this.parent.transition("idle");
  }
};
function maybeSnapToGrid(point, editor) {
  const isGridMode = editor.getInstanceState().isGridMode;
  const gridSize = editor.getDocumentSettings().gridSize;
  if (isGridMode) return point.clone().snapToGrid(gridSize);
  return point.clone();
}
class BaseBoxShapeTool extends StateNode {
  static id = "box";
  static initial = "idle";
  static children() {
    return [Idle$c, Pointing$8];
  }
}
function useGlobalMenuIsOpen(id, onChange, onEvent) {
  const rIsOpen = reactExports.useRef(false);
  const onOpenChange = reactExports.useCallback(
    (isOpen2) => {
      rIsOpen.current = isOpen2;
      if (isOpen2) {
        tlmenus.addOpenMenu(id);
      } else {
        tlmenus.deleteOpenMenu(id);
      }
      onChange?.(isOpen2);
    },
    [id, onChange]
  );
  const isOpen = useValue("is menu open", () => tlmenus.getOpenMenus().includes(id), [id]);
  reactExports.useEffect(() => {
    if (rIsOpen.current) {
      onEvent?.("open-menu");
      tlmenus.addOpenMenu(id);
    }
    return () => {
      if (rIsOpen.current) {
        tlmenus.deleteOpenMenu(id);
        tlmenus.getOpenMenus().forEach((menuId) => {
          if (menuId.startsWith(id)) {
            onEvent?.("close-menu");
            tlmenus.deleteOpenMenu(menuId);
          }
        });
        rIsOpen.current = false;
      }
    };
  }, [id, onEvent]);
  return [isOpen, onOpenChange];
}
function useIsEditing(shapeId) {
  const editor = useEditor();
  return useValue("isEditing", () => editor.getEditingShapeId() === shapeId, [editor, shapeId]);
}
function usePassThroughMouseOverEvents(ref) {
  if (!ref) throw Error("usePassThroughWheelEvents must be passed a ref");
  const container = useContainer();
  const editor = useMaybeEditor();
  reactExports.useEffect(() => {
    function onMouseOver(e) {
      if (!editor?.getInstanceState().isFocused) return;
      if (e.isSpecialRedispatchedEvent) return;
      preventDefault(e);
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs) return;
      const newEvent = new PointerEvent(e.type, e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    const elm = ref.current;
    if (!elm) return;
    elm.addEventListener("mouseover", onMouseOver, { passive: false });
    return () => {
      elm.removeEventListener("mouseover", onMouseOver);
    };
  }, [container, editor, ref]);
}
function useSelectionEvents(handle) {
  const editor = useEditor();
  const events = reactExports.useMemo(
    function selectionEvents() {
      const onPointerDown = (e) => {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (e.button === RIGHT_MOUSE_BUTTON) {
          editor.dispatch({
            type: "pointer",
            target: "selection",
            handle,
            name: "right_click",
            ...getPointerInfo(editor, e)
          });
          return;
        }
        if (e.button !== 0) return;
        const elm = loopToHtmlElement(e.currentTarget);
        function releaseCapture() {
          elm.removeEventListener("pointerup", releaseCapture);
          releasePointerCapture(elm, e);
        }
        setPointerCapture(elm, e);
        elm.addEventListener("pointerup", releaseCapture);
        editor.dispatch({
          name: "pointer_down",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(editor, e)
        });
        editor.markEventAsHandled(e);
      };
      let lastX, lastY;
      function onPointerMove(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (e.button !== 0) return;
        if (e.clientX === lastX && e.clientY === lastY) return;
        lastX = e.clientX;
        lastY = e.clientY;
        editor.dispatch({
          name: "pointer_move",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(editor, e)
        });
      }
      const onPointerUp = (e) => {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (e.button !== 0) return;
        editor.dispatch({
          name: "pointer_up",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(editor, e)
        });
      };
      return {
        onPointerDown,
        onPointerMove,
        onPointerUp
      };
    },
    [editor, handle]
  );
  return events;
}
function useTLStore(opts) {
  const [current, setCurrent] = reactExports.useState(() => ({ store: createTLStore(opts), opts }));
  if (!areObjectsShallowEqual(current.opts, opts)) {
    const next = { store: createTLStore(opts), opts };
    setCurrent(next);
    return next.store;
  }
  return current.store;
}
const SPACING = 20;
const MIN_COUNT = 8;
function getVerticesCountForArcLength(length, spacing = SPACING) {
  return Math.max(MIN_COUNT, Math.ceil(length / spacing));
}
class Arc2d extends Geometry2d {
  _center;
  _radius;
  _start;
  _end;
  _largeArcFlag;
  _sweepFlag;
  _measure;
  _angleStart;
  _angleEnd;
  constructor(config) {
    super({ ...config, isFilled: false, isClosed: false });
    const { center, sweepFlag, largeArcFlag, start, end } = config;
    if (start.equals(end)) throw Error(`Arc must have different start and end points.`);
    this._angleStart = Vec.Angle(center, start);
    this._angleEnd = Vec.Angle(center, end);
    this._radius = Vec.Dist(center, start);
    this._measure = getArcMeasure(this._angleStart, this._angleEnd, sweepFlag, largeArcFlag);
    this._start = start;
    this._end = end;
    this._sweepFlag = sweepFlag;
    this._largeArcFlag = largeArcFlag;
    this._center = center;
  }
  nearestPoint(point) {
    const {
      _center,
      _measure: measure,
      _radius: radius,
      _angleEnd: angleEnd,
      _angleStart: angleStart,
      _start: A,
      _end: B
    } = this;
    const t2 = getPointInArcT(measure, angleStart, angleEnd, _center.angle(point));
    if (t2 <= 0) return A;
    if (t2 >= 1) return B;
    const P = Vec.Sub(point, _center).uni().mul(radius).add(_center);
    let nearest;
    let dist = Infinity;
    let d;
    for (const p of [A, B, P]) {
      d = Vec.Dist2(point, p);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    const {
      _center,
      _radius: radius,
      _measure: measure,
      _angleStart: angleStart,
      _angleEnd: angleEnd
    } = this;
    const intersection = intersectLineSegmentCircle(A, B, _center, radius);
    if (intersection === null) return false;
    return intersection.some((p) => {
      const result = getPointInArcT(measure, angleStart, angleEnd, _center.angle(p));
      return result >= 0 && result <= 1;
    });
  }
  getVertices() {
    const { _center, _measure: measure, length, _radius: radius, _angleStart: angleStart } = this;
    const vertices = [];
    for (let i = 0, n = getVerticesCountForArcLength(Math.abs(length)); i < n + 1; i++) {
      const t2 = i / n * measure;
      const angle = angleStart + t2;
      vertices.push(getPointOnCircle(_center, radius, angle));
    }
    return vertices;
  }
  getSvgPathData(first2 = true) {
    const {
      _start: start,
      _end: end,
      _radius: radius,
      _largeArcFlag: largeArcFlag,
      _sweepFlag: sweepFlag
    } = this;
    return `${first2 ? `M${start.toFixed()}` : ``} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.toFixed()}`;
  }
  getLength() {
    return Math.abs(this._measure * this._radius);
  }
}
class Circle2d extends Geometry2d {
  constructor(config) {
    super({ isClosed: true, ...config });
    this.config = config;
    const { x = 0, y = 0, radius } = config;
    this._x = x;
    this._y = y;
    this._center = new Vec(radius + x, radius + y);
    this._radius = radius;
  }
  _center;
  _radius;
  _x;
  _y;
  getBounds() {
    return new Box(this._x, this._y, this._radius * 2, this._radius * 2);
  }
  getVertices() {
    const { _center, _radius: radius } = this;
    const perimeter = PI2 * radius;
    const vertices = [];
    for (let i = 0, n = getVerticesCountForArcLength(perimeter); i < n; i++) {
      const angle = i / n * PI2;
      vertices.push(getPointOnCircle(_center, radius, angle));
    }
    return vertices;
  }
  nearestPoint(point) {
    const { _center, _radius: radius } = this;
    if (_center.equals(point)) return Vec.AddXY(_center, radius, 0);
    return Vec.Sub(point, _center).uni().mul(radius).add(_center);
  }
  hitTestLineSegment(A, B, distance = 0) {
    const { _center, _radius: radius } = this;
    return intersectLineSegmentCircle(A, B, _center, radius + distance) !== null;
  }
  getSvgPathData() {
    const { _center, _radius: radius } = this;
    return `M${_center.x + radius},${_center.y} a${radius},${radius} 0 1,0 ${radius * 2},0a${radius},${radius} 0 1,0 -${radius * 2},0`;
  }
}
class CubicBezier2d extends Polyline2d {
  _a;
  _b;
  _c;
  _d;
  _resolution;
  constructor(config) {
    const { start: a, cp1: b, cp2: c, end: d } = config;
    super({ ...config, points: [a, d] });
    this._a = a;
    this._b = b;
    this._c = c;
    this._d = d;
    this._resolution = config.resolution ?? 10;
  }
  getVertices() {
    const vertices = [];
    const { _a: a, _b: b, _c: c, _d: d } = this;
    for (let i = 0, n = this._resolution; i <= n; i++) {
      const t2 = i / n;
      vertices.push(
        new Vec(
          (1 - t2) * (1 - t2) * (1 - t2) * a.x + 3 * ((1 - t2) * (1 - t2)) * t2 * b.x + 3 * (1 - t2) * (t2 * t2) * c.x + t2 * t2 * t2 * d.x,
          (1 - t2) * (1 - t2) * (1 - t2) * a.y + 3 * ((1 - t2) * (1 - t2)) * t2 * b.y + 3 * (1 - t2) * (t2 * t2) * c.y + t2 * t2 * t2 * d.y
        )
      );
    }
    return vertices;
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let d;
    let p;
    for (const edge of this.segments) {
      p = edge.nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  getSvgPathData(first2 = true) {
    const { _a: a, _b: b, _c: c, _d: d } = this;
    return `${first2 ? `M ${a.toFixed()} ` : ``} C${b.toFixed()} ${c.toFixed()} ${d.toFixed()}`;
  }
  static GetAtT(segment, t2) {
    const { _a: a, _b: b, _c: c, _d: d } = segment;
    return new Vec(
      (1 - t2) * (1 - t2) * (1 - t2) * a.x + 3 * ((1 - t2) * (1 - t2)) * t2 * b.x + 3 * (1 - t2) * (t2 * t2) * c.x + t2 * t2 * t2 * d.x,
      (1 - t2) * (1 - t2) * (1 - t2) * a.y + 3 * ((1 - t2) * (1 - t2)) * t2 * b.y + 3 * (1 - t2) * (t2 * t2) * c.y + t2 * t2 * t2 * d.y
    );
  }
  getLength(_filters, precision = 32) {
    let n1, p1 = this._a, length = 0;
    for (let i = 1; i <= precision; i++) {
      n1 = CubicBezier2d.GetAtT(this, i / precision);
      length += Vec.Dist(p1, n1);
      p1 = n1;
    }
    return length;
  }
}
class Ellipse2d extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: true });
    this.config = config;
    const { width, height } = config;
    this._w = width;
    this._h = height;
  }
  _w;
  _h;
  _edges;
  // eslint-disable-next-line no-restricted-syntax
  get edges() {
    if (!this._edges) {
      const { vertices } = this;
      this._edges = [];
      for (let i = 0, n = vertices.length; i < n; i++) {
        const start = vertices[i];
        const end = vertices[(i + 1) % n];
        this._edges.push(new Edge2d({ start, end }));
      }
    }
    return this._edges;
  }
  getVertices() {
    const w = Math.max(1, this._w);
    const h2 = Math.max(1, this._h);
    const cx = w / 2;
    const cy = h2 / 2;
    const q = Math.pow(cx - cy, 2) / Math.pow(cx + cy, 2);
    const p = PI$1 * (cx + cy) * (1 + 3 * q / (10 + Math.sqrt(4 - 3 * q)));
    const len = getVerticesCountForArcLength(p);
    const step = PI2 / len;
    const a = Math.cos(step);
    const b = Math.sin(step);
    let sin = 0;
    let cos = 1;
    let ts2 = 0;
    let tc = 1;
    const vertices = Array(len);
    for (let i = 0; i < len; i++) {
      vertices[i] = new Vec(clamp$3(cx + cx * cos, 0, w), clamp$3(cy + cy * sin, 0, h2));
      ts2 = b * cos + a * sin;
      tc = a * cos - b * sin;
      sin = ts2;
      cos = tc;
    }
    return vertices;
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let d;
    let p;
    for (const edge of this.edges) {
      p = edge.nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    return this.edges.some((edge) => edge.hitTestLineSegment(A, B));
  }
  getBounds() {
    return new Box(0, 0, this._w, this._h);
  }
  getLength() {
    const { _w: w, _h: h2 } = this;
    const cx = w / 2;
    const cy = h2 / 2;
    const rx = Math.max(0, cx);
    const ry = Math.max(0, cy);
    return perimeterOfEllipse(rx, ry);
  }
  getSvgPathData(first2 = false) {
    const { _w: w, _h: h2 } = this;
    const cx = w / 2;
    const cy = h2 / 2;
    const rx = Math.max(0, cx);
    const ry = Math.max(0, cy);
    return `${first2 ? `M${cx - rx},${cy}` : ``} a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`;
  }
}
function kickoutOccludedShapes(editor, shapeIds, opts) {
  const parentsToCheck = /* @__PURE__ */ new Set();
  for (const id of shapeIds) {
    const shape = editor.getShape(id);
    if (!shape) continue;
    parentsToCheck.add(shape);
    const parent = editor.getShape(shape.parentId);
    if (!parent) continue;
    parentsToCheck.add(parent);
  }
  const parentsToLostChildren = /* @__PURE__ */ new Map();
  for (const parent of parentsToCheck) {
    const childIds = editor.getSortedChildIdsForParent(parent);
    if (opts?.filter && !opts.filter(parent)) {
      parentsToLostChildren.set(parent, childIds);
    } else {
      const overlappingChildren = getOverlappingShapes(editor, parent.id, childIds);
      if (overlappingChildren.length < childIds.length) {
        parentsToLostChildren.set(
          parent,
          childIds.filter((id) => !overlappingChildren.includes(id))
        );
      }
    }
  }
  const sortedShapeIds = editor.getCurrentPageShapesSorted().map((s) => s.id);
  const parentsToNewChildren = {};
  for (const [prevParent, lostChildrenIds] of parentsToLostChildren) {
    const lostChildren = compact(lostChildrenIds.map((id) => editor.getShape(id)));
    const { reparenting, remainingShapesToReparent } = getDroppedShapesToNewParents(
      editor,
      lostChildren,
      (shape, maybeNewParent) => {
        if (opts?.filter && !opts.filter(maybeNewParent)) return false;
        return maybeNewParent.id !== prevParent.id && sortedShapeIds.indexOf(maybeNewParent.id) < sortedShapeIds.indexOf(shape.id);
      }
    );
    reparenting.forEach((childrenToReparent, newParentId) => {
      if (childrenToReparent.length === 0) return;
      if (!parentsToNewChildren[newParentId]) {
        parentsToNewChildren[newParentId] = {
          parentId: newParentId,
          shapeIds: []
        };
      }
      parentsToNewChildren[newParentId].shapeIds.push(...childrenToReparent.map((s) => s.id));
    });
    if (remainingShapesToReparent.size > 0) {
      const newParentId = editor.findShapeAncestor(prevParent, (s) => editor.isShapeOfType(s, "group"))?.id ?? editor.getCurrentPageId();
      remainingShapesToReparent.forEach((shape) => {
        if (!parentsToNewChildren[newParentId]) {
          let insertIndexKey;
          const oldParentSiblingIds = editor.getSortedChildIdsForParent(newParentId);
          const oldParentIndex = oldParentSiblingIds.indexOf(prevParent.id);
          if (oldParentIndex > -1) {
            const siblingsIndexAbove = oldParentSiblingIds[oldParentIndex + 1];
            const indexKeyAbove = siblingsIndexAbove ? editor.getShape(siblingsIndexAbove).index : getIndexAbove(prevParent.index);
            insertIndexKey = getIndexBetween(prevParent.index, indexKeyAbove);
          }
          parentsToNewChildren[newParentId] = {
            parentId: newParentId,
            shapeIds: [],
            index: insertIndexKey
          };
        }
        parentsToNewChildren[newParentId].shapeIds.push(shape.id);
      });
    }
  }
  editor.run(() => {
    Object.values(parentsToNewChildren).forEach(({ parentId, shapeIds: shapeIds2, index: index2 }) => {
      if (shapeIds2.length === 0) return;
      shapeIds2.sort((a, b) => sortedShapeIds.indexOf(a) < sortedShapeIds.indexOf(b) ? -1 : 1);
      editor.reparentShapes(shapeIds2, parentId, index2);
    });
  });
}
function getOverlappingShapes(editor, shape, otherShapes) {
  if (otherShapes.length === 0) {
    return EMPTY_ARRAY;
  }
  const parentPageBounds = editor.getShapePageBounds(shape);
  if (!parentPageBounds) return EMPTY_ARRAY;
  const parentGeometry = editor.getShapeGeometry(shape);
  const parentPageTransform = editor.getShapePageTransform(shape);
  const parentPageCorners = parentPageTransform.applyToPoints(parentGeometry.vertices);
  const _shape = editor.getShape(shape);
  if (!_shape) return EMPTY_ARRAY;
  const pageTransform = editor.getShapePageTransform(shape);
  const clipPath = editor.getShapeUtil(_shape.type).getClipPath?.(_shape);
  const parentPageMaskVertices = clipPath ? pageTransform.applyToPoints(clipPath) : void 0;
  const parentPagePolygon = parentPageMaskVertices ? intersectPolygonPolygon(parentPageMaskVertices, parentPageCorners) : parentPageCorners;
  if (!parentPagePolygon) return EMPTY_ARRAY;
  return otherShapes.filter((childId) => {
    const shapePageBounds = editor.getShapePageBounds(childId);
    if (!shapePageBounds || !parentPageBounds.includes(shapePageBounds)) return false;
    const parentPolygonInShapeShape = editor.getShapePageTransform(childId).clone().invert().applyToPoints(parentPagePolygon);
    const geometry = editor.getShapeGeometry(childId);
    return geometry.overlapsPolygon(parentPolygonInShapeShape);
  });
}
function getDroppedShapesToNewParents(editor, shapes, cb) {
  const shapesToActuallyCheck = new Set(shapes);
  const movingGroups = /* @__PURE__ */ new Set();
  for (const shape of shapes) {
    const parent = editor.getShapeParent(shape);
    if (parent && editor.isShapeOfType(parent, "group")) {
      if (!movingGroups.has(parent)) {
        movingGroups.add(parent);
      }
    }
  }
  for (const movingGroup of movingGroups) {
    const children = compact(
      editor.getSortedChildIdsForParent(movingGroup).map((id) => editor.getShape(id))
    );
    for (const child of children) {
      shapesToActuallyCheck.delete(child);
    }
    shapesToActuallyCheck.add(movingGroup);
  }
  const shapeGroupIds = /* @__PURE__ */ new Map();
  const reparenting = /* @__PURE__ */ new Map();
  const remainingShapesToReparent = new Set(shapesToActuallyCheck);
  const potentialParentShapes = editor.getCurrentPageShapesSorted().filter(
    (s) => editor.getShapeUtil(s).canReceiveNewChildrenOfType?.(s, s.type) && !remainingShapesToReparent.has(s)
  );
  parentCheck: for (let i = potentialParentShapes.length - 1; i >= 0; i--) {
    const parentShape = potentialParentShapes[i];
    const parentShapeContainingGroupId = editor.findShapeAncestor(
      parentShape,
      (s) => editor.isShapeOfType(s, "group")
    )?.id;
    const parentGeometry = editor.getShapeGeometry(parentShape);
    const parentPageTransform = editor.getShapePageTransform(parentShape);
    const parentPageMaskVertices = editor.getShapeMask(parentShape);
    const parentPageCorners = parentPageTransform.applyToPoints(parentGeometry.vertices);
    const parentPagePolygon = parentPageMaskVertices ? intersectPolygonPolygon(parentPageMaskVertices, parentPageCorners) : parentPageCorners;
    if (!parentPagePolygon) continue parentCheck;
    const childrenToReparent = [];
    shapeCheck: for (const shape of remainingShapesToReparent) {
      if (parentShape.id === shape.id) continue shapeCheck;
      if (cb && !cb(shape, parentShape)) continue shapeCheck;
      if (!shapeGroupIds.has(shape.id)) {
        shapeGroupIds.set(
          shape.id,
          editor.findShapeAncestor(shape, (s) => editor.isShapeOfType(s, "group"))?.id
        );
      }
      const shapeGroupId = shapeGroupIds.get(shape.id);
      if (shapeGroupId !== parentShapeContainingGroupId) continue shapeCheck;
      if (editor.findShapeAncestor(parentShape, (s) => shape.id === s.id)) continue shapeCheck;
      const parentPolygonInShapeSpace = editor.getShapePageTransform(shape).clone().invert().applyToPoints(parentPagePolygon);
      if (editor.getShapeGeometry(shape).overlapsPolygon(parentPolygonInShapeSpace)) {
        if (!editor.getShapeUtil(parentShape).canReceiveNewChildrenOfType?.(parentShape, shape.type))
          continue shapeCheck;
        if (shape.parentId !== parentShape.id) {
          childrenToReparent.push(shape);
        }
        remainingShapesToReparent.delete(shape);
        continue shapeCheck;
      }
    }
    if (childrenToReparent.length) {
      reparenting.set(parentShape.id, childrenToReparent);
    }
  }
  return {
    // these are the shapes that will be reparented to new parents
    reparenting,
    // these are the shapes that will be reparented to the page or their ancestral group
    remainingShapesToReparent
  };
}
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey) content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1) return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size) return this;
    return new OrderedMap(map2.content.concat(this.subtract(map2).content));
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size) return this;
    return new OrderedMap(this.subtract(map2).content.concat(map2.content));
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map2) {
    var result = this;
    map2 = OrderedMap.from(map2);
    for (var i = 0; i < map2.content.length; i += 2)
      result = result.remove(map2.content[i]);
    return result;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value;
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content);
};
function findDiffStart(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size2 = childA.nodeSize;
    if (childA == childB) {
      posA -= size2;
      posB -= size2;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size2;
    posB -= size2;
  }
}
class Fragment {
  /**
  @internal
  */
  constructor(content, size2) {
    this.content = content;
    this.size = size2 || 0;
    if (size2 == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start), Math.min(child.content.size, to - start), f, nodeStart + start);
      }
      pos = end;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text = "", first2 = true;
    this.nodesBetween(from2, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last2 = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last2.isText && last2.sameMarkup(first2)) {
      content[content.length - 1] = last2.withText(last2.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size2 = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from2) {
          if (pos < from2 || end > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size2 += child.nodeSize;
        }
        pos = end;
      }
    return new Fragment(result, size2);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index2, node) {
    let current = this.content[index2];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size2 = this.size + node.nodeSize - current.nodeSize;
    copy2[index2] = node;
    return new Fragment(copy2, size2);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index2) {
    let found2 = this.content[index2];
    if (!found2)
      throw new RangeError("Index " + index2 + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content[index2] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos)
          return retIndex(i + 1, end);
        return retIndex(i, curPos);
      }
      curPos = end;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array2) {
    if (!array2.length)
      return Fragment.empty;
    let joined, size2 = 0;
    for (let i = 0; i < array2.length; i++) {
      let node = array2[i];
      size2 += node.nodeSize;
      if (i && node.isText && array2[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array2.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new Fragment(joined || array2, size2);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return Fragment.empty;
    if (nodes instanceof Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(index2, offset2) {
  found.index = index2;
  found.offset = offset2;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array2 = Array.isArray(a);
  if (Array.isArray(b) != array2)
    return false;
  if (array2) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}
let Mark$1 = class Mark {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type.create(json.attrs);
    type.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return Mark.none;
    if (marks instanceof Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
};
Mark$1.none = [];
class ReplaceError extends Error {
}
class Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new Slice(fragment, openStart, openEnd);
  }
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index: index2, offset: offset2 } = content.findIndex(from2), child = content.maybeChild(index2);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset2 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index2 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index2, child.copy(removeRange(child.content, from2 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index: index2, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index2);
  if (offset2 == dist || child.isText) {
    if (parent && !parent.canReplace(index2, index2, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset2 - 1, insert, child);
  return inner && content.replaceChild(index2, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index2 = $from.index(depth), node = $from.node(depth);
  if (index2 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index2, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable$1($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last2 = target.length - 1;
  if (last2 >= 0 && child.isText && child.sameMarkup(target[last2]))
    target[last2] = child.withText(target[last2].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable$1($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
class ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index2 = this.index(this.depth);
    if (index2 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index2);
    return dOff ? parent.child(index2).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index2 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index2).cut(0, dOff);
    return index2 == 0 ? null : this.parent.child(index2 - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index2, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index2; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index2 = this.index();
    if (parent.content.size == 0)
      return Mark$1.none;
    if (this.textOffset)
      return parent.child(index2).marks;
    let main = parent.maybeChild(index2 - 1), other = parent.maybeChild(index2);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks = main.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start = 0, parentOffset = pos;
    for (let node = doc2; ; ) {
      let { index: index2, offset: offset2 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset2;
      path.push(node, index2, start + offset2);
      if (!rem)
        break;
      node = node.child(index2);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start += offset2 + 1;
    }
    return new ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc2, pos) {
    let cache = resolveCache.get(doc2);
    if (cache) {
      for (let i = 0; i < cache.elts.length; i++) {
        let elt = cache.elts[i];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc2, cache = new ResolveCache());
    }
    let result = cache.elts[cache.i] = ResolvedPos.resolve(doc2, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result;
  }
}
class ResolveCache {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
}
const resolveCacheSize = 12, resolveCache = /* @__PURE__ */ new WeakMap();
class NodeRange {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const emptyAttrs = /* @__PURE__ */ Object.create(null);
let Node$1 = class Node2 {
  /**
  @internal
  */
  constructor(type, attrs, content, marks = Mark$1.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index2) {
    return this.content.child(index2);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content.maybeChild(index2);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, marks || Mark$1.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new Node2(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new Node2(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start, $to.pos - start);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index: index2, offset: offset2 } = node.content.findIndex(pos);
      node = node.maybeChild(index2);
      if (!node)
        return null;
      if (offset2 == pos || node.isText)
        return node;
      pos -= offset2 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index: index2, offset: offset2 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index2), index: index2, offset: offset2 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index2, offset: offset2 } = this.content.findIndex(pos);
    if (offset2 < pos)
      return { node: this.content.child(index2), index: index2, offset: offset2 };
    let node = this.content.child(index2 - 1);
    return { node, index: index2 - 1, offset: offset2 - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index2) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index2);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start, end);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start; i < end; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start = this.contentMatchAt(from2).matchType(type);
    let end = start && start.matchFragment(this.content, to);
    return end ? end.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark$1.none;
    for (let i = 0; i < this.marks.length; i++) {
      let mark = this.marks[i];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark$1.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    let node = schema.nodeType(json.type).create(json.attrs, content, marks);
    node.type.checkAttrs(node.attrs);
    return node;
  }
};
Node$1.prototype.text = void 0;
class TextNode extends Node$1 {
  /**
  @internal
  */
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
}
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
class ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string2, nodeTypes) {
    let stream = new TokenStream(string2, nodeTypes);
    if (stream.next == null)
      return ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start = 0, end = frag.childCount) {
    let cur = this;
    for (let i = start; cur && i < end; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed2 = this.computeWrapping(target);
    this.wrapCache.push(target, computed2);
    return computed2;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
}
ContentMatch.empty = new ContentMatch(true);
class TokenStream {
  constructor(string2, nodeTypes) {
    this.string = string2;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string2.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
}
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.isInGroup(name))
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from2, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile(expr2.expr, from2), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values, type, name) {
  for (let name2 in values)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(typeName, name, attrs[name]);
  return result;
}
let NodeType$1 = class NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content), Mark$1.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node$1(this, this.computeAttrs(attrs), content, Mark$1.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node$1(this, attrs, content.append(after), Mark$1.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark$1.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
function validateType(typeName, attrName, type) {
  let types = type.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
class Attribute {
  constructor(typeName, attrName, options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
    this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark$1(this, defaults2) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark$1(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
}
class Schema {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      if (type.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type.isInline || !type.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type;
      }
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = (json) => Node$1.fromJSON(this, json);
    this.markFromJSON = (json) => Mark$1.fromJSON(this, json);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType$1))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark$1.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
}
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
let DOMParser$1 = class DOMParser2 {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return false;
      let node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, Mark$1.none, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, Mark$1.none, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
  }
};
const blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
const ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
const listTags = { ol: true, ul: true };
const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
class NodeContext {
  constructor(type, attrs, marks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark$1.none;
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start = this.type.contentMatch, wrap2;
        if (wrap2 = start.findWrapping(node.type)) {
          this.match = start;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last2 = this.content[this.content.length - 1], m;
      if (last2 && last2.isText && (m = /[ \t\r\n\u000c]+$/.exec(last2.text))) {
        let text = last2;
        if (last2.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
}
class ParseContext {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark$1.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark$1.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
    let { schema } = this.parser;
    if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS === "full") {
        value = value.replace(/\r\n?/g, "\n");
      } else if (schema.linebreakReplacement && /[\r\n]/.test(value) && this.top.findWrapping(schema.linebreakReplacement.create())) {
        let lines = value.split(/\r?\n|\r/);
        for (let i = 0; i < lines.length; i++) {
          if (i)
            this.insertNode(schema.linebreakReplacement.create(), marks, true);
          if (lines[i])
            this.insertNode(schema.text(lines[i]), marks, !/\S/.test(lines[i]));
        }
        value = "";
      } else {
        value = value.replace(/\r?\n|\r/g, " ");
      }
      if (value)
        this.insertNode(schema.text(value), marks, !/\S/.test(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom, marks);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top.content.length && top.content[0].isInline && this.open) {
          this.open--;
          top = this.top;
        }
        sync = true;
        if (!top.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom, marks);
        break out;
      }
      let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
      if (innerMarks)
        this.addAll(dom, innerMarks);
      if (sync)
        this.sync(top);
      this.needsBlock = oldNeedsBlock;
    } else {
      let innerMarks = this.readStyles(dom, marks);
      if (innerMarks)
        this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
    }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks, true);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom, marks) {
    let styles = dom.style;
    if (styles && styles.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
        if (value)
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m) => !rule.clearMark(m));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks, false));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index2 = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index2) {
      this.findAtPoint(parent, index2);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index2);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node, marks, cautious) {
    let route, sync;
    for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length + penalty)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid) {
        if (cautious)
          break;
        penalty += 2;
      }
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      marks = this.enterInner(route[i], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node, marks, cautious) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node, marks, cautious);
    if (innerMarks) {
      this.closeExtra();
      let top = this.top;
      if (top.match)
        top.match = top.match.matchType(node.type);
      let nodeMarks = Mark$1.none;
      for (let m of innerMarks.concat(node.marks))
        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
          nodeMarks = m.addToSet(nodeMarks);
      top.content.push(node.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, marks, preserveWS) {
    let innerMarks = this.findPlace(type.create(attrs), marks, false);
    if (innerMarks)
      innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type, attrs, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.match = top.match && top.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
      options |= OPT_OPEN_LEFT;
    let applyMarks = Mark$1.none;
    marks = marks.filter((m) => {
      if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
        applyMarks = m.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset2) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset2)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
}
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type, next } = match.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
class DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc$1(options).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push([add, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options) {
    let { dom, contentDOM } = renderSpec(doc$1(options), this.nodes[node.type.name](node), null, node.attrs);
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options = {}) {
    let dom = this.serializeNodeInner(node, options);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc$1(options), toDOM(mark, inline), null, mark.attrs);
  }
  static renderSpec(doc2, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc2, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
}
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc$1(options) {
  return options.document || window.document;
}
const suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i = 0; i < value.length; i++)
            scan(value[i]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result;
}
function renderSpec(doc2, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc2.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  let attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else if (name == "style" && dom.style)
          dom.style.cssText = attrs[name];
        else
          dom.setAttribute(name, attrs[name]);
      }
  }
  for (let i = start; i < structure.length; i++) {
    let child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc2, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}
const lower16 = 65535;
const factor16 = Math.pow(2, 16);
function makeRecover(index2, offset2) {
  return index2 + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty)
      return StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index2 = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index2; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index2 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result = start + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
        let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start : pos != end)
          del |= DEL_SIDE;
        return new MapResult(result, del, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index2 = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
      if (pos <= end && i == index2 * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps, mirror, from2 = 0, to = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new Mapping(this._maps, this.mirror, from2, to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map2, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map2);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this._maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map2 = this._maps[i], result = map2.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this._maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
}
class StepResult {
  /**
  @internal
  */
  constructor(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc2) {
    return new StepResult(doc2, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc2, from2, to, slice2) {
    try {
      return StepResult.ok(doc2.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return StepResult.fail(e.message);
      throw e;
    }
  }
}
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
class AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new AddNodeMarkStep(this.pos, node.marks[i]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc2) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice, this.structure);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc2) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from2, to) {
  let $from = doc2.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from2), end = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s) => tr2.step(s));
  added.forEach((s) => tr2.step(s));
}
function removeMark(tr2, from2, to, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end, step });
        }
      }
    }
  });
  matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr2.step(new RemoveMarkStep(cur, end, child.marks[j]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr2.step(replSteps[i]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth, contentBefore = 0, contentAfter = 0; ; --depth) {
    let node = range.$from.node(depth);
    let index2 = range.$from.index(depth) + contentBefore, endIndex = range.$to.indexAfter(depth) - contentAfter;
    if (depth < range.depth && node.canReplace(index2, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index2, endIndex))
      break;
    if (index2)
      contentBefore = 1;
    if (endIndex < node.childCount)
      contentAfter = 1;
  }
  return null;
}
function lift$4(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr2.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr2, range, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start = range.start, end = range.end;
  tr2.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType$1(tr2, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr2, node, pos, mapFrom);
      clearIncompatible(tr2, tr2.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr2, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr2, node, pos, mapFrom) {
  node.forEach((child, offset2) => {
    if (child.isText) {
      let m, newline = /\r?\n|\r/g;
      while (m = newline.exec(child.text)) {
        let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset2 + m.index);
        tr2.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr2, node, pos, mapFrom) {
  node.forEach((child, offset2) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset2);
      tr2.replaceWith(start, start + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc2, pos, type) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return $pos.parent.canReplaceWith(index2, index2 + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs, marks) {
  let node = tr2.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr2.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc2, pos, depth = 1, typesAfter) {
  let $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    let node = $pos.node(d), index3 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index3, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index3 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index2 = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index2, index2, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = Fragment.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc2, pos) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index2, index2 + 1);
}
function canAppendWithSubstitutedLinebreaks(a, b) {
  if (!b.content.size)
    a.type.compatibleContent(b.type);
  let match = a.contentMatchAt(a.childCount);
  let { linebreakReplacement } = a.type.schema;
  for (let i = 0; i < b.childCount; i++) {
    let child = b.child(i);
    let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
    match = match.matchType(type);
    if (!match)
      return false;
    if (!a.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable(a, b) {
  return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
}
function joinPoint(doc2, pos, dir = -1) {
  let $pos = doc2.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index2 = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index2++;
      after = $pos.node(d).maybeChild(index2);
    } else {
      before = $pos.node(d).maybeChild(index2 - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index2, index2 + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr2, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr2.doc.type.schema;
  let $before = tr2.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr2.steps.length;
  if (convertNewlines === false) {
    let $after = tr2.doc.resolve(pos + depth);
    replaceLinebreaks(tr2, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr2, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr2.mapping.slice(mapFrom), start = mapping.map(pos - depth);
  tr2.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr2.doc.resolve(start);
    replaceNewlines(tr2, $full.node(), $full.before(), tr2.steps.length);
  }
  return tr2;
}
function insertPoint(doc2, pos, nodeType) {
  let $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index2 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
        return $pos.before(d + 1);
      if (index2 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index2 = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
        return $pos.after(d + 1);
      if (index2 < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc2, pos, slice2) {
  let $pos = doc2.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc2, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc2.resolve(from2), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
class Fitter {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top = this.frontier[this.depth], level;
    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      let { match, type } = this.frontier[i];
      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      let fit = contentAfterFits($to, i, type, match, dropInner);
      if (!fit)
        continue;
      for (let d = i - 1; d >= 0; d--) {
        let { match: match2, type: type2 } = this.frontier[d];
        let matches2 = contentAfterFits($to, d, type2, match2, true);
        if (!matches2 || matches2.childCount)
          continue scan;
      }
      return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top = this.frontier[this.depth];
    top.match = top.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
}
function dropFromFragment(fragment, depth, count2) {
  if (depth == 0)
    return fragment.cutByIndex(count2, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count2)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index2 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index2 == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index2);
  return fit && !invalidMarks(type, node.content, index2) ? fit : null;
}
function invalidMarks(type, fragment, start) {
  for (let i = start; i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, $to);
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice2.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index2 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index2, index2, insert.type, insert.marks))
        return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr2.replace(from2, to, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to, node) {
  if (!node.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr2.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr2.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange$3(tr2, from2, to) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last2 = i == covered.length - 1;
    if (last2 && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last2 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
      return tr2.delete($from.before(d), to);
  }
  tr2.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
      result.push(d);
  }
  return result;
}
class AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(json.pos, json.attr, json.value);
  }
}
Step.jsonID("attr", AttrStep);
class DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc2.attrs)
      attrs[name] = doc2.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc2.type.create(attrs, doc2.content, doc2.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep(json.attr, json.value);
  }
}
Step.jsonID("docAttr", DocAttrStep);
let TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc2;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange$3(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift$4(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs = null) {
    setBlockType$1(this, from2, to, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    let node = this.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at position " + pos);
    if (mark instanceof Mark$1) {
      if (mark.isInSet(node.marks))
        this.step(new RemoveNodeMarkStep(pos, mark));
    } else {
      let set = node.marks, found2, steps = [];
      while (found2 = mark.isInSet(set)) {
        steps.push(new RemoveNodeMarkStep(pos, found2));
        set = found2.removeFromSet(set);
      }
      for (let i = steps.length - 1; i >= 0; i--)
        this.step(steps[i]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
}
const classesById = /* @__PURE__ */ Object.create(null);
class Selection {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr2, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd$3(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr2, node) {
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr2.deleteRange(from2, to);
      } else {
        tr2.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd$3(tr2, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc2, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection.prototype.visible = true;
class SelectionRange {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
class TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr2, content = Slice.empty) {
    super.replace(tr2, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr2.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head);
  }
}
Selection.jsonID("text", TextSelection);
class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}
class NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc2.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc2, from2) {
    return new NodeSelection(doc2.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
}
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
}
class AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr2, content = Slice.empty) {
    if (content == Slice.empty) {
      tr2.delete(0, tr2.doc.content.size);
      let sel = Selection.atStart(tr2.doc);
      if (!sel.eq(tr2.selection))
        tr2.setSelection(sel);
    } else {
      super.replace(tr2, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc2) {
    return new AllSelection(doc2);
  }
  map(doc2) {
    return new AllSelection(doc2);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node, pos, index2, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc2, pos);
  for (let i = index2 - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd$3(tr2, startLen, bias) {
  let last2 = tr2.steps.length - 1;
  if (last2 < startLen)
    return;
  let step = tr2.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr2.mapping.maps[last2], end;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
class Transaction2 extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    super.addStep(step, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from2;
      if (!text)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text, marks));
      if (!this.selection.empty && this.selection.to == from2 + text.length)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
class FieldDesc {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
}
const baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr2) {
      return tr2.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr2) {
      return tr2.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr2, _marks, _old, state) {
      return state.selection.$cursor ? tr2.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr2, prev) {
      return tr2.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
class Configuration {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
}
class EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr2) {
    return this.applyTransaction(tr2).state;
  }
  /**
  @internal
  */
  filterTransaction(tr2, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr2 = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr2 && newState.filterTransaction(tr2, i)) {
            tr2.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr2);
            newState = newState.applyInner(tr2);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr2) {
    if (!tr2.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Accessor that constructs and returns a new [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction2(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node$1.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
}
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
class Plugin {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
}
const keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
class PluginKey {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
}
const domIndex = function(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
};
const parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
let reusedRange = null;
const textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
const clearReusedRange = function() {
  reusedRange = null;
};
const isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
const atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  var _a2;
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      let child = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (child.nodeType == 1 && child.contentEditable == "false") {
        if ((_a2 = child.pmViewDesc) === null || _a2 === void 0 ? void 0 : _a2.ignoreForSelection)
          off += dir;
        else
          return false;
      } else {
        node = child;
        off = dir < 0 ? nodeSize(node) : 0;
      }
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3 && offset2)
      return node;
    if (node.nodeType == 1 && offset2 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2 - 1];
      offset2 = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset2 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3 && offset2 < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset2 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2];
      offset2 = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset2 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index2 = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index2 == 0;
    atEnd = atEnd && index2 == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
const selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc2, x, y) {
  if (doc2.caretPositionFromPoint) {
    try {
      let pos = doc2.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_) {
    }
  }
  if (doc2.caretRangeFromPoint) {
    let range = doc2.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
const nav = typeof navigator != "undefined" ? navigator : null;
const doc = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
const chrome = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
const windows$1 = nav ? /Win/.test(nav.platform) : false;
const android = /Android \d/.test(agent);
const webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc2) {
  let vp = doc2.defaultView && doc2.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide$1(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc2 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc2.body;
    let bounding = atTop ? windowRect(doc2) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide$1(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide$1(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide$1(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide$1(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide$1(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide$1(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide$1(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide$1(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide$1(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack2 = [], doc2 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack2.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc2)
      break;
  }
  return stack2;
}
function resetScrollPos({ refDOM, refTop, stack: stack2 }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack2, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack2, dTop) {
  for (let i = 0; i < stack2.length; i++) {
    let { dom, top, left } = stack2[i];
    if (dom.scrollTop != top + dTop)
      dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left)
      dom.scrollLeft = left;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset2 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset2, bias);
}
function posFromCaret(view, node, offset2, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc2 = view.dom.ownerDocument, node, offset2 = 0;
  let caret = caretFromPoint(doc2, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset2 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset2 = Math.min(offset2, node.childNodes.length);
      if (offset2 < node.childNodes.length) {
        let next = node.childNodes[offset2], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset2++;
      }
    }
    let prev;
    if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset2--;
    if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset2, atom: atom2 } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset2, offset2), side);
      if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom2 || 0));
  if (!$dom.parent.inlineContent) {
    if (atom2 == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom2 == null && offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom2 == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
    let before = node.childNodes[offset2 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom2 == null && offset2 < nodeSize(node)) {
    let after = node.childNodes[offset2];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0)
    return rect;
  let x = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top) {
  if (rect.height == 0)
    return rect;
  let y = top ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
const maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
let cachedState = null;
let cachedDir = null;
let cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
class ViewDesc {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size2 = 0;
    for (let i = 0; i < this.children.length; i++)
      size2 += this.children[i].size;
    return size2;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset2 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset2];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset2, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset2, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (offset2 == pos && end != offset2) {
        while (!child.border && child.children.length) {
          for (let i2 = 0; i2 < child.children.length; i2++) {
            let inner = child.children[i2];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end)
        return child.descAt(pos - offset2 - child.border);
      offset2 = end;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset2 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end = curPos + child.size;
      if (end > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i = 0; ; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (fromOffset == -1 && from2 <= end) {
        let childBase = offset2 + child.border;
        if (from2 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset2;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
        to = end;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset2 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset2 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset2];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (from2 > offset2 && to < end)
        return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, view, force);
      offset2 = end;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset2 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset2 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset2 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (offset2 == end ? from2 <= end && to >= offset2 : from2 < end && to > offset2) {
        let startInside = offset2 + child.border, endInside = end - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset2 || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset2 = end;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  get ignoreForSelection() {
    return false;
  }
  isText(text) {
    return false;
  }
}
class WidgetViewDesc extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CompositionViewDesc extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset2) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
}
class MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size2 = this.size;
    if (to < size2)
      nodes = replaceNodes(nodes, to, size2, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
}
class NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark$1.none : this.node.child(i).marks, inline, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.nodeDOM.draggable = true;
    }
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.nodeDOM.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  let docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
class TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset2, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
}
class TrailingHackViewDesc extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CustomNodeViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
}
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
const OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
const noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top.class = (top.class ? top.class + " " : "") + val;
      else if (name == "style")
        top.style = (top.style ? top.style + ";" : "") + val;
      else if (name != "nodeName")
        top[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class ViewTreeUpdater {
  constructor(top, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start, end) {
    if (start == end)
      return;
    for (let i = start; i < end; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start, end - start);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index2) {
    let found2 = -1, targetDesc;
    if (index2 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index2 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index2, view) {
    let child = this.top.children[index2];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index2);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index2, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index2)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
}
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node = desc.node;
    if (!node)
      continue;
    if (node != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches2.push(desc);
  }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset2, child), i);
      offset2 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index2;
    if (restNode) {
      index2 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index2 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset2)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    let end = offset2 + child.nodeSize;
    if (child.isText) {
      let cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end) {
        restNode = child.cut(cutAt - offset2);
        child = child.cut(0, cutAt - offset2);
        end = cutAt;
        index2 = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset2, child), index2);
    offset2 = end;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start = off, end = off += child.size;
    if (start >= to || end <= from2) {
      result.push(child);
    } else {
      if (start < from2)
        result.push(child.slice(0, from2 - start, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end > to)
        result.push(child.slice(to - start, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc2 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc2.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min2 = head, max2 = head;
      for (let i = 0; i < domSel.rangeCount; i++) {
        let range = domSel.getRangeAt(i);
        min2 = Math.min(min2, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max2 = Math.max(max2, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min2 < 0)
        return null;
      [anchor, head] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
      $head = doc2.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc2.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
const brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
  let before = offset2 ? node.childNodes[offset2 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    domSel.collapse(node.parentNode, domIndex(node) + 1);
  else
    domSel.collapse(node, 0);
  if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac$2 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset2 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node = before;
          offset2 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = 0;
      } else {
        node = prev;
        offset2 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset2];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node = next;
        offset2 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset2) {
  while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
    offset2 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset2 < node.childNodes.length) {
    let next = node.childNodes[offset2];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = 0;
  }
}
function textNodeBefore(node, offset2) {
  while (node && !offset2 && !hasBlockDesc(node)) {
    offset2 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset2) {
    let next = node.childNodes[offset2 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset2) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset2)) {
      node = after;
      offset2 = 0;
    } else if (before = textNodeBefore(node, offset2)) {
      node = before;
      offset2 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset2);
    range.setStart(node, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset2);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows$1) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed2 = getComputedStyle(view.dom).direction;
  return computed2 == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac$2 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods$1(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code2 = event.keyCode, mods = getMods$1(event);
  if (code2 == 8 || mac$2 && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code2 == 46 && !event.shiftKey || mac$2 && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37 || mac$2 && code2 == 66 && mods == "c") {
    let dir = code2 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 39 || mac$2 && code2 == 70 && mods == "c") {
    let dir = code2 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 38 || mac$2 && code2 == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code2 == 40 || mac$2 && code2 == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac$2 ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc2 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc2.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text, slice: slice2 };
}
function parseFromClipboard(view, text, html2, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html2 && !text)
    return null;
  let asText = !!text && (plainText || inCode || !html2);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode) {
      slice2 = new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0);
      view.someProp("transformPasted", (f) => {
        slice2 = f(slice2, view, true);
      });
      return slice2;
    }
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html2 = f(html2, view);
    });
    dom = readHTML(html2);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view, asText);
  });
  return slice2;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i = wrap2.length - 1; i >= from2; i--)
    node = wrap2[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
let _policy = null;
function maybeWrapTrusted(html2) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html2;
  if (!_policy)
    _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
  return _policy.createHTML(html2);
}
function readHTML(html2) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html2);
  if (metas)
    html2 = html2.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html2), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html2 = wrap2.map((n) => "<" + n + ">").join("") + html2 + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html2);
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array2;
  try {
    array2 = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array2.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array2[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array2[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
const handlers = {};
const editHandlers = {};
const passiveHandlers = { touchstart: true, touchmove: true };
class InputState {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
}
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    let deflt = () => view.state.tr.insertText(text).scrollIntoView();
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))
      view.dispatch(deflt());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr2 = view.state.tr.setSelection(selection);
  tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos));
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt));
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size));
      return true;
    }
    return false;
  }
  let $pos = doc2.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size));
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc2, nodePos));
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
class MouseDown {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)));
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
}
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
          let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset2 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view), cur = view.state.selection;
    if (sel && !sel.eq(cur))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html2, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html2, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText$2(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText$2(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
let Dragging$1 = class Dragging {
  constructor(slice2, move, node) {
    this.slice = slice2;
    this.move = move;
    this.node = node;
  }
};
const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
function dragMoves(view, event) {
  let moves = view.someProp("dragCopies", (test) => !test(event));
  return moves != null ? moves : !event[dragCopyModifier];
}
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging$1(slice2, dragMoves(view, event), node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view, false);
    });
  } else {
    slice2 = parseFromClipboard(view, getText$2(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && dragMoves(view, event));
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr2 = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr2);
    else
      tr2.deleteSelection();
  }
  let pos = tr2.mapping.map(insertPos);
  let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr2.doc;
  if (isNode2)
    tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr2.replaceRange(pos, pos, slice2);
  if (tr2.doc.eq(beforeInsert))
    return;
  let $pos = tr2.doc.resolve(pos);
  if (isNode2 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr2.setSelection(new NodeSelection($pos));
  } else {
    let end = tr2.mapping.map(insertPos);
    tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
    tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr2.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
class WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
}
class InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType;
  }
  destroy() {
  }
}
class NodeType2 {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset2, to.pos - offset2, this);
  }
  valid(node, span) {
    let { index: index2, offset: offset2 } = node.content.findIndex(span.from), child;
    return offset2 == span.from && !(child = node.child(index2)).isText && offset2 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
}
class Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new Decoration(from2, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
}
const none = [], noSpec = {};
class DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start, end, predicate) {
    let result = [];
    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
    return result;
  }
  findInner(start, end, result, offset2, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end && this.children[i + 1] > start) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset2 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc2, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset2, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
    else
      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  }
  addInner(doc2, decorations, offset2) {
    let children, childIndex = 0;
    doc2.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc2, local[i]))
        local.splice(i--, 1);
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from2 = children[i] + offset2, to = children[i + 1] + offset2;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet(local, children) : empty;
  }
  forChild(offset2, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset2) {
        if (this.children[i] == offset2)
          child = this.children[i + 2];
        break;
      }
    let start = offset2 + 1, end = start + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
        let from2 = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
  forEachSet(f) {
    f(this);
  }
}
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
const empty = DecorationSet.empty;
class DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc2) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
    return DecorationGroup.from(mappedDecos);
  }
  forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset2, child);
      if (result == empty)
        continue;
      if (result instanceof DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
  forEachSet(f) {
    for (let i = 0; i < this.members.length; i++)
      this.members[i].forEachSet(f);
  }
}
function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end = children[i2 + 1];
        if (end < 0 || oldStart > end + baseOffset - moved)
          continue;
        let start = children[i2] + baseOffset - moved;
        if (oldEnd >= start) {
          children[i2 + 1] = oldStart <= start ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset2;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index: index2, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index2);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j < children.length && children[j] < from2)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset2) {
  if (node.isLeaf)
    return null;
  let end = offset2 + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array2) {
  let result = [];
  for (let i = 0; i < array2.length; i++)
    if (array2[i] != null)
      result.push(array2[i]);
  return result;
}
function buildTree(spans, node, offset2, options) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array2, i, deco) {
  while (i < array2.length && byPos(deco, array2[i]) > 0)
    i++;
  array2.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
const observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
const useCharData = ie$1 && ie_version <= 11;
class SelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
}
class DOMObserver {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie$1 && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let [a, b] = brs;
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++) {
        let node = mut.addedNodes[i];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
}
let cssChecked = /* @__PURE__ */ new WeakMap();
let cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
    let desc = view.docView.nearestDesc(p, true);
    if (desc && desc.node.isBlock)
      return p;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc2, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
const isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr2 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr2.setMeta("pointer", true);
      else if (origin == "key")
        tr2.scrollIntoView();
      if (compositionID)
        tr2.setMeta("composition", compositionID);
      view.dispatch(tr2);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared2 = $before.sharedDepth(to);
  from2 = $before.before(shared2 + 1);
  to = view.state.doc.resolve(to).after(shared2 + 1);
  let sel = view.state.selection;
  let parse2 = parseBetween(view, from2, to);
  let doc2 = view.state.doc, compare = doc2.slice(parse2.from, parse2.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse2.doc.content, parse2.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse2.sel && parse2.sel.anchor != parse2.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse2.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse2.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr2 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr2.setMeta("composition", compositionID);
          view.dispatch(tr2);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse2.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse2.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse2.from && parse2.doc.textBetween(change.start - parse2.from - 1, change.start - parse2.from + 1) == " ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse2.doc.resolveNoCache(change.start - parse2.from);
  let $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
  let $fromA = doc2.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse2.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && $from.pos < $to.pos && !/\S/.test(parse2.doc.textBetween($from.pos, $to.pos, "", ""))) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse2.sel && parse2.sel.anchor == parse2.sel.head && parse2.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let mkTr = (base2) => {
    let tr2 = base2 || view.state.tr.replace(chFrom, chTo, parse2.doc.slice(change.start - parse2.from, change.endB - parse2.from));
    if (parse2.sel) {
      let sel2 = resolveSelection(view, tr2.doc, parse2.sel);
      if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
        tr2.setSelection(sel2);
    }
    if (compositionID)
      tr2.setMeta("composition", compositionID);
    return tr2.scrollIntoView();
  };
  let markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      let tr2 = mkTr(view.state.tr.delete(chFrom, chTo));
      let marks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
      if (marks)
        tr2.ensureMarks(marks);
      view.dispatch(tr2);
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      let tr2 = mkTr(view.state.tr);
      if (markChange.type == "add")
        tr2.addMark(chFrom, chTo, markChange.mark);
      else
        tr2.removeMark(chFrom, chTo, markChange.mark);
      view.dispatch(tr2);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));
      if (!view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text, deflt)))
        view.dispatch(deflt());
    } else {
      view.dispatch(mkTr());
    }
  } else {
    view.dispatch(mkTr());
  }
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
    return null;
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end == start + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start = a.findDiffStart(b, pos);
  if (start == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move;
    if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endA = start + (endA - endB);
    endB = start;
  }
  return { start, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
class EditorView {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a2;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie$1 || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a2 = this.dragging) === null || _a2 === void 0 ? void 0 : _a2.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
    else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging$1(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie$1) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html2, event) {
    return doPaste(this, "", html2, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(slice2) {
    return serializeForClipboard(this, slice2);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
EditorView.prototype.dispatch = function(tr2) {
  let dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction)
    dispatchTransaction.call(this, tr2);
  else
    this.updateState(this.state.apply(tr2));
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift$3 = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift$3[i] = String.fromCharCode(i);
}
for (var code$1 in base) if (!shift$3.hasOwnProperty(code$1)) shift$3[code$1] = base[code$1];
function keyName(event) {
  var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift$3 : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}
const mac = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
const windows = typeof navigator != "undefined" && /Win/.test(navigator.platform);
function normalizeKeyName$3(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName$3(prop)] = map2[prop];
  return copy2;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
const deleteSelection$3 = (state, dispatch2) => {
  if (state.selection.empty)
    return false;
  if (dispatch2)
    dispatch2(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
const joinBackward$3 = (state, dispatch2, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch2)
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch2, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch2) {
          let tr2 = state.tr.step(delStep);
          tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
          dispatch2(tr2.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2)
      dispatch2(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
const joinTextblockBackward$3 = (state, dispatch2, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
};
const joinTextblockForward$3 = (state, dispatch2, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
};
function joinTextblocksAround(state, $cut, dispatch2) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch2) {
    let tr2 = state.tr.step(step);
    tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
const selectNodeBackward$3 = (state, dispatch2, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
const joinForward$3 = (state, dispatch2, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch2, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
        dispatch2(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2)
      dispatch2(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
const selectNodeForward$3 = (state, dispatch2, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
const joinUp$3 = (state, dispatch2) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch2) {
    let tr2 = state.tr.join(point);
    if (nodeSel)
      tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
const joinDown$3 = (state, dispatch2) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch2)
    dispatch2(state.tr.join(point).scrollIntoView());
  return true;
};
const lift$3 = (state, dispatch2) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch2)
    dispatch2(state.tr.lift(range, target).scrollIntoView());
  return true;
};
const newlineInCode$3 = (state, dispatch2) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch2)
    dispatch2(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt$3(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
const exitCode$3 = (state, dispatch2) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt$3(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch2) {
    let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
const createParagraphNear$3 = (state, dispatch2) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt$3($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch2) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr2 = state.tr.insert(side, type.createAndFill());
    tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
const liftEmptyBlock$3 = (state, dispatch2) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch2)
        dispatch2(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch2)
    dispatch2(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch2) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch2)
        dispatch2(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d = $from.depth; ; d--) {
      let node = $from.node(d);
      if (node.isBlock) {
        atEnd = $from.end(d) == $from.pos + ($from.depth - d);
        atStart = $from.start(d) == $from.pos - ($from.depth - d);
        deflt = defaultBlockAt$3($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
        types.unshift(atEnd && deflt ? { type: deflt } : null);
        splitDepth = d;
        break;
      } else {
        if (d == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr2 = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
      tr2.deleteSelection();
    let splitPos = tr2.mapping.map($from.pos);
    let can = canSplit(tr2.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr2.doc, splitPos, types.length, types);
    }
    if (!can)
      return false;
    tr2.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first2 = tr2.mapping.map($from.before(splitDepth)), $first = tr2.doc.resolve(first2);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr2.setNodeMarkup(tr2.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch2)
      dispatch2(tr2.scrollIntoView());
    return true;
  };
}
const splitBlock$3 = splitBlockAs();
const selectParentNode$3 = (state, dispatch2) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch2) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
    if (dispatch2)
      dispatch2(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch2)
    dispatch2(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch2, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch2))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch2) {
      let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap2 = Fragment.from(conn[i].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
      let $joinAt = tr2.doc.resolve(end + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr2.doc, $joinAt.pos))
        tr2.join($joinAt.pos);
      dispatch2(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch2)
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at2 = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at2);
      if (at2.isTextblock)
        break;
      at2 = at2.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at2.canReplace(at2.childCount, at2.childCount, afterText.content)) {
      if (dispatch2) {
        let end = Fragment.empty;
        for (let i = wrap2.length - 1; i >= 0; i--)
          end = Fragment.from(wrap2[i].copy(end));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
        dispatch2(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch2) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch2)
      dispatch2(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
const selectTextblockStart$3 = selectTextblockSide(-1);
const selectTextblockEnd$3 = selectTextblockSide(1);
function wrapIn$3(nodeType, attrs = null) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch2)
      dispatch2(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType(nodeType, attrs = null) {
  return function(state, dispatch2) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index2 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch2) {
      let tr2 = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        tr2.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch2(tr2.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands) {
  return function(state, dispatch2, view) {
    for (let i = 0; i < commands.length; i++)
      if (commands[i](state, dispatch2, view))
        return true;
    return false;
  };
}
chainCommands(deleteSelection$3, joinBackward$3, selectNodeBackward$3);
chainCommands(deleteSelection$3, joinForward$3, selectNodeForward$3);
({
  "Enter": chainCommands(newlineInCode$3, createParagraphNear$3, liftEmptyBlock$3, splitBlock$3)
});
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
function wrapInList$3(listType, attrs = null) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to);
    if (!range)
      return false;
    let tr2 = dispatch2 ? state.tr : null;
    if (!wrapRangeInList(tr2, range, listType, attrs))
      return false;
    if (dispatch2)
      dispatch2(tr2.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr2, range, listType, attrs = null) {
  let doJoin = false, outerRange = range, doc2 = range.$from.doc;
  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
    if (range.$from.index(range.depth - 1) == 0)
      return false;
    let $insert = doc2.resolve(range.start - 2);
    outerRange = new NodeRange($insert, $insert, range.depth);
    if (range.endIndex < range.parent.childCount)
      range = new NodeRange(range.$from, doc2.resolve(range.$to.end(range.depth)), range.depth);
    doJoin = true;
  }
  let wrap2 = findWrapping(outerRange, listType, attrs, range);
  if (!wrap2)
    return false;
  if (tr2)
    doWrapInList(tr2, range, wrap2, doJoin, listType);
  return true;
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr2;
}
function liftListItem$3(itemType) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch2)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch2, itemType, range);
    else
      return liftOutOfList(state, dispatch2, range);
  };
}
function liftToOuterList(state, dispatch2, itemType, range) {
  let tr2 = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr2.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr2.lift(range, target);
  let $after = tr2.doc.resolve(tr2.mapping.map(end, -1) - 1);
  if (canJoin(tr2.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr2.join($after.pos);
  dispatch2(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch2, range) {
  let tr2 = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr2.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch2(tr2.scrollIntoView());
  return true;
}
function sinkListItem$3(itemType) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch2) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch2(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}
var __defProp$6 = Object.defineProperty;
var __export$3 = (target, all) => {
  for (var name in all)
    __defProp$6(target, name, { get: all[name], enumerable: true });
};
function createChainableState$2(config) {
  const { state, transaction: transaction2 } = config;
  let { selection } = transaction2;
  let { doc: doc2 } = transaction2;
  let { storedMarks } = transaction2;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction2.selection;
      doc2 = transaction2.doc;
      storedMarks = transaction2.storedMarks;
      return transaction2;
    }
  };
}
var CommandManager$2 = class CommandManager {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args) => {
          const callback = command2(...args)(props);
          if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr2);
          }
          return callback;
        };
        return [name, method];
      })
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run3 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain2 = {
      ...Object.fromEntries(
        Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args) => {
            const props = this.buildProps(tr2, shouldDispatch);
            const callback = command2(...args)(props);
            callbacks.push(callback);
            return chain2;
          };
          return [name, chainedCommand];
        })
      ),
      run: run3
    };
    return chain2;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch2 = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch2);
    const formattedCommands = Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
      })
    );
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch2)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState$2({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          })
        );
      }
    };
    return props;
  }
};
function combineTransactionSteps$2(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction2) => {
    transaction2.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
var removeWhitespaces$2 = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces$2(child);
    }
  }
  return node;
};
function elementFromString$2(value) {
  if (typeof window === "undefined") {
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  }
  const wrappedValue = `<body>${value}</body>`;
  const html2 = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces$2(html2);
}
function createNodeFromContent$2(content, schema, options) {
  if (content instanceof Node$1 || content instanceof Fragment) {
    return content;
  }
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent$2("", schema, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser$1.fromSchema(contentCheckSchema).parseSlice(elementFromString$2(content), options.parseOptions);
      } else {
        DOMParser$1.fromSchema(contentCheckSchema).parse(elementFromString$2(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${invalidContent}`)
        });
      }
    }
    const parser = DOMParser$1.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(elementFromString$2(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString$2(content), options.parseOptions);
  }
  return createNodeFromContent$2("", schema, options);
}
function createDocument$2(content, schema, parseOptions = {}, options = {}) {
  return createNodeFromContent$2(content, schema, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options.errorOnInvalidContent
  });
}
function defaultBlockAt$2(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findParentNodeClosestToPos$2($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode$2(predicate) {
  return (selection) => findParentNodeClosestToPos$2(selection.$from, predicate);
}
function getExtensionField$2(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField$2(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField$2(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function flattenExtensions$2(extensions) {
  return extensions.map((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addExtensions = getExtensionField$2(extension, "addExtensions", context);
    if (addExtensions) {
      return [extension, ...flattenExtensions$2(addExtensions())];
    }
    return extension;
  }).flat(10);
}
function isFunction$3(value) {
  return typeof value === "function";
}
function callOrReturn$2(value, context = void 0, ...props) {
  if (isFunction$3(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject$2(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function splitExtensions$2(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions$2(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions$2(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    validate: void 0,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField$2(
      extension,
      "addGlobalAttributes",
      context
    );
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField$2(
      extension,
      "addAttributes",
      context
    );
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function mergeAttributes$2(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        newStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes$2(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes$2(attributes, attribute), {});
}
function fromString$2(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule$2(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString$2(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem$2(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject$2(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions$2(extensions, editor) {
  var _a2;
  const allAttributes = getAttributesFromExtensions$2(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions$2(extensions);
  const topNode = (_a2 = nodeExtensions.find((extension) => getExtensionField$2(extension, "topNode"))) == null ? void 0 : _a2.name;
  const nodes = Object.fromEntries(
    nodeExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraNodeFields = extensions.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField$2(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem$2({
        ...extraNodeFields,
        content: callOrReturn$2(getExtensionField$2(extension, "content", context)),
        marks: callOrReturn$2(getExtensionField$2(extension, "marks", context)),
        group: callOrReturn$2(getExtensionField$2(extension, "group", context)),
        inline: callOrReturn$2(getExtensionField$2(extension, "inline", context)),
        atom: callOrReturn$2(getExtensionField$2(extension, "atom", context)),
        selectable: callOrReturn$2(getExtensionField$2(extension, "selectable", context)),
        draggable: callOrReturn$2(getExtensionField$2(extension, "draggable", context)),
        code: callOrReturn$2(getExtensionField$2(extension, "code", context)),
        whitespace: callOrReturn$2(getExtensionField$2(extension, "whitespace", context)),
        linebreakReplacement: callOrReturn$2(
          getExtensionField$2(extension, "linebreakReplacement", context)
        ),
        defining: callOrReturn$2(getExtensionField$2(extension, "defining", context)),
        isolating: callOrReturn$2(getExtensionField$2(extension, "isolating", context)),
        attrs: Object.fromEntries(
          extensionAttributes.map((extensionAttribute) => {
            var _a22, _b;
            return [
              extensionAttribute.name,
              { default: (_a22 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a22.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }
            ];
          })
        )
      });
      const parseHTML = callOrReturn$2(getExtensionField$2(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule$2(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField$2(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node) => renderHTML({
          node,
          HTMLAttributes: getRenderedAttributes$2(node, extensionAttributes)
        });
      }
      const renderText = getExtensionField$2(extension, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension.name, schema];
    })
  );
  const marks = Object.fromEntries(
    markExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraMarkFields = extensions.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField$2(e, "extendMarkSchema", context);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem$2({
        ...extraMarkFields,
        inclusive: callOrReturn$2(getExtensionField$2(extension, "inclusive", context)),
        excludes: callOrReturn$2(getExtensionField$2(extension, "excludes", context)),
        group: callOrReturn$2(getExtensionField$2(extension, "group", context)),
        spanning: callOrReturn$2(getExtensionField$2(extension, "spanning", context)),
        code: callOrReturn$2(getExtensionField$2(extension, "code", context)),
        attrs: Object.fromEntries(
          extensionAttributes.map((extensionAttribute) => {
            var _a22, _b;
            return [
              extensionAttribute.name,
              { default: (_a22 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a22.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }
            ];
          })
        )
      });
      const parseHTML = callOrReturn$2(getExtensionField$2(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule$2(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField$2(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark) => renderHTML({
          mark,
          HTMLAttributes: getRenderedAttributes$2(mark, extensionAttributes)
        });
      }
      return [extension.name, schema];
    })
  );
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function findDuplicates$2(items) {
  const filtered = items.filter((el, index2) => items.indexOf(el) !== index2);
  return Array.from(new Set(filtered));
}
function sortExtensions$2(extensions) {
  const defaultPriority = 100;
  return extensions.sort((a, b) => {
    const priorityA = getExtensionField$2(a, "priority") || defaultPriority;
    const priorityB = getExtensionField$2(b, "priority") || defaultPriority;
    if (priorityA > priorityB) {
      return -1;
    }
    if (priorityA < priorityB) {
      return 1;
    }
    return 0;
  });
}
function resolveExtensions$2(extensions) {
  const resolvedExtensions = sortExtensions$2(flattenExtensions$2(extensions));
  const duplicatedNames = findDuplicates$2(resolvedExtensions.map((extension) => extension.name));
  if (duplicatedNames.length) {
    console.warn(
      `[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`
    );
  }
  return resolvedExtensions;
}
function getSchema$1(extensions, editor) {
  const resolvedExtensions = resolveExtensions$2(extensions);
  return getSchemaByResolvedExtensions$2(resolvedExtensions, editor);
}
function getTextBetween$2(startNode, range, options) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text = "";
  startNode.nodesBetween(from2, to, (node, pos, parent, index2) => {
    var _a2;
    if (node.isBlock && pos > from2) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers == null ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index: index2,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a2 = node == null ? void 0 : node.text) == null ? void 0 : _a2.slice(Math.max(from2, pos) - pos, to - pos);
    }
  });
  return text;
}
function getTextSerializersFromSchema$2(schema) {
  return Object.fromEntries(
    Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText])
  );
}
function getMarkType$2(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
function getMarkAttributes$2(state, typeOrName) {
  const type = getMarkType$2(typeOrName, state.schema);
  const { from: from2, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function getNodeType$2(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function getSchemaTypeNameByName$2(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function removeDuplicates$2(array2, by = JSON.stringify) {
  const seen = {};
  return array2.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges$2(changes) {
  const uniqueChanges = removeDuplicates$2(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index2) => {
    const rest = uniqueChanges.filter((_, i) => i !== index2);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges$2(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index2) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index2];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index2).map(from2, -1);
      const newEnd = mapping.slice(index2).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges$2(changes);
}
function isRegExp$2(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
function objectIncludes$2(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp$2(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet$2(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes$2(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
      attributes
    );
  });
}
function isMarkInSet$2(marks, type, attributes = {}) {
  return !!findMarkInSet$2(marks, type, attributes);
}
function getMarkRange$2($pos, type, attributes) {
  var _a2;
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a2 = start.node.marks[0]) == null ? void 0 : _a2.attrs);
  const mark = findMarkInSet$2([...start.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  while (startIndex > 0 && isMarkInSet$2([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet$2([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getSplittedAttributes$2(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(
    Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    })
  );
}
function isMarkActive$2(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType$2(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes$2(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(
        ...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        }))
      );
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes$2(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isNodeActive$2(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType$2(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes$2(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
function isList$2(name, extensions) {
  const { nodeExtensions } = splitExtensions$2(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn$2(getExtensionField$2(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty$2(node, {
  checkChildren = true,
  ignoreWhitespace = false
} = {}) {
  var _a2;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a2 = node.text) != null ? _a2 : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty$2(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isTextSelection$2(value) {
  return value instanceof TextSelection;
}
function minMax$2(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition$2(doc2, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc2);
  const selectionAtEnd = Selection.atEnd(doc2);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc2, minMax$2(0, minPos, maxPos), minMax$2(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax$2(position, minPos, maxPos), minMax$2(position, minPos, maxPos));
}
function selectionToInsertionEnd$2(tr2, startLen, bias) {
  const last2 = tr2.steps.length - 1;
  if (last2 < startLen) {
    return;
  }
  const step = tr2.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr2.mapping.maps[last2];
  let end = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
function getType$2(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject$2(value) {
  if (getType$2(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep$2(target, source) {
  const output = { ...target };
  if (isPlainObject$2(target) && isPlainObject$2(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject$2(source[key]) && isPlainObject$2(target[key])) {
        output[key] = mergeDeep$2(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var Extendable$2 = class Extendable {
  constructor(config = {}) {
    this.type = "extendable";
    this.parent = null;
    this.child = null;
    this.name = "";
    this.config = {
      name: this.name
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
  }
  get options() {
    return {
      ...callOrReturn$2(
        getExtensionField$2(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...callOrReturn$2(
        getExtensionField$2(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep$2(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new this.constructor({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = "name" in extendedConfig ? extendedConfig.name : extension.parent.name;
    return extension;
  }
};
var extensions_exports$2 = {};
__export$3(extensions_exports$2, {
  ClipboardTextSerializer: () => ClipboardTextSerializer$2,
  Commands: () => Commands$2,
  Delete: () => Delete$2,
  Drop: () => Drop$2,
  Editable: () => Editable$2,
  FocusEvents: () => FocusEvents$2,
  Keymap: () => Keymap$2,
  Paste: () => Paste$2,
  Tabindex: () => Tabindex$2,
  focusEventsPluginKey: () => focusEventsPluginKey$2
});
var Extension$2 = class _Extension extends Extendable$2 {
  constructor() {
    super(...arguments);
    this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Extension(resolvedConfig);
  }
  configure(options) {
    return super.configure(options);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
var ClipboardTextSerializer$2 = Extension$2.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc2, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema$2(schema);
            const range = { from: from2, to };
            return getTextBetween$2(doc2, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var commands_exports$2 = {};
__export$3(commands_exports$2, {
  blur: () => blur$2,
  clearContent: () => clearContent$2,
  clearNodes: () => clearNodes$2,
  command: () => command$2,
  createParagraphNear: () => createParagraphNear$2,
  cut: () => cut$2,
  deleteCurrentNode: () => deleteCurrentNode$2,
  deleteNode: () => deleteNode$2,
  deleteRange: () => deleteRange$2,
  deleteSelection: () => deleteSelection$2,
  enter: () => enter$2,
  exitCode: () => exitCode$2,
  extendMarkRange: () => extendMarkRange$2,
  first: () => first$2,
  focus: () => focus$3,
  forEach: () => forEach$2,
  insertContent: () => insertContent$2,
  insertContentAt: () => insertContentAt$2,
  joinBackward: () => joinBackward$2,
  joinDown: () => joinDown$2,
  joinForward: () => joinForward$2,
  joinItemBackward: () => joinItemBackward$2,
  joinItemForward: () => joinItemForward$2,
  joinTextblockBackward: () => joinTextblockBackward$2,
  joinTextblockForward: () => joinTextblockForward$2,
  joinUp: () => joinUp$2,
  keyboardShortcut: () => keyboardShortcut$2,
  lift: () => lift$2,
  liftEmptyBlock: () => liftEmptyBlock$2,
  liftListItem: () => liftListItem$2,
  newlineInCode: () => newlineInCode$2,
  resetAttributes: () => resetAttributes$2,
  scrollIntoView: () => scrollIntoView$2,
  selectAll: () => selectAll$2,
  selectNodeBackward: () => selectNodeBackward$2,
  selectNodeForward: () => selectNodeForward$2,
  selectParentNode: () => selectParentNode$2,
  selectTextblockEnd: () => selectTextblockEnd$2,
  selectTextblockStart: () => selectTextblockStart$2,
  setContent: () => setContent$2,
  setMark: () => setMark$2,
  setMeta: () => setMeta$2,
  setNode: () => setNode$2,
  setNodeSelection: () => setNodeSelection$2,
  setTextSelection: () => setTextSelection$2,
  sinkListItem: () => sinkListItem$2,
  splitBlock: () => splitBlock$2,
  splitListItem: () => splitListItem$2,
  toggleList: () => toggleList$2,
  toggleMark: () => toggleMark$2,
  toggleNode: () => toggleNode$2,
  toggleWrap: () => toggleWrap$2,
  undoInputRule: () => undoInputRule$2,
  unsetAllMarks: () => unsetAllMarks$2,
  unsetMark: () => unsetMark$2,
  updateAttributes: () => updateAttributes$2,
  wrapIn: () => wrapIn$2,
  wrapInList: () => wrapInList$2
});
var blur$2 = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a2;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a2 = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
    }
  });
  return true;
};
var clearContent$2 = (emitUpdate = true) => ({ commands }) => {
  return commands.setContent("", { emitUpdate });
};
var clearNodes$2 = () => ({ state, tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr2;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command$2 = (fn) => (props) => {
  return fn(props);
};
var createParagraphNear$2 = () => ({ state, dispatch: dispatch2 }) => {
  return createParagraphNear$3(state, dispatch2);
};
var cut$2 = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(Math.max(newPos - 1, 0))));
  return true;
};
var deleteCurrentNode$2 = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode$2 = (typeOrName) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getNodeType$2(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange$2 = (range) => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { from: from2, to } = range;
  if (dispatch2) {
    tr2.delete(from2, to);
  }
  return true;
};
var deleteSelection$2 = () => ({ state, dispatch: dispatch2 }) => {
  return deleteSelection$3(state, dispatch2);
};
var enter$2 = () => ({ commands }) => {
  return commands.keyboardShortcut("Enter");
};
var exitCode$2 = () => ({ state, dispatch: dispatch2 }) => {
  return exitCode$3(state, dispatch2);
};
var extendMarkRange$2 = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getMarkType$2(typeOrName, state.schema);
  const { doc: doc2, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch2) {
    const range = getMarkRange$2($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc2, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
var first$2 = (commands) => (props) => {
  const items = typeof commands === "function" ? commands(props) : commands;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
function isAndroid$2() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS$2() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus$3 = (position = null, options = {}) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS$2() || isAndroid$2()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options == null ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch2 && position === null && !isTextSelection$2(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition$2(tr2.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch2) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach$2 = (items, fn) => (props) => {
  return items.every((item, index2) => fn(item, { ...props, index: index2 }));
};
var insertContent$2 = (value, options) => ({ tr: tr2, commands }) => {
  return commands.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
};
var isFragment$2 = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
var insertContentAt$2 = (position, value, options) => ({ tr: tr2, dispatch: dispatch2, editor }) => {
  var _a2;
  if (dispatch2) {
    options = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content;
    const emitContentError = (error) => {
      editor.emit("contentError", {
        editor,
        error,
        disableCollaboration: () => {
          if ("collaboration" in editor.storage && typeof editor.storage.collaboration === "object" && editor.storage.collaboration) {
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
    };
    const parseOptions = {
      preserveWhitespace: "full",
      ...options.parseOptions
    };
    if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {
      try {
        createNodeFromContent$2(value, editor.schema, {
          parseOptions,
          errorOnInvalidContent: true
        });
      } catch (e) {
        emitContentError(e);
      }
    }
    try {
      content = createNodeFromContent$2(value, editor.schema, {
        parseOptions,
        errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) != null ? _a2 : editor.options.enableContentCheck
      });
    } catch (e) {
      emitContentError(e);
      return false;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment$2(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr2.insertText(newContent, from2, to);
    } else {
      newContent = content;
      const $from = tr2.doc.resolve(from2);
      const $fromNode = $from.node();
      const fromSelectionAtStart = $from.parentOffset === 0;
      const isTextSelection2 = $fromNode.isText || $fromNode.isTextblock;
      const hasContent = $fromNode.content.size > 0;
      if (fromSelectionAtStart && isTextSelection2 && hasContent) {
        from2 = Math.max(0, from2 - 1);
      }
      tr2.replaceWith(from2, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd$2(tr2, tr2.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr2.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options.applyPasteRules) {
      tr2.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
var joinUp$2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinUp$3(state, dispatch2);
};
var joinDown$2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinDown$3(state, dispatch2);
};
var joinBackward$2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinBackward$3(state, dispatch2);
};
var joinForward$2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinForward$3(state, dispatch2);
};
var joinItemBackward$2 = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward$2 = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinTextblockBackward$2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockBackward$3(state, dispatch2);
};
var joinTextblockForward$2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockForward$3(state, dispatch2);
};
function isMacOS$2() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName$2(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS$2() || isMacOS$2()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut$2 = (name) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  const keys2 = normalizeKeyName$2(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch2) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
var lift$2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType$2(typeOrName, state.schema);
  const isActive2 = isNodeActive$2(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift$3(state, dispatch2);
};
var liftEmptyBlock$2 = () => ({ state, dispatch: dispatch2 }) => {
  return liftEmptyBlock$3(state, dispatch2);
};
var liftListItem$2 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType$2(typeOrName, state.schema);
  return liftListItem$3(type)(state, dispatch2);
};
var newlineInCode$2 = () => ({ state, dispatch: dispatch2 }) => {
  return newlineInCode$3(state, dispatch2);
};
function deleteProps$2(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes$2 = (typeOrName, attributes) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName$2(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType$2(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType$2(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr2.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, deleteProps$2(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps$2(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView$2 = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    tr2.scrollIntoView();
  }
  return true;
};
var selectAll$2 = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const selection = new AllSelection(tr2.doc);
    tr2.setSelection(selection);
  }
  return true;
};
var selectNodeBackward$2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeBackward$3(state, dispatch2);
};
var selectNodeForward$2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeForward$3(state, dispatch2);
};
var selectParentNode$2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectParentNode$3(state, dispatch2);
};
var selectTextblockEnd$2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockEnd$3(state, dispatch2);
};
var selectTextblockStart$2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockStart$3(state, dispatch2);
};
var setContent$2 = (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) => ({ editor, tr: tr2, dispatch: dispatch2, commands }) => {
  const { doc: doc2 } = tr2;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument$2(content, editor.schema, parseOptions, {
      errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
    });
    if (dispatch2) {
      tr2.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch2) {
    tr2.setMeta("preventUpdate", !emitUpdate);
  }
  return commands.insertContentAt({ from: 0, to: doc2.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
  });
};
function canSetMark$2(state, tr2, newMarkType) {
  var _a2;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection$2(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a2 = state.storedMarks) != null ? _a2 : cursor.marks();
    const parentAllowsMarkType = cursor.parent.type.allowsMarkType(newMarkType);
    return parentAllowsMarkType && (!!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType)));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark$2 = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType$2(typeOrName, state.schema);
  if (dispatch2) {
    if (empty2) {
      const oldAttributes = getMarkAttributes$2(state, type);
      tr2.addStoredMark(
        type.create({
          ...oldAttributes,
          ...attributes
        })
      );
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(
                  trimmedFrom,
                  trimmedTo,
                  type.create({
                    ...mark.attrs,
                    ...attributes
                  })
                );
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark$2(state, tr2, type);
};
var setMeta$2 = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
var setNode$2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2, chain: chain2 }) => {
  const type = getNodeType$2(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain2().command(({ commands }) => {
    const canSetBlock = setBlockType(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch2);
  }).run();
};
var setNodeSelection$2 = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr2;
    const from2 = minMax$2(position, 0, doc2.content.size);
    const selection = NodeSelection.create(doc2, from2);
    tr2.setSelection(selection);
  }
  return true;
};
var setTextSelection$2 = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr2;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc2).from;
    const maxPos = TextSelection.atEnd(doc2).to;
    const resolvedFrom = minMax$2(from2, minPos, maxPos);
    const resolvedEnd = minMax$2(to, minPos, maxPos);
    const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
var sinkListItem$2 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType$2(typeOrName, state.schema);
  return sinkListItem$3(type)(state, dispatch2);
};
function ensureMarks$2(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks == null ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock$2 = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  const { selection, doc: doc2 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes$2(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      if (keepMarks) {
        ensureMarks$2(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt$2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch2) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr2.deleteSelection();
      }
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks$2(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return can;
};
var splitListItem$2 = (typeOrName, overrideAttrs = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  var _a2;
  const type = getNodeType$2(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch2) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = (
        // eslint-disable-next-line no-nested-ternary
        $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3
      );
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes$2(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a2 = type.contentMatch.defaultType) == null ? void 0 : _a2.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start, tr2.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes$2(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes$2(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch2) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch2) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards$2 = (tr2, listType) => {
  const list = findParentNode$2((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
var joinListForwards$2 = (tr2, listType) => {
  const list = findParentNode$2((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
var toggleList$2 = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch: dispatch2, chain: chain2, commands, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType$2(listTypeOrName, state.schema);
  const itemType = getNodeType$2(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode$2((node) => isList$2(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands.liftListItem(itemType);
    }
    if (isList$2(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch2) {
      return chain2().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards$2(tr2, listType)).command(() => joinListForwards$2(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch2) {
    return chain2().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards$2(tr2, listType)).command(() => joinListForwards$2(tr2, listType)).run();
  }
  return chain2().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards$2(tr2, listType)).command(() => joinListForwards$2(tr2, listType)).run();
};
var toggleMark$2 = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType$2(typeOrName, state.schema);
  const isActive2 = isMarkActive$2(state, type, attributes);
  if (isActive2) {
    return commands.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands.setMark(type, attributes);
};
var toggleNode$2 = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType$2(typeOrName, state.schema);
  const toggleType = getNodeType$2(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive$2(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands.setNode(toggleType, attributesToCopy);
  }
  return commands.setNode(type, { ...attributesToCopy, ...attributes });
};
var toggleWrap$2 = (typeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType$2(typeOrName, state.schema);
  const isActive2 = isNodeActive$2(state, type, attributes);
  if (isActive2) {
    return commands.lift(type);
  }
  return commands.wrapIn(type, attributes);
};
var undoInputRule$2 = () => ({ state, dispatch: dispatch2 }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch2) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks$2 = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch2) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark$2 = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  var _a2;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr2;
  const type = getMarkType$2(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a2 = $from.marks().find((mark) => mark.type === type)) == null ? void 0 : _a2.attrs;
    const range = getMarkRange$2($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
var updateAttributes$2 = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName$2(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType$2(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType$2(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr2.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr2.selection.empty) {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
        });
      } else {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (pos < from2 && nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
          if (pos >= from2 && pos <= to) {
            if (nodeType && nodeType === node.type) {
              tr2.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom2 = Math.max(pos, from2);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr2.addMark(
                    trimmedFrom2,
                    trimmedTo2,
                    markType.create({
                      ...mark.attrs,
                      ...attributes
                    })
                  );
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== void 0) {
          tr2.setNodeMarkup(lastPos, void 0, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(
                trimmedFrom,
                trimmedTo,
                markType.create({
                  ...mark.attrs,
                  ...attributes
                })
              );
            }
          });
        }
      }
    });
  }
  return true;
};
var wrapIn$2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType$2(typeOrName, state.schema);
  return wrapIn$3(type, attributes)(state, dispatch2);
};
var wrapInList$2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType$2(typeOrName, state.schema);
  return wrapInList$3(type, attributes)(state, dispatch2);
};
var Commands$2 = Extension$2.create({
  name: "commands",
  addCommands() {
    return {
      ...commands_exports$2
    };
  }
});
var Delete$2 = Extension$2.create({
  name: "delete",
  onUpdate({ transaction: transaction2, appendedTransactions }) {
    var _a2, _b, _c;
    const callback = () => {
      var _a22, _b2, _c2, _d;
      if ((_d = (_c2 = (_b2 = (_a22 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a22.delete) == null ? void 0 : _b2.filterTransaction) == null ? void 0 : _c2.call(_b2, transaction2)) != null ? _d : transaction2.getMeta("y-sync$")) {
        return;
      }
      const nextTransaction = combineTransactionSteps$2(transaction2.before, [transaction2, ...appendedTransactions]);
      const changes = getChangedRanges$2(nextTransaction);
      changes.forEach((change) => {
        if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {
          nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from2) => {
            const to = from2 + node.nodeSize - 2;
            const isFullyWithinRange = change.oldRange.from <= from2 && to <= change.oldRange.to;
            this.editor.emit("delete", {
              type: "node",
              node,
              from: from2,
              to,
              newFrom: nextTransaction.mapping.map(from2),
              newTo: nextTransaction.mapping.map(to),
              deletedRange: change.oldRange,
              newRange: change.newRange,
              partial: !isFullyWithinRange,
              editor: this.editor,
              transaction: transaction2,
              combinedTransform: nextTransaction
            });
          });
        }
      });
      const mapping = nextTransaction.mapping;
      nextTransaction.steps.forEach((step, index2) => {
        var _a3, _b3;
        if (step instanceof RemoveMarkStep) {
          const newStart = mapping.slice(index2).map(step.from, -1);
          const newEnd = mapping.slice(index2).map(step.to);
          const oldStart = mapping.invert().map(newStart, -1);
          const oldEnd = mapping.invert().map(newEnd);
          const foundBeforeMark = (_a3 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a3.marks.some((mark) => mark.eq(step.mark));
          const foundAfterMark = (_b3 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b3.marks.some((mark) => mark.eq(step.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: step.mark,
            from: step.from,
            to: step.to,
            deletedRange: {
              from: oldStart,
              to: oldEnd
            },
            newRange: {
              from: newStart,
              to: newEnd
            },
            partial: Boolean(foundAfterMark || foundBeforeMark),
            editor: this.editor,
            transaction: transaction2,
            combinedTransform: nextTransaction
          });
        }
      });
    };
    if ((_c = (_b = (_a2 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a2.delete) == null ? void 0 : _b.async) != null ? _c : true) {
      setTimeout(callback, 0);
    } else {
      callback();
    }
  }
});
var Drop$2 = Extension$2.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e, slice2, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: slice2,
              moved
            });
          }
        }
      })
    ];
  }
});
var Editable$2 = Extension$2.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var focusEventsPluginKey$2 = new PluginKey("focusEvents");
var FocusEvents$2 = Extension$2.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: focusEventsPluginKey$2,
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction2 = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction2 = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap$2 = Extension$2.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands.command(({ tr: tr2 }) => {
        const { selection, doc: doc2 } = tr2;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands.clearNodes();
      }),
      () => commands.deleteSelection(),
      () => commands.joinBackward(),
      () => commands.selectNodeBackward()
    ]);
    const handleDelete2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.deleteSelection(),
      () => commands.deleteCurrentNode(),
      () => commands.joinForward(),
      () => commands.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands }) => [
      () => commands.newlineInCode(),
      () => commands.createParagraphNear(),
      () => commands.liftEmptyBlock(),
      () => commands.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace2,
      "Mod-Backspace": handleBackspace2,
      "Shift-Backspace": handleBackspace2,
      Delete: handleDelete2,
      "Mod-Delete": handleDelete2,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace2,
      "Alt-Backspace": handleBackspace2,
      "Ctrl-d": handleDelete2,
      "Ctrl-Alt-Backspace": handleDelete2,
      "Alt-Delete": handleDelete2,
      "Alt-d": handleDelete2,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS$2() || isMacOS$2()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr22) => tr22.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction2) => transaction2.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction2) => transaction2.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty = isNodeEmpty$2(newState.doc);
          if (!isEmpty) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState$2({
            state: newState,
            transaction: tr2
          });
          const { commands } = new CommandManager$2({
            editor: this.editor,
            state
          });
          commands.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
var Paste$2 = Extension$2.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e, slice2) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: slice2
            });
          }
        }
      })
    ];
  }
});
var Tabindex$2 = Extension$2.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
const schemaCache = new WeakCache();
function getTipTapSchema(tipTapConfig) {
  return schemaCache.get(tipTapConfig, () => getSchema$1(tipTapConfig.extensions ?? []));
}
function getFontsFromRichText(editor, richText, initialState2) {
  const { tipTapConfig, addFontsFromNode } = editor.getTextOptions();
  assert(tipTapConfig, "textOptions.tipTapConfig must be set to use rich text");
  assert(addFontsFromNode, "textOptions.addFontsFromNode must be set to use rich text");
  const schema = getTipTapSchema(tipTapConfig);
  const rootNode = Node$1.fromJSON(schema, richText);
  const fonts = /* @__PURE__ */ new Set();
  function addFont(font) {
    fonts.add(font);
  }
  function visit(node, state) {
    state = addFontsFromNode(node, state, addFont);
    for (const child of node.children) {
      visit(child, state);
    }
  }
  visit(rootNode, initialState2);
  return Array.from(fonts);
}
async function hardReset({ shouldReload = true } = {}) {
  clearSessionStorage();
  for (const instance of LocalIndexedDb.connectedInstances) {
    await instance.close();
  }
  await Promise.all(getAllIndexDbNames().map((db) => deleteDB(db)));
  clearLocalStorage();
  if (shouldReload) {
    window.location.reload();
  }
}
if (typeof window !== "undefined") {
  window.__tldraw__hardReset = hardReset;
}
function openWindow(url, target = "_blank", allowReferrer) {
  return runtime.openWindow(url, target, allowReferrer);
}
registerTldrawLibraryVersion(
  "@tldraw/editor",
  "4.2.0",
  "esm"
);
class PathBuilder {
  static lineThroughPoints(points, opts) {
    const path = new PathBuilder();
    path.moveTo(points[0].x, points[0].y, { ...opts, offset: opts?.endOffsets ?? opts?.offset });
    for (let i = 1; i < points.length; i++) {
      const isLast = i === points.length - 1;
      path.lineTo(points[i].x, points[i].y, isLast ? { offset: opts?.endOffsets } : void 0);
    }
    return path;
  }
  static cubicSplineThroughPoints(points, opts) {
    const path = new PathBuilder();
    const len = points.length;
    const last2 = len - 2;
    const k = 1.25;
    path.moveTo(points[0].x, points[0].y, { ...opts, offset: opts?.endOffsets ?? opts?.offset });
    for (let i = 0; i < len - 1; i++) {
      const p0 = i === 0 ? points[0] : points[i - 1];
      const p1 = points[i];
      const p2 = points[i + 1];
      const p3 = i === last2 ? p2 : points[i + 2];
      let cp1x, cp1y, cp2x, cp2y;
      if (i === 0) {
        cp1x = p0.x;
        cp1y = p0.y;
      } else {
        cp1x = p1.x + (p2.x - p0.x) / 6 * k;
        cp1y = p1.y + (p2.y - p0.y) / 6 * k;
      }
      let pointOpts = void 0;
      if (i === last2) {
        cp2x = p2.x;
        cp2y = p2.y;
        pointOpts = { offset: opts?.endOffsets };
      } else {
        cp2x = p2.x - (p3.x - p1.x) / 6 * k;
        cp2y = p2.y - (p3.y - p1.y) / 6 * k;
      }
      path.cubicBezierTo(p2.x, p2.y, cp1x, cp1y, cp2x, cp2y, pointOpts);
    }
    return path;
  }
  constructor() {
  }
  /** @internal */
  commands = [];
  lastMoveTo = null;
  assertHasMoveTo() {
    assert(this.lastMoveTo, "Start an SVGPathBuilder with `.moveTo()`");
    return this.lastMoveTo;
  }
  moveTo(x, y, opts) {
    this.lastMoveTo = { type: "move", x, y, closeIdx: null, isClose: false, opts };
    this.commands.push(this.lastMoveTo);
    return this;
  }
  lineTo(x, y, opts) {
    this.assertHasMoveTo();
    this.commands.push({ type: "line", x, y, isClose: false, opts });
    return this;
  }
  circularArcTo(radius, largeArcFlag, sweepFlag, x2, y2, opts) {
    return this.arcTo(radius, radius, largeArcFlag, sweepFlag, 0, x2, y2, opts);
  }
  arcTo(rx, ry, largeArcFlag, sweepFlag, xAxisRotationRadians, x2, y2, opts) {
    this.assertHasMoveTo();
    const x1 = this.commands[this.commands.length - 1].x;
    const y1 = this.commands[this.commands.length - 1].y;
    if (x1 === x2 && y1 === y2) {
      return this;
    }
    if (rx === 0 || ry === 0) {
      return this.lineTo(x2, y2, opts);
    }
    const phi = xAxisRotationRadians;
    const sinPhi = Math.sin(phi);
    const cosPhi = Math.cos(phi);
    let rx1 = Math.abs(rx);
    let ry1 = Math.abs(ry);
    const dx = (x1 - x2) / 2;
    const dy = (y1 - y2) / 2;
    const x1p = cosPhi * dx + sinPhi * dy;
    const y1p = -sinPhi * dx + cosPhi * dy;
    const lambda = x1p * x1p / (rx1 * rx1) + y1p * y1p / (ry1 * ry1);
    if (lambda > 1) {
      const sqrtLambda = Math.sqrt(lambda);
      rx1 *= sqrtLambda;
      ry1 *= sqrtLambda;
    }
    const sign = largeArcFlag !== sweepFlag ? 1 : -1;
    const term = rx1 * rx1 * ry1 * ry1 - rx1 * rx1 * y1p * y1p - ry1 * ry1 * x1p * x1p;
    const numerator = rx1 * rx1 * y1p * y1p + ry1 * ry1 * x1p * x1p;
    let radicand = term / numerator;
    radicand = radicand < 0 ? 0 : radicand;
    const coef = sign * Math.sqrt(radicand);
    const cxp = coef * (rx1 * y1p / ry1);
    const cyp = coef * (-(ry1 * x1p) / rx1);
    const cx = cosPhi * cxp - sinPhi * cyp + (x1 + x2) / 2;
    const cy = sinPhi * cxp + cosPhi * cyp + (y1 + y2) / 2;
    const ux = (x1p - cxp) / rx1;
    const uy = (y1p - cyp) / ry1;
    const vx = (-x1p - cxp) / rx1;
    const vy = (-y1p - cyp) / ry1;
    const startAngle = Math.atan2(uy, ux);
    let endAngle = Math.atan2(vy, vx);
    if (!sweepFlag && endAngle > startAngle) {
      endAngle -= 2 * Math.PI;
    } else if (sweepFlag && endAngle < startAngle) {
      endAngle += 2 * Math.PI;
    }
    const sweepAngle = endAngle - startAngle;
    const approximateArcLength = Math.max(rx1, ry1) * Math.abs(sweepAngle);
    const numSegments = Math.min(4, Math.ceil(Math.abs(sweepAngle) / (Math.PI / 2)));
    const resolutionPerSegment = Math.ceil(
      getVerticesCountForArcLength(approximateArcLength) / numSegments
    );
    const anglePerSegment = sweepAngle / numSegments;
    const ellipsePoint = (angle) => {
      return {
        x: cx + rx1 * Math.cos(angle) * cosPhi - ry1 * Math.sin(angle) * sinPhi,
        y: cy + rx1 * Math.cos(angle) * sinPhi + ry1 * Math.sin(angle) * cosPhi
      };
    };
    const ellipseDerivative = (angle) => {
      return {
        x: -rx1 * Math.sin(angle) * cosPhi - ry1 * Math.cos(angle) * sinPhi,
        y: -rx1 * Math.sin(angle) * sinPhi + ry1 * Math.cos(angle) * cosPhi
      };
    };
    for (let i = 0; i < numSegments; i++) {
      const theta1 = startAngle + i * anglePerSegment;
      const theta2 = startAngle + (i + 1) * anglePerSegment;
      const deltaTheta = theta2 - theta1;
      const start = ellipsePoint(theta1);
      const end = ellipsePoint(theta2);
      const d1 = ellipseDerivative(theta1);
      const d2 = ellipseDerivative(theta2);
      const handleScale = 4 / 3 * Math.tan(deltaTheta / 4);
      const cp1x = start.x + handleScale * d1.x;
      const cp1y = start.y + handleScale * d1.y;
      const cp2x = end.x - handleScale * d2.x;
      const cp2y = end.y - handleScale * d2.y;
      const bezierOpts = i === 0 ? opts : { ...opts, mergeWithPrevious: true };
      this.cubicBezierToWithResolution(
        end.x,
        end.y,
        cp1x,
        cp1y,
        cp2x,
        cp2y,
        bezierOpts,
        resolutionPerSegment
      );
    }
    return this;
  }
  cubicBezierTo(x, y, cp1X, cp1Y, cp2X, cp2Y, opts) {
    return this.cubicBezierToWithResolution(x, y, cp1X, cp1Y, cp2X, cp2Y, opts);
  }
  cubicBezierToWithResolution(x, y, cp1X, cp1Y, cp2X, cp2Y, opts, resolution) {
    this.assertHasMoveTo();
    this.commands.push({
      type: "cubic",
      x,
      y,
      cp1: { x: cp1X, y: cp1Y },
      cp2: { x: cp2X, y: cp2Y },
      isClose: false,
      opts,
      resolution
    });
    return this;
  }
  close() {
    const lastMoveTo = this.assertHasMoveTo();
    const lastCommand = this.commands[this.commands.length - 1];
    if (approximately(lastMoveTo.x, lastCommand.x) && approximately(lastMoveTo.y, lastCommand.y)) {
      lastCommand.isClose = true;
    } else {
      this.commands.push({
        type: "line",
        x: lastMoveTo.x,
        y: lastMoveTo.y,
        isClose: true
      });
    }
    lastMoveTo.closeIdx = this.commands.length - 1;
    this.lastMoveTo = null;
    return this;
  }
  toD(opts = {}) {
    const { startIdx = 0, endIdx = this.commands.length, onlyFilled = false } = opts;
    const parts = [];
    let isSkippingCurrentLine = false;
    let didAddMove = false;
    let didAddNaturalMove = false;
    const addMoveIfNeeded = (i) => {
      if (didAddMove || i === 0) return;
      didAddMove = true;
      const command2 = this.commands[i - 1];
      parts.push("M", toDomPrecision(command2.x), toDomPrecision(command2.y));
    };
    for (let i = startIdx; i < endIdx; i++) {
      const command2 = this.commands[i];
      switch (command2.type) {
        case "move": {
          const isFilled = command2.opts?.geometry === false ? false : command2.opts?.geometry?.isFilled ?? false;
          if (onlyFilled && !isFilled) {
            isSkippingCurrentLine = true;
          } else {
            isSkippingCurrentLine = false;
            didAddMove = true;
            didAddNaturalMove = true;
            parts.push("M", toDomPrecision(command2.x), toDomPrecision(command2.y));
          }
          break;
        }
        case "line":
          if (isSkippingCurrentLine) break;
          addMoveIfNeeded(i);
          if (command2.isClose && didAddNaturalMove) {
            parts.push("Z");
          } else {
            parts.push("L", toDomPrecision(command2.x), toDomPrecision(command2.y));
          }
          break;
        case "cubic":
          if (isSkippingCurrentLine) break;
          addMoveIfNeeded(i);
          parts.push(
            "C",
            toDomPrecision(command2.cp1.x),
            toDomPrecision(command2.cp1.y),
            toDomPrecision(command2.cp2.x),
            toDomPrecision(command2.cp2.y),
            toDomPrecision(command2.x),
            toDomPrecision(command2.y)
          );
          break;
        default:
          exhaustiveSwitchError(command2, "type");
      }
    }
    return parts.join(" ");
  }
  toSvg(opts) {
    if (opts.forceSolid) {
      return this.toSolidSvg(opts);
    }
    switch (opts.style) {
      case "solid":
        return this.toSolidSvg(opts);
      case "dashed":
      case "dotted":
        return this.toDashedSvg(opts);
      case "draw": {
        const d = this.toDrawSvg(opts);
        return d;
      }
      default:
        exhaustiveSwitchError(opts, "style");
    }
  }
  toGeometry() {
    const geometries = [];
    let current = null;
    for (let i = 0; i < this.commands.length; i++) {
      const command2 = this.commands[i];
      if (command2.type === "move") {
        if (current && current.opts?.geometry !== false) {
          geometries.push(
            new PathBuilderGeometry2d(this, current.startIdx, i, {
              ...current.opts?.geometry,
              isFilled: current.opts?.geometry?.isFilled ?? false,
              isClosed: current.moveCommand.closeIdx !== null
            })
          );
        }
        current = { startIdx: i, moveCommand: command2, opts: command2.opts, isClosed: false };
      }
      if (command2.isClose) {
        assert(current, "No current move command");
        current.isClosed = true;
      }
    }
    if (current && current.opts?.geometry !== false) {
      geometries.push(
        new PathBuilderGeometry2d(this, current.startIdx, this.commands.length, {
          ...current.opts?.geometry,
          isFilled: current.opts?.geometry?.isFilled ?? false,
          isClosed: current.moveCommand.closeIdx !== null
        })
      );
    }
    assert(geometries.length > 0);
    if (geometries.length === 1) return geometries[0];
    return new Group2d({ children: geometries });
  }
  toSolidSvg(opts) {
    const { strokeWidth, props } = opts;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeWidth, d: this.toD({ onlyFilled: opts.onlyFilled }), ...props });
  }
  toDashedSvg(opts) {
    const {
      style: style2,
      strokeWidth,
      snap,
      lengthRatio,
      props: { markerStart, markerEnd, ...props } = {}
    } = opts;
    const parts = [];
    let isCurrentPathClosed = false;
    let isSkippingCurrentLine = false;
    let currentLineOpts = void 0;
    let currentRun = null;
    const addCurrentRun = () => {
      if (!currentRun) return;
      const { startIdx, endIdx, isFirst, isLast, length, lineOpts, pathIsClosed } = currentRun;
      currentRun = null;
      if (startIdx === endIdx && this.commands[startIdx].type === "move") return;
      const start = lineOpts?.dashStart ?? opts.start;
      const end = lineOpts?.dashEnd ?? opts.end;
      const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(length, strokeWidth, {
        style: style2,
        snap,
        lengthRatio,
        start: isFirst ? start ?? (pathIsClosed ? "outset" : "none") : "outset",
        end: isLast ? end ?? (pathIsClosed ? "outset" : "none") : "outset"
      });
      const d = this.toD({ startIdx, endIdx: endIdx + 1 });
      parts.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d,
            strokeDasharray,
            strokeDashoffset,
            markerStart: isFirst ? markerStart : void 0,
            markerEnd: isLast ? markerEnd : void 0
          },
          parts.length
        )
      );
    };
    for (let i = 0; i < this.commands.length; i++) {
      const command2 = this.commands[i];
      const lastCommand = this.commands[i - 1];
      if (command2.type === "move") {
        isCurrentPathClosed = command2.closeIdx !== null;
        const isFilled = command2.opts?.geometry === false ? false : command2.opts?.geometry?.isFilled ?? false;
        if (opts.onlyFilled && !isFilled) {
          isSkippingCurrentLine = true;
        } else {
          isSkippingCurrentLine = false;
          currentLineOpts = command2.opts;
        }
        continue;
      }
      if (isSkippingCurrentLine) continue;
      const segmentLength = this.calculateSegmentLength(lastCommand, command2);
      const isFirst = lastCommand.type === "move";
      const isLast = command2.isClose || i === this.commands.length - 1 || this.commands[i + 1]?.type === "move";
      if (currentRun && command2.opts?.mergeWithPrevious) {
        currentRun.length += segmentLength;
        currentRun.endIdx = i;
        currentRun.isLast = isLast;
      } else {
        addCurrentRun();
        currentRun = {
          startIdx: i,
          endIdx: i,
          isFirst,
          isLast,
          length: segmentLength,
          lineOpts: currentLineOpts,
          pathIsClosed: isCurrentPathClosed
        };
      }
    }
    addCurrentRun();
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { strokeWidth, ...props, children: parts });
  }
  toDrawSvg(opts) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeWidth: opts.strokeWidth, d: this.toDrawD(opts), ...opts.props });
  }
  toDrawD(opts) {
    const {
      strokeWidth,
      randomSeed,
      offset: defaultOffset = strokeWidth / 3,
      roundness: defaultRoundness = strokeWidth * 2,
      passes = 2,
      onlyFilled = false
    } = opts;
    const parts = [];
    const commandInfo = this.getCommandInfo();
    const drawCommands = [];
    let lastMoveCommandIdx = null;
    for (let i = 0; i < this.commands.length; i++) {
      const command2 = this.commands[i];
      const offset2 = command2.opts?.offset ?? defaultOffset;
      const roundness = command2.opts?.roundness ?? defaultRoundness;
      if (command2.type === "move") {
        lastMoveCommandIdx = i;
      }
      const nextIdx = command2.isClose ? assertExists(lastMoveCommandIdx) + 1 : !this.commands[i + 1] || this.commands[i + 1].type === "move" ? void 0 : i + 1;
      const nextInfo = nextIdx !== void 0 && this.commands[nextIdx] && this.commands[nextIdx]?.type !== "move" ? commandInfo[nextIdx] : void 0;
      const currentSupportsRoundness = commandsSupportingRoundness[command2.type];
      const nextSupportsRoundness = nextIdx !== void 0 ? commandsSupportingRoundness[this.commands[nextIdx].type] : false;
      const currentInfo = commandInfo[i];
      const tangentToPrev = currentInfo?.tangentEnd;
      const tangentToNext = nextInfo?.tangentStart;
      const roundnessClampedForAngle = currentSupportsRoundness && nextSupportsRoundness && tangentToPrev && tangentToNext && Vec.Len2(tangentToPrev) > 0.01 && Vec.Len2(tangentToNext) > 0.01 ? modulate(
        Math.abs(Vec.AngleBetween(tangentToPrev, tangentToNext)),
        [Math.PI / 2, Math.PI],
        [roundness, 0],
        true
      ) : 0;
      const shortestDistance = Math.min(
        currentInfo?.length ?? Infinity,
        nextInfo?.length ?? Infinity
      );
      const offsetLimit = shortestDistance - roundnessClampedForAngle * 2;
      const offsetAmount = clamp$3(offset2, 0, offsetLimit / 4);
      const roundnessBeforeClampedForLength = Math.min(
        roundnessClampedForAngle,
        (currentInfo?.length ?? Infinity) / 4
      );
      const roundnessAfterClampedForLength = Math.min(
        roundnessClampedForAngle,
        (nextInfo?.length ?? Infinity) / 4
      );
      const drawCommand = {
        command: command2,
        offsetAmount,
        roundnessBefore: roundnessBeforeClampedForLength,
        roundnessAfter: roundnessAfterClampedForLength,
        tangentToPrev: commandInfo[i]?.tangentEnd,
        tangentToNext: nextInfo?.tangentStart,
        moveDidClose: false
      };
      drawCommands.push(drawCommand);
      if (command2.isClose && lastMoveCommandIdx !== null) {
        const lastMoveCommand = drawCommands[lastMoveCommandIdx];
        lastMoveCommand.moveDidClose = true;
        lastMoveCommand.roundnessAfter = roundnessAfterClampedForLength;
      } else if (command2.type === "move") {
        lastMoveCommandIdx = i;
      }
    }
    for (let pass = 0; pass < passes; pass++) {
      const random = rng(randomSeed + pass);
      let lastMoveToOffset = { x: 0, y: 0 };
      let isSkippingCurrentLine = false;
      for (const {
        command: command2,
        offsetAmount,
        roundnessBefore,
        roundnessAfter,
        tangentToNext,
        tangentToPrev
      } of drawCommands) {
        const offset2 = command2.isClose ? lastMoveToOffset : { x: random() * offsetAmount, y: random() * offsetAmount };
        if (command2.type === "move") {
          lastMoveToOffset = offset2;
          const isFilled = command2.opts?.geometry === false ? false : command2.opts?.geometry?.isFilled ?? false;
          if (onlyFilled && !isFilled) {
            isSkippingCurrentLine = true;
          } else {
            isSkippingCurrentLine = false;
          }
        }
        if (isSkippingCurrentLine) continue;
        const offsetPoint = Vec.Add(command2, offset2);
        const endPoint = tangentToNext && roundnessAfter > 0 ? Vec.Mul(tangentToNext, -roundnessAfter).add(offsetPoint) : offsetPoint;
        const startPoint = tangentToPrev && roundnessBefore > 0 ? Vec.Mul(tangentToPrev, roundnessBefore).add(offsetPoint) : offsetPoint;
        if (endPoint === offsetPoint || startPoint === offsetPoint) {
          switch (command2.type) {
            case "move":
              parts.push("M", toDomPrecision(endPoint.x), toDomPrecision(endPoint.y));
              break;
            case "line":
              parts.push("L", toDomPrecision(endPoint.x), toDomPrecision(endPoint.y));
              break;
            case "cubic": {
              const offsetCp1 = Vec.Add(command2.cp1, offset2);
              const offsetCp2 = Vec.Add(command2.cp2, offset2);
              parts.push(
                "C",
                toDomPrecision(offsetCp1.x),
                toDomPrecision(offsetCp1.y),
                toDomPrecision(offsetCp2.x),
                toDomPrecision(offsetCp2.y),
                toDomPrecision(endPoint.x),
                toDomPrecision(endPoint.y)
              );
              break;
            }
            default:
              exhaustiveSwitchError(command2, "type");
          }
        } else {
          switch (command2.type) {
            case "move":
              parts.push("M", toDomPrecision(endPoint.x), toDomPrecision(endPoint.y));
              break;
            case "line":
              parts.push(
                "L",
                toDomPrecision(startPoint.x),
                toDomPrecision(startPoint.y),
                "Q",
                toDomPrecision(offsetPoint.x),
                toDomPrecision(offsetPoint.y),
                toDomPrecision(endPoint.x),
                toDomPrecision(endPoint.y)
              );
              break;
            case "cubic": {
              const offsetCp1 = Vec.Add(command2.cp1, offset2);
              const offsetCp2 = Vec.Add(command2.cp2, offset2);
              parts.push(
                "C",
                toDomPrecision(offsetCp1.x),
                toDomPrecision(offsetCp1.y),
                toDomPrecision(offsetCp2.x),
                toDomPrecision(offsetCp2.y),
                toDomPrecision(offsetPoint.x),
                toDomPrecision(offsetPoint.y)
              );
              break;
            }
            default:
              exhaustiveSwitchError(command2, "type");
          }
        }
      }
    }
    return parts.join(" ");
  }
  calculateSegmentLength(lastPoint, command2) {
    switch (command2.type) {
      case "move":
        return 0;
      case "line":
        return Vec.Dist(lastPoint, command2);
      case "cubic":
        return CubicBezier.length(
          lastPoint.x,
          lastPoint.y,
          command2.cp1.x,
          command2.cp1.y,
          command2.cp2.x,
          command2.cp2.y,
          command2.x,
          command2.y
        );
      default:
        exhaustiveSwitchError(command2, "type");
    }
  }
  /** @internal */
  getCommands() {
    return this.commands;
  }
  /** @internal */
  getCommandInfo() {
    const commandInfo = [];
    for (let i = 1; i < this.commands.length; i++) {
      const previous = this.commands[i - 1];
      const current = this.commands[i];
      if (current._info) {
        commandInfo[i] = current._info;
        continue;
      }
      if (current.type === "move") {
        continue;
      }
      let tangentStart, tangentEnd;
      switch (current.type) {
        case "line":
          tangentStart = tangentEnd = Vec.Sub(previous, current).uni();
          break;
        case "cubic": {
          tangentStart = Vec.Sub(current.cp1, previous).uni();
          tangentEnd = Vec.Sub(current.cp2, current).uni();
          break;
        }
        default:
          exhaustiveSwitchError(current, "type");
      }
      current._info = {
        tangentStart,
        tangentEnd,
        length: this.calculateSegmentLength(previous, current)
      };
      commandInfo[i] = current._info;
    }
    return commandInfo;
  }
}
const commandsSupportingRoundness = {
  line: true,
  move: true,
  cubic: false
};
class PathBuilderGeometry2d extends Geometry2d {
  constructor(path, startIdx, endIdx, options) {
    super(options);
    this.path = path;
    this.startIdx = startIdx;
    this.endIdx = endIdx;
  }
  _segments = null;
  getSegments() {
    if (this._segments) return this._segments;
    this._segments = [];
    let last2 = this.path.commands[this.startIdx];
    assert(last2.type === "move");
    for (let i = this.startIdx + 1; i < this.endIdx; i++) {
      const command2 = this.path.commands[i];
      assert(command2.type !== "move");
      switch (command2.type) {
        case "line":
          this._segments.push(new Edge2d({ start: Vec.From(last2), end: Vec.From(command2) }));
          break;
        case "cubic": {
          this._segments.push(
            new CubicBezier2d({
              start: Vec.From(last2),
              cp1: Vec.From(command2.cp1),
              cp2: Vec.From(command2.cp2),
              end: Vec.From(command2),
              resolution: command2.resolution
            })
          );
          break;
        }
        default:
          exhaustiveSwitchError(command2, "type");
      }
      last2 = command2;
    }
    return this._segments;
  }
  getVertices(filters) {
    const vs = this.getSegments().flatMap((s) => s.getVertices(filters)).filter((vertex, i, vertices) => {
      const prev = vertices[i - 1];
      if (!prev) return true;
      return !Vec.Equals(prev, vertex);
    });
    if (this.isClosed) {
      const last2 = vs[vs.length - 1];
      const first2 = vs[0];
      if (!Vec.Equals(last2, first2)) {
        vs.push(first2);
      }
    }
    return vs;
  }
  nearestPoint(point, _filters) {
    let nearest = null;
    let nearestDistance = Infinity;
    for (const segment of this.getSegments()) {
      const candidate = segment.nearestPoint(point);
      const distance = Vec.Dist2(point, candidate);
      if (distance < nearestDistance) {
        nearestDistance = distance;
        nearest = candidate;
      }
    }
    assert(nearest, "No nearest point found");
    return nearest;
  }
  hitTestLineSegment(A, B, distance = 0, filters) {
    return super.hitTestLineSegment(A, B, distance, filters);
  }
  getSvgPathData() {
    return this.path.toD({ startIdx: this.startIdx, endIdx: this.endIdx });
  }
}
const CubicBezier = {
  base3(t2, p1, p2, p3, p4) {
    const t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
    const t22 = t2 * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t2 * t22 - 3 * p1 + 3 * p2;
  },
  /**
   * Calculate the approximate length of a cubic bezier curve from (x1, y1) to (x4, y4) with
   * control points (x2, y2) and (x3, y3).
   */
  length(x1, y1, x2, y2, x3, y3, x4, y4, z = 1) {
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    const z2 = z / 2;
    const n = 12;
    let sum = 0;
    sum = 0;
    for (let i = 0; i < n; i++) {
      const ct = z2 * CubicBezier.Tvalues[i] + z2;
      const xbase = CubicBezier.base3(ct, x1, x2, x3, x4);
      const ybase = CubicBezier.base3(ct, y1, y2, y3, y4);
      const comb = xbase * xbase + ybase * ybase;
      sum += CubicBezier.Cvalues[i] * Math.sqrt(comb);
    }
    return z2 * sum;
  },
  Tvalues: [
    -0.1252,
    0.1252,
    -0.3678,
    0.3678,
    -0.5873,
    0.5873,
    -0.7699,
    0.7699,
    -0.9041,
    0.9041,
    -0.9816,
    0.9816
  ],
  Cvalues: [
    0.2491,
    0.2491,
    0.2335,
    0.2335,
    0.2032,
    0.2032,
    0.1601,
    0.1601,
    0.1069,
    0.1069,
    0.0472,
    0.0472
  ]
};
function usePrefersReducedMotion() {
  const editor = useMaybeEditor();
  const animationSpeed = useValue("animationSpeed", () => editor?.user.getAnimationSpeed(), [
    editor
  ]);
  const [prefersReducedMotion, setPrefersReducedMotion] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (animationSpeed !== void 0) {
      setPrefersReducedMotion(animationSpeed === 0 ? true : false);
      return;
    }
    if (typeof window === "undefined" || !("matchMedia" in window)) return;
    const mql = window.matchMedia("(prefers-reduced-motion: reduce)");
    const handler = () => {
      setPrefersReducedMotion(mql.matches);
    };
    handler();
    mql.addEventListener("change", handler);
    return () => mql.removeEventListener("change", handler);
  }, [animationSpeed]);
  return prefersReducedMotion;
}
const A11yContext = reactExports.createContext(null);
function TldrawUiA11yProvider({ children }) {
  const currentMsg = useAtom("a11y", { msg: "", priority: "assertive" });
  const ctx = reactExports.useContext(A11yContext);
  const current = reactExports.useMemo(
    () => ({
      currentMsg,
      announce(msg2) {
        if (!msg2) return;
        currentMsg.set(msg2);
      }
    }),
    [currentMsg]
  );
  if (ctx) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(A11yContext.Provider, { value: current, children });
}
function useA11y() {
  const ctx = reactExports.useContext(A11yContext);
  if (!ctx) {
    throw new Error("useA11y must be used within a A11yContext.Provider");
  }
  return ctx;
}
const AssetUrlsContext = reactExports.createContext(null);
function AssetUrlsProvider({
  assetUrls,
  children
}) {
  reactExports.useEffect(() => {
    for (const src of Object.values(assetUrls.icons)) {
      if (!src) continue;
      const image = Image();
      image.crossOrigin = "anonymous";
      image.src = src;
      image.decode();
    }
    for (const src of Object.values(assetUrls.embedIcons)) {
      if (!src) continue;
      const image = Image();
      image.crossOrigin = "anonymous";
      image.src = src;
      image.decode();
    }
  }, [assetUrls]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AssetUrlsContext.Provider, { value: assetUrls, children });
}
function useAssetUrls() {
  const assetUrls = reactExports.useContext(AssetUrlsContext);
  if (!assetUrls) {
    throw new Error("useAssetUrls must be used within an AssetUrlsProvider");
  }
  return assetUrls;
}
const DEFAULT_TRANSLATION = {
  "action.toggle-auto-pan": "Auto (trackpad)",
  "action.toggle-auto-zoom": "Auto (mouse)",
  "action.toggle-auto-none": "Auto",
  "action.toggle-mouse": "Mouse",
  "action.toggle-trackpad": "Trackpad",
  "action.convert-to-bookmark": "Convert to bookmark",
  "action.convert-to-embed": "Convert to embed",
  "action.open-embed-link": "Open link",
  "action.align-bottom": "Align bottom",
  "action.align-center-horizontal": "Align horizontally",
  "action.align-center-vertical": "Align vertically",
  "action.align-center-horizontal.short": "Align H",
  "action.align-center-vertical.short": "Align V",
  "action.align-left": "Align left",
  "action.align-right": "Align right",
  "action.align-top": "Align top",
  "action.back-to-content": "Back to content",
  "action.bring-forward": "Bring forward",
  "action.bring-to-front": "Bring to front",
  "action.copy-as-png.short": "PNG",
  "action.copy-as-png": "Copy as PNG",
  "action.copy-as-svg.short": "SVG",
  "action.copy-as-svg": "Copy as SVG",
  "action.copy": "Copy",
  "action.cut": "Cut",
  "action.delete": "Delete",
  "action.unlock-all": "Unlock all",
  "action.distribute-horizontal": "Distribute horizontally",
  "action.distribute-vertical": "Distribute vertically",
  "action.distribute-horizontal.short": "Distribute H",
  "action.distribute-vertical.short": "Distribute V",
  "action.download-original": "Download original",
  "action.duplicate": "Duplicate",
  "action.edit-link": "Edit link",
  "action.exit-pen-mode": "Exit pen mode",
  "action.export-as-png.short": "PNG",
  "action.export-as-png": "Export as PNG",
  "action.export-as-svg.short": "SVG",
  "action.export-as-svg": "Export as SVG",
  "action.export-all-as-png.short": "PNG",
  "action.export-all-as-png": "Export as PNG",
  "action.export-all-as-svg.short": "SVG",
  "action.export-all-as-svg": "Export as SVG",
  "action.fit-frame-to-content": "Fit to content",
  "action.flip-horizontal": "Flip horizontally",
  "action.flip-vertical": "Flip vertically",
  "action.flip-horizontal.short": "Flip H",
  "action.flip-vertical.short": "Flip V",
  "action.fork-project": "Fork this project",
  "action.fork-project-on-tldraw": "Fork project on tldraw",
  "action.group": "Group",
  "action.insert-embed": "Insert embed",
  "action.insert-media": "Upload media",
  "action.leave-shared-project": "Leave shared project",
  "action.new-project": "New project",
  "action.new-shared-project": "New shared project",
  "action.open-cursor-chat": "Cursor chat",
  "action.open-kbd-shortcuts": "Open keyboard shortcuts",
  "action.open-file": "Open file",
  "action.pack": "Pack",
  "action.paste": "Paste",
  "action.paste-error-title": "Pasting failed",
  "action.paste-error-description": "Could not paste due to missing clipboard permissions. Please enable the permissions and try again.",
  "action.print": "Print",
  "action.redo": "Redo",
  "action.remove-frame": "Remove frame",
  "action.rename": "Rename",
  "action.rotate-ccw": "Rotate counterclockwise",
  "action.rotate-cw": "Rotate clockwise",
  "action.save-copy": "Save a copy",
  "action.select-all": "Select all",
  "action.select-none": "Select none",
  "action.send-backward": "Send backward",
  "action.send-to-back": "Send to back",
  "action.share-project": "Share this project",
  "action.stack-horizontal": "Stack horizontally",
  "action.stack-vertical": "Stack vertically",
  "action.stack-horizontal.short": "Stack H",
  "action.stack-vertical.short": "Stack V",
  "action.stop-following": "Stop following",
  "action.stretch-horizontal": "Stretch horizontally",
  "action.stretch-vertical": "Stretch vertically",
  "action.stretch-horizontal.short": "Stretch H",
  "action.stretch-vertical.short": "Stretch V",
  "action.toggle-auto-size": "Toggle auto size",
  "action.toggle-dark-mode.menu": "Dark mode",
  "action.toggle-dark-mode": "Toggle dark mode",
  "action.toggle-paste-at-cursor.menu": "Paste at cursor",
  "action.toggle-paste-at-cursor": "Toggle paste at cursor",
  "action.toggle-wrap-mode.menu": "Select on wrap",
  "action.toggle-wrap-mode": "Toggle select on wrap",
  "action.toggle-reduce-motion.menu": "Reduce motion",
  "action.toggle-reduce-motion": "Toggle reduce motion",
  "action.toggle-keyboard-shortcuts.menu": "Enable keyboard shortcuts",
  "action.toggle-keyboard-shortcuts": "Toggle keyboard shortcuts",
  "action.enhanced-a11y-mode.menu": "Enhanced accessibility mode",
  "action.enhanced-a11y-mode": "Toggle enhanced accessibility mode",
  "action.toggle-edge-scrolling.menu": "Edge scrolling",
  "action.toggle-edge-scrolling": "Toggle edge scrolling",
  "action.toggle-debug-mode.menu": "Debug mode",
  "action.toggle-debug-mode": "Toggle debug mode",
  "action.toggle-focus-mode.menu": "Focus mode",
  "action.toggle-focus-mode": "Toggle focus mode",
  "action.toggle-dynamic-size-mode.menu": "Dynamic size",
  "action.toggle-dynamic-size-mode": "Toggle dynamic size",
  "action.toggle-grid.menu": "Show grid",
  "action.toggle-grid": "Toggle grid",
  "action.toggle-lock": "Toggle locked",
  "action.flatten-to-image": "Flatten",
  "action.toggle-snap-mode.menu": "Always snap",
  "action.toggle-snap-mode": "Toggle always snap",
  "action.toggle-tool-lock.menu": "Tool lock",
  "action.toggle-tool-lock": "Toggle tool lock",
  "action.toggle-transparent.context-menu": "Transparent",
  "action.toggle-transparent.menu": "Transparent",
  "action.toggle-transparent": "Toggle transparent background",
  "action.undo": "Undo",
  "action.ungroup": "Ungroup",
  "action.zoom-in": "Zoom in",
  "action.zoom-out": "Zoom out",
  "action.zoom-to-100": "Zoom to 100%",
  "action.zoom-to-fit": "Zoom to fit",
  "action.zoom-to-selection": "Zoom to selection",
  "assets.files.size-too-big": "File size is too big",
  "assets.files.maximum-size": "Maximum file size is {size}",
  "assets.files.type-not-allowed": "File type is not allowed",
  "assets.files.upload-failed": "Upload failed",
  "assets.files.amount-too-many": "Too many files",
  "assets.url.failed": "Couldnt load URL preview",
  "theme.dark": "Dark",
  "theme.light": "Light",
  "theme.system": "System",
  "color-style.white": "White",
  "color-style.black": "Black",
  "color-style.blue": "Blue",
  "color-style.green": "Green",
  "color-style.grey": "Grey",
  "color-style.light-blue": "Light blue",
  "color-style.light-green": "Light green",
  "color-style.light-red": "Light red",
  "color-style.light-violet": "Light violet",
  "color-style.orange": "Orange",
  "color-style.red": "Red",
  "color-style.violet": "Violet",
  "color-style.yellow": "Yellow",
  "fill-style.none": "None",
  "document.default-name": "Untitled",
  "fill-style.semi": "Semi",
  "fill-style.solid": "Solid",
  "fill-style.pattern": "Pattern",
  "fill-style.fill": "Fill",
  "fill-style.lined-fill": "Lined fill",
  "dash-style.dashed": "Dashed",
  "dash-style.dotted": "Dotted",
  "dash-style.draw": "Draw",
  "dash-style.solid": "Solid",
  "size-style.s": "Small",
  "size-style.m": "Medium",
  "size-style.l": "Large",
  "size-style.xl": "Extra large",
  "opacity-style.0.1": "10%",
  "opacity-style.0.25": "25%",
  "opacity-style.0.5": "50%",
  "opacity-style.0.75": "75%",
  "opacity-style.1": "100%",
  "font-style.draw": "Draw",
  "font-style.sans": "Sans",
  "font-style.serif": "Serif",
  "font-style.mono": "Mono",
  "align-style.start": "Start",
  "align-style.middle": "Middle",
  "align-style.end": "End",
  "align-style.justify": "Justify",
  "verticalAlign-style.start": "Top",
  "verticalAlign-style.middle": "Middle",
  "verticalAlign-style.end": "Bottom",
  "geo-style.arrow-down": "Arrow down",
  "geo-style.arrow-left": "Arrow left",
  "geo-style.arrow-right": "Arrow right",
  "geo-style.arrow-up": "Arrow up",
  "geo-style.cloud": "Cloud",
  "geo-style.diamond": "Diamond",
  "geo-style.ellipse": "Ellipse",
  "geo-style.heart": "Heart",
  "geo-style.hexagon": "Hexagon",
  "geo-style.octagon": "Octagon",
  "geo-style.oval": "Oval",
  "geo-style.pentagon": "Pentagon",
  "geo-style.rectangle": "Rectangle",
  "geo-style.rhombus": "Rhombus",
  "geo-style.rhombus-2": "Rhombus left",
  "geo-style.star": "Star",
  "geo-style.trapezoid": "Trapezoid",
  "geo-style.triangle": "Triangle",
  "geo-style.x-box": "X box",
  "geo-style.check-box": "Check box",
  "arrowheadStart-style.none": "None",
  "arrowheadStart-style.arrow": "Arrow",
  "arrowheadStart-style.bar": "Bar",
  "arrowheadStart-style.diamond": "Diamond",
  "arrowheadStart-style.dot": "Dot",
  "arrowheadStart-style.inverted": "Inverted",
  "arrowheadStart-style.pipe": "Pipe",
  "arrowheadStart-style.square": "Square",
  "arrowheadStart-style.triangle": "Triangle",
  "arrowheadEnd-style.none": "None",
  "arrowheadEnd-style.arrow": "Arrow",
  "arrowheadEnd-style.bar": "Bar",
  "arrowheadEnd-style.diamond": "Diamond",
  "arrowheadEnd-style.dot": "Dot",
  "arrowheadEnd-style.inverted": "Inverted",
  "arrowheadEnd-style.pipe": "Pipe",
  "arrowheadEnd-style.square": "Square",
  "arrowheadEnd-style.triangle": "Triangle",
  "spline-style.line": "Line",
  "spline-style.cubic": "Cubic",
  "arrow-kind-style.arc": "Arc",
  "arrow-kind-style.elbow": "Elbow",
  "tool.select": "Select",
  "tool.hand": "Hand",
  "tool.draw": "Draw",
  "tool.eraser": "Eraser",
  "tool.arrow-down": "Arrow down",
  "tool.arrow-left": "Arrow left",
  "tool.arrow-right": "Arrow right",
  "tool.arrow-up": "Arrow up",
  "tool.arrow": "Arrow",
  "tool.cloud": "Cloud",
  "tool.diamond": "Diamond",
  "tool.ellipse": "Ellipse",
  "tool.heart": "Heart",
  "tool.hexagon": "Hexagon",
  "tool.highlight": "Highlight",
  "tool.line": "Line",
  "tool.octagon": "Octagon",
  "tool.oval": "Oval",
  "tool.pentagon": "Pentagon",
  "tool.rectangle": "Rectangle",
  "tool.rhombus": "Rhombus",
  "tool.star": "Star",
  "tool.trapezoid": "Trapezoid",
  "tool.triangle": "Triangle",
  "tool.x-box": "X box",
  "tool.check-box": "Check box",
  "tool.media": "Media",
  "tool.frame": "Frame",
  "tool.note": "Note",
  "tool.laser": "Laser",
  "tool.embed": "Embed",
  "tool.text": "Text",
  "tool.pointer-down": "Pointer down",
  "tool.image-zoom": "Zoom",
  "tool.replace-media": "Replace media",
  "tool.flip-horz": "Flip horizontally",
  "tool.flip-vert": "Flip vertically",
  "tool.rotate-cw": "Rotate",
  "tool.aspect-ratio": "Aspect ratio",
  "tool.aspect-ratio.original": "Original",
  "tool.aspect-ratio.square": "Square (1:1)",
  "tool.aspect-ratio.circle": "Circle (1:1)",
  "tool.aspect-ratio.landscape": "Landscape (4:3)",
  "tool.aspect-ratio.portrait": "Portrait (3:4)",
  "tool.aspect-ratio.wide": "Wide (16:9)",
  "tool.image-toolbar-title": "Image tools",
  "tool.image-crop": "Crop image",
  "tool.image-crop-confirm": "Confirm",
  "tool.media-alt-text": "Alternative text",
  "tool.media-alt-text-desc": "Give a description",
  "tool.media-alt-text-confirm": "Confirm",
  "tool.rich-text-bold": "Bold",
  "tool.rich-text-italic": "Italic",
  "tool.rich-text-code": "Code",
  "tool.rich-text-highlight": "Highlight",
  "tool.rich-text-strikethrough": "Strikethrough",
  "tool.rich-text-link": "Link",
  "tool.rich-text-link-visit": "Visit link",
  "tool.rich-text-link-remove": "Remove link",
  "tool.rich-text-header": "Header",
  "tool.rich-text-bulletList": "Bulleted list",
  "tool.rich-text-toolbar-title": "Text formatting",
  "tool.rich-text-orderedList": "Ordered list",
  "tool.bookmark": "Bookmark",
  "a11y.status": "Status",
  "a11y.skip-to-main-content": "Move focus to canvas",
  "a11y.shape-index": "{num} of {total}",
  "a11y.shape-image": "Image",
  "a11y.shape-video": "Video",
  "a11y.multiple-shapes": "{num} shapes selected",
  "a11y.select-shape": "Select next shape",
  "a11y.select-shape-direction": "Select shape in direction",
  "a11y.enter-leave-container": "Enter/leave container",
  "a11y.repeat-shape": "Repeat shape",
  "a11y.move-shape": "Move shape",
  "a11y.move-shape-faster": "Move shape faster",
  "a11y.rotate-shape-cw": "Rotate shape clockwise",
  "a11y.rotate-shape-ccw": "Rotate shape counterclockwise",
  "a11y.rotate-shape-cw-fine": "Rotate shape clockwise (fine)",
  "a11y.rotate-shape-ccw-fine": "Rotate shape counterclockwise (fine)",
  "a11y.enlarge-shape": "Enlarge shape",
  "a11y.shrink-shape": "Shrink shape",
  "a11y.pan-camera": "Pan camera",
  "a11y.adjust-shape-styles": "Adjust shape styles",
  "a11y.open-context-menu": "Open context menu",
  "a11y.open-keyboard-shortcuts": "Open keyboard shortcuts",
  "menu.title": "Menu",
  "menu.theme": "Theme",
  "menu.accessibility": "Accessibility",
  "menu.copy-as": "Copy as",
  "menu.edit": "Edit",
  "menu.export-as": "Export as",
  "menu.file": "File",
  "menu.language": "Language",
  "menu.preferences": "Preferences",
  "menu.view": "View",
  "menu.input-mode": "Input mode",
  "context-menu.title": "Context menu",
  "context-menu.edit": "Edit",
  "context-menu.arrange": "Arrange",
  "context-menu.copy-as": "Copy as",
  "context-menu.export-as": "Export as",
  "context-menu.export-all-as": "Export",
  "context-menu.move-to-page": "Move to page",
  "context-menu.reorder": "Reorder",
  "page-menu.title": "Pages",
  "page-menu.create-new-page": "Create new page",
  "page-menu.max-page-count-reached": "Max pages reached",
  "page-menu.new-page-initial-name": "Page 1",
  "page-menu.edit-start": "Edit",
  "page-menu.edit-done": "Done",
  "page-menu.go-to-page": "Go to page",
  "page-menu.submenu.rename": "Rename",
  "page-menu.submenu.duplicate-page": "Duplicate",
  "page-menu.submenu.title": "Menu",
  "page-menu.submenu.move-down": "Move down",
  "page-menu.submenu.move-up": "Move up",
  "page-menu.submenu.delete": "Delete",
  "share-menu.title": "Share",
  "share-menu.save-note": "Download this project to your computer as a .tldr file.",
  "share-menu.fork-note": "Create a new shared project based on this snapshot.",
  "share-menu.share-project": "Share this project",
  "share-menu.copy-link": "Copy editor link",
  "share-menu.create-snapshot-link": "Copy snapshot link",
  "share-menu.snapshot-link-note": "Capture and share this project as a read-only snapshot link.",
  "share-menu.copy-readonly-link": "Copy viewer link",
  "share-menu.offline-note": "Create a new shared project based on your current project.",
  "share-menu.copy-link-note": "Anyone with the link will be able to view and edit this project.",
  "share-menu.copy-readonly-link-note": "Anyone with the link will be able to access this project.",
  "share-menu.project-too-large": "Sorry, this project cant be shared because its too large. Were working on it!",
  "share-menu.upload-failed": "Sorry, we couldnt upload your project at the moment. Please try again or let us know if the problem persists.",
  "share-menu.creating-project": "Creating the new project",
  "share-menu.copied": "Copied link",
  "document-name-menu.copy-link": "Copy link",
  "status.offline": "Offline",
  "people-menu.title": "People",
  "people-menu.change-name": "Change name",
  "people-menu.avatar-color": "Avatar color",
  "people-menu.change-color": "Change color",
  "people-menu.follow": "Following",
  "people-menu.following": "Following",
  "people-menu.leading": "Following you",
  "people-menu.user": "(You)",
  "people-menu.invite": "Invite others",
  "people-menu.anonymous-user": "New user",
  "help-menu.import-tldr-file": "Import file",
  "help-menu.title": "Help and resources",
  "help-menu.about": "About tldraw",
  "help-menu.discord": "Discord",
  "help-menu.github": "GitHub",
  "help-menu.keyboard-shortcuts": "Keyboard shortcuts",
  "help-menu.twitter": "Twitter",
  "help-menu.terms": "Terms of service",
  "help-menu.privacy": "Privacy policy",
  "actions-menu.title": "Actions",
  "edit-link-dialog.title": "Edit link",
  "edit-link-dialog.invalid-url": "A link must be a valid URL.",
  "edit-link-dialog.detail": "Links will open in a new tab.",
  "edit-link-dialog.url": "URL",
  "edit-link-dialog.clear": "Clear",
  "edit-link-dialog.save": "Continue",
  "edit-link-dialog.cancel": "Cancel",
  "edit-link-dialog.external-link": "External link",
  "embed-dialog.title": "Insert embed",
  "embed-dialog.back": "Back",
  "embed-dialog.create": "Create",
  "embed-dialog.cancel": "Cancel",
  "embed-dialog.url": "URL",
  "embed-dialog.instruction": "Paste in the sites URL to create the embed.",
  "embed-dialog.invalid-url": "We could not create an embed from that URL.",
  "shortcuts-dialog.title": "Keyboard shortcuts",
  "shortcuts-dialog.edit": "Edit",
  "shortcuts-dialog.file": "File",
  "shortcuts-dialog.preferences": "Preferences",
  "shortcuts-dialog.tools": "Tools",
  "shortcuts-dialog.transform": "Transform",
  "shortcuts-dialog.view": "View",
  "shortcuts-dialog.collaboration": "Collaboration",
  "shortcuts-dialog.a11y": "Accessibility",
  "shortcuts-dialog.text-formatting": "Text formatting",
  "style-panel.title": "Styles",
  "style-panel.align": "Align",
  "style-panel.label-align": "Label align",
  "style-panel.vertical-align": "Vertical align",
  "style-panel.position": "Position",
  "style-panel.arrowheads": "Arrows",
  "style-panel.arrowhead-start": "Start",
  "style-panel.arrowhead-end": "End",
  "style-panel.arrow-kind": "Line",
  "style-panel.color": "Color",
  "style-panel.dash": "Dash",
  "style-panel.fill": "Fill",
  "style-panel.font": "Font",
  "style-panel.geo": "Shape",
  "style-panel.mixed": "Mixed",
  "style-panel.opacity": "Opacity",
  "style-panel.size": "Size",
  "style-panel.spline": "Spline",
  "style-panel.selected": "selected",
  "tool-panel.title": "Tools",
  "tool-panel.more": "More",
  "navigation-zone.title": "Navigation",
  "navigation-zone.minimap": "Minimap",
  "navigation-zone.toggle-minimap": "Toggle minimap",
  "navigation-zone.zoom": "Zoom",
  "focus-mode.toggle-focus-mode": "Toggle focus mode",
  "toast.close": "Close",
  "toast.success": "Success",
  "toast.error": "Error",
  "toast.info": "Info",
  "toast.warning": "Warning",
  "file-system.file-open-error.title": "Could not open file",
  "file-system.file-open-error.not-a-tldraw-file": "The file you tried to open doesnt look like a tldraw file.",
  "file-system.file-open-error.file-format-version-too-new": "The file you tried to open is from a newer version of tldraw. Please reload the page and try again.",
  "file-system.file-open-error.generic-corrupted-file": "The file you tried to open is corrupted.",
  "file-system.confirm-open.title": "Overwrite current project?",
  "file-system.confirm-open.description": "Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-open.cancel": "Cancel",
  "file-system.confirm-open.open": "Open file",
  "file-system.confirm-open.dont-show-again": "Dont ask again",
  "file-system.confirm-clear.title": "Clear current project?",
  "file-system.confirm-clear.description": "Creating a new project will clear your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-clear.cancel": "Cancel",
  "file-system.confirm-clear.continue": "Continue",
  "file-system.confirm-clear.dont-show-again": "Dont ask again",
  "file-system.shared-document-file-open-error.title": "Could not open file",
  "file-system.shared-document-file-open-error.description": "Opening files from shared projects is not supported.",
  "sharing.confirm-leave.title": "Leave current project?",
  "sharing.confirm-leave.description": "Are you sure you want to leave this shared project? You can return to it by navigating to its URL.",
  "sharing.confirm-leave.cancel": "Cancel",
  "sharing.confirm-leave.leave": "Leave",
  "sharing.confirm-leave.dont-show-again": "Dont ask again",
  "toast.error.export-fail.title": "Failed export",
  "toast.error.export-fail.desc": "Failed to export image",
  "toast.error.copy-fail.title": "Failed copy",
  "toast.error.copy-fail.desc": "Failed to copy image",
  "context.pages.new-page": "New page",
  "vscode.file-open.desc": "Weve updated this document to work with the current version of tldraw. If youd like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
  "vscode.file-open.open": "Continue",
  "vscode.file-open.backup": "Backup",
  "vscode.file-open.backup-saved": "Backup saved",
  "vscode.file-open.backup-failed": "Backup failed: this is not a .tldr file.",
  "vscode.file-open.dont-show-again": "Dont ask again",
  "cursor-chat.type-to-chat": "Type to chat",
  "app.loading": "Loading tldraw",
  "handle.resize-top": "Resize top",
  "handle.resize-bottom": "Resize bottom",
  "handle.resize-left": "Resize left",
  "handle.resize-right": "Resize right",
  "handle.resize-top-left": "Resize top left",
  "handle.resize-top-right": "Resize top right",
  "handle.resize-bottom-left": "Resize bottom left",
  "handle.resize-bottom-right": "Resize bottom right",
  "handle.rotate.top_left_rotate": "Rotate top left",
  "handle.rotate.top_right_rotate": "Rotate top right",
  "handle.rotate.bottom_left_rotate": "Rotate bottom left",
  "handle.rotate.bottom_right_rotate": "Rotate bottom right",
  "handle.rotate.mobile_rotate": "Rotate",
  "handle.crop.top": "Crop top",
  "handle.crop.bottom": "Crop bottom",
  "handle.crop.left": "Crop left",
  "handle.crop.right": "Crop right",
  "handle.crop.top-left": "Crop top left",
  "handle.crop.top-right": "Crop top right",
  "handle.crop.bottom-left": "Crop bottom left",
  "handle.crop.bottom-right": "Crop bottom right",
  "ui.close": "Close",
  "ui.checked": "Checked",
  "ui.unchecked": "Unchecked"
};
const RTL_LANGUAGES = /* @__PURE__ */ new Set(["ar", "fa", "he", "ur", "ku"]);
const EN_TRANSLATION = {
  locale: "en",
  label: "English",
  messages: DEFAULT_TRANSLATION,
  dir: "ltr"
};
async function fetchTranslation(locale, assetUrls) {
  const mainRes = await fetch$1(assetUrls.translations.en);
  if (!mainRes.ok) {
    console.warn(`No main translations found.`);
    return EN_TRANSLATION;
  }
  if (locale === "en") {
    return EN_TRANSLATION;
  }
  const language = LANGUAGES.find((t2) => t2.locale === locale);
  if (!language) {
    console.warn(`No translation found for locale ${locale}`);
    return EN_TRANSLATION;
  }
  const res = await fetch$1(assetUrls.translations[language.locale]);
  const messages = await res.json();
  if (!messages) {
    console.warn(`No messages found for locale ${locale}`);
    return EN_TRANSLATION;
  }
  for (const key in EN_TRANSLATION.messages) {
    if (!messages[key]) ;
  }
  return {
    locale,
    label: language.label,
    dir: RTL_LANGUAGES.has(language.locale) ? "rtl" : "ltr",
    messages: { ...EN_TRANSLATION.messages, ...messages }
  };
}
const TranslationsContext = reactExports.createContext(null);
function useCurrentTranslation() {
  const translations = reactExports.useContext(TranslationsContext);
  if (!translations) {
    throw new Error("useCurrentTranslation must be used inside of <TldrawUiContextProvider />");
  }
  return translations;
}
function TldrawUiTranslationProvider({
  overrides,
  locale,
  children
}) {
  const getAssetUrl = useAssetUrls();
  const [currentTranslation, setCurrentTranslation] = reactExports.useState(() => {
    if (overrides && overrides["en"]) {
      return {
        locale: "en",
        label: "English",
        dir: "ltr",
        messages: { ...DEFAULT_TRANSLATION, ...overrides["en"] }
      };
    }
    return {
      locale: "en",
      label: "English",
      dir: "ltr",
      messages: DEFAULT_TRANSLATION
    };
  });
  reactExports.useEffect(() => {
    let isCancelled = false;
    async function loadTranslation() {
      const translation = await fetchTranslation(locale, getAssetUrl);
      if (translation && !isCancelled) {
        if (overrides && overrides[locale]) {
          setCurrentTranslation({
            ...translation,
            messages: { ...translation.messages, ...overrides[locale] }
          });
        } else {
          setCurrentTranslation(translation);
        }
      }
    }
    loadTranslation();
    return () => {
      isCancelled = true;
    };
  }, [getAssetUrl, locale, overrides]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TranslationsContext.Provider, { value: currentTranslation, children });
}
function useTranslation() {
  const translation = useCurrentTranslation();
  return reactExports.useCallback(
    function msg2(id) {
      return translation.messages[id] ?? id;
    },
    [translation]
  );
}
function untranslated(string2) {
  return string2;
}
const namedClassNamesSoThatICanGrepForThis = {
  normal: "tlui-button__normal",
  primary: "tlui-button__primary",
  danger: "tlui-button__danger",
  low: "tlui-button__low",
  icon: "tlui-button__icon",
  tool: "tlui-button__tool",
  menu: "tlui-button__menu",
  help: "tlui-button__help"
};
const TldrawUiButton = reactExports.forwardRef(
  function TldrawUiButton2({ children, type, htmlButtonType, isActive: isActive2, ...props }, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        ref,
        type: htmlButtonType || "button",
        draggable: false,
        "data-isactive": isActive2,
        ...props,
        className: classNames(
          "tlui-button",
          namedClassNamesSoThatICanGrepForThis[type],
          props.className
        ),
        children
      }
    );
  }
);
function SkipToMainContent() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const button = reactExports.useRef(null);
  const handleNavigateToFirstShape = reactExports.useCallback(
    (e) => {
      editor.markEventAsHandled(e);
      button.current?.blur();
      const shapes = editor.getCurrentPageShapesInReadingOrder();
      if (!shapes.length) return;
      editor.setSelectedShapes([shapes[0].id]);
      editor.zoomToSelectionIfOffscreen(256, {
        animation: {
          duration: editor.options.animationMediumMs
        },
        inset: 0
      });
      editor.timers.setTimeout(() => editor.getContainer().focus(), 100);
    },
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiButton,
    {
      ref: button,
      type: "low",
      tabIndex: 0,
      className: "tl-skip-to-main-content",
      onClick: handleNavigateToFirstShape,
      children: msg2("a11y.skip-to-main-content")
    }
  );
}
const DefaultA11yAnnouncer = reactExports.memo(function TldrawUiA11yAnnouncer() {
  const a11y = useA11y();
  const translation = useTranslation();
  const msg2 = useValue("a11y-msg", () => a11y.currentMsg.get(), []);
  useA11yDebug(msg2.msg);
  useSelectedShapesAnnouncer();
  return msg2.msg && /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      "aria-label": translation("a11y.status"),
      "aria-live": msg2.priority || "assertive",
      role: "status",
      "aria-hidden": "false",
      style: {
        position: "absolute",
        top: "-10000px",
        left: "-10000px"
      },
      children: msg2.msg
    }
  );
});
function generateShapeAnnouncementMessage(args) {
  const { editor, selectedShapeIds, msg: msg2 } = args;
  let a11yLive = "";
  const numShapes = selectedShapeIds.length;
  if (numShapes > 1) {
    a11yLive = msg2("a11y.multiple-shapes").replace("{num}", numShapes.toString());
  } else if (numShapes === 1) {
    const shapeId = selectedShapeIds[0];
    const shape = editor.getShape(shapeId);
    if (!shape) return "";
    const shapeUtil = editor.getShapeUtil(shape.type);
    const isMedia = ["image", "video"].includes(shape.type);
    let shapeType = "";
    if (shape.type === "geo") {
      shapeType = msg2(`geo-style.${shape.props.geo}`);
    } else if (isMedia) {
      shapeType = msg2(`a11y.shape-${shape.type}`);
    } else {
      shapeType = msg2(`tool.${shape.type}`);
    }
    const readingOrderShapes = editor.getCurrentPageShapesInReadingOrder();
    const currentShapeIndex = (readingOrderShapes.findIndex((s) => s.id === shapeId) + 1).toString();
    const totalShapes = readingOrderShapes.length.toString();
    const shapeIndex = msg2("a11y.shape-index").replace("{num}", currentShapeIndex).replace("{total}", totalShapes);
    const describingText = shapeUtil.getAriaDescriptor(shape) || shapeUtil.getText(shape) || "";
    a11yLive = (describingText ? `${describingText}, ` : "") + `${shapeType}. ${shapeIndex}`;
  }
  return a11yLive;
}
const useSelectedShapesAnnouncer = () => {
  const editor = useMaybeEditor();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const rPrevSelectedShapeIds = reactExports.useRef([]);
  useReactor(
    "announce selection",
    () => {
      if (!editor) return;
      const isInSelecting = editor.isIn("select.idle");
      if (isInSelecting) {
        const selectedShapeIds = editor.getSelectedShapeIds();
        if (selectedShapeIds !== rPrevSelectedShapeIds.current) {
          rPrevSelectedShapeIds.current = selectedShapeIds;
          unsafe__withoutCapture(() => {
            const a11yLive = generateShapeAnnouncementMessage({
              editor,
              selectedShapeIds,
              msg: msg2
            });
            if (a11yLive) {
              a11y.announce({ msg: a11yLive });
            }
          });
        }
      }
    },
    [editor, a11y, msg2]
  );
};
const useA11yDebug = (msg2) => {
  const container = useContainer();
  reactExports.useEffect(() => {
    if (debugFlags.a11y.get()) {
      const log = (msg22) => {
        console.debug(
          `%ca11y%c: ${msg22}`,
          `color: white; background: #40C057; padding: 2px;border-radius: 3px;`,
          "font-weight: normal"
        );
      };
      const handleKeyUp = (e) => {
        const el = document.activeElement;
        if (e.key === "Tab" && el && el !== document.body && !el.classList.contains("tl-container")) {
          const label = el.getAttribute("aria-label") || el.getAttribute("title") || el.textContent;
          if (label) {
            log(label);
          }
        }
      };
      if (msg2) {
        log(msg2);
      }
      document.addEventListener("keyup", handleKeyUp);
      return () => document.removeEventListener("keyup", handleKeyUp);
    }
  }, [container, msg2]);
};
const BOOKMARK_WIDTH = 300;
const BOOKMARK_HEIGHT = 320;
const BOOKMARK_JUST_URL_HEIGHT = 46;
const SHORT_BOOKMARK_HEIGHT = 101;
function getBookmarkHeight(editor, assetId) {
  const asset = assetId ? editor.getAsset(assetId) : null;
  if (asset) {
    if (!asset.props.image) {
      if (!asset.props.title) {
        return BOOKMARK_JUST_URL_HEIGHT;
      } else {
        return SHORT_BOOKMARK_HEIGHT;
      }
    }
  }
  return BOOKMARK_HEIGHT;
}
function setBookmarkHeight(editor, shape) {
  return {
    ...shape,
    props: { ...shape.props, h: getBookmarkHeight(editor, shape.props.assetId) }
  };
}
const getHumanReadableAddress = (url) => {
  try {
    const objUrl = new URL(url);
    return objUrl.hostname.replace(/^www\./, "");
  } catch {
    return url;
  }
};
function updateBookmarkAssetOnUrlChange(editor, shape) {
  const { url } = shape.props;
  const assetId = AssetRecordType.createId(getHashForString(url));
  if (editor.getAsset(assetId)) {
    if (shape.props.assetId !== assetId) {
      editor.updateShapes([
        {
          id: shape.id,
          type: shape.type,
          props: { assetId }
        }
      ]);
    }
  } else {
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: { assetId: null }
      }
    ]);
    createBookmarkAssetOnUrlChange(editor, shape);
  }
}
const createBookmarkAssetOnUrlChange = debounce(async (editor, shape) => {
  if (editor.isDisposed) return;
  const { url } = shape.props;
  const asset = await editor.getAssetForExternalContent({ type: "url", url });
  if (!asset) {
    return;
  }
  editor.run(() => {
    editor.createAssets([asset]);
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: { assetId: asset.id }
      }
    ]);
  });
}, 500);
async function createBookmarkFromUrl(editor, {
  url,
  center = editor.getViewportPageBounds().center
}) {
  try {
    const asset = await editor.getAssetForExternalContent({ type: "url", url });
    const shapeId = createShapeId();
    const shapePartial = {
      id: shapeId,
      type: "bookmark",
      x: center.x - BOOKMARK_WIDTH / 2,
      y: center.y - BOOKMARK_HEIGHT / 2,
      rotation: 0,
      opacity: 1,
      props: {
        url,
        assetId: asset?.id || null,
        w: BOOKMARK_WIDTH,
        h: getBookmarkHeight(editor, asset?.id)
      }
    };
    editor.run(() => {
      if (asset) {
        editor.createAssets([asset]);
      }
      editor.createShapes([shapePartial]);
    });
    const createdShape = editor.getShape(shapeId);
    return Result.ok(createdShape);
  } catch (error) {
    return Result.err(error instanceof Error ? error.message : "Failed to create bookmark");
  }
}
function removeFrame(editor, ids) {
  const frames = compact(
    ids.map((id) => editor.getShape(id)).filter((f) => f && editor.isShapeOfType(f, "frame"))
  );
  if (!frames.length) return;
  const allChildren = [];
  editor.run(() => {
    frames.map((frame) => {
      const children = editor.getSortedChildIdsForParent(frame.id);
      if (children.length) {
        kickoutOccludedShapes(editor, children, {
          filter: (s) => !frames.find((f) => f.id === s.id)
        });
        allChildren.push(...children);
      }
    });
    editor.setSelectedShapes(allChildren);
    editor.deleteShapes(ids);
  });
}
const DEFAULT_FRAME_PADDING = 50;
function getFrameChildrenBounds(children, editor, opts = { padding: DEFAULT_FRAME_PADDING }) {
  const bounds = Box.FromPoints(
    children.flatMap((shape) => {
      if (!shape) return [];
      const geometry = editor.getShapeGeometry(shape.id);
      const transform = editor.getShapeLocalTransform(shape);
      return transform?.applyToPoints(geometry.vertices) ?? [];
    })
  );
  const padding = opts.padding ?? DEFAULT_FRAME_PADDING;
  const w = bounds.w + 2 * padding;
  const h2 = bounds.h + 2 * padding;
  const dx = padding - bounds.minX;
  const dy = padding - bounds.minY;
  return { w, h: h2, dx, dy };
}
function fitFrameToContent(editor, id, opts = {}) {
  const frame = editor.getShape(id);
  if (!frame) return;
  const childIds = editor.getSortedChildIdsForParent(frame.id);
  const children = compact(childIds.map((id2) => editor.getShape(id2)));
  if (!children.length) return;
  const { w, h: h2, dx, dy } = getFrameChildrenBounds(children, editor, opts);
  if (dx === 0 && dy === 0 && frame.props.w === w && frame.props.h === h2) return;
  const diff = new Vec(dx, dy).rot(frame.rotation);
  editor.run(() => {
    const changes = childIds.map((child) => {
      const shape = editor.getShape(child);
      return {
        id: shape.id,
        type: shape.type,
        x: shape.x + dx,
        y: shape.y + dy
      };
    });
    changes.push({
      id: frame.id,
      type: frame.type,
      x: frame.x - diff.x,
      y: frame.y - diff.y,
      props: {
        w,
        h: h2
      }
    });
    editor.updateShapes(changes);
  });
}
function TldrawUiButtonLabel({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tlui-button__label", children });
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot$3 = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
  const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef$1(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== reactExports.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return reactExports.cloneElement(children, props2);
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
function isSlottable(child) {
  return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node}`);
  const Node4 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node4.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node4 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME$3 = "VisuallyHidden";
var VisuallyHidden = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME$3;
var Root$6 = VisuallyHidden;
function createContext2(rootComponentName, defaultContext) {
  const Context2 = reactExports.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value = reactExports.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context2.Provider, { value, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext2(consumerName) {
    const context = reactExports.useContext(Context2);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext2];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      const { scope, children, ...context } = props;
      const Context2 = scope?.[scopeName]?.[index2] || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context2.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      const Context2 = scope?.[scopeName]?.[index2] || BaseContext;
      const context = reactExports.useContext(Context2);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function createCollection(name) {
  const PROVIDER_NAME2 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React.useRef(null);
    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = /* @__PURE__ */ createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = /* @__PURE__ */ createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}
var useLayoutEffect2 = globalThis?.document ? reactExports.useLayoutEffect : () => {
};
var useInsertionEffect = React$1[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  {
    const isControlledRef = reactExports.useRef(prop !== void 0);
    reactExports.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from2 = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from2} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = reactExports.useCallback(
    (nextValue) => {
      if (isControlled) {
        const value2 = isFunction$2(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          onChangeRef.current?.(value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = reactExports.useState(defaultProp);
  const prevValueRef = reactExports.useRef(value);
  const onChangeRef = reactExports.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction$2(value) {
  return typeof value === "function";
}
function useStateMachine(initialState2, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode2] = reactExports.useState();
  const stylesRef = reactExports.useRef(null);
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: reactExports.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode2(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var useReactId = React$1[" useId ".trim().toString()] || (() => void 0);
var count$1 = 0;
function useId(deterministicId) {
  const [id, setId] = reactExports.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count$1++));
  }, [deterministicId]);
  return id ? `radix-${id}` : "";
}
var DirectionContext = reactExports.createContext(void 0);
function useDirection(localDir) {
  const globalDir = reactExports.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
function useCallbackRef$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown2 = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown2, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = reactExports.useContext(DismissableLayerContext);
    const [node, setNode2] = reactExports.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode2(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    reactExports.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    reactExports.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
  const context = reactExports.useContext(DismissableLayerContext);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent$1(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent$1(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent$1(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var Root$5 = DismissableLayer;
var Branch$1 = DismissableLayerBranch;
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus$2(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus$2(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus$2(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$3(removeLinks(getTabbableCandidates$1(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus$2(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus$2(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown2 = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first2, last2] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first2 && last2;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last2) {
            event.preventDefault();
            if (loop) focus$2(first2, { select: true });
          } else if (event.shiftKey && focusedElement === first2) {
            event.preventDefault();
            if (loop) focus$2(last2, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown2 });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst$3(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus$2(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates$1(container);
  const first2 = findVisible(candidates, container);
  const last2 = findVisible(candidates.reverse(), container);
  return [first2, last2];
}
function getTabbableCandidates$1(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus$2(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack2 = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack2[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack2 = arrayRemove(stack2, focusScope);
      stack2.unshift(focusScope);
    },
    remove(focusScope) {
      stack2 = arrayRemove(stack2, focusScope);
      stack2[0]?.resume();
    }
  };
}
function arrayRemove(array2, item) {
  const updatedArray = [...array2];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var PORTAL_NAME$6 = "Portal";
var Portal$3 = reactExports.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$3.displayName = PORTAL_NAME$6;
var count = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers$3(thisArg, initializers, value) {
  var useValue2 = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue2 ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue2 ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
      if (y = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2];
            _.ops.push(op);
            break;
          }
          if (t2[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};
var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function(o2) {
    var ar = [];
    for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
const tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers: __runInitializers$3,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __rewriteRelativeImportExtension,
  __runInitializers: __runInitializers$3,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles = _a2.styles, dynamic = _a2.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b = _a2.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), scrollHeight = _a2[1], clientHeight = _a2[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a2 = getScrollVariables(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(styleSingleton)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var selection = window.getSelection();
    var anchorNode = selection && selection.anchorNode;
    var isTouchingSelection = anchorNode ? anchorNode === target || anchorNode.contains(target) : false;
    if (isTouchingSelection) {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst2) {
        return inst2 !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode2, markerName, controlAttribute) {
  var targets = correctTargets(parentNode2, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode2);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode2, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var DIALOG_NAME = "Dialog";
var [createDialogContext] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME$4 = "DialogTrigger";
var DialogTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME$4, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$1(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME$4;
var PORTAL_NAME$5 = "DialogPortal";
var [PortalProvider$3, usePortalContext$3] = createDialogContext(PORTAL_NAME$5, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME$5, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$3, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME$5;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$3(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var Slot$2 = /* @__PURE__ */ createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot$2, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-state": getState$1(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME$6 = "DialogContent";
var DialogContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$3(CONTENT_NAME$6, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$6, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME$6;
var DialogContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$6, props.__scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$6, props.__scopeDialog);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$6, __scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState$1(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME$1 = "DialogTitle";
var DialogTitle = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME$1;
var DESCRIPTION_NAME$1 = "DialogDescription";
var DialogDescription = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME$1;
var CLOSE_NAME$2 = "DialogClose";
var DialogClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME$2, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME$2;
function getState$1(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$6,
  titleName: TITLE_NAME$1,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  reactExports.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  reactExports.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$4 = Dialog;
var Portal$2 = DialogPortal;
var Overlay = DialogOverlay;
var Content$1 = DialogContent;
var Title$1 = DialogTitle;
function usePrevious(value) {
  const ref = reactExports.useRef({ value, previous: value });
  return reactExports.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
function useSize(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry2 = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry2) {
          const borderSizeEntry = entry2["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
const sides = ["top", "right", "bottom", "left"];
const min$1 = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(start, value, end) {
  return max(start, min$1(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"];
const rlPlacement = ["right", "left"];
const tbPlacement = ["top", "bottom"];
const btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$4 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min$1(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding);
    const min$1$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp$1(min$1$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1$1 ? center - min$1$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
const originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min$1(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min$1(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement$1(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
const containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit2 = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit2 && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit2 && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode2 = getParentNode(node);
  if (isLastTraversableNode(parentNode2)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement$1(parentNode2) && isOverflowElement(parentNode2)) {
    return parentNode2;
  }
  return getNearestOverflowAncestor(parentNode2);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$1(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$1(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect2 = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect2.left + visualOffsets.x) / scale.x;
  let y = (clientRect2.top + visualOffsets.y) / scale.y;
  let width = clientRect2.width / scale.x;
  let height = clientRect2.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html2.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
const SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html2);
  if (windowScrollbarX <= 0) {
    const doc2 = html2.ownerDocument;
    const body = doc2.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc2.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html2.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect2 = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect2.top + element.clientTop;
  const left = clientRect2.left + element.clientLeft;
  const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode2 = getParentNode(element);
  if (parentNode2 === stopNode || !isElement(parentNode2) || isLastTraversableNode(parentNode2)) {
    return false;
  }
  return getComputedStyle$1(parentNode2).position === "fixed" || hasFixedPositionAncestor(parentNode2, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult2 = cache.get(element);
  if (cachedResult2) {
    return cachedResult2;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min$1(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$3 = arrow$4;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document !== "undefined";
var noop$1 = function noop() {
};
var index = isClient ? reactExports.useLayoutEffect : noop$1;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys2;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a);
    length = keys2.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys2[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys2[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$3({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$3({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow$2 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$2 = "Arrow";
var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$2;
var Root$3 = Arrow$1;
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$2 = "PopperAnchor";
var PopperAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME$2, __scopePopper);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const anchorRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      const previousAnchor = anchorRef.current;
      anchorRef.current = virtualRef?.current || ref.current;
      if (previousAnchor !== anchorRef.current) {
        context.onAnchorChange(anchorRef.current);
      }
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$2;
var CONTENT_NAME$5 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$5);
var PopperContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$5, __scopePopper);
    const [content, setContent2] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent2(node));
    const [arrow2, setArrow] = reactExports.useState(null);
    const arrowSize = useSize(arrow2);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow2 && arrow$2({ element: arrow2, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$5;
var ARROW_NAME$5 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = reactExports.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$5, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$3,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$5;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$5 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow = PopperArrow;
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var GROUP_NAME$3 = "RovingFocusGroup";
var [Collection$3, useCollection$3, createCollectionScope$3] = createCollection(GROUP_NAME$3);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME$3,
  [createCollectionScope$3]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$3);
var RovingFocusGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME$3;
var RovingFocusGroupImpl = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME$3
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
  const handleEntryFocus = useCallbackRef$1(onEntryFocus);
  const getItems = useCollection$3(__scopeRovingFocusGroup);
  const isClickFocusRef = reactExports.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: reactExports.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: reactExports.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst$2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME$4 = "RovingFocusGroupItem";
var RovingFocusGroupItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props;
    const autoId = useId();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME$4, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection$3(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    reactExports.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$3.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray$1(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst$2(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME$4;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst$2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$1(array2, startIndex) {
  return array2.map((_, index2) => array2[(startIndex + index2) % array2.length]);
}
var Root$2 = RovingFocusGroup;
var Item$1 = RovingFocusGroupItem;
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection$2, useCollection$2, createCollectionScope$2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope$2,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope$2 = createPopperScope();
var useRovingFocusGroupScope$2 = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope$2(__scopeMenu);
  const [content, setContent2] = reactExports.useState(null);
  const isUsingKeyboardRef = reactExports.useRef(false);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  const direction = useDirection(dir);
  reactExports.useEffect(() => {
    const handleKeyDown2 = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown2, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent2,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: reactExports.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME$1 = "MenuAnchor";
var MenuAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope$2(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME$1;
var PORTAL_NAME$4 = "MenuPortal";
var [PortalProvider$2, usePortalContext$2] = createMenuContext(PORTAL_NAME$4, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME$4, __scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$2, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME$4;
var CONTENT_NAME$4 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME$4);
var MenuContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$4, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useMenuContext(CONTENT_NAME$4, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$4, props.__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME$4, props.__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      const content = ref.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = reactExports.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME$4, props.__scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var Slot$1 = /* @__PURE__ */ createSlot("MenuContent.ScrollLock");
var MenuContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context = useMenuContext(CONTENT_NAME$4, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$4, __scopeMenu);
    const popperScope = usePopperScope$2(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const getItems = useCollection$2(__scopeMenu);
    const [currentItemId, setCurrentItemId] = reactExports.useState(null);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = reactExports.useRef(0);
    const searchRef = reactExports.useRef("");
    const pointerGraceTimerRef = reactExports.useRef(0);
    const pointerGraceIntentRef = reactExports.useRef(null);
    const pointerDirRef = reactExports.useRef("right");
    const lastPointerXRef = reactExports.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? ReactRemoveScroll : reactExports.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot$1, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    reactExports.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = reactExports.useCallback((event) => {
      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;
      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) return;
            contentRef.current?.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: reactExports.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              event.preventDefault();
              contentRef.current?.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Root$2,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Content,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst$1(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME$4;
var GROUP_NAME$2 = "MenuGroup";
var MenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME$2;
var LABEL_NAME$2 = "MenuLabel";
var MenuLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME$2;
var ITEM_NAME$3 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = reactExports.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME$3, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME$3, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = reactExports.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          props.onPointerDown?.(event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          if (!isPointerDownRef.current) event.currentTarget?.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME$3;
var MenuItemImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME$3, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const [textContent, setTextContent] = reactExports.useState("");
    reactExports.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$2.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME$2 = "MenuCheckboxItem";
var MenuCheckboxItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$2;
var RADIO_GROUP_NAME$2 = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
  RADIO_GROUP_NAME$2,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef$1(onValueChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupProvider, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME$2;
var RADIO_ITEM_NAME$2 = "MenuRadioItem";
var MenuRadioItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, ...radioItemProps } = props;
    const context = useRadioGroupContext(RADIO_ITEM_NAME$2, props.__scopeMenu);
    const checked = value === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => context.onValueChange?.(value),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME$2;
var ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME,
  { checked: false }
);
var MenuItemIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Presence,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME$3 = "MenuSeparator";
var MenuSeparator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME$3;
var ARROW_NAME$4 = "MenuArrow";
var MenuArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope$2(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME$4;
var SUB_NAME$1 = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME$1);
var MenuSub = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext(SUB_NAME$1, __scopeMenu);
  const popperScope = usePopperScope$2(__scopeMenu);
  const [trigger2, setTrigger] = reactExports.useState(null);
  const [content, setContent2] = reactExports.useState(null);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  reactExports.useEffect(() => {
    if (parentMenuContext.open === false) handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent2,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId(),
          triggerId: useId(),
          trigger: trigger2,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) });
};
MenuSub.displayName = SUB_NAME$1;
var SUB_TRIGGER_NAME$2 = "MenuSubTrigger";
var MenuSubTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const openTimerRef = reactExports.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = reactExports.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    reactExports.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    reactExports.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          props.onClick?.(event);
          if (props.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse((event) => {
            clearOpenTimer();
            const contentRect = context.content?.getBoundingClientRect();
            if (contentRect) {
              const side = context.content?.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            context.content?.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME$2;
var SUB_CONTENT_NAME$2 = "MenuSubContent";
var MenuSubContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$4, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context = useMenuContext(CONTENT_NAME$4, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$4, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME$2, props.__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            subContext.trigger?.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME$2;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst$1(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray(array2, startIndex) {
  return array2.map((_, index2) => array2[(startIndex + index2) % array2.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon$1(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon$1(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root3$1 = Menu;
var Anchor2 = MenuAnchor;
var Portal$1 = MenuPortal;
var Content2$4 = MenuContent;
var Group = MenuGroup;
var Label = MenuLabel;
var Item2$3 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator$1 = MenuSeparator;
var Arrow2$1 = MenuArrow;
var Sub = MenuSub;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;
var CONTEXT_MENU_NAME = "ContextMenu";
var [createContextMenuContext] = createContextScope(CONTEXT_MENU_NAME, [
  createMenuScope
]);
var useMenuScope$1 = createMenuScope();
var [ContextMenuProvider, useContextMenuContext] = createContextMenuContext(CONTEXT_MENU_NAME);
var ContextMenu = (props) => {
  const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props;
  const [open, setOpen] = reactExports.useState(false);
  const menuScope = useMenuScope$1(__scopeContextMenu);
  const handleOpenChangeProp = useCallbackRef$1(onOpenChange);
  const handleOpenChange = reactExports.useCallback(
    (open2) => {
      setOpen(open2);
      handleOpenChangeProp(open2);
    },
    [handleOpenChangeProp]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ContextMenuProvider,
    {
      scope: __scopeContextMenu,
      open,
      onOpenChange: handleOpenChange,
      modal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Root3$1,
        {
          ...menuScope,
          dir,
          open,
          onOpenChange: handleOpenChange,
          modal,
          children
        }
      )
    }
  );
};
ContextMenu.displayName = CONTEXT_MENU_NAME;
var TRIGGER_NAME$3 = "ContextMenuTrigger";
var ContextMenuTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, disabled = false, ...triggerProps } = props;
    const context = useContextMenuContext(TRIGGER_NAME$3, __scopeContextMenu);
    const menuScope = useMenuScope$1(__scopeContextMenu);
    const pointRef = reactExports.useRef({ x: 0, y: 0 });
    const virtualRef = reactExports.useRef({
      getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...pointRef.current })
    });
    const longPressTimerRef = reactExports.useRef(0);
    const clearLongPress = reactExports.useCallback(
      () => window.clearTimeout(longPressTimerRef.current),
      []
    );
    const handleOpen = (event) => {
      pointRef.current = { x: event.clientX, y: event.clientY };
      context.onOpenChange(true);
    };
    reactExports.useEffect(() => clearLongPress, [clearLongPress]);
    reactExports.useEffect(() => void (disabled && clearLongPress()), [disabled, clearLongPress]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2, { ...menuScope, virtualRef }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.span,
        {
          "data-state": context.open ? "open" : "closed",
          "data-disabled": disabled ? "" : void 0,
          ...triggerProps,
          ref: forwardedRef,
          style: { WebkitTouchCallout: "none", ...props.style },
          onContextMenu: disabled ? props.onContextMenu : composeEventHandlers(props.onContextMenu, (event) => {
            clearLongPress();
            handleOpen(event);
            event.preventDefault();
          }),
          onPointerDown: disabled ? props.onPointerDown : composeEventHandlers(
            props.onPointerDown,
            whenTouchOrPen((event) => {
              clearLongPress();
              longPressTimerRef.current = window.setTimeout(() => handleOpen(event), 700);
            })
          ),
          onPointerMove: disabled ? props.onPointerMove : composeEventHandlers(props.onPointerMove, whenTouchOrPen(clearLongPress)),
          onPointerCancel: disabled ? props.onPointerCancel : composeEventHandlers(props.onPointerCancel, whenTouchOrPen(clearLongPress)),
          onPointerUp: disabled ? props.onPointerUp : composeEventHandlers(props.onPointerUp, whenTouchOrPen(clearLongPress))
        }
      )
    ] });
  }
);
ContextMenuTrigger.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$3 = "ContextMenuPortal";
var ContextMenuPortal = (props) => {
  const { __scopeContextMenu, ...portalProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { ...menuScope, ...portalProps });
};
ContextMenuPortal.displayName = PORTAL_NAME$3;
var CONTENT_NAME$3 = "ContextMenuContent";
var ContextMenuContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...contentProps } = props;
    const context = useContextMenuContext(CONTENT_NAME$3, __scopeContextMenu);
    const menuScope = useMenuScope$1(__scopeContextMenu);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$4,
      {
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented && hasInteractedOutsideRef.current) {
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented && !context.modal) hasInteractedOutsideRef.current = true;
        },
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
ContextMenuContent.displayName = CONTENT_NAME$3;
var GROUP_NAME$1 = "ContextMenuGroup";
var ContextMenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...groupProps } = props;
    const menuScope = useMenuScope$1(__scopeContextMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
ContextMenuGroup.displayName = GROUP_NAME$1;
var LABEL_NAME$1 = "ContextMenuLabel";
var ContextMenuLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...labelProps } = props;
    const menuScope = useMenuScope$1(__scopeContextMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
ContextMenuLabel.displayName = LABEL_NAME$1;
var ITEM_NAME$2 = "ContextMenuItem";
var ContextMenuItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...itemProps } = props;
    const menuScope = useMenuScope$1(__scopeContextMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$3, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
ContextMenuItem.displayName = ITEM_NAME$2;
var CHECKBOX_ITEM_NAME$1 = "ContextMenuCheckboxItem";
var ContextMenuCheckboxItem = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
ContextMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
var RADIO_GROUP_NAME$1 = "ContextMenuRadioGroup";
var ContextMenuRadioGroup = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
ContextMenuRadioGroup.displayName = RADIO_GROUP_NAME$1;
var RADIO_ITEM_NAME$1 = "ContextMenuRadioItem";
var ContextMenuRadioItem = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
ContextMenuRadioItem.displayName = RADIO_ITEM_NAME$1;
var INDICATOR_NAME$1 = "ContextMenuItemIndicator";
var ContextMenuItemIndicator = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
ContextMenuItemIndicator.displayName = INDICATOR_NAME$1;
var SEPARATOR_NAME$2 = "ContextMenuSeparator";
var ContextMenuSeparator = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...separatorProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator$1, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
ContextMenuSeparator.displayName = SEPARATOR_NAME$2;
var ARROW_NAME$3 = "ContextMenuArrow";
var ContextMenuArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...arrowProps } = props;
    const menuScope = useMenuScope$1(__scopeContextMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2$1, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
ContextMenuArrow.displayName = ARROW_NAME$3;
var SUB_NAME = "ContextMenuSub";
var ContextMenuSub = (props) => {
  const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SUB_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
ContextMenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME$1 = "ContextMenuSubTrigger";
var ContextMenuSubTrigger = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...triggerItemProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger, { ...menuScope, ...triggerItemProps, ref: forwardedRef });
});
ContextMenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
var SUB_CONTENT_NAME$1 = "ContextMenuSubContent";
var ContextMenuSubContent = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...subContentProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
ContextMenuSubContent.displayName = SUB_CONTENT_NAME$1;
function whenTouchOrPen(handler) {
  return (event) => event.pointerType !== "mouse" ? handler(event) : void 0;
}
var Root2$4 = ContextMenu;
var Trigger$3 = ContextMenuTrigger;
var Portal2$1 = ContextMenuPortal;
var Content2$3 = ContextMenuContent;
var Item2$2 = ContextMenuItem;
var CheckboxItem2$1 = ContextMenuCheckboxItem;
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = reactExports.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root3$1, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME$2 = "DropdownMenuTrigger";
var DropdownMenuTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context = useDropdownMenuContext(TRIGGER_NAME$2, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger.displayName = TRIGGER_NAME$2;
var PORTAL_NAME$2 = "DropdownMenuPortal";
var DropdownMenuPortal = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME$2;
var CONTENT_NAME$2 = "DropdownMenuContent";
var DropdownMenuContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context = useDropdownMenuContext(CONTENT_NAME$2, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$4,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent.displayName = CONTENT_NAME$2;
var GROUP_NAME = "DropdownMenuGroup";
var DropdownMenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME;
var LABEL_NAME = "DropdownMenuLabel";
var DropdownMenuLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME;
var ITEM_NAME$1 = "DropdownMenuItem";
var DropdownMenuItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$3, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem.displayName = ITEM_NAME$1;
var CHECKBOX_ITEM_NAME = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME;
var INDICATOR_NAME = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME;
var SEPARATOR_NAME$1 = "DropdownMenuSeparator";
var DropdownMenuSeparator = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator$1, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME$1;
var ARROW_NAME$2 = "DropdownMenuArrow";
var DropdownMenuArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2$1, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME$2;
var DropdownMenuSub = (props) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
var SUB_TRIGGER_NAME = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "DropdownMenuSubContent";
var DropdownMenuSubContent = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME;
var Root2$3 = DropdownMenu;
var Trigger$2 = DropdownMenuTrigger;
var Portal2 = DropdownMenuPortal;
var Content2$2 = DropdownMenuContent;
var Item2$1 = DropdownMenuItem;
var CheckboxItem2 = DropdownMenuCheckboxItem;
var ItemIndicator2 = DropdownMenuItemIndicator;
var Sub2 = DropdownMenuSub;
var SubTrigger2 = DropdownMenuSubTrigger;
var SubContent2 = DropdownMenuSubContent;
function clamp(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
var POPOVER_NAME = "Popover";
var [createPopoverContext] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope$1 = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope$1(__scopePopover);
  const triggerRef = reactExports.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = reactExports.useState(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: POPOVER_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: reactExports.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: reactExports.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME = "PopoverAnchor";
var PopoverAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME, __scopePopover);
    const popperScope = usePopperScope$1(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    reactExports.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME;
var TRIGGER_NAME$1 = "PopoverTrigger";
var PopoverTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME$1, __scopePopover);
    const popperScope = usePopperScope$1(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger2 = /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger2 : /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: trigger2 });
  }
);
PopoverTrigger.displayName = TRIGGER_NAME$1;
var PORTAL_NAME$1 = "PopoverPortal";
var [PortalProvider$1, usePortalContext$1] = createPopoverContext(PORTAL_NAME$1, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME$1, __scopePopover);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$1, { scope: __scopePopover, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME$1;
var CONTENT_NAME$1 = "PopoverContent";
var PopoverContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$1, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME$1, props.__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent.displayName = CONTENT_NAME$1;
var Slot = /* @__PURE__ */ createSlot("PopoverContent.RemoveScroll");
var PopoverContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME$1, props.__scopePopover);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          if (!isRightClickOutsideRef.current) context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME$1, props.__scopePopover);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME$1, __scopePopover);
    const popperScope = usePopperScope$1(__scopePopover);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Content,
              {
                "data-state": getState(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME$1 = "PopoverClose";
var PopoverClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME$1, __scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME$1;
var ARROW_NAME$1 = "PopoverArrow";
var PopoverArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope$1(__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME$1;
function getState(open) {
  return open ? "open" : "closed";
}
var Root2$2 = Popover;
var Trigger$1 = PopoverTrigger;
var Portal = PopoverPortal;
var Content2$1 = PopoverContent;
var NAME$1 = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = ["horizontal", "vertical"];
var Separator = reactExports.forwardRef((props, forwardedRef) => {
  const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;
  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
  const ariaOrientation = orientation === "vertical" ? orientation : void 0;
  const semanticProps = decorative ? { role: "none" } : { "aria-orientation": ariaOrientation, role: "separator" };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-orientation": orientation,
      ...semanticProps,
      ...domProps,
      ref: forwardedRef
    }
  );
});
Separator.displayName = NAME$1;
function isValidOrientation(orientation) {
  return ORIENTATIONS.includes(orientation);
}
var Root$1 = Separator;
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var SLIDER_NAME = "Slider";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(SLIDER_NAME);
var [createSliderContext] = createContextScope(SLIDER_NAME, [
  createCollectionScope$1
]);
var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
var Slider = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      name,
      min: min2 = 0,
      max: max2 = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min2],
      value,
      onValueChange = () => {
      },
      onValueCommit = () => {
      },
      inverted = false,
      form,
      ...sliderProps
    } = props;
    const thumbRefs = reactExports.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = reactExports.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
    const [values = [], setValues] = useControllableState({
      prop: value,
      defaultProp: defaultValue,
      onChange: (value2) => {
        const thumbs = [...thumbRefs.current];
        thumbs[valueIndexToChangeRef.current]?.focus();
        onValueChange(value2);
      }
    });
    const valuesBeforeSlideStartRef = reactExports.useRef(values);
    function handleSlideStart(value2) {
      const closestIndex = getClosestValueIndex(values, value2);
      updateValues(value2, closestIndex);
    }
    function handleSlideMove(value2) {
      updateValues(value2, valueIndexToChangeRef.current);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
      const nextValue = values[valueIndexToChangeRef.current];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged) onValueCommit(values);
    }
    function updateValues(value2, atIndex, { commit } = { commit: false }) {
      const decimalCount = getDecimalCount(step);
      const snapToStep = roundValue(Math.round((value2 - min2) / step) * step + min2, decimalCount);
      const nextValue = clamp(snapToStep, [min2, max2]);
      setValues((prevValues = []) => {
        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          const hasChanged = String(nextValues) !== String(prevValues);
          if (hasChanged && commit) onValueCommit(nextValues);
          return hasChanged ? nextValues : prevValues;
        } else {
          return prevValues;
        }
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderProvider,
      {
        scope: props.__scopeSlider,
        name,
        disabled,
        min: min2,
        max: max2,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        form,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Provider, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderOrientation,
          {
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0,
            ...sliderProps,
            ref: forwardedRef,
            onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {
              if (!disabled) valuesBeforeSlideStartRef.current = values;
            }),
            min: min2,
            max: max2,
            inverted,
            onSlideStart: disabled ? void 0 : handleSlideStart,
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onSlideEnd: disabled ? void 0 : handleSlideEnd,
            onHomeKeyDown: () => !disabled && updateValues(min2, 0, { commit: true }),
            onEndKeyDown: () => !disabled && updateValues(max2, values.length - 1, { commit: true }),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const isPageKey = PAGE_KEYS.includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex = valueIndexToChangeRef.current;
                const value2 = values[atIndex];
                const stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex, { commit: true });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Slider.displayName = SLIDER_NAME;
var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
});
var SliderHorizontal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min2,
      max: max2,
      dir,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const [slider, setSlider] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));
    const rectRef = reactExports.useRef(void 0);
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || slider.getBoundingClientRect();
      const input = [0, rect.width];
      const output = isSlidingFromLeft ? [min2, max2] : [max2, min2];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.left);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromLeft ? "left" : "right",
        endEdge: isSlidingFromLeft ? "right" : "left",
        direction: isSlidingFromLeft ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            dir: direction,
            "data-orientation": "horizontal",
            ...sliderProps,
            ref: composedRefs,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateX(-50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderVertical = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min2,
      max: max2,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const sliderRef = reactExports.useRef(null);
    const ref = useComposedRefs(forwardedRef, sliderRef);
    const rectRef = reactExports.useRef(void 0);
    const isSlidingFromBottom = !inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
      const input = [0, rect.height];
      const output = isSlidingFromBottom ? [max2, min2] : [min2, max2];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.top);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromBottom ? "bottom" : "top",
        endEdge: isSlidingFromBottom ? "top" : "bottom",
        size: "height",
        direction: isSlidingFromBottom ? 1 : -1,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            "data-orientation": "vertical",
            ...sliderProps,
            ref,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateY(50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSlider,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onHomeKeyDown,
      onEndKeyDown,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const context = useSliderContext(SLIDER_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...sliderProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === "Home") {
            onHomeKeyDown(event);
            event.preventDefault();
          } else if (event.key === "End") {
            onEndKeyDown(event);
            event.preventDefault();
          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
            onStepKeyDown(event);
            event.preventDefault();
          }
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          const target = event.target;
          target.setPointerCapture(event.pointerId);
          event.preventDefault();
          if (context.thumbs.has(target)) {
            target.focus();
          } else {
            onSlideStart(event);
          }
        }),
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            onSlideEnd(event);
          }
        })
      }
    );
  }
);
var TRACK_NAME = "SliderTrack";
var SliderTrack = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props;
    const context = useSliderContext(TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        ...trackProps,
        ref: forwardedRef
      }
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderRange";
var SliderRange = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props;
    const context = useSliderContext(RANGE_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => convertValueToPercentage(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        ...rangeProps,
        ref: composedRefs,
        style: {
          ...props.style,
          [orientation.startEdge]: offsetStart + "%",
          [orientation.endEdge]: offsetEnd + "%"
        }
      }
    );
  }
);
SliderRange.displayName = RANGE_NAME;
var THUMB_NAME = "SliderThumb";
var SliderThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const getItems = useCollection$1(props.__scopeSlider);
    const [thumb, setThumb] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const index2 = reactExports.useMemo(
      () => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1,
      [getItems, thumb]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderThumbImpl, { ...props, ref: composedRefs, index: index2 });
  }
);
var SliderThumbImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, index: index2, name, ...thumbProps } = props;
    const context = useSliderContext(THUMB_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);
    const [thumb, setThumb] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const isFormControl = thumb ? context.form || !!thumb.closest("form") : true;
    const size2 = useSize(thumb);
    const value = context.values[index2];
    const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
    const label = getLabel(index2, context.values.length);
    const orientationSize = size2?.[orientation.size];
    const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;
    reactExports.useEffect(() => {
      if (thumb) {
        context.thumbs.add(thumb);
        return () => {
          context.thumbs.delete(thumb);
        };
      }
    }, [thumb, context.thumbs]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.ItemSlot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.span,
            {
              role: "slider",
              "aria-label": props["aria-label"] || label,
              "aria-valuemin": context.min,
              "aria-valuenow": value,
              "aria-valuemax": context.max,
              "aria-orientation": context.orientation,
              "data-orientation": context.orientation,
              "data-disabled": context.disabled ? "" : void 0,
              tabIndex: context.disabled ? void 0 : 0,
              ...thumbProps,
              ref: composedRefs,
              style: value === void 0 ? { display: "none" } : props.style,
              onFocus: composeEventHandlers(props.onFocus, () => {
                context.valueIndexToChangeRef.current = index2;
              })
            }
          ) }),
          isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderBubbleInput,
            {
              name: name ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0),
              form: context.form,
              value
            },
            index2
          )
        ]
      }
    );
  }
);
SliderThumb.displayName = THUMB_NAME;
var BUBBLE_INPUT_NAME = "RadioBubbleInput";
var SliderBubbleInput = reactExports.forwardRef(
  ({ __scopeSlider, value, ...props }, forwardedRef) => {
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevValue = usePrevious(value);
    reactExports.useEffect(() => {
      const input = ref.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("input", { bubbles: true });
        setValue.call(input, value);
        input.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.input,
      {
        style: { display: "none" },
        ...props,
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SliderBubbleInput.displayName = BUBBLE_INPUT_NAME;
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function convertValueToPercentage(value, min2, max2) {
  const maxSteps = max2 - min2;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min2);
  return clamp(percentage, [0, 100]);
}
function getLabel(index2, totalValues) {
  if (totalValues > 2) {
    return `Value ${index2 + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index2];
  } else {
    return void 0;
  }
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1) return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset2 = linearScale([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset2(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index2) => values[index2 + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var Root = Slider;
var Track = SliderTrack;
var Range$1 = SliderRange;
var Thumb = SliderThumb;
var PROVIDER_NAME$1 = "ToastProvider";
var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
var [createToastContext] = createContextScope("Toast", [createCollectionScope]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME$1);
var ToastProvider = (props) => {
  const {
    __scopeToast,
    label = "Notification",
    duration = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50,
    children
  } = props;
  const [viewport, setViewport] = reactExports.useState(null);
  const [toastCount, setToastCount] = reactExports.useState(0);
  const isFocusedToastEscapeKeyDownRef = reactExports.useRef(false);
  const isClosePausedRef = reactExports.useRef(false);
  if (!label.trim()) {
    console.error(
      `Invalid prop \`label\` supplied to \`${PROVIDER_NAME$1}\`. Expected non-empty \`string\`.`
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToastProviderProvider,
    {
      scope: __scopeToast,
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange: setViewport,
      onToastAdd: reactExports.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
      onToastRemove: reactExports.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef,
      children
    }
  ) });
};
ToastProvider.displayName = PROVIDER_NAME$1;
var VIEWPORT_NAME = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
    const getItems = useCollection(__scopeToast);
    const wrapperRef = reactExports.useRef(null);
    const headFocusProxyRef = reactExports.useRef(null);
    const tailFocusProxyRef = reactExports.useRef(null);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    reactExports.useEffect(() => {
      const handleKeyDown2 = (event) => {
        const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed) ref.current?.focus();
      };
      document.addEventListener("keydown", handleKeyDown2);
      return () => document.removeEventListener("keydown", handleKeyDown2);
    }, [hotkey]);
    reactExports.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport = ref.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside) handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef]);
    const getSortedTabbableCandidates = reactExports.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    reactExports.useEffect(() => {
      const viewport = ref.current;
      if (viewport) {
        const handleKeyDown2 = (event) => {
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              headFocusProxyRef.current?.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown2);
        return () => viewport.removeEventListener("keydown", handleKeyDown2);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Branch$1,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport.displayName = VIEWPORT_NAME;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VisuallyHidden,
      {
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);
          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? true,
      onChange: onOpenChange,
      caller: TOAST_NAME
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef$1(props.onPause),
        onResume: useCallbackRef$1(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode2] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode2(node2));
    const pointerStartRef = reactExports.useRef(null);
    const swipeDeltaRef = reactExports.useRef(null);
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = reactExports.useRef(0);
    const closeTimerRemainingTimeRef = reactExports.useRef(duration);
    const closeTimerRef = reactExports.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef$1(() => {
      const isFocusInToast = node?.contains(document.activeElement);
      if (isFocusInToast) context.viewport?.focus();
      onClose();
    });
    const startTimer = reactExports.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity) return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    reactExports.useEffect(() => {
      const viewport = context.viewport;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume?.();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause?.();
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context.viewport, duration, onPause, onResume, startTimer]);
    reactExports.useEffect(() => {
      if (open && !context.isClosePausedRef.current) startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]);
    reactExports.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = reactExports.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context.viewport) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$5,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
              context.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.li,
              {
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape") return;
                  onEscapeKeyDown?.(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0) return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current) return;
                  const x = event.clientX - pointerStartRef.current.x;
                  const y = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                  const clamp2 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp2(0, x) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp2(0, y) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = reactExports.useState(false);
  const [isAnnounced, setIsAnnounced] = reactExports.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  reactExports.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    context.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME = "ToastTitle";
var ToastTitle = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "ToastDescription";
var ToastDescription = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "ToastAction";
var ToastAction = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction.displayName = ACTION_NAME;
var CLOSE_NAME = "ToastClose";
var ToastClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose.displayName = CLOSE_NAME;
var ToastAnnounceExclude = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText) textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
  if (handler) currentTarget.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef$1(callback);
  useLayoutEffect2(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
var Provider$1 = ToastProvider;
var Root2$1 = Toast;
var Title = ToastTitle;
var Description = ToastDescription;
var Action = ToastAction;
var Close = ToastClose;
var NAME = "Toggle";
var Toggle = reactExports.forwardRef((props, forwardedRef) => {
  const { pressed: pressedProp, defaultPressed, onPressedChange, ...buttonProps } = props;
  const [pressed, setPressed] = useControllableState({
    prop: pressedProp,
    onChange: onPressedChange,
    defaultProp: defaultPressed ?? false,
    caller: NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.button,
    {
      type: "button",
      "aria-pressed": pressed,
      "data-state": pressed ? "on" : "off",
      "data-disabled": props.disabled ? "" : void 0,
      ...buttonProps,
      ref: forwardedRef,
      onClick: composeEventHandlers(props.onClick, () => {
        if (!props.disabled) {
          setPressed(!pressed);
        }
      })
    }
  );
});
Toggle.displayName = NAME;
var TOGGLE_GROUP_NAME$1 = "ToggleGroup";
var [createToggleGroupContext, createToggleGroupScope] = createContextScope(TOGGLE_GROUP_NAME$1, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope$1 = createRovingFocusGroupScope();
var ToggleGroup$1 = React.forwardRef((props, forwardedRef) => {
  const { type, ...toggleGroupProps } = props;
  if (type === "single") {
    const singleProps = toggleGroupProps;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplSingle, { ...singleProps, ref: forwardedRef });
  }
  if (type === "multiple") {
    const multipleProps = toggleGroupProps;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplMultiple, { ...multipleProps, ref: forwardedRef });
  }
  throw new Error(`Missing prop \`type\` expected on \`${TOGGLE_GROUP_NAME$1}\``);
});
ToggleGroup$1.displayName = TOGGLE_GROUP_NAME$1;
var [ToggleGroupValueProvider, useToggleGroupValueContext] = createToggleGroupContext(TOGGLE_GROUP_NAME$1);
var ToggleGroupImplSingle = React.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...toggleGroupSingleProps
  } = props;
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? "",
    onChange: onValueChange,
    caller: TOGGLE_GROUP_NAME$1
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "single",
      value: React.useMemo(() => value ? [value] : [], [value]),
      onItemActivate: setValue,
      onItemDeactivate: React.useCallback(() => setValue(""), [setValue]),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImpl, { ...toggleGroupSingleProps, ref: forwardedRef })
    }
  );
});
var ToggleGroupImplMultiple = React.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...toggleGroupMultipleProps
  } = props;
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? [],
    onChange: onValueChange,
    caller: TOGGLE_GROUP_NAME$1
  });
  const handleButtonActivate = React.useCallback(
    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
    [setValue]
  );
  const handleButtonDeactivate = React.useCallback(
    (itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)),
    [setValue]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "multiple",
      value,
      onItemActivate: handleButtonActivate,
      onItemDeactivate: handleButtonDeactivate,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImpl, { ...toggleGroupMultipleProps, ref: forwardedRef })
    }
  );
});
ToggleGroup$1.displayName = TOGGLE_GROUP_NAME$1;
var [ToggleGroupContext, useToggleGroupContext] = createToggleGroupContext(TOGGLE_GROUP_NAME$1);
var ToggleGroupImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToggleGroup,
      disabled = false,
      rovingFocus = true,
      orientation,
      dir,
      loop = true,
      ...toggleGroupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeToggleGroup);
    const direction = useDirection(dir);
    const commonProps = { role: "group", dir: direction, ...toggleGroupProps };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupContext, { scope: __scopeToggleGroup, rovingFocus, disabled, children: rovingFocus ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$2,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation,
        dir: direction,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...commonProps, ref: forwardedRef })
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...commonProps, ref: forwardedRef }) });
  }
);
var ITEM_NAME = "ToggleGroupItem";
var ToggleGroupItem = React.forwardRef(
  (props, forwardedRef) => {
    const valueContext = useToggleGroupValueContext(ITEM_NAME, props.__scopeToggleGroup);
    const context = useToggleGroupContext(ITEM_NAME, props.__scopeToggleGroup);
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(props.__scopeToggleGroup);
    const pressed = valueContext.value.includes(props.value);
    const disabled = context.disabled || props.disabled;
    const commonProps = { ...props, pressed, disabled };
    const ref = React.useRef(null);
    return context.rovingFocus ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: pressed,
        ref,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef })
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef });
  }
);
ToggleGroupItem.displayName = ITEM_NAME;
var ToggleGroupItemImpl = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToggleGroup, value, ...itemProps } = props;
    const valueContext = useToggleGroupValueContext(ITEM_NAME, __scopeToggleGroup);
    const singleProps = { role: "radio", "aria-checked": props.pressed, "aria-pressed": void 0 };
    const typeProps = valueContext.type === "single" ? singleProps : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Toggle,
      {
        ...typeProps,
        ...itemProps,
        ref: forwardedRef,
        onPressedChange: (pressed) => {
          if (pressed) {
            valueContext.onItemActivate(value);
          } else {
            valueContext.onItemDeactivate(value);
          }
        }
      }
    );
  }
);
var Root2 = ToggleGroup$1;
var Item2 = ToggleGroupItem;
var TOOLBAR_NAME = "Toolbar";
var [createToolbarContext] = createContextScope(TOOLBAR_NAME, [
  createRovingFocusGroupScope,
  createToggleGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var useToggleGroupScope = createToggleGroupScope();
var [ToolbarProvider, useToolbarContext] = createToolbarContext(TOOLBAR_NAME);
var Toolbar = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, orientation = "horizontal", dir, loop = true, ...toolbarProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToolbar);
    const direction = useDirection(dir);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarProvider, { scope: __scopeToolbar, orientation, dir: direction, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$2,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation,
        dir: direction,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "toolbar",
            "aria-orientation": orientation,
            dir: direction,
            ...toolbarProps,
            ref: forwardedRef
          }
        )
      }
    ) });
  }
);
Toolbar.displayName = TOOLBAR_NAME;
var SEPARATOR_NAME = "ToolbarSeparator";
var ToolbarSeparator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...separatorProps } = props;
    const context = useToolbarContext(SEPARATOR_NAME, __scopeToolbar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$1,
      {
        orientation: context.orientation === "horizontal" ? "vertical" : "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
ToolbarSeparator.displayName = SEPARATOR_NAME;
var BUTTON_NAME = "ToolbarButton";
var ToolbarButton = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...buttonProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToolbar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: !props.disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.button, { type: "button", ...buttonProps, ref: forwardedRef }) });
  }
);
ToolbarButton.displayName = BUTTON_NAME;
var LINK_NAME = "ToolbarLink";
var ToolbarLink = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...linkProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToolbar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.a,
      {
        ...linkProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === " ") event.currentTarget.click();
        })
      }
    ) });
  }
);
ToolbarLink.displayName = LINK_NAME;
var TOGGLE_GROUP_NAME = "ToolbarToggleGroup";
var ToolbarToggleGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...toggleGroupProps } = props;
    const context = useToolbarContext(TOGGLE_GROUP_NAME, __scopeToolbar);
    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root2,
      {
        "data-orientation": context.orientation,
        dir: context.dir,
        ...toggleGroupScope,
        ...toggleGroupProps,
        ref: forwardedRef,
        rovingFocus: false
      }
    );
  }
);
ToolbarToggleGroup.displayName = TOGGLE_GROUP_NAME;
var TOGGLE_ITEM_NAME = "ToolbarToggleItem";
var ToolbarToggleItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...toggleItemProps } = props;
    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);
    const scope = { __scopeToolbar: props.__scopeToolbar };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarButton, { asChild: true, ...scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Item2, { ...toggleGroupScope, ...toggleItemProps, ref: forwardedRef }) });
  }
);
ToolbarToggleItem.displayName = TOGGLE_ITEM_NAME;
var Root4 = Toolbar;
var Button = ToolbarButton;
var ToggleGroup = ToolbarToggleGroup;
var ToggleItem = ToolbarToggleItem;
var [createTooltipContext] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = reactExports.useRef(true);
  const isPointerInTransitRef = reactExports.useRef(false);
  const skipDelayTimerRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayedRef,
      delayDuration,
      onOpen: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        isOpenDelayedRef.current = false;
      }, []),
      onClose: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => isOpenDelayedRef.current = true,
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: reactExports.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger2, setTrigger] = reactExports.useState(null);
  const contentId = useId();
  const openTimerRef = reactExports.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = reactExports.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange?.(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = reactExports.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  reactExports.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      onTriggerEnter: reactExports.useCallback(() => {
        if (providerContext.isOpenDelayedRef.current) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
      onTriggerLeave: reactExports.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME = "TooltipTrigger";
var TooltipTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = reactExports.useRef(false);
    const hasPointerMoveOpenedRef = reactExports.useRef(false);
    const handlePointerUp = reactExports.useCallback(() => isPointerDownRef.current = false, []);
    reactExports.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          if (context.open) {
            context.onClose();
          }
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, {
  forceMount: void 0
});
var CONTENT_NAME = "TooltipContent";
var TooltipContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = reactExports.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = reactExports.useState(null);
  const { trigger: trigger2, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = reactExports.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = reactExports.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  reactExports.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (trigger2 && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger2);
      trigger2.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger2.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger2, content, handleCreateGraceArea, handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = trigger2?.contains(target) || content?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger2, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable = /* @__PURE__ */ createSlottable("TooltipContent");
var TooltipContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    reactExports.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    reactExports.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target?.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$6, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME;
var ARROW_NAME = "TooltipArrow";
var TooltipArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x) return -1;
    else if (a.x > b.x) return 1;
    else if (a.y < b.y) return -1;
    else if (a.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider;
var Root3 = Tooltip;
var Trigger = TooltipTrigger;
var Content2 = TooltipContent;
var Arrow2 = TooltipArrow;
const TldrawUiIcon = reactExports.memo(function TldrawUiIcon2({
  label,
  small,
  invertIcon,
  icon,
  color,
  className,
  ...props
}) {
  if (typeof icon === "string") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUIIconInner,
      {
        label,
        small,
        invertIcon,
        icon,
        color,
        className,
        ...props
      }
    );
  }
  return reactExports.cloneElement(icon, {
    ...props,
    className: classNames({ "tlui-icon__small": small }, className, icon.props.className),
    "aria-label": label,
    style: {
      color,
      transform: invertIcon ? "scale(-1, 1)" : void 0,
      ...icon.props.style
    }
  });
});
function TldrawUIIconInner({
  label,
  small,
  invertIcon,
  icon,
  color,
  className,
  ...props
}) {
  const assetUrls = useAssetUrls();
  const asset = assetUrls.icons[icon] ?? assetUrls.icons["question-mark-circle"];
  const ref = reactExports.useRef(null);
  reactExports.useLayoutEffect(() => {
    if (!asset) {
      console.error(`Icon not found: ${icon}. Add it to the assetUrls.icons object.`);
    }
    if (ref?.current) {
      ref.current.style.webkitMask = `url(${asset}) center 100% / 100% no-repeat`;
    }
  }, [ref, asset, icon]);
  if (icon === "none") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: classNames(
          "tlui-icon tlui-icon__placeholder",
          { "tlui-icon__small": small },
          className
        ),
        ...props
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ...props,
      ref,
      "aria-label": label,
      role: "img",
      className: classNames("tlui-icon", { "tlui-icon__small": small }, className),
      style: {
        color,
        mask: `url(${asset}) center 100% / 100% no-repeat`,
        transform: invertIcon ? "scale(-1, 1)" : void 0
      }
    }
  );
}
function TldrawUiButtonIcon({ icon, small, invertIcon }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiIcon,
    {
      "aria-hidden": "true",
      label: "",
      className: "tlui-button__icon",
      icon,
      small,
      invertIcon
    }
  );
}
function TldrawUiDialogHeader({ className, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("tlui-dialog__header", className), children });
}
function TldrawUiDialogTitle({ className, children, style: style2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Title$1,
    {
      dir: "ltr",
      className: classNames("tlui-dialog__header__title", className),
      style: style2,
      children
    }
  );
}
function TldrawUiDialogCloseButton() {
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-dialog__header__close", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogClose, { "data-testid": "dialog.close", dir: "ltr", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiButton,
    {
      type: "icon",
      "aria-label": msg2("ui.close"),
      onTouchEnd: (e) => e.target.click(),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "cross-2" })
    }
  ) }) });
}
function TldrawUiDialogBody({ className, children, style: style2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("tlui-dialog__body", className), style: style2, tabIndex: 0, children });
}
function TldrawUiDialogFooter({ className, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("tlui-dialog__footer", className), children });
}
const TldrawUiInput = reactExports.forwardRef(
  function TldrawUiInput2({
    className,
    label,
    icon,
    iconLeft,
    iconLabel,
    autoSelect = false,
    autoFocus = false,
    defaultValue,
    placeholder,
    onComplete,
    onValueChange,
    onCancel,
    onFocus,
    onBlur,
    shouldManuallyMaintainScrollPositionWhenFocused = false,
    children,
    value,
    "data-testid": dataTestId,
    disabled,
    "aria-label": ariaLabel
  }, ref) {
    const editor = useMaybeEditor();
    const rInputRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref, () => rInputRef.current);
    const msg2 = useTranslation();
    const rInitialValue = reactExports.useRef(defaultValue ?? "");
    const rCurrentValue = reactExports.useRef(defaultValue ?? "");
    const isComposing = reactExports.useRef(false);
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const handleFocus = reactExports.useCallback(
      (e) => {
        setIsFocused(true);
        const elm = e.currentTarget;
        rCurrentValue.current = elm.value;
        if (editor) {
          editor.timers.requestAnimationFrame(() => {
            if (autoSelect) {
              elm.select();
            }
          });
        } else {
          tltime.requestAnimationFrame("anon", () => {
            if (autoSelect) {
              elm.select();
            }
          });
        }
        onFocus?.();
      },
      [autoSelect, editor, onFocus]
    );
    const handleChange = reactExports.useCallback(
      (e) => {
        const value2 = e.currentTarget.value;
        rCurrentValue.current = value2;
        onValueChange?.(value2);
      },
      [onValueChange]
    );
    const handleKeyDownCapture = reactExports.useCallback(
      (e) => {
        switch (e.key) {
          case "Enter": {
            if (isComposing.current) return;
            e.currentTarget.blur();
            e.stopPropagation();
            onComplete?.(e.currentTarget.value);
            break;
          }
          case "Escape": {
            e.currentTarget.value = rInitialValue.current;
            onCancel?.(e.currentTarget.value);
            e.currentTarget.blur();
            e.stopPropagation();
            break;
          }
        }
      },
      [onComplete, onCancel]
    );
    const handleBlur = reactExports.useCallback(
      (e) => {
        setIsFocused(false);
        const value2 = e.currentTarget.value;
        onBlur?.(value2);
      },
      [onBlur]
    );
    const handleCompositionStart = reactExports.useCallback(() => isComposing.current = true, []);
    const handleCompositionEnd = reactExports.useCallback(() => isComposing.current = false, []);
    reactExports.useEffect(() => {
      if (!tlenv.isIos) return;
      const visualViewport = window.visualViewport;
      if (isFocused && shouldManuallyMaintainScrollPositionWhenFocused && visualViewport) {
        const onViewportChange = () => {
          rInputRef.current?.scrollIntoView({ block: "center" });
        };
        visualViewport.addEventListener("resize", onViewportChange);
        visualViewport.addEventListener("scroll", onViewportChange);
        if (editor) {
          editor.timers.requestAnimationFrame(() => {
            rInputRef.current?.scrollIntoView({ block: "center" });
          });
        } else {
          tltime.requestAnimationFrame("anon", () => {
            rInputRef.current?.scrollIntoView({ block: "center" });
          });
        }
        return () => {
          visualViewport.removeEventListener("resize", onViewportChange);
          visualViewport.removeEventListener("scroll", onViewportChange);
        };
      }
    }, [isFocused, editor, shouldManuallyMaintainScrollPositionWhenFocused]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { draggable: false, className: "tlui-input__wrapper", children: [
      children,
      label && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: msg2(label) }),
      iconLeft && /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiIcon,
        {
          label: iconLabel ? msg2(iconLabel) : "",
          icon: iconLeft,
          className: "tlui-icon-left",
          small: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          ref: rInputRef,
          className: classNames("tlui-input", className),
          type: "text",
          defaultValue,
          onKeyDownCapture: handleKeyDownCapture,
          onChange: handleChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onCompositionStart: handleCompositionStart,
          onCompositionEnd: handleCompositionEnd,
          autoFocus,
          "aria-label": ariaLabel,
          placeholder,
          value,
          "data-testid": dataTestId,
          disabled
        }
      ),
      icon && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiIcon, { label: iconLabel ? msg2(iconLabel) : "", icon, small: !!label })
    ] });
  }
);
function validateUrl(url) {
  if (linkUrl.isValid(url)) {
    return { isValid: true, hasProtocol: true };
  }
  if (linkUrl.isValid("https://" + url)) {
    return { isValid: true, hasProtocol: false };
  }
  return { isValid: false, hasProtocol: false };
}
const EditLinkDialog = track(function EditLinkDialog2({ onClose }) {
  const editor = useEditor();
  const selectedShape = editor.getOnlySelectedShape();
  if (!(selectedShape && "url" in selectedShape.props && typeof selectedShape.props.url === "string")) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EditLinkDialogInner, { onClose, selectedShape });
});
const EditLinkDialogInner = track(function EditLinkDialogInner2({
  onClose,
  selectedShape
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const rInput = reactExports.useRef(null);
  reactExports.useEffect(() => {
    editor.timers.requestAnimationFrame(() => rInput.current?.focus());
  }, [editor]);
  const rInitialValue = reactExports.useRef(selectedShape.props.url);
  const [urlInputState, setUrlInputState] = reactExports.useState(() => {
    const urlValidResult = validateUrl(selectedShape.props.url);
    const initialValue = urlValidResult.isValid === true ? urlValidResult.hasProtocol ? selectedShape.props.url : "https://" + selectedShape.props.url : "https://";
    return {
      actual: initialValue,
      safe: initialValue,
      valid: true
    };
  });
  const handleChange = reactExports.useCallback((rawValue) => {
    const fixedRawValue = rawValue.replace(/https?:\/\/(https?:\/\/)/, (_match, arg1) => {
      return arg1;
    });
    const urlValidResult = validateUrl(fixedRawValue);
    const safeValue = urlValidResult.isValid === true ? urlValidResult.hasProtocol ? fixedRawValue : "https://" + fixedRawValue : "https://";
    setUrlInputState({
      actual: fixedRawValue,
      safe: safeValue,
      valid: urlValidResult.isValid
    });
  }, []);
  const handleClear = reactExports.useCallback(() => {
    const onlySelectedShape = editor.getOnlySelectedShape();
    if (!onlySelectedShape) return;
    editor.updateShapes([
      { id: onlySelectedShape.id, type: onlySelectedShape.type, props: { url: "" } }
    ]);
    onClose();
  }, [editor, onClose]);
  const handleComplete = reactExports.useCallback(() => {
    const onlySelectedShape = editor.getOnlySelectedShape();
    if (!onlySelectedShape) return;
    if (onlySelectedShape && "url" in onlySelectedShape.props) {
      if (onlySelectedShape.props.url !== urlInputState.safe) {
        editor.updateShapes([
          {
            id: onlySelectedShape.id,
            type: onlySelectedShape.type,
            props: { url: urlInputState.safe }
          }
        ]);
      }
    }
    onClose();
  }, [editor, onClose, urlInputState]);
  const handleCancel = reactExports.useCallback(() => {
    onClose();
  }, [onClose]);
  if (!selectedShape) {
    onClose();
    return null;
  }
  const isRemoving = rInitialValue.current && !urlInputState.valid;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogTitle, { children: msg2("edit-link-dialog.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogCloseButton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogBody, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-edit-link-dialog", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiInput,
        {
          ref: rInput,
          className: "tlui-edit-link-dialog__input",
          label: "edit-link-dialog.url",
          autoFocus: true,
          autoSelect: true,
          placeholder: "https://example.com",
          value: urlInputState.actual,
          onValueChange: handleChange,
          onComplete: handleComplete,
          onCancel: handleCancel
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: urlInputState.valid ? msg2("edit-link-dialog.detail") : msg2("edit-link-dialog.invalid-url") })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "normal", onClick: handleCancel, onTouchEnd: handleCancel, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.cancel") }) }),
      isRemoving ? /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "danger", onTouchEnd: handleClear, onClick: handleClear, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.clear") }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiButton,
        {
          type: "primary",
          disabled: !urlInputState.valid,
          onTouchEnd: handleComplete,
          onClick: handleComplete,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.save") })
        }
      )
    ] })
  ] });
});
var define_process_env_default = {};
const TLDRAW_APP_RE = /(^\/[f|p|r|ro|s|v]\/[^/]+\/?$)/;
const DEFAULT_EMBED_DEFINITIONS = [
  {
    type: "tldraw",
    title: "tldraw",
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: true,
    overridePermissions: {
      "allow-top-navigation": true
    },
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {
        urlObj.searchParams.append("embed", "true");
        return url;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {
        urlObj.searchParams.delete("embed");
        return url;
      }
      return;
    },
    embedOnPaste: false
  },
  {
    type: "figma",
    title: "Figma",
    hostnames: ["figma.com"],
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      if (!!url.match(
        // eslint-disable-next-line no-useless-escape
        /https:\/\/([\w\.-]+\.)?figma.com\/(file|proto|design)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/
      ) && !url.includes("figma.com/embed")) {
        return `https://www.figma.com/embed?embed_host=share&url=${url}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/?$/)) {
        const outUrl = urlObj.searchParams.get("url");
        if (outUrl) {
          return outUrl;
        }
      }
      return;
    },
    embedOnPaste: true
  },
  {
    type: "google_maps",
    title: "Google Maps",
    hostnames: ["google.*"],
    width: 720,
    height: 500,
    doesResize: true,
    overridePermissions: {
      "allow-presentation": true
    },
    toEmbedUrl: (url) => {
      if (url.includes("/maps/embed?")) {
        return url;
      } else if (url.includes("/maps/")) {
        const match = url.match(/@(.*?),(.*?),(.*?)(z|m)/);
        let result;
        if (match) {
          const [, lat, lng, zoomOrMeters, mapTypeSymbol] = match;
          const mapType = mapTypeSymbol === "z" ? "roadmap" : "satellite";
          const z = mapType === "roadmap" ? zoomOrMeters : -Math.log2(parseInt(zoomOrMeters) / 14772321) / 0.8;
          const host = new URL(url).host.replace("www.", "");
          result = `https://${host}/maps/embed/v1/view?key=${define_process_env_default.NEXT_PUBLIC_GC_API_KEY}&center=${lat},${lng}&zoom=${z}&maptype=${mapType}`;
        } else {
          result = "";
        }
        return result;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const matches2 = urlObj.pathname.match(/^\/maps\/embed\/v1\/view\/?$/);
      if (matches2 && urlObj.searchParams.has("center") && urlObj.searchParams.get("zoom")) {
        const zoom = urlObj.searchParams.get("zoom") ?? "12";
        const mapType = urlObj.searchParams.get("maptype") ?? "roadmap";
        const zoomOrMeters = mapType === "roadmap" ? zoom : 14772321 * Math.pow(2, parseInt(zoom) * -0.8);
        const [lat, lon] = urlObj.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${lat},${lon},${zoomOrMeters}${mapType === "roadmap" ? "z" : "m"}`;
      }
      return;
    },
    embedOnPaste: true
  },
  {
    type: "val_town",
    title: "Val Town",
    hostnames: ["val.town"],
    minWidth: 260,
    minHeight: 100,
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/v\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/embed/${matches2[1]}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/v/${matches2[1]}`;
      }
      return;
    },
    embedOnPaste: true
  },
  {
    type: "codesandbox",
    title: "CodeSandbox",
    hostnames: ["codesandbox.io"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/s\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/embed/${matches2[1]}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/s/${matches2[1]}`;
      }
      return;
    },
    embedOnPaste: true
  },
  {
    type: "codepen",
    title: "Codepen",
    hostnames: ["codepen.io"],
    minWidth: 300,
    minHeight: 300,
    width: 520,
    height: 400,
    doesResize: true,
    toEmbedUrl: (url) => {
      const CODEPEN_URL_REGEXP = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/;
      const matches2 = url.match(CODEPEN_URL_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/embed/${id}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const CODEPEN_EMBED_REGEXP = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/;
      const matches2 = url.match(CODEPEN_EMBED_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/pen/${id}`;
      }
      return;
    },
    embedOnPaste: true
  },
  {
    type: "scratch",
    title: "Scratch",
    hostnames: ["scratch.mit.edu"],
    width: 520,
    height: 400,
    doesResize: false,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const SCRATCH_URL_REGEXP = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/;
      const matches2 = url.match(SCRATCH_URL_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/embed/${id}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const SCRATCH_EMBED_REGEXP = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/;
      const matches2 = url.match(SCRATCH_EMBED_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/${id}`;
      }
      return;
    }
  },
  {
    type: "youtube",
    title: "YouTube",
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    width: 800,
    height: 450,
    doesResize: true,
    overridePermissions: {
      "allow-presentation": true,
      "allow-popups-to-escape-sandbox": true
    },
    isAspectRatioLocked: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtu.be") {
        const videoId = urlObj.pathname.split("/").filter(Boolean)[0];
        const searchParams = new URLSearchParams(urlObj.search);
        const timeStart = searchParams.get("t");
        if (timeStart) {
          searchParams.set("start", timeStart);
          searchParams.delete("t");
        }
        const search = searchParams.toString() ? "?" + searchParams.toString() : "";
        return `https://www.youtube.com/embed/${videoId}${search}`;
      } else if ((hostname === "youtube.com" || hostname === "m.youtube.com") && urlObj.pathname.match(/^\/watch/)) {
        const videoId = urlObj.searchParams.get("v");
        const searchParams = new URLSearchParams(urlObj.search);
        searchParams.delete("v");
        const timeStart = searchParams.get("t");
        if (timeStart) {
          searchParams.set("start", timeStart);
          searchParams.delete("t");
        }
        const search = searchParams.toString() ? "?" + searchParams.toString() : "";
        return `https://www.youtube.com/embed/${videoId}${search}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtube.com") {
        const matches2 = urlObj.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (matches2) {
          const params = new URLSearchParams(urlObj.search);
          params.set("v", matches2?.[1] ?? "");
          const timeStart = params.get("start");
          if (timeStart) {
            params.set("t", timeStart);
            params.delete("start");
          }
          return `https://www.youtube.com/watch?${params.toString()}`;
        }
      }
      return;
    }
  },
  {
    type: "google_calendar",
    title: "Google Calendar",
    hostnames: ["calendar.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: true,
    instructionLink: "https://support.google.com/calendar/answer/41207?hl=en",
    overridePermissions: {
      "allow-popups-to-escape-sandbox": true
    },
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const cidQs = urlObj?.searchParams.get("cid");
      if (urlObj?.pathname.match(/\/calendar\/u\/0/) && cidQs) {
        urlObj.pathname = "/calendar/embed";
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("src", cidQs);
        return urlObj.href;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const srcQs = urlObj?.searchParams.get("src");
      if (urlObj?.pathname.match(/\/calendar\/embed/) && srcQs) {
        urlObj.pathname = "/calendar/u/0";
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("cid", srcQs);
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "google_slides",
    title: "Google Slides",
    hostnames: ["docs.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: true,
    overridePermissions: {
      "allow-popups-to-escape-sandbox": true
    },
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj?.pathname.match(/^\/presentation/) && urlObj?.pathname.match(/\/pub\/?$/)) {
        urlObj.pathname = urlObj.pathname.replace(/\/pub$/, "/embed");
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj?.pathname.match(/^\/presentation/) && urlObj?.pathname.match(/\/embed\/?$/)) {
        urlObj.pathname = urlObj.pathname.replace(/\/embed$/, "/pub");
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "github_gist",
    title: "GitHub Gist",
    hostnames: ["gist.github.com"],
    width: 720,
    height: 500,
    doesResize: true,
    embedOnPaste: true,
    // Security warning:
    // Gists allow adding .json extensions to the URL which return JSONP.
    // Furthermore, the JSONP can include callbacks that execute arbitrary JavaScript.
    // It _is_ sandboxed by the iframe but we still want to disable it nonetheless.
    // We restrict the id to only allow hexdecimal characters to prevent this.
    // Read more:
    //   https://github.com/bhaveshk90/Content-Security-Policy-CSP-Bypass-Techniques
    //   https://github.com/renniepak/CSPBypass
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/)) {
        if (!url.split("/").pop()) return;
        return url;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/)) {
        if (!url.split("/").pop()) return;
        return url;
      }
      return;
    }
  },
  {
    type: "replit",
    title: "Replit",
    hostnames: ["replit.com"],
    width: 720,
    height: 500,
    doesResize: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/)) {
        urlObj.searchParams.append("embed", "true");
        return urlObj.href;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/) && urlObj.searchParams.has("embed")) {
        urlObj.searchParams.delete("embed");
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "felt",
    title: "Felt",
    hostnames: ["felt.com"],
    width: 720,
    height: 500,
    doesResize: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/map\//)) {
        return urlObj.origin + "/embed" + urlObj.pathname;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/map\//)) {
        urlObj.pathname = urlObj.pathname.replace(/^\/embed/, "");
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "spotify",
    title: "Spotify",
    hostnames: ["open.spotify.com"],
    width: 720,
    height: 500,
    minHeight: 500,
    overrideOutlineRadius: 12,
    doesResize: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/(artist|album)\//)) {
        return urlObj.origin + "/embed" + urlObj.pathname;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/(artist|album)\//)) {
        return urlObj.origin + urlObj.pathname.replace(/^\/embed/, "");
      }
      return;
    }
  },
  {
    type: "vimeo",
    title: "Vimeo",
    hostnames: ["vimeo.com", "player.vimeo.com"],
    width: 640,
    height: 360,
    doesResize: true,
    isAspectRatioLocked: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "vimeo.com") {
        if (urlObj.pathname.match(/^\/[0-9]+/)) {
          return "https://player.vimeo.com/video/" + urlObj.pathname.split("/")[1] + "?title=0&byline=0";
        }
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "player.vimeo.com") {
        const matches2 = urlObj.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (matches2) {
          return "https://vimeo.com/" + matches2[1];
        }
      }
      return;
    }
  },
  {
    type: "observable",
    title: "Observable",
    hostnames: ["observablehq.com"],
    width: 720,
    height: 500,
    doesResize: true,
    isAspectRatioLocked: false,
    backgroundColor: "#fff",
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}/embed${urlObj.pathname}?cell=*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/d\/([^/]+)\/?$/)) {
        const pathName = urlObj.pathname.replace(/^\/d/, "");
        return `${urlObj.origin}/embed${pathName}?cell=*`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "")}#cell-*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/embed\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "/d")}#cell-*`;
      }
      return;
    }
  },
  {
    type: "desmos",
    title: "Desmos",
    hostnames: ["desmos.com"],
    width: 700,
    height: 450,
    doesResize: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "" && urlObj.hash === "") {
        return `${url}?embed`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "?embed" && urlObj.hash === "") {
        return url.replace("?embed", "");
      }
      return;
    }
  }
];
const embedShapePermissionDefaults = {
  // ========================================================================================
  // Disabled permissions
  // ========================================================================================
  // [MDN] Experimental: Allows for downloads to occur without a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads-without-user-activation": false,
  // [MDN] Allows for downloads to occur with a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads": false,
  // [MDN] Lets the resource open modal windows.
  // [REASON] The <iframe/> could 'window.prompt("Enter your tldraw password")'.
  "allow-modals": false,
  // [MDN] Lets the resource lock the screen orientation.
  // [REASON] Would interfere with the tldraw interface.
  "allow-orientation-lock": false,
  // [MDN] Lets the resource use the Pointer Lock API.
  // [REASON] Maybe we should allow this for games embeds (scratch/codepen/codesandbox).
  "allow-pointer-lock": false,
  // [MDN] Allows popups (such as window.open(), target="_blank", or showModalDialog()). If this keyword is not used, the popup will silently fail to open.
  // [REASON] We want to allow embeds to link back to their original sites (e.g. YouTube).
  "allow-popups": true,
  // [MDN] Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.
  // [REASON] We shouldn't allow popups as a embed could pretend to be us by opening a mocked version of tldraw. This is very unobvious when it is performed as an action within our app.
  "allow-popups-to-escape-sandbox": false,
  // [MDN] Lets the resource start a presentation session.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-presentation": false,
  // [MDN] Experimental: Lets the resource request access to the parent's storage capabilities with the Storage Access API.
  // [REASON] We don't want anyone else to access our storage.
  "allow-storage-access-by-user-activation": false,
  // [MDN] Lets the resource navigate the top-level browsing context (the one named _top).
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation": false,
  // [MDN] Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation-by-user-activation": false,
  // ========================================================================================
  // Enabled permissions
  // ========================================================================================
  // [MDN] Lets the resource run scripts (but not create popup windows).
  "allow-scripts": true,
  // [MDN] If this token is not used, the resource is treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs).
  "allow-same-origin": true,
  // [MDN] Allows the resource to submit forms. If this keyword is not used, form submission is blocked.
  "allow-forms": true
};
const DEFAULT_EMBED_DEFINITION_TYPES = DEFAULT_EMBED_DEFINITIONS.map(
  (def) => def.type
);
function isDefaultEmbedDefinitionType(type) {
  return DEFAULT_EMBED_DEFINITION_TYPES.includes(type);
}
function isCustomEmbedDefinition(def) {
  return "icon" in def;
}
function useGetEmbedShapeUtil() {
  const editor = useMaybeEditor();
  if (!editor) return void 0;
  if (editor.hasShapeUtil("embed")) {
    return editor.getShapeUtil("embed");
  }
  return void 0;
}
function useGetEmbedDefinition() {
  const embedUtil = useGetEmbedShapeUtil();
  return (url) => {
    return embedUtil ? embedUtil.getEmbedDefinition(url) : void 0;
  };
}
function useGetEmbedDefinitions() {
  const embedUtil = useGetEmbedShapeUtil();
  return embedUtil ? embedUtil.getEmbedDefinitions() : [];
}
const EmbedDialog = track(function EmbedDialog2({ onClose }) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const assetUrls = useAssetUrls();
  const [embedDefinition, setEmbedDefinition] = reactExports.useState(null);
  const [url, setUrl] = reactExports.useState("");
  const [embedInfoForUrl, setEmbedInfoForUrl] = reactExports.useState(null);
  const [showError, setShowError] = reactExports.useState(false);
  const rShowErrorTimeout = reactExports.useRef(-1);
  const definitions = useGetEmbedDefinitions();
  const getEmbedDefinition = useGetEmbedDefinition();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogTitle, { children: embedDefinition ? `${msg2("embed-dialog.title")}  ${embedDefinition.title}` : msg2("embed-dialog.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogCloseButton, {})
    ] }),
    embedDefinition ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogBody, { className: "tlui-embed-dialog__enter", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiInput,
          {
            className: "tlui-embed-dialog__input",
            label: "embed-dialog.url",
            placeholder: "https://example.com",
            autoFocus: true,
            onValueChange: (value) => {
              setUrl(value);
              const embedInfo = getEmbedDefinition(value);
              setEmbedInfoForUrl(
                embedInfo && embedInfo.definition.type === embedDefinition.type ? embedInfo : null
              );
              setShowError(false);
              clearTimeout(rShowErrorTimeout.current);
              rShowErrorTimeout.current = editor.timers.setTimeout(
                () => setShowError(!embedInfo),
                320
              );
            }
          }
        ),
        url === "" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-embed-dialog__instruction", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: msg2("embed-dialog.instruction") }),
          " ",
          embedDefinition.instructionLink && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                target: "_blank",
                rel: "noopener noreferrer",
                href: embedDefinition.instructionLink,
                className: "tlui-embed-dialog__instruction__link",
                children: "Learn more"
              }
            ),
            "."
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-embed-dialog__warning", children: showError ? msg2("embed-dialog.invalid-url") : "" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButton,
          {
            type: "normal",
            onClick: () => {
              setEmbedDefinition(null);
              setEmbedInfoForUrl(null);
              setUrl("");
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("embed-dialog.back") })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-embed__spacer" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "normal", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("embed-dialog.cancel") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButton,
          {
            type: "primary",
            disabled: !embedInfoForUrl,
            onClick: () => {
              if (!embedInfoForUrl) return;
              editor.putExternalContent({
                type: "embed",
                url,
                point: editor.getViewportPageBounds().center,
                embed: embedInfoForUrl.definition
              });
              onClose();
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("embed-dialog.create") })
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogBody, { className: "tlui-embed-dialog__list", children: definitions.map((def) => {
      const url2 = isDefaultEmbedDefinitionType(def.type) ? assetUrls.embedIcons[def.type] : isCustomEmbedDefinition(def) ? def.icon : void 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiButton, { type: "menu", onClick: () => setEmbedDefinition(def), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: untranslated(def.title) }),
        url2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "tlui-embed-dialog__item__image",
            style: { backgroundImage: `url(${url2})` }
          }
        )
      ] }, def.type);
    }) }) })
  ] });
});
const PORTRAIT_BREAKPOINTS = [0, 389, 436, 476, 580, 640, 840, 1023];
var PORTRAIT_BREAKPOINT = /* @__PURE__ */ ((PORTRAIT_BREAKPOINT2) => {
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["ZERO"] = 0] = "ZERO";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_XXS"] = 1] = "MOBILE_XXS";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_XS"] = 2] = "MOBILE_XS";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_SM"] = 3] = "MOBILE_SM";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE"] = 4] = "MOBILE";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["TABLET_SM"] = 5] = "TABLET_SM";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["TABLET"] = 6] = "TABLET";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["DESKTOP"] = 7] = "DESKTOP";
  return PORTRAIT_BREAKPOINT2;
})(PORTRAIT_BREAKPOINT || {});
const BreakpointContext = React.createContext(null);
function BreakPointProvider({ forceMobile = false, children }) {
  const editor = useMaybeEditor();
  const breakpoint = useValue(
    "breakpoint",
    () => {
      const { width } = editor?.getViewportScreenBounds() ?? { width: window.innerWidth };
      const maxBreakpoint = forceMobile ? PORTRAIT_BREAKPOINT.MOBILE_SM : PORTRAIT_BREAKPOINTS.length - 1;
      for (let i = 0; i < maxBreakpoint; i++) {
        if (width > PORTRAIT_BREAKPOINTS[i] && width <= PORTRAIT_BREAKPOINTS[i + 1]) {
          return i;
        }
      }
      return maxBreakpoint;
    },
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BreakpointContext.Provider, { value: breakpoint, children });
}
function useBreakpoint() {
  const breakpoint = reactExports.useContext(BreakpointContext);
  if (breakpoint === null) {
    throw new Error("useBreakpoint must be used inside of the <BreakpointProvider /> component");
  }
  return breakpoint;
}
const menuContext = reactExports.createContext(null);
function useTldrawUiMenuContext() {
  const context = reactExports.useContext(menuContext);
  if (!context) {
    throw new Error("useTldrawUiMenuContext must be used within a TldrawUiMenuContextProvider");
  }
  return context;
}
function TldrawUiMenuContextProvider({
  type,
  sourceId,
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(menuContext.Provider, { value: { type, sourceId }, children });
}
function useShowCollaborationUi() {
  const editor = useMaybeEditor();
  return editor?.store.props.collaboration !== void 0;
}
function useCollaborationStatus() {
  const editor = useMaybeEditor();
  return useValue(
    "sync status",
    () => {
      if (!editor?.store.props.collaboration?.status) {
        return null;
      }
      return editor.store.props.collaboration.status.get();
    },
    [editor]
  );
}
function useReadonly() {
  const editor = useMaybeEditor();
  return useValue("isReadonlyMode", () => !!editor?.getIsReadonly(), [editor]);
}
const cmdKey = tlenv.isDarwin ? "" : "__CTRL__";
const ctrlKey = tlenv.isDarwin ? "" : "__CTRL__";
const altKey = tlenv.isDarwin ? "" : "__ALT__";
function kbd(str) {
  if (str === ",") return [","];
  return str.split(",")[0].split(/(\[\[[^\]]+\]\])/g).map(
    (s) => s.startsWith("[[") ? s.replace(/[[\]]/g, "") : s.replace(/cmd\+/g, cmdKey).replace(/ctrl\+/g, ctrlKey).replace(/alt\+/g, altKey).replace(/shift\+/g, "").replace(/\$/g, cmdKey).replace(/\?/g, altKey).replace(/!/g, "").match(/__CTRL__|__ALT__|./g) || []
  ).flat().map((sub, index2) => {
    if (sub[0] === "+") return [];
    let modifiedKey;
    if (sub === "__CTRL__") {
      modifiedKey = "Ctrl";
    } else if (sub === "__ALT__") {
      modifiedKey = "Alt";
    } else {
      modifiedKey = sub[0].toUpperCase() + sub.slice(1);
    }
    return tlenv.isDarwin || !index2 ? modifiedKey : ["+", modifiedKey];
  }).flat();
}
function kbdStr(str) {
  return " " + kbd(str).join("");
}
function Spinner(props) {
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultSpinner, { "aria-label": msg2("app.loading"), ...props });
}
const defaultEventHandler = () => void 0;
const EventsContext = reactExports.createContext(null);
function TldrawUiEventsProvider({ onEvent, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EventsContext.Provider, { value: onEvent ?? defaultEventHandler, children });
}
function useUiEvents() {
  const eventHandler2 = reactExports.useContext(EventsContext);
  return eventHandler2 ?? defaultEventHandler;
}
function useMenuIsOpen(id, cb) {
  const editor = useMaybeEditor();
  const onChange = reactExports.useCallback(
    (isOpen) => {
      if (isOpen) {
        editor?.complete();
      }
      cb?.(isOpen);
    },
    [editor, cb]
  );
  const trackEvent = useUiEvents();
  const onEvent = reactExports.useCallback(
    (eventName) => {
      trackEvent(eventName, { source: "unknown", id });
    },
    [id, trackEvent]
  );
  return useGlobalMenuIsOpen(editor ? `${id}-${editor.contextId}` : id, onChange, onEvent);
}
function TldrawUiDropdownMenuRoot({
  id,
  children,
  modal = false,
  debugOpen = false
}) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root2$3,
    {
      open: debugOpen || open,
      dir: "ltr",
      modal,
      onOpenChange,
      children
    }
  );
}
function TldrawUiDropdownMenuTrigger({ children, ...rest }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Trigger$2,
    {
      dir: "ltr",
      asChild: true,
      onTouchEnd: (e) => preventDefault(e),
      ...rest,
      children
    }
  );
}
function TldrawUiDropdownMenuContent({
  className,
  side = "bottom",
  align = "start",
  sideOffset = 8,
  alignOffset = 8,
  children
}) {
  const container = useContainer();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content2$2,
    {
      className: classNames("tlui-menu", className),
      side,
      sideOffset,
      align,
      alignOffset,
      collisionPadding: 4,
      children
    }
  ) });
}
function TldrawUiDropdownMenuSub({ id, children }) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Sub2, { open, onOpenChange, children });
}
function TldrawUiDropdownMenuSubTrigger({
  id,
  label,
  title,
  disabled
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger2, { dir: "ltr", asChild: true, disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TldrawUiButton,
    {
      "data-testid": id,
      type: "menu",
      className: "tlui-menu__submenu__trigger",
      disabled,
      title,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: label }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "chevron-right", small: true })
      ]
    }
  ) });
}
function TldrawUiDropdownMenuSubContent({
  id,
  alignOffset = -1,
  sideOffset = -6,
  size: size2 = "small",
  children
}) {
  const container = useContainer();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent2,
    {
      "data-testid": id,
      className: "tlui-menu tlui-menu__submenu__content",
      alignOffset,
      sideOffset,
      collisionPadding: 4,
      "data-size": size2,
      children
    }
  ) });
}
function TldrawUiDropdownMenuGroup({ className, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dir: "ltr", className: classNames("tlui-menu__group", className), children });
}
function TldrawUiDropdownMenuItem({ noClose, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$1, { dir: "ltr", asChild: true, onClick: noClose ? preventDefault : void 0, children });
}
function TldrawUiDropdownMenuCheckboxItem({
  children,
  onSelect,
  ...rest
}) {
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    CheckboxItem2,
    {
      dir: "ltr",
      className: "tlui-button tlui-button__menu tlui-button__checkbox",
      onSelect: (e) => {
        onSelect?.(e);
        preventDefault(e);
      },
      ...rest,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-button__checkbox__indicator", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { dir: "ltr", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiIcon, { label: msg2("ui.checked"), icon: "check", small: true }) }) }),
        children
      ]
    }
  );
}
function TldrawUiKbd({ children, visibleOnMobileLayout = false }) {
  const breakpoint = useBreakpoint();
  if (!visibleOnMobileLayout && breakpoint < PORTRAIT_BREAKPOINT.MOBILE) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("kbd", { className: "tlui-kbd", children: kbd(children).map((k, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: k }, i)) });
}
const TldrawUiOrientationContext = reactExports.createContext({
  orientation: "horizontal",
  tooltipSide: "bottom"
});
function TldrawUiOrientationProvider({
  children,
  orientation,
  tooltipSide
}) {
  const prevContext = useTldrawUiOrientation();
  const tooltipSideToUse = tooltipSide ?? (orientation === prevContext.orientation ? prevContext.tooltipSide : orientation === "horizontal" ? "bottom" : "right");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiOrientationContext.Provider, { value: { orientation, tooltipSide: tooltipSideToUse }, children });
}
function useTldrawUiOrientation() {
  return reactExports.useContext(TldrawUiOrientationContext);
}
const TldrawUiRow = reactExports.forwardRef(
  ({ asChild, className, tooltipSide, ...props }, ref) => {
    const Component = asChild ? Slot$3 : "div";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiOrientationProvider, { orientation: "horizontal", tooltipSide, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ref, className: classNames("tlui-row", className), ...props }) });
  }
);
const TldrawUiColumn = reactExports.forwardRef(
  ({ asChild, className, tooltipSide, ...props }, ref) => {
    const Component = asChild ? Slot$3 : "div";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiOrientationProvider, { orientation: "vertical", tooltipSide, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ref, className: classNames("tlui-column", className), ...props }) });
  }
);
const TldrawUiGrid = reactExports.forwardRef(
  ({ asChild, className, tooltipSide, ...props }, ref) => {
    const Component = asChild ? Slot$3 : "div";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiOrientationProvider, { orientation: "horizontal", tooltipSide, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ref, className: classNames("tlui-grid", className), ...props }) });
  }
);
const DEFAULT_TOOLTIP_DELAY_MS = 700;
class TooltipManager {
  static instance = null;
  currentTooltip = atom("current tooltip", null);
  destroyTimeoutId = null;
  static getInstance() {
    if (!TooltipManager.instance) {
      TooltipManager.instance = new TooltipManager();
    }
    return TooltipManager.instance;
  }
  showTooltip(tooltipId, content, targetElement, side, sideOffset, showOnMobile, delayDuration) {
    if (this.destroyTimeoutId) {
      clearTimeout(this.destroyTimeoutId);
      this.destroyTimeoutId = null;
    }
    this.currentTooltip.set({
      id: tooltipId,
      content,
      side,
      sideOffset,
      showOnMobile,
      targetElement,
      delayDuration
    });
  }
  updateCurrentTooltip(tooltipId, update) {
    this.currentTooltip.update((tooltip) => {
      if (tooltip?.id === tooltipId) {
        return update(tooltip);
      }
      return tooltip;
    });
  }
  hideTooltip(editor, tooltipId, instant = false) {
    const hide2 = () => {
      if (this.currentTooltip.get()?.id === tooltipId) {
        this.currentTooltip.set(null);
        this.destroyTimeoutId = null;
      }
    };
    if (editor && !instant) {
      this.destroyTimeoutId = editor.timers.setTimeout(hide2, 300);
    } else {
      hide2();
    }
  }
  hideAllTooltips() {
    this.currentTooltip.set(null);
    this.destroyTimeoutId = null;
  }
  getCurrentTooltipData() {
    const currentTooltip = this.currentTooltip.get();
    if (!currentTooltip) return null;
    if (!this.supportsHover() && !currentTooltip.showOnMobile) return null;
    return currentTooltip;
  }
  supportsHoverAtom = null;
  supportsHover() {
    if (!this.supportsHoverAtom) {
      const mediaQuery = window.matchMedia("(hover: hover)");
      const supportsHover = atom("has hover", mediaQuery.matches);
      this.supportsHoverAtom = supportsHover;
      mediaQuery.addEventListener("change", (e) => {
        supportsHover.set(e.matches);
      });
    }
    return this.supportsHoverAtom.get();
  }
}
const tooltipManager = TooltipManager.getInstance();
const TooltipSingletonContext = reactExports.createContext(false);
function TldrawUiTooltipProvider({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { skipDelayDuration: 700, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipSingletonContext.Provider, { value: true, children: [
    children,
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipSingleton, {})
  ] }) });
}
function TooltipSingleton() {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const triggerRef = reactExports.useRef(null);
  const isFirstShowRef = reactExports.useRef(true);
  const editor = useMaybeEditor();
  const currentTooltip = useValue(
    "current tooltip",
    () => tooltipManager.getCurrentTooltipData(),
    []
  );
  const cameraState = useValue("camera state", () => editor?.getCameraState(), [editor]);
  reactExports.useEffect(() => {
    if (cameraState === "moving" && isOpen && currentTooltip) {
      tooltipManager.hideTooltip(editor, currentTooltip.id, true);
    }
  }, [cameraState, isOpen, currentTooltip, editor]);
  reactExports.useEffect(() => {
    function handleKeyDown2(event) {
      if (event.key === "Escape" && currentTooltip && isOpen) {
        tooltipManager.hideTooltip(editor, currentTooltip.id);
        event.stopPropagation();
      }
    }
    document.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown2, { capture: true });
    };
  }, [editor, currentTooltip, isOpen]);
  reactExports.useEffect(() => {
    let timer = null;
    if (currentTooltip && triggerRef.current) {
      const activeRect = currentTooltip.targetElement.getBoundingClientRect();
      const trigger2 = triggerRef.current;
      trigger2.style.position = "fixed";
      trigger2.style.left = `${activeRect.left}px`;
      trigger2.style.top = `${activeRect.top}px`;
      trigger2.style.width = `${activeRect.width}px`;
      trigger2.style.height = `${activeRect.height}px`;
      trigger2.style.pointerEvents = "none";
      trigger2.style.zIndex = "9999";
      if (isFirstShowRef.current) {
        timer = setTimeout(() => {
          setIsOpen(true);
          isFirstShowRef.current = false;
        }, currentTooltip.delayDuration);
      } else {
        setIsOpen(true);
      }
    } else {
      setIsOpen(false);
      isFirstShowRef.current = true;
    }
    return () => {
      if (timer !== null) {
        clearTimeout(timer);
      }
    };
  }, [currentTooltip]);
  if (!currentTooltip) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root3, { open: isOpen, delayDuration: 0, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: triggerRef }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Content2,
      {
        className: "tlui-tooltip",
        side: currentTooltip.side,
        sideOffset: currentTooltip.sideOffset,
        avoidCollisions: true,
        collisionPadding: 8,
        dir: "ltr",
        children: [
          currentTooltip.content,
          /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2, { className: "tlui-tooltip__arrow" })
        ]
      }
    )
  ] });
}
const TldrawUiTooltip = reactExports.forwardRef(
  ({
    children,
    content,
    side,
    sideOffset = 5,
    disabled = false,
    showOnMobile = false,
    delayDuration
  }, ref) => {
    const editor = useMaybeEditor();
    const tooltipId = reactExports.useRef(uniqueId());
    const hasProvider = reactExports.useContext(TooltipSingletonContext);
    const enhancedA11yMode = useValue(
      "enhancedA11yMode",
      () => editor?.user.getEnhancedA11yMode(),
      [editor]
    );
    const orientationCtx = useTldrawUiOrientation();
    const sideToUse = side ?? orientationCtx.tooltipSide;
    reactExports.useEffect(() => {
      const currentTooltipId = tooltipId.current;
      return () => {
        if (hasProvider) {
          tooltipManager.hideTooltip(editor, currentTooltipId, true);
        }
      };
    }, [editor, hasProvider]);
    reactExports.useLayoutEffect(() => {
      if (hasProvider && tooltipManager.getCurrentTooltipData()?.id === tooltipId.current) {
        tooltipManager.updateCurrentTooltip(tooltipId.current, (tooltip) => ({
          ...tooltip,
          content,
          side: sideToUse,
          sideOffset,
          showOnMobile
        }));
      }
    }, [content, sideToUse, sideOffset, showOnMobile, hasProvider]);
    if (disabled || !content) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
    }
    let delayDurationToUse;
    if (enhancedA11yMode) {
      delayDurationToUse = 0;
    } else {
      delayDurationToUse = delayDuration ?? (editor?.options.tooltipDelayMs || DEFAULT_TOOLTIP_DELAY_MS);
    }
    if (!hasProvider || enhancedA11yMode) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Root3,
        {
          delayDuration: delayDurationToUse,
          disableHoverableContent: !enhancedA11yMode,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger, { asChild: true, ref, children }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Content2,
              {
                className: "tlui-tooltip",
                side: sideToUse,
                sideOffset,
                avoidCollisions: true,
                collisionPadding: 8,
                dir: "ltr",
                children: [
                  content,
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2, { className: "tlui-tooltip__arrow" })
                ]
              }
            )
          ]
        }
      );
    }
    const child = React.Children.only(children);
    assert(React.isValidElement(child), "TldrawUiTooltip children must be a single element");
    const handleMouseEnter = (event) => {
      child.props.onMouseEnter?.(event);
      tooltipManager.showTooltip(
        tooltipId.current,
        content,
        event.currentTarget,
        sideToUse,
        sideOffset,
        showOnMobile,
        delayDurationToUse
      );
    };
    const handleMouseLeave = (event) => {
      child.props.onMouseLeave?.(event);
      tooltipManager.hideTooltip(editor, tooltipId.current);
    };
    const handleFocus = (event) => {
      child.props.onFocus?.(event);
      tooltipManager.showTooltip(
        tooltipId.current,
        content,
        event.currentTarget,
        sideToUse,
        sideOffset,
        showOnMobile,
        delayDurationToUse
      );
    };
    const handleBlur = (event) => {
      child.props.onBlur?.(event);
      tooltipManager.hideTooltip(editor, tooltipId.current);
    };
    const childrenWithHandlers = React.cloneElement(children, {
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onFocus: handleFocus,
      onBlur: handleBlur
    });
    return childrenWithHandlers;
  }
);
const LayoutByOrientation = {
  horizontal: TldrawUiRow,
  vertical: TldrawUiColumn,
  grid: TldrawUiGrid
};
const TldrawUiToolbar = React.forwardRef(
  ({
    children,
    className,
    label,
    orientation = "horizontal",
    tooltipSide,
    ...props
  }, ref) => {
    const Layout2 = LayoutByOrientation[orientation];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Layout2, { asChild: true, tooltipSide, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root4,
      {
        ref,
        ...props,
        className: classNames("tlui-toolbar", className),
        "aria-label": label,
        orientation: orientation === "grid" ? "horizontal" : orientation,
        children
      }
    ) });
  }
);
const TldrawUiToolbarButton = React.forwardRef(
  ({ asChild, children, type, isActive: isActive2, tooltip, ...props }, ref) => {
    const button = /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        ref,
        asChild,
        draggable: false,
        "data-isactive": isActive2,
        ...props,
        "aria-label": props.title,
        title: void 0,
        className: classNames("tlui-button", `tlui-button__${type}`, props.className),
        children
      }
    );
    const tooltipContent = tooltip || props.title;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiTooltip, { content: tooltipContent, children: button });
  }
);
const TldrawUiToolbarToggleGroup = ({
  children,
  className,
  type,
  asChild,
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToggleGroup,
    {
      asChild,
      type,
      ...props,
      role: "radiogroup",
      className: classNames("tlui-toolbar-toggle-group", className),
      children
    }
  );
};
const TldrawUiToolbarToggleItem = ({
  children,
  className,
  type,
  value,
  tooltip,
  ...props
}) => {
  const toggleItem = /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToggleItem,
    {
      ...props,
      title: void 0,
      className: classNames(
        "tlui-button",
        `tlui-button__${type}`,
        "tlui-toolbar-toggle-group-item",
        className
      ),
      value,
      children
    }
  );
  const tooltipContent = tooltip || props.title;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiTooltip, { content: tooltipContent, children: toggleItem });
};
function TldrawUiMenuItem({
  disabled = false,
  spinner = false,
  readonlyOk = false,
  id,
  kbd: kbd2,
  label,
  icon,
  iconLeft,
  onSelect,
  noClose,
  isSelected,
  onDragStart
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const msg2 = useTranslation();
  const [disableClicks, setDisableClicks] = reactExports.useState(false);
  const isReadonlyMode = useReadonly();
  if (isReadonlyMode && !readonlyOk) return null;
  const labelToUse = unwrapLabel(label, menuType);
  const kbdToUse = kbd2 ? kbdStr(kbd2) : void 0;
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  const titleStr = labelStr && kbdToUse ? `${labelStr} ${kbdToUse}` : labelStr;
  switch (menuType) {
    case "menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TldrawUiButton,
        {
          type: "menu",
          "data-testid": `${sourceId}.${id}`,
          disabled,
          onClick: (e) => {
            if (noClose) {
              preventDefault(e);
            }
            if (disableClicks) {
              setDisableClicks(false);
            } else {
              onSelect(sourceId);
            }
          },
          children: [
            iconLeft && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: iconLeft, small: true }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: labelStr }),
            kbd2 && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiKbd, { children: kbd2 })
          ]
        }
      ) });
    }
    case "context-menu": {
      if (disabled) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Item2$2,
        {
          dir: "ltr",
          draggable: false,
          className: "tlui-button tlui-button__menu",
          "data-testid": `${sourceId}.${id}`,
          onSelect: (e) => {
            if (noClose) preventDefault(e);
            if (disableClicks) {
              setDisableClicks(false);
            } else {
              onSelect(sourceId);
            }
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            iconLeft && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: iconLeft, small: true }),
            kbd2 && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiKbd, { children: kbd2 }),
            spinner && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, {})
          ]
        }
      );
    }
    case "small-icons":
    case "icons": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          "data-testid": `${sourceId}.${id}`,
          type: "icon",
          title: titleStr,
          disabled,
          onClick: () => onSelect(sourceId),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon, small: true })
        }
      );
    }
    case "keyboard-shortcuts": {
      if (!kbd2) {
        console.warn(
          `Menu item '${label}' isn't shown in the keyboard shortcuts dialog because it doesn't have a keyboard shortcut.`
        );
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-shortcuts-dialog__key-pair", "data-testid": `${sourceId}.${id}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__key", children: labelStr }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__value", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiKbd, { visibleOnMobileLayout: true, children: kbd2 }) })
      ] });
    }
    case "helper-buttons": {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiButton, { type: "low", onClick: () => onSelect(sourceId), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: labelStr })
      ] });
    }
    case "toolbar": {
      if (onDragStart) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          DraggableToolbarButton,
          {
            id,
            icon,
            onSelect,
            onDragStart,
            labelStr,
            titleStr,
            disabled,
            isSelected
          }
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          "aria-label": labelStr,
          "aria-pressed": isSelected ? "true" : "false",
          "data-testid": `tools.${id}`,
          "data-value": id,
          disabled,
          onClick: () => onSelect("toolbar"),
          onTouchStart: (e) => {
            preventDefault(e);
            onSelect("toolbar");
          },
          title: titleStr,
          type: "tool",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon })
        }
      );
    }
    case "toolbar-overflow": {
      if (onDragStart) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          DraggableToolbarButton,
          {
            id,
            icon,
            onSelect,
            onDragStart,
            labelStr,
            titleStr,
            disabled,
            isSelected,
            overflow: true
          }
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          "aria-label": labelStr,
          "aria-pressed": isSelected ? "true" : "false",
          isActive: isSelected,
          "data-testid": `tools.more.${id}`,
          "data-value": id,
          disabled,
          onClick: () => onSelect("toolbar"),
          title: titleStr,
          type: "icon",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon })
        }
      );
    }
    default: {
      throw exhaustiveSwitchError(menuType);
    }
  }
}
function useDraggableEvents(onDragStart, onSelect) {
  const editor = useEditor();
  const events = reactExports.useMemo(() => {
    let state = { name: "idle" };
    function handlePointerDown(e) {
      state = {
        name: "pointing",
        screenSpaceStart: { x: e.clientX, y: e.clientY }
      };
      e.currentTarget.setPointerCapture(e.pointerId);
    }
    function handlePointerMove(e) {
      if (e.isSpecialRedispatchedEvent) return;
      if (state.name === "pointing") {
        const distanceSq = Vec.Dist2(state.screenSpaceStart, { x: e.clientX, y: e.clientY });
        if (distanceSq > (editor.getInstanceState().isCoarsePointer ? editor.options.uiCoarseDragDistanceSquared : editor.options.uiDragDistanceSquared)) {
          const screenSpaceStart = state.screenSpaceStart;
          state = {
            name: "dragging",
            screenSpaceStart
          };
          editor.run(() => {
            editor.setCurrentTool("select");
            editor.dispatch({
              type: "pointer",
              target: "canvas",
              name: "pointer_down",
              ...getPointerInfo(editor, e),
              point: screenSpaceStart
            });
            editor.selectNone();
            onDragStart?.("toolbar", {
              type: "pointer",
              target: "canvas",
              name: "pointer_move",
              ...getPointerInfo(editor, e),
              point: screenSpaceStart
            });
            tooltipManager.hideAllTooltips();
            editor.getContainer().focus();
          });
        }
      }
    }
    function handlePointerUp(e) {
      if (e.isSpecialRedispatchedEvent) return;
      e.currentTarget.releasePointerCapture(e.pointerId);
      editor.dispatch({
        type: "pointer",
        target: "canvas",
        name: "pointer_up",
        ...getPointerInfo(editor, e)
      });
    }
    function handleClick2() {
      if (state.name === "dragging" || state.name === "dragged") {
        state = { name: "idle" };
        return true;
      }
      state = { name: "idle" };
      onSelect?.("toolbar");
    }
    return {
      onPointerDown: handlePointerDown,
      onPointerMove: handlePointerMove,
      onPointerUp: handlePointerUp,
      onClick: handleClick2
    };
  }, [onDragStart, editor, onSelect]);
  return events;
}
function DraggableToolbarButton({
  id,
  labelStr,
  titleStr,
  disabled,
  isSelected,
  icon,
  onSelect,
  onDragStart,
  overflow
}) {
  const events = useDraggableEvents(onDragStart, onSelect);
  if (overflow) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiToolbarButton,
      {
        "aria-label": labelStr,
        "aria-pressed": isSelected ? "true" : "false",
        isActive: isSelected,
        className: "tlui-button-grid__button",
        "data-testid": `tools.more.${id}`,
        "data-value": id,
        disabled,
        title: titleStr,
        type: "icon",
        ...events,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon })
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiToolbarButton,
    {
      "aria-label": labelStr,
      "aria-pressed": isSelected ? "true" : "false",
      "data-testid": `tools.${id}`,
      "data-value": id,
      disabled,
      onTouchStart: (e) => {
        preventDefault(e);
        onSelect("toolbar");
      },
      title: titleStr,
      type: "tool",
      ...events,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon })
    }
  );
}
function TldrawUiMenuActionItem({ actionId = "", ...rest }) {
  const actions = useActions();
  const action = actions[actionId];
  if (!action) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { ...action, ...rest });
}
function TldrawUiMenuGroup({ id, label, className, children }) {
  const menu = useTldrawUiMenuContext();
  const { orientation } = useTldrawUiOrientation();
  const msg2 = useTranslation();
  const labelToUse = unwrapLabel(label, menu.type);
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menu.type) {
    case "menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiDropdownMenuGroup,
        {
          className,
          "data-testid": `${menu.sourceId}-group.${id}`,
          children
        }
      );
    }
    case "context-menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          dir: "ltr",
          className: classNames("tlui-menu__group", className),
          "data-testid": `${menu.sourceId}-group.${id}`,
          children
        }
      );
    }
    case "keyboard-shortcuts": {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-shortcuts-dialog__group", "data-testid": `${menu.sourceId}-group.${id}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "tlui-shortcuts-dialog__group__title", children: labelStr }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-shortcuts-dialog__group__content", children })
      ] });
    }
    case "toolbar": {
      const Layout2 = orientation === "horizontal" ? TldrawUiRow : TldrawUiColumn;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Layout2, { className: "tlui-main-toolbar__group", "data-testid": `${menu.sourceId}-group.${id}`, children });
    }
    case "toolbar-overflow": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiGrid,
        {
          className: "tlui-main-toolbar__group",
          "data-testid": `${menu.sourceId}-group.${id}`,
          children
        }
      );
    }
    default: {
      return children;
    }
  }
}
const DialogsContext = reactExports.createContext(null);
function TldrawUiDialogsProvider({ context, children }) {
  const ctx = reactExports.useContext(DialogsContext);
  const trackEvent = useUiEvents();
  const dialogs = useAtom("dialogs", []);
  const content = reactExports.useMemo(() => {
    return {
      dialogs,
      addDialog(dialog) {
        const id = dialog.id ?? uniqueId();
        dialogs.update((d) => {
          return [...d.filter((m) => m.id !== dialog.id), { ...dialog, id }];
        });
        trackEvent("open-menu", { source: "dialog", id });
        tlmenus.addOpenMenu(id, context);
        return id;
      },
      removeDialog(id) {
        const dialog = dialogs.get().find((d) => d.id === id);
        if (dialog) {
          dialog.onClose?.();
          trackEvent("close-menu", { source: "dialog", id });
          tlmenus.deleteOpenMenu(id, context);
          dialogs.update((d) => d.filter((m) => m !== dialog));
        }
        return id;
      },
      clearDialogs() {
        const current = dialogs.get();
        if (current.length === 0) return;
        current.forEach((d) => {
          d.onClose?.();
          trackEvent("close-menu", { source: "dialog", id: d.id });
          tlmenus.deleteOpenMenu(d.id, context);
        });
        dialogs.set([]);
      }
    };
  }, [trackEvent, dialogs, context]);
  if (ctx) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogsContext.Provider, { value: content, children });
}
function useDialogs() {
  const ctx = reactExports.useContext(DialogsContext);
  if (!ctx) {
    throw new Error("useDialogs must be used within a DialogsProvider");
  }
  return ctx;
}
const ToastsContext = reactExports.createContext(null);
function TldrawUiToastsProvider({ children }) {
  const toasts = useAtom("toasts", []);
  const ctx = reactExports.useContext(ToastsContext);
  const current = reactExports.useMemo(() => {
    return {
      toasts,
      addToast(toast) {
        const id = toast.id ?? uniqueId();
        toasts.update((d) => [...d.filter((m) => m.id !== toast.id), { ...toast, id }]);
        return id;
      },
      removeToast(id) {
        toasts.update((d) => d.filter((m) => m.id !== id));
        return id;
      },
      clearToasts() {
        toasts.set([]);
      }
    };
  }, [toasts]);
  if (ctx) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Provider$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastsContext.Provider, { value: current, children }) });
}
function useToasts() {
  const ctx = reactExports.useContext(ToastsContext);
  if (!ctx) {
    throw new Error("useToasts must be used within a ToastsProvider");
  }
  return ctx;
}
function getLocalFiles(options) {
  return new Promise((resolve) => {
    const { allowMultiple = true, mimeTypes = [] } = options || {};
    const input = document.createElement("input");
    input.type = "file";
    input.accept = mimeTypes?.join(",");
    input.multiple = allowMultiple;
    input.style.display = "none";
    function dispose() {
      input.removeEventListener("change", onchange);
      input.removeEventListener("cancel", oncancel);
      input.remove();
    }
    async function onchange(e) {
      const fileList = e.target.files;
      if (!fileList || fileList.length === 0) {
        resolve([]);
        dispose();
        return;
      }
      const files = Array.from(fileList);
      input.value = "";
      resolve(files);
      dispose();
    }
    function oncancel() {
      resolve([]);
      dispose();
    }
    document.body.appendChild(input);
    input.addEventListener("cancel", oncancel);
    input.addEventListener("change", onchange);
    input?.click();
  });
}
var lzString = { exports: {} };
var hasRequiredLzString;
function requireLzString() {
  if (hasRequiredLzString) return lzString.exports;
  hasRequiredLzString = 1;
  (function(module) {
    var LZString = (function() {
      var f = String.fromCharCode;
      var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      var baseReverseDic = {};
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (var i = 0; i < alphabet.length; i++) {
            baseReverseDic[alphabet][alphabet.charAt(i)] = i;
          }
        }
        return baseReverseDic[alphabet][character];
      }
      var LZString2 = {
        compressToBase64: function(input) {
          if (input == null) return "";
          var res = LZString2._compress(input, 6, function(a) {
            return keyStrBase64.charAt(a);
          });
          switch (res.length % 4) {
            // To produce valid Base64
            default:
            // When could this happen ?
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        },
        decompressFromBase64: function(input) {
          if (input == null) return "";
          if (input == "") return null;
          return LZString2._decompress(input.length, 32, function(index2) {
            return getBaseValue(keyStrBase64, input.charAt(index2));
          });
        },
        compressToUTF16: function(input) {
          if (input == null) return "";
          return LZString2._compress(input, 15, function(a) {
            return f(a + 32);
          }) + " ";
        },
        decompressFromUTF16: function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString2._decompress(compressed.length, 16384, function(index2) {
            return compressed.charCodeAt(index2) - 32;
          });
        },
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: function(uncompressed) {
          var compressed = LZString2.compress(uncompressed);
          var buf = new Uint8Array(compressed.length * 2);
          for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
            var current_value = compressed.charCodeAt(i);
            buf[i * 2] = current_value >>> 8;
            buf[i * 2 + 1] = current_value % 256;
          }
          return buf;
        },
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: function(compressed) {
          if (compressed === null || compressed === void 0) {
            return LZString2.decompress(compressed);
          } else {
            var buf = new Array(compressed.length / 2);
            for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
              buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
            }
            var result = [];
            buf.forEach(function(c) {
              result.push(f(c));
            });
            return LZString2.decompress(result.join(""));
          }
        },
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: function(input) {
          if (input == null) return "";
          return LZString2._compress(input, 6, function(a) {
            return keyStrUriSafe.charAt(a);
          });
        },
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: function(input) {
          if (input == null) return "";
          if (input == "") return null;
          input = input.replace(/ /g, "+");
          return LZString2._decompress(input.length, 32, function(index2) {
            return getBaseValue(keyStrUriSafe, input.charAt(index2));
          });
        },
        compress: function(uncompressed) {
          return LZString2._compress(uncompressed, 16, function(a) {
            return f(a);
          });
        },
        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null) return "";
          var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
          for (ii = 0; ii < uncompressed.length; ii += 1) {
            context_c = uncompressed.charAt(ii);
            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
              context_dictionary[context_c] = context_dictSize++;
              context_dictionaryToCreate[context_c] = true;
            }
            context_wc = context_w + context_c;
            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
              context_w = context_wc;
            } else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 8; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 16; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              context_dictionary[context_wc] = context_dictSize++;
              context_w = String(context_c);
            }
          }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
          }
          value = 2;
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
          while (true) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else context_data_position++;
          }
          return context_data.join("");
        },
        decompress: function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString2._decompress(compressed.length, 32768, function(index2) {
            return compressed.charCodeAt(index2);
          });
        },
        _decompress: function(length, resetValue, getNextValue) {
          var dictionary = [], enlargeIn = 4, dictSize = 4, numBits = 3, entry2 = "", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
          for (i = 0; i < 3; i += 1) {
            dictionary[i] = i;
          }
          bits = 0;
          maxpower = Math.pow(2, 2);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 2:
              return "";
          }
          dictionary[3] = c;
          w = c;
          result.push(c);
          while (true) {
            if (data.index > length) {
              return "";
            }
            bits = 0;
            maxpower = Math.pow(2, numBits);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (c = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 2:
                return result.join("");
            }
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
            if (dictionary[c]) {
              entry2 = dictionary[c];
            } else {
              if (c === dictSize) {
                entry2 = w + w.charAt(0);
              } else {
                return null;
              }
            }
            result.push(entry2);
            dictionary[dictSize++] = w + entry2.charAt(0);
            enlargeIn--;
            w = entry2;
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
          }
        }
      };
      return LZString2;
    })();
    if (module != null) {
      module.exports = LZString;
    } else if (typeof angular !== "undefined" && angular != null) {
      angular.module("LZString", []).factory("LZString", function() {
        return LZString;
      });
    }
  })(lzString);
  return lzString.exports;
}
var lzStringExports = requireLzString();
const lz = /* @__PURE__ */ getDefaultExportFromCjs(lzStringExports);
const TLDRAW_CUSTOM_PNG_MIME_TYPE = "web image/vnd.tldraw+png";
const additionalClipboardWriteTypes = {
  png: TLDRAW_CUSTOM_PNG_MIME_TYPE
};
const canonicalClipboardReadTypes = {
  [TLDRAW_CUSTOM_PNG_MIME_TYPE]: "image/png"
};
function getAdditionalClipboardWriteType(format2) {
  return getOwnProperty(additionalClipboardWriteTypes, format2) ?? null;
}
function getCanonicalClipboardReadType(mimeType) {
  return getOwnProperty(canonicalClipboardReadTypes, mimeType) ?? mimeType;
}
function doesClipboardSupportType(mimeType) {
  return typeof ClipboardItem !== "undefined" && "supports" in ClipboardItem && ClipboardItem.supports(mimeType);
}
function clipboardWrite(types) {
  const entries = Object.entries(types);
  for (const [_, promise] of entries) promise.catch((err) => console.error(err));
  return navigator.clipboard.write([new ClipboardItem(types)]).catch((err) => {
    console.error(err);
    return Promise.all(
      entries.map(async ([type, promise]) => {
        return [type, await promise];
      })
    ).then((entries2) => {
      const resolvedTypes = objectMapFromEntries(entries2);
      return navigator.clipboard.write([new ClipboardItem(resolvedTypes)]);
    });
  });
}
async function pasteFiles(editor, blobs, point, sources) {
  const files = blobs.map(
    (blob) => blob instanceof File ? blob : new File([blob], "tldrawFile", { type: blob.type })
  );
  editor.markHistoryStoppingPoint("paste");
  await editor.putExternalContent({
    type: "files",
    files,
    point,
    sources
  });
}
async function pasteUrl(editor, url, point, sources) {
  editor.markHistoryStoppingPoint("paste");
  return await editor.putExternalContent({
    type: "url",
    point,
    url,
    sources
  });
}
const expectedPasteFileMimeTypes = [
  TLDRAW_CUSTOM_PNG_MIME_TYPE,
  "image/png",
  "image/jpeg",
  "image/webp",
  "image/svg+xml"
];
function stripHtml(html2) {
  const doc2 = document.implementation.createHTMLDocument("");
  doc2.documentElement.innerHTML = html2.trim();
  return doc2.body.textContent || doc2.body.innerText || "";
}
const isValidHttpURL = (url) => {
  try {
    const u = new URL(url);
    return u.protocol === "http:" || u.protocol === "https:";
  } catch {
    return false;
  }
};
const getValidHttpURLList = (url) => {
  const urls = url.split(/[\n\s]/);
  for (const url2 of urls) {
    try {
      const u = new URL(url2);
      if (!(u.protocol === "http:" || u.protocol === "https:")) {
        return;
      }
    } catch {
      return;
    }
  }
  return uniq(urls);
};
const isSvgText = (text) => {
  return /^<svg/.test(text);
};
const INPUTS = ["input", "select", "textarea"];
function areShortcutsDisabled$1(editor) {
  const { activeElement } = document;
  return editor.menus.hasAnyOpenMenus() || activeElement && (activeElement.isContentEditable || INPUTS.indexOf(activeElement.tagName.toLowerCase()) > -1);
}
const handleText = (editor, data, point, sources) => {
  const validUrlList = getValidHttpURLList(data);
  if (validUrlList) {
    for (const url of validUrlList) {
      pasteUrl(editor, url, point);
    }
  } else if (isValidHttpURL(data)) {
    pasteUrl(editor, data, point);
  } else if (isSvgText(data)) {
    editor.markHistoryStoppingPoint("paste");
    editor.putExternalContent({
      type: "svg-text",
      text: data,
      point,
      sources
    });
  } else {
    editor.markHistoryStoppingPoint("paste");
    editor.putExternalContent({
      type: "text",
      text: data,
      point,
      sources
    });
  }
};
const handlePasteFromEventClipboardData = async (editor, clipboardData, point) => {
  if (editor.getEditingShapeId() !== null) return;
  if (!clipboardData) {
    throw Error("No clipboard data");
  }
  const things = [];
  for (const item of Object.values(clipboardData.items)) {
    switch (item.kind) {
      case "file": {
        things.push({
          type: "file",
          source: new Promise((r) => r(item.getAsFile()))
        });
        break;
      }
      case "string": {
        if (item.type === "text/html") {
          things.push({
            type: "html",
            source: new Promise((r) => item.getAsString(r))
          });
        } else if (item.type === "text/plain") {
          things.push({
            type: "text",
            source: new Promise((r) => item.getAsString(r))
          });
        } else {
          things.push({ type: item.type, source: new Promise((r) => item.getAsString(r)) });
        }
        break;
      }
    }
  }
  handleClipboardThings(editor, things, point);
};
const handlePasteFromClipboardApi = async ({
  editor,
  clipboardItems,
  point,
  fallbackFiles
}) => {
  const things = [];
  for (const item of clipboardItems) {
    for (const type of expectedPasteFileMimeTypes) {
      if (item.types.includes(type)) {
        const blobPromise = item.getType(type).then((blob) => FileHelpers.rewriteMimeType(blob, getCanonicalClipboardReadType(type)));
        things.push({
          type: "blob",
          source: blobPromise
        });
        break;
      }
    }
    if (item.types.includes("text/html")) {
      things.push({
        type: "html",
        source: (async () => {
          const blob = await item.getType("text/html");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
    if (item.types.includes("text/uri-list")) {
      things.push({
        type: "url",
        source: (async () => {
          const blob = await item.getType("text/uri-list");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
    if (item.types.includes("text/plain")) {
      things.push({
        type: "text",
        source: (async () => {
          const blob = await item.getType("text/plain");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
  }
  if (fallbackFiles?.length && things.length === 1 && things[0].type === "text") {
    things.pop();
    things.push(
      ...fallbackFiles.map((f) => ({ type: "file", source: Promise.resolve(f) }))
    );
  } else if (fallbackFiles?.length && things.length === 0) {
    things.push(
      ...fallbackFiles.map((f) => ({ type: "file", source: Promise.resolve(f) }))
    );
  }
  return await handleClipboardThings(editor, things, point);
};
async function handleClipboardThings(editor, things, point) {
  const files = things.filter(
    (t2) => (t2.type === "file" || t2.type === "blob") && t2.source !== null
  );
  if (files.length) {
    if (files.length > editor.options.maxFilesAtOnce) {
      throw Error("Too many files");
    }
    const fileBlobs = compact(await Promise.all(files.map((t2) => t2.source)));
    return await pasteFiles(editor, fileBlobs, point);
  }
  const results = await Promise.all(
    things.filter((t2) => t2.type !== "file").map(
      (t2) => new Promise((r) => {
        const thing = t2;
        if (thing.type === "file") {
          r({ type: "error", data: null, reason: "unexpected file" });
          return;
        }
        thing.source.then((text) => {
          const tldrawHtmlComment = text.match(/<div data-tldraw[^>]*>(.*)<\/div>/)?.[1];
          if (tldrawHtmlComment) {
            try {
              let json;
              try {
                json = JSON.parse(tldrawHtmlComment);
              } catch {
                const jsonComment = lz.decompressFromBase64(tldrawHtmlComment);
                if (jsonComment === null) {
                  r({
                    type: "error",
                    data: null,
                    reason: `found tldraw data comment but could not parse`
                  });
                  return;
                }
                json = JSON.parse(jsonComment);
              }
              if (json.type !== "application/tldraw") {
                r({
                  type: "error",
                  data: json,
                  reason: `found tldraw data comment but JSON was of a different type: ${json.type}`
                });
                return;
              }
              if (json.version === 3) {
                try {
                  const otherData = JSON.parse(
                    lz.decompressFromBase64(json.data.otherCompressed) || "{}"
                  );
                  const reconstructedData = {
                    assets: json.data.assets || [],
                    ...otherData
                  };
                  r({ type: "tldraw", data: reconstructedData });
                  return;
                } catch (error) {
                  r({
                    type: "error",
                    data: json,
                    reason: `failed to decompress version 2 clipboard data: ${error}`
                  });
                  return;
                }
              }
              if (json.version === 2) {
                r({ type: "tldraw", data: json.data });
              } else {
                if (typeof json.data === "string") {
                  r({
                    type: "error",
                    data: json,
                    reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
                  });
                  return;
                }
                r({ type: "tldraw", data: json.data });
                return;
              }
            } catch {
              r({
                type: "error",
                data: tldrawHtmlComment,
                reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
              });
              return;
            }
          } else {
            if (thing.type === "html") {
              r({ type: "text", data: text, subtype: "html" });
              return;
            }
            if (thing.type === "url") {
              r({ type: "text", data: text, subtype: "url" });
              return;
            }
            try {
              const json = JSON.parse(text);
              if (json.type === "excalidraw/clipboard") {
                r({ type: "excalidraw", data: json });
                return;
              } else {
                r({ type: "text", data: text, subtype: "json" });
                return;
              }
            } catch {
              r({ type: "text", data: text, subtype: "text" });
              return;
            }
          }
          r({ type: "error", data: text, reason: "unhandled case" });
        });
      })
    )
  );
  for (const result of results) {
    if (result.type === "tldraw") {
      editor.markHistoryStoppingPoint("paste");
      editor.putExternalContent({ type: "tldraw", content: result.data, point });
      return;
    }
  }
  for (const result of results) {
    if (result.type === "excalidraw") {
      editor.markHistoryStoppingPoint("paste");
      editor.putExternalContent({ type: "excalidraw", content: result.data, point });
      return;
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "html") {
      const rootNode = new DOMParser().parseFromString(result.data, "text/html");
      const bodyNode = rootNode.querySelector("body");
      const isHtmlSingleLink = bodyNode && Array.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 && bodyNode.firstElementChild && bodyNode.firstElementChild.tagName === "A" && bodyNode.firstElementChild.hasAttribute("href") && bodyNode.firstElementChild.getAttribute("href") !== "";
      if (isHtmlSingleLink) {
        const href = bodyNode.firstElementChild.getAttribute("href");
        handleText(editor, href, point, results);
        return;
      }
      if (!results.some((r) => r.type === "text" && r.subtype !== "html") && result.data.trim()) {
        const html2 = stripHtml(result.data) ?? "";
        if (html2) {
          handleText(editor, stripHtml(result.data), point, results);
          return;
        }
      }
      if (results.some((r) => r.type === "text" && r.subtype !== "html")) {
        const html2 = stripHtml(result.data) ?? "";
        if (html2) {
          editor.markHistoryStoppingPoint("paste");
          editor.putExternalContent({
            type: "text",
            text: html2,
            html: result.data,
            point,
            sources: results
          });
          return;
        }
      }
    }
    if (result.type === "text" && result.subtype === "text" && result.data.startsWith("<iframe ")) {
      const rootNode = new DOMParser().parseFromString(result.data, "text/html");
      const bodyNode = rootNode.querySelector("body");
      const isSingleIframe = bodyNode && Array.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 && bodyNode.firstElementChild && bodyNode.firstElementChild.tagName === "IFRAME" && bodyNode.firstElementChild.hasAttribute("src") && bodyNode.firstElementChild.getAttribute("src") !== "";
      if (isSingleIframe) {
        const src = bodyNode.firstElementChild.getAttribute("src");
        handleText(editor, src, point, results);
        return;
      }
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "url") {
      pasteUrl(editor, result.data, point, results);
      return;
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "text" && result.data.trim()) {
      handleText(editor, result.data, point, results);
      return;
    }
  }
}
const handleNativeOrMenuCopy = async (editor) => {
  const navigator2 = editor.getContainer().ownerDocument?.defaultView?.navigator ?? globalThis.navigator;
  const content = await editor.resolveAssetsInContent(
    editor.getContentFromCurrentPage(editor.getSelectedShapeIds())
  );
  if (!content) {
    if (navigator2 && navigator2.clipboard) {
      navigator2.clipboard.writeText("");
    }
    return;
  }
  const { assets, ...otherData } = content;
  const clipboardData = {
    type: "application/tldraw",
    kind: "content",
    version: 3,
    data: {
      assets: assets || [],
      // Plain JSON, no compression
      otherCompressed: lz.compressToBase64(JSON.stringify(otherData))
      // Only compress non-asset data
    }
  };
  const stringifiedClipboard = JSON.stringify(clipboardData);
  if (typeof navigator2 === "undefined") {
    return;
  } else {
    const textItems = content.shapes.map((shape) => {
      const util = editor.getShapeUtil(shape);
      return util.getText(shape);
    }).filter(isDefined);
    if (navigator2.clipboard?.write) {
      const htmlBlob = new Blob([`<div data-tldraw>${stringifiedClipboard}</div>`], {
        type: "text/html"
      });
      let textContent = textItems.join(" ");
      if (textContent === "") {
        textContent = " ";
      }
      navigator2.clipboard.write([
        new ClipboardItem({
          "text/html": htmlBlob,
          // What is this second blob used for?
          "text/plain": new Blob([textContent], { type: "text/plain" })
        })
      ]);
    } else if (navigator2.clipboard.writeText) {
      navigator2.clipboard.writeText(`<div data-tldraw>${stringifiedClipboard}</div>`);
    }
  }
};
function useMenuClipboardEvents() {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const copy2 = reactExports.useCallback(
    async function onCopy(source) {
      assert(editor, "editor is required for copy");
      if (editor.getSelectedShapeIds().length === 0) return;
      await handleNativeOrMenuCopy(editor);
      trackEvent("copy", { source });
    },
    [editor, trackEvent]
  );
  const cut2 = reactExports.useCallback(
    async function onCut(source) {
      if (!editor) return;
      if (editor.getSelectedShapeIds().length === 0) return;
      await handleNativeOrMenuCopy(editor);
      editor.deleteShapes(editor.getSelectedShapeIds());
      trackEvent("cut", { source });
    },
    [editor, trackEvent]
  );
  const paste = reactExports.useCallback(
    async function onPaste(data, source, point) {
      if (!editor) return;
      if (editor.getEditingShapeId() !== null) return;
      if (Array.isArray(data) && data[0] instanceof ClipboardItem) {
        handlePasteFromClipboardApi({ editor, clipboardItems: data, point });
        trackEvent("paste", { source: "menu" });
      } else {
        navigator.clipboard.read().then((clipboardItems) => {
          paste(clipboardItems, source, point);
        });
      }
    },
    [editor, trackEvent]
  );
  return {
    copy: copy2,
    cut: cut2,
    paste
  };
}
function useNativeClipboardEvents() {
  const editor = useEditor();
  const ownerDocument = editor.getContainer().ownerDocument;
  const trackEvent = useUiEvents();
  const appIsFocused = useValue("editor.isFocused", () => editor.getInstanceState().isFocused, [
    editor
  ]);
  reactExports.useEffect(() => {
    if (!appIsFocused) return;
    const copy2 = async (e) => {
      if (editor.getSelectedShapeIds().length === 0 || editor.getEditingShapeId() !== null || areShortcutsDisabled$1(editor)) {
        return;
      }
      preventDefault(e);
      await handleNativeOrMenuCopy(editor);
      trackEvent("copy", { source: "kbd" });
    };
    async function cut2(e) {
      if (editor.getSelectedShapeIds().length === 0 || editor.getEditingShapeId() !== null || areShortcutsDisabled$1(editor)) {
        return;
      }
      preventDefault(e);
      await handleNativeOrMenuCopy(editor);
      editor.deleteShapes(editor.getSelectedShapeIds());
      trackEvent("cut", { source: "kbd" });
    }
    let disablingMiddleClickPaste = false;
    const pointerUpHandler = (e) => {
      if (e.button === 1) {
        disablingMiddleClickPaste = true;
        editor.timers.requestAnimationFrame(() => {
          disablingMiddleClickPaste = false;
        });
      }
    };
    const paste = (e) => {
      if (disablingMiddleClickPaste) {
        editor.markEventAsHandled(e);
        return;
      }
      if (editor.getEditingShapeId() !== null || areShortcutsDisabled$1(editor)) return;
      let point = void 0;
      let pasteAtCursor = false;
      if (editor.inputs.shiftKey) pasteAtCursor = true;
      if (editor.user.getIsPasteAtCursorMode()) pasteAtCursor = !pasteAtCursor;
      if (pasteAtCursor) point = editor.inputs.currentPagePoint;
      const pasteFromEvent = () => {
        if (e.clipboardData) {
          handlePasteFromEventClipboardData(editor, e.clipboardData, point);
        }
      };
      if (navigator.clipboard?.read) {
        const fallbackFiles = Array.from(e.clipboardData?.files || []);
        navigator.clipboard.read().then(
          (clipboardItems) => {
            if (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {
              handlePasteFromClipboardApi({ editor, clipboardItems, point, fallbackFiles });
            }
          },
          () => {
            pasteFromEvent();
          }
        );
      } else {
        pasteFromEvent();
      }
      preventDefault(e);
      trackEvent("paste", { source: "kbd" });
    };
    ownerDocument?.addEventListener("copy", copy2);
    ownerDocument?.addEventListener("cut", cut2);
    ownerDocument?.addEventListener("paste", paste);
    ownerDocument?.addEventListener("pointerup", pointerUpHandler);
    return () => {
      ownerDocument?.removeEventListener("copy", copy2);
      ownerDocument?.removeEventListener("cut", cut2);
      ownerDocument?.removeEventListener("paste", paste);
      ownerDocument?.removeEventListener("pointerup", pointerUpHandler);
    };
  }, [editor, trackEvent, appIsFocused, ownerDocument]);
}
const clipboardMimeTypesByFormat = {
  jpeg: "image/jpeg",
  png: "image/png",
  webp: "image/webp",
  svg: "text/plain"
};
function exportToImagePromiseForClipboard(editor, ids, opts = {}) {
  const idsToUse = ids?.length ? ids : [...editor.getCurrentPageShapeIds()];
  const format2 = opts.format ?? "png";
  return {
    blobPromise: editor.toImage(idsToUse, opts).then(
      (result) => FileHelpers.rewriteMimeType(result.blob, clipboardMimeTypesByFormat[format2])
    ),
    mimeType: clipboardMimeTypesByFormat[format2]
  };
}
function copyAs(editor, ids, opts) {
  if (!navigator.clipboard) return Promise.reject(new Error("Copy not supported"));
  if (navigator.clipboard.write) {
    const { blobPromise, mimeType } = exportToImagePromiseForClipboard(editor, ids, opts);
    const types = { [mimeType]: blobPromise };
    const additionalMimeType = getAdditionalClipboardWriteType(opts.format);
    if (additionalMimeType && doesClipboardSupportType(additionalMimeType)) {
      types[additionalMimeType] = blobPromise.then(
        (blob) => FileHelpers.rewriteMimeType(blob, additionalMimeType)
      );
    }
    return clipboardWrite(types);
  }
  switch (opts.format) {
    case "svg": {
      return fallbackWriteTextAsync(async () => {
        const result = await editor.getSvgString(ids, opts);
        if (!result) throw new Error("Failed to copy");
        return result.svg;
      });
    }
    case "png":
      throw new Error("Copy not supported");
    default:
      exhaustiveSwitchError(opts.format);
  }
}
async function fallbackWriteTextAsync(getText2) {
  await navigator.clipboard?.writeText?.(await getText2());
}
function useCopyAs() {
  const editor = useMaybeEditor();
  const { addToast } = useToasts();
  const msg2 = useTranslation();
  return reactExports.useCallback(
    (ids, format2 = "svg") => {
      assert(editor, "useCopyAs: editor is required");
      copyAs(editor, ids, { format: format2 }).catch(() => {
        addToast({
          id: "copy-fail",
          severity: "warning",
          title: msg2("toast.error.copy-fail.title"),
          description: msg2("toast.error.copy-fail.desc")
        });
      });
    },
    [editor, addToast, msg2]
  );
}
async function exportAs(editor, ids, opts) {
  let name = opts.name;
  if (!name) {
    name = `shapes at ${getTimestamp()}`;
    if (ids.length === 1) {
      const first2 = editor.getShape(ids[0]);
      if (editor.isShapeOfType(first2, "frame")) {
        name = first2.props.name || "frame";
      } else {
        name = `${sanitizeId(first2.id)} at ${getTimestamp()}`;
      }
    }
  }
  name += `.${opts.format}`;
  const { blob } = await editor.toImage(ids, opts);
  const file = new File([blob], name, { type: blob.type });
  downloadFile(file);
}
function getTimestamp() {
  const now = /* @__PURE__ */ new Date();
  const year = String(now.getFullYear()).slice(2);
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${year}-${month}-${day} ${hours}.${minutes}.${seconds}`;
}
function downloadFile(file) {
  const link = document.createElement("a");
  const url = URL.createObjectURL(file);
  link.href = url;
  link.download = file.name;
  link.click();
  URL.revokeObjectURL(url);
}
function useExportAs() {
  const editor = useMaybeEditor();
  const { addToast } = useToasts();
  const msg2 = useTranslation();
  return reactExports.useCallback(
    (ids, opts = {}) => {
      assert(editor, "useExportAs: editor is required");
      const { format: format2 = "png", name, scale = 1 } = opts;
      exportAs(editor, ids, {
        format: format2,
        name,
        scale
      }).catch((e) => {
        console.error(e.message);
        addToast({
          id: "export-fail",
          title: msg2("toast.error.export-fail.title"),
          description: msg2("toast.error.export-fail.desc"),
          severity: "error"
        });
      });
    },
    [editor, addToast, msg2]
  );
}
function usePrint() {
  const editor = useMaybeEditor();
  const prevPrintEl = reactExports.useRef(null);
  const prevStyleEl = reactExports.useRef(null);
  return reactExports.useCallback(
    async function printSelectionOrPages() {
      assert(editor, "usePrint: editor is required");
      const el = document.createElement("div");
      const style2 = document.createElement("style");
      const clearElements = (printEl, styleEl) => {
        if (printEl) printEl.innerHTML = "";
        if (styleEl && document.head.contains(styleEl)) document.head.removeChild(styleEl);
        if (printEl && document.body.contains(printEl)) {
          document.body.removeChild(printEl);
        }
      };
      clearElements(prevPrintEl.current, prevStyleEl.current);
      prevPrintEl.current = el;
      prevStyleEl.current = style2;
      const className = `tl-print-surface-${uniqueId()}`;
      el.className = className;
      style2.innerHTML = `
			.${className} {
				display: none;
			}

			.${className} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.tldraw__editor {
					display: none;
				}

				.${className} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${className}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${className}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${className}__item__header {
					display: none;
				}

				.${className}__item__footer {
					display: none;
					text-align: right;
				}

				.${className}__item__footer__hide {
					display: none;
				}

				${""}
			}

		`;
      const beforePrintHandler = () => {
        document.head.appendChild(style2);
        document.body.appendChild(el);
      };
      const afterPrintHandler = () => {
        editor.once("tick", () => {
          clearElements(el, style2);
        });
      };
      window.addEventListener("beforeprint", beforePrintHandler);
      window.addEventListener("afterprint", afterPrintHandler);
      function addPageToPrint(title, footer, svg) {
        try {
          el.innerHTML += `<div class="${className}__item">
        <div class="${className}__item__header">
          ${title.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
        </div>
        <div class="${className}__item__main">
          ${svg}
        </div>
        <div class="${className}__item__footer ${className}__item__footer__${footer ? "" : "hide"}">
          ${footer ?? ""}
        </div>
      </div>`;
        } catch (e) {
          console.error(e);
        }
      }
      function triggerPrint() {
        if (tlenv.isChromeForIos) {
          beforePrintHandler();
          window.print();
        } else if (tlenv.isSafari) {
          beforePrintHandler();
          document.execCommand("print", false);
        } else {
          window.print();
        }
      }
      const selectedShapeIds = editor.getSelectedShapeIds();
      const currentPageId = editor.getCurrentPageId();
      const pages = editor.getPages();
      const preserveAspectRatio = "xMidYMid meet";
      const svgOpts = {
        scale: 1,
        background: false,
        darkMode: false,
        preserveAspectRatio
      };
      if (editor.getSelectedShapeIds().length > 0) {
        const svgExport = await editor.getSvgString(selectedShapeIds, svgOpts);
        if (svgExport) {
          const page = pages.find((p) => p.id === currentPageId);
          addPageToPrint(`tldraw  ${page?.name}`, null, svgExport.svg);
          triggerPrint();
        }
      } else {
        {
          const page = editor.getCurrentPage();
          const svgExport = await editor.getSvgString(
            editor.getSortedChildIdsForParent(page.id),
            svgOpts
          );
          if (svgExport) {
            addPageToPrint(`tldraw  ${page.name}`, null, svgExport.svg);
            triggerPrint();
          }
        }
      }
      window.removeEventListener("beforeprint", beforePrintHandler);
      window.removeEventListener("afterprint", afterPrintHandler);
    },
    [editor]
  );
}
const MimeTypeContext = reactExports.createContext([]);
function useDefaultHelpers() {
  const editor = useMaybeEditor();
  const { addToast, removeToast, clearToasts } = useToasts();
  const { addDialog, clearDialogs, removeDialog } = useDialogs();
  const msg2 = useTranslation();
  const printSelectionOrPages = usePrint();
  const { cut: cut2, copy: copy2, paste } = useMenuClipboardEvents();
  const copyAs2 = useCopyAs();
  const exportAs2 = useExportAs();
  const getEmbedDefinition = useGetEmbedDefinition();
  const breakpoint = useBreakpoint();
  const isMobile = breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM;
  const mimeTypes = useShallowArrayIdentity(reactExports.useContext(MimeTypeContext));
  const insertMedia = reactExports.useCallback(async () => {
    if (!editor) return;
    const files = await getLocalFiles({
      allowMultiple: true,
      mimeTypes
    });
    if (!files.length) return;
    editor.markHistoryStoppingPoint("insert media");
    editor.putExternalContent({
      type: "files",
      files,
      point: editor.getViewportPageBounds().center
    });
  }, [editor, mimeTypes]);
  const replaceMedia = reactExports.useCallback(
    async (isImage) => {
      if (!editor) return;
      const files = await getLocalFiles({
        allowMultiple: false,
        mimeTypes: mimeTypes?.filter(
          (m) => isImage ? m.startsWith("image/") : m.startsWith("video/")
        )
      });
      if (!files.length) return;
      const shape = editor.getOnlySelectedShape();
      if (!shape || isImage && shape.type !== "image" || !isImage && shape.type !== "video")
        return;
      editor.markHistoryStoppingPoint("replace media");
      const file = files[0];
      editor.replaceExternalContent({
        type: "file-replace",
        file,
        shapeId: shape.id,
        isImage
      });
    },
    [editor, mimeTypes]
  );
  const replaceImage = reactExports.useCallback(() => replaceMedia(
    true
    /* isImage */
  ), [replaceMedia]);
  const replaceVideo = reactExports.useCallback(() => replaceMedia(
    false
    /* isImage */
  ), [replaceMedia]);
  return reactExports.useMemo(
    () => ({
      addToast,
      removeToast,
      clearToasts,
      addDialog,
      removeDialog,
      clearDialogs,
      msg: msg2,
      isMobile,
      insertMedia,
      replaceImage,
      replaceVideo,
      printSelectionOrPages,
      cut: cut2,
      copy: copy2,
      paste,
      copyAs: copyAs2,
      exportAs: exportAs2,
      getEmbedDefinition
    }),
    [
      addToast,
      removeToast,
      clearToasts,
      addDialog,
      removeDialog,
      clearDialogs,
      msg2,
      isMobile,
      insertMedia,
      replaceImage,
      replaceVideo,
      printSelectionOrPages,
      cut2,
      copy2,
      paste,
      copyAs2,
      exportAs2,
      getEmbedDefinition
    ]
  );
}
function mergeOverrides(overrides, defaultHelpers) {
  const mergedTranslations = {};
  for (const override of overrides) {
    if (override.translations) {
      for (const [key, value] of objectMapEntries(override.translations)) {
        let strings = mergedTranslations[key];
        if (!strings) {
          strings = mergedTranslations[key] = {};
        }
        Object.assign(strings, value);
      }
    }
  }
  return {
    actions: (editor, schema, helpers) => {
      for (const override of overrides) {
        if (override.actions) {
          schema = override.actions(editor, schema, helpers);
        }
      }
      return schema;
    },
    tools: (editor, schema, helpers) => {
      for (const override of overrides) {
        if (override.tools) {
          schema = override.tools(editor, schema, { ...defaultHelpers, ...helpers });
        }
      }
      return schema;
    },
    translations: mergedTranslations
  };
}
function useShallowArrayEquality(array2) {
  return reactExports.useMemo(() => array2, array2);
}
function useMergedTranslationOverrides(overrides) {
  const overridesArray = useShallowArrayEquality(
    overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
  );
  return reactExports.useMemo(() => {
    const mergedTranslations = {};
    for (const override of overridesArray) {
      if (override.translations) {
        for (const [key, value] of objectMapEntries(override.translations)) {
          let strings = mergedTranslations[key];
          if (!strings) {
            strings = mergedTranslations[key] = {};
          }
          Object.assign(strings, value);
        }
      }
    }
    return mergedTranslations;
  }, [overridesArray]);
}
function useMergedOverrides(overrides) {
  const defaultHelpers = useDefaultHelpers();
  const overridesArray = useShallowArrayEquality(
    overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
  );
  return reactExports.useMemo(
    () => mergeOverrides(overridesArray, defaultHelpers),
    [overridesArray, defaultHelpers]
  );
}
const ToolsContext = reactExports.createContext(null);
function ToolsProvider({ overrides, children }) {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const helpers = useDefaultHelpers();
  const onToolSelect = reactExports.useCallback(
    (source, tool, id) => {
      a11y.announce({ msg: msg2(tool.label) });
      trackEvent("select-tool", { source, id: id ?? tool.id });
    },
    [a11y, msg2, trackEvent]
  );
  const tools = reactExports.useMemo(() => {
    if (!editor) return {};
    const toolsArray = [
      {
        id: "select",
        label: "tool.select",
        icon: "tool-pointer",
        kbd: "v",
        readonlyOk: true,
        onSelect(source) {
          if (editor.isIn("select")) {
            const currentNode = editor.root.getCurrent();
            currentNode.exit({}, currentNode.id);
            currentNode.enter({}, currentNode.id);
          }
          editor.setCurrentTool("select");
          onToolSelect(source, this);
        }
      },
      {
        id: "hand",
        label: "tool.hand",
        icon: "tool-hand",
        kbd: "h",
        readonlyOk: true,
        onSelect(source) {
          editor.setCurrentTool("hand");
          onToolSelect(source, this);
        }
      },
      {
        id: "eraser",
        label: "tool.eraser",
        icon: "tool-eraser",
        kbd: "e",
        onSelect(source) {
          editor.setCurrentTool("eraser");
          onToolSelect(source, this);
        }
      },
      {
        id: "draw",
        label: "tool.draw",
        icon: "tool-pencil",
        kbd: "d,b,x",
        onSelect(source) {
          editor.setCurrentTool("draw");
          onToolSelect(source, this);
        }
      },
      ...[...GeoShapeGeoStyle.values].map((geo) => ({
        id: geo,
        label: `tool.${geo}`,
        meta: {
          geo
        },
        kbd: geo === "rectangle" ? "r" : geo === "ellipse" ? "o" : void 0,
        icon: "geo-" + geo,
        onSelect(source) {
          editor.run(() => {
            editor.setStyleForNextShapes(GeoShapeGeoStyle, geo);
            editor.setCurrentTool("geo");
            onToolSelect(source, this, `geo-${geo}`);
          });
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => editor.createShape({ id, type: "geo", props: { w: 200, h: 200, geo } })
          });
          trackEvent("drag-tool", { source, id: "geo" });
        }
      })),
      {
        id: "arrow",
        label: "tool.arrow",
        icon: "tool-arrow",
        kbd: "a",
        onSelect(source) {
          editor.setCurrentTool("arrow");
          onToolSelect(source, this);
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => editor.createShape({
              id,
              type: "arrow",
              props: { start: { x: 0, y: 200 }, end: { x: 200, y: 0 } }
            })
          });
          trackEvent("drag-tool", { source, id: "arrow" });
        }
      },
      {
        id: "line",
        label: "tool.line",
        icon: "tool-line",
        kbd: "l",
        onSelect(source) {
          editor.setCurrentTool("line");
          onToolSelect(source, this);
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => {
              const [start, end] = getIndicesBetween(null, null, 2);
              editor.createShape({
                id,
                type: "line",
                props: {
                  points: {
                    [start]: { id: start, index: start, x: 0, y: 200 },
                    [end]: { id: end, index: end, x: 200, y: 0 }
                  }
                }
              });
            }
          });
          trackEvent("drag-tool", { source, id: "line" });
        }
      },
      {
        id: "frame",
        label: "tool.frame",
        icon: "tool-frame",
        kbd: "f",
        onSelect(source) {
          editor.setCurrentTool("frame");
          onToolSelect(source, this);
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => editor.createShape({ id, type: "frame" })
          });
          trackEvent("drag-tool", { source, id: "frame" });
        }
      },
      {
        id: "text",
        label: "tool.text",
        icon: "tool-text",
        kbd: "t",
        onSelect(source) {
          editor.setCurrentTool("text");
          onToolSelect(source, this);
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => editor.createShape({ id, type: "text", props: { richText: toRichText("Text") } }),
            onDragEnd: (id) => {
              editor.setEditingShape(id);
              editor.emit("select-all-text", { shapeId: id });
            }
          });
          trackEvent("drag-tool", { source, id: "text" });
        }
      },
      {
        id: "asset",
        label: "tool.media",
        icon: "tool-media",
        kbd: "cmd+u,ctrl+u",
        onSelect(source) {
          helpers.insertMedia();
          onToolSelect(source, this, "media");
        }
      },
      {
        id: "note",
        label: "tool.note",
        icon: "tool-note",
        kbd: "n",
        onSelect(source) {
          editor.setCurrentTool("note");
          onToolSelect(source, this);
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => editor.createShape({ id, type: "note" }),
            onDragEnd: (id) => {
              editor.setEditingShape(id);
              editor.emit("select-all-text", { shapeId: id });
            }
          });
          trackEvent("drag-tool", { source, id: "note" });
        }
      },
      {
        id: "laser",
        label: "tool.laser",
        readonlyOk: true,
        icon: "tool-laser",
        kbd: "k",
        onSelect(source) {
          editor.setCurrentTool("laser");
          onToolSelect(source, this);
        }
      },
      {
        id: "embed",
        label: "tool.embed",
        icon: "dot",
        onSelect(source) {
          helpers.addDialog({ component: EmbedDialog });
          onToolSelect(source, this);
        }
      },
      {
        id: "highlight",
        label: "tool.highlight",
        icon: "tool-highlight",
        // TODO: pick a better shortcut
        kbd: "shift+d",
        onSelect(source) {
          editor.setCurrentTool("highlight");
          onToolSelect(source, this);
        }
      }
    ];
    toolsArray.forEach((t2) => t2.onSelect = t2.onSelect.bind(t2));
    const tools2 = Object.fromEntries(toolsArray.map((t2) => [t2.id, t2]));
    if (overrides) {
      return overrides(editor, tools2, helpers);
    }
    return tools2;
  }, [overrides, editor, helpers, onToolSelect, trackEvent]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolsContext.Provider, { value: tools, children });
}
function useTools() {
  const ctx = reactExports.useContext(ToolsContext);
  if (!ctx) {
    throw new Error("useTools must be used within a ToolProvider");
  }
  return ctx;
}
function onDragFromToolbarToCreateShape(editor, info, opts) {
  const { x, y } = editor.inputs.currentPagePoint;
  const stoppingPoint = editor.markHistoryStoppingPoint("drag shape tool");
  editor.setCurrentTool("select.translating");
  const id = createShapeId();
  opts.createShape(id);
  const shape = assertExists(editor.getShape(id), "Shape not found");
  const { w, h: h2 } = editor.getShapePageBounds(id);
  editor.updateShape({ id, type: shape.type, x: x - w / 2, y: y - h2 / 2 });
  editor.select(id);
  editor.setCurrentTool("select.translating", {
    ...info,
    target: "shape",
    shape: editor.getShape(id),
    isCreating: true,
    creatingMarkId: stoppingPoint,
    onCreate() {
      editor.setCurrentTool("select.idle");
      editor.select(id);
      opts.onDragEnd?.(id);
    }
  });
  editor.getCurrentTool().setCurrentToolIdMask(shape.type);
}
function TldrawUiMenuToolItem({ toolId = "", ...rest }) {
  const tools = useTools();
  const tool = tools[toolId];
  if (!tool) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { ...tool, ...rest });
}
function DefaultKeyboardShortcutsDialogContent() {
  const showCollaborationUi = useShowCollaborationUi();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.tools", id: "tools", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-tool-lock" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "insert-media" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "select" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "draw" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "eraser" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "hand" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "rectangle" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "ellipse" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "arrow" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "line" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "text" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "frame" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "note" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "laser" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "pointer-down",
          label: "tool.pointer-down",
          kbd: ",",
          onSelect: () => {
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.preferences", id: "preferences", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-dark-mode" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-focus-mode" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-grid" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.edit", id: "edit", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "undo" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "redo" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "cut" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "copy" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "paste" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "select-all" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "delete" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "duplicate" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.view", id: "view", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-in" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-out" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-to-100" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-to-fit" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-to-selection" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.transform", id: "transform", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-to-front" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-forward" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-backward" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-to-back" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "group" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "ungroup" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "flip-horizontal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "flip-vertical" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-top" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-vertical" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-bottom" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-left" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-horizontal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-right" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.text-formatting", id: "text", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-bold",
          label: "tool.rich-text-bold",
          kbd: "cmd+b",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-italic",
          label: "tool.rich-text-italic",
          kbd: "cmd+i",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-code",
          label: "tool.rich-text-code",
          kbd: "cmd+e",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-highlight",
          label: "tool.rich-text-highlight",
          kbd: "cmd+shift+h",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-strikethrough",
          label: "tool.rich-text-strikethrough",
          kbd: "cmd+shift+s",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-link",
          label: "tool.rich-text-link",
          kbd: "cmd+shift+k",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-header",
          label: "tool.rich-text-header",
          kbd: "cmd+alt+[[1-6]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-orderedList",
          label: "tool.rich-text-orderedList",
          kbd: "cmd+shift+7",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-bulletedlist",
          label: "tool.rich-text-bulletList",
          kbd: "cmd+shift+8",
          onSelect: () => {
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.a11y", id: "a11y", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape",
          label: "a11y.select-shape",
          kbd: "[[Tab]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape-direction",
          label: "a11y.select-shape-direction",
          kbd: "cmd+[[]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape-container",
          label: "a11y.enter-leave-container",
          kbd: "cmd+shift+[[]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-pan-camera",
          label: "a11y.pan-camera",
          kbd: "[[Space]]+[[]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "adjust-shape-styles",
          label: "a11y.adjust-shape-styles",
          kbd: "cmd+[[Enter]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "open-context-menu",
          label: "a11y.open-context-menu",
          kbd: "cmd+shift+[[Enter]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-move-shape",
          label: "a11y.move-shape",
          kbd: "[[]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-move-shape-faster",
          label: "a11y.move-shape-faster",
          kbd: "shift+[[]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-rotate-shape-cw",
          label: "a11y.rotate-shape-cw",
          kbd: "shift+",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-rotate-shape-cw-fine",
          label: "a11y.rotate-shape-cw-fine",
          kbd: "shift+alt+",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-rotate-shape-ccw",
          label: "a11y.rotate-shape-ccw",
          kbd: "shift+",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-rotate-shape-ccw-fine",
          label: "a11y.rotate-shape-ccw-fine",
          kbd: "shift+alt+",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "enlarge-shapes" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "shrink-shapes" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "a11y-repeat-shape-announce" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-open-keyboard-shortcuts",
          label: "a11y.open-keyboard-shortcuts",
          kbd: "cmd+alt+/",
          onSelect: () => {
          }
        }
      )
    ] }),
    showCollaborationUi && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { label: "shortcuts-dialog.collaboration", id: "collaboration", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "open-cursor-chat" }) })
  ] });
}
const DefaultKeyboardShortcutsDialog = reactExports.memo(function DefaultKeyboardShortcutsDialog2({
  children
}) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultKeyboardShortcutsDialogContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogHeader, { className: "tlui-shortcuts-dialog__header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogTitle, { children: msg2("shortcuts-dialog.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogCloseButton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiDialogBody,
      {
        className: classNames("tlui-shortcuts-dialog__body", {
          "tlui-shortcuts-dialog__body__mobile": breakpoint <= PORTRAIT_BREAKPOINT.MOBILE_XS,
          "tlui-shortcuts-dialog__body__tablet": breakpoint <= PORTRAIT_BREAKPOINT.TABLET
        }),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "keyboard-shortcuts", sourceId: "kbd", children: content })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-dialog__scrim" })
  ] });
});
async function flattenShapesToImages(editor, shapeIds, flattenImageBoundsExpand) {
  const shapes = compact(
    shapeIds.map((id) => {
      const shape = editor.getShape(id);
      if (!shape) return;
      const util = editor.getShapeUtil(shape.type);
      if (util.toSvg === void 0) return;
      return shape;
    })
  );
  if (shapes.length === 0) return;
  if (shapes.length === 1) {
    const shape = shapes[0];
    if (!shape) return;
    if (editor.isShapeOfType(shape, "image")) return;
  }
  const groups = [];
  if (flattenImageBoundsExpand !== void 0) {
    const expandedBounds = shapes.map((shape) => {
      return {
        shape,
        bounds: editor.getShapeMaskedPageBounds(shape).clone().expandBy(flattenImageBoundsExpand)
      };
    });
    for (let i = 0; i < expandedBounds.length; i++) {
      const item = expandedBounds[i];
      if (i === 0) {
        groups[0] = {
          shapes: [item.shape],
          bounds: item.bounds
        };
        continue;
      }
      let didLand = false;
      for (const group of groups) {
        if (group.bounds.includes(item.bounds)) {
          group.shapes.push(item.shape);
          group.bounds.expand(item.bounds);
          didLand = true;
          break;
        }
      }
      if (!didLand) {
        groups.push({
          shapes: [item.shape],
          bounds: item.bounds
        });
      }
    }
  } else {
    const bounds = Box.Common(shapes.map((shape) => editor.getShapeMaskedPageBounds(shape)));
    groups.push({
      shapes,
      bounds
    });
  }
  const padding = editor.options.flattenImageBoundsPadding;
  for (const group of groups) {
    if (flattenImageBoundsExpand !== void 0) {
      group.bounds.expandBy(-flattenImageBoundsExpand);
    }
    const svgResult = await editor.getSvgString(group.shapes, {
      padding,
      background: false
    });
    if (!svgResult?.svg) continue;
    const asset = await editor.getAssetForExternalContent({
      type: "file",
      file: new File([svgResult.svg], "asset.svg", { type: "image/svg+xml" })
    });
    if (!asset) continue;
    group.asset = asset;
  }
  const createdShapeIds = [];
  transact(() => {
    for (const group of groups) {
      const { asset, bounds, shapes: shapes2 } = group;
      if (!asset) continue;
      const commonAncestorId = editor.findCommonAncestor(shapes2) ?? editor.getCurrentPageId();
      if (!commonAncestorId) continue;
      let index2 = "a1";
      for (const shape of shapes2) {
        if (shape.parentId === commonAncestorId) {
          if (shape.index > index2) {
            index2 = shape.index;
          }
          break;
        }
      }
      let x;
      let y;
      let rotation;
      if (isShapeId(commonAncestorId)) {
        const commonAncestor = editor.getShape(commonAncestorId);
        if (!commonAncestor) continue;
        const point = editor.getPointInShapeSpace(commonAncestor, {
          x: bounds.x,
          y: bounds.y
        });
        rotation = editor.getShapePageTransform(commonAncestorId).rotation();
        point.sub(new Vec(padding, padding).rot(-rotation));
        x = point.x;
        y = point.y;
      } else {
        x = bounds.x - padding;
        y = bounds.y - padding;
        rotation = 0;
      }
      editor.deleteShapes(shapes2);
      editor.createAssets([{ ...asset, id: asset.id }]);
      const shapeId = createShapeId();
      editor.createShape({
        id: shapeId,
        type: "image",
        index: index2,
        parentId: commonAncestorId,
        x,
        y,
        rotation: -rotation,
        props: {
          assetId: asset.id,
          w: bounds.w + padding * 2,
          h: bounds.h + padding * 2
        }
      });
      createdShapeIds.push(shapeId);
    }
  });
  return createdShapeIds;
}
function TldrawUiPopover({ id, children, onOpenChange, open, className }) {
  const [isOpen, handleOpenChange] = useMenuIsOpen(id, onOpenChange);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$2, { onOpenChange: handleOpenChange, open: open || isOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("tlui-popover", className), children }) });
}
function TldrawUiPopoverTrigger({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$1, { asChild: true, dir: "ltr", children });
}
function TldrawUiPopoverContent({
  side,
  children,
  align = "center",
  sideOffset = 8,
  alignOffset = 0,
  disableEscapeKeyDown = false,
  autoFocusFirstButton = true
}) {
  const container = useContainer();
  const ref = React.useRef(null);
  const handleOpenAutoFocus = React.useCallback(() => {
    if (!autoFocusFirstButton) return;
    const buttons = ref.current?.querySelectorAll("button:not([disabled])") ?? [];
    const visibleButtons = [...buttons].filter(
      (button) => button.offsetWidth || button.offsetHeight
    );
    const firstButton = visibleButtons[0];
    if (firstButton) firstButton.focus();
  }, [autoFocusFirstButton]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content2$1,
    {
      className: "tlui-popover__content",
      side,
      sideOffset,
      align,
      alignOffset,
      dir: "ltr",
      ref,
      onOpenAutoFocus: handleOpenAutoFocus,
      onEscapeKeyDown: (e) => disableEscapeKeyDown && e.preventDefault(),
      children
    }
  ) });
}
function getStraightArrowInfo(editor, shape, bindings) {
  const { arrowheadStart, arrowheadEnd } = shape.props;
  const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings);
  const a = terminalsInArrowSpace.start.clone();
  const b = terminalsInArrowSpace.end.clone();
  const c = Vec.Med(a, b);
  if (Vec.Equals(a, b)) {
    return {
      bindings,
      type: "straight",
      start: {
        handle: a,
        point: a,
        arrowhead: shape.props.arrowheadStart
      },
      end: {
        handle: b,
        point: b,
        arrowhead: shape.props.arrowheadEnd
      },
      middle: c,
      isValid: false,
      length: 0
    };
  }
  const uAB = Vec.Sub(b, a).uni();
  const startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "start");
  const endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "end");
  const arrowPageTransform = editor.getShapePageTransform(shape);
  updateArrowheadPointWithBoundShape(
    b,
    // <-- will be mutated
    terminalsInArrowSpace.start,
    arrowPageTransform,
    endShapeInfo
  );
  updateArrowheadPointWithBoundShape(
    a,
    // <-- will be mutated
    terminalsInArrowSpace.end,
    arrowPageTransform,
    startShapeInfo
  );
  let offsetA = 0;
  let offsetB = 0;
  let strokeOffsetA = 0;
  let strokeOffsetB = 0;
  let minLength = MIN_ARROW_LENGTH * shape.props.scale;
  const isSelfIntersection = startShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape;
  const relationship = startShapeInfo && endShapeInfo ? getBoundShapeRelationships(editor, startShapeInfo.shape.id, endShapeInfo.shape.id) : "safe";
  if (relationship === "safe" && startShapeInfo && endShapeInfo && !isSelfIntersection && !startShapeInfo.isExact && !endShapeInfo.isExact) {
    if (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {
      if (startShapeInfo.isClosed) {
        a.setTo(b.clone().add(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)));
      }
    } else if (!endShapeInfo.didIntersect) {
      if (endShapeInfo.isClosed) {
        b.setTo(a.clone().sub(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)));
      }
    }
  }
  const distance = Vec.Sub(b, a);
  const u = Vec.Len(distance) ? distance.uni() : Vec.From(distance);
  const didFlip = !Vec.Equals(u, uAB);
  if (!isSelfIntersection) {
    if (relationship !== "start-contains-end" && startShapeInfo && arrowheadStart !== "none" && !startShapeInfo.isExact) {
      strokeOffsetA = STROKE_SIZES$1[shape.props.size] / 2 + ("size" in startShapeInfo.shape.props ? STROKE_SIZES$1[startShapeInfo.shape.props.size] / 2 : 0);
      offsetA = (BOUND_ARROW_OFFSET + strokeOffsetA) * shape.props.scale;
      minLength += strokeOffsetA * shape.props.scale;
    }
    if (relationship !== "end-contains-start" && endShapeInfo && arrowheadEnd !== "none" && !endShapeInfo.isExact) {
      strokeOffsetB = STROKE_SIZES$1[shape.props.size] / 2 + ("size" in endShapeInfo.shape.props ? STROKE_SIZES$1[endShapeInfo.shape.props.size] / 2 : 0);
      offsetB = (BOUND_ARROW_OFFSET + strokeOffsetB) * shape.props.scale;
      minLength += strokeOffsetB * shape.props.scale;
    }
  }
  const tA = a.clone().add(u.clone().mul(offsetA * (didFlip ? -1 : 1)));
  const tB = b.clone().sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)));
  if (Vec.DistMin(tA, tB, minLength)) {
    if (offsetA !== 0 && offsetB !== 0) {
      offsetA *= -1.5;
      offsetB *= -1.5;
    } else if (offsetA !== 0) {
      offsetA *= -1;
    } else if (offsetB !== 0) {
      offsetB *= -1;
    } else ;
  }
  a.add(u.clone().mul(offsetA * (didFlip ? -1 : 1)));
  b.sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)));
  if (didFlip) {
    if (startShapeInfo && endShapeInfo) {
      b.setTo(Vec.Add(a, u.clone().mul(-MIN_ARROW_LENGTH * shape.props.scale)));
    }
    c.setTo(Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end));
  } else {
    c.setTo(Vec.Med(a, b));
  }
  const length = Vec.Dist(a, b);
  return {
    bindings,
    type: "straight",
    start: {
      handle: terminalsInArrowSpace.start,
      point: a,
      arrowhead: shape.props.arrowheadStart
    },
    end: {
      handle: terminalsInArrowSpace.end,
      point: b,
      arrowhead: shape.props.arrowheadEnd
    },
    middle: c,
    isValid: length > 0,
    length
  };
}
function updateArrowheadPointWithBoundShape(point, opposite, arrowPageTransform, targetShapeInfo) {
  if (targetShapeInfo === void 0) {
    return;
  }
  if (targetShapeInfo.isExact) {
    return;
  }
  const pageFrom = Mat.applyToPoint(arrowPageTransform, opposite);
  const pageTo = Mat.applyToPoint(arrowPageTransform, point);
  const targetFrom = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageFrom);
  const targetTo = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageTo);
  const intersection = Array.from(
    targetShapeInfo.geometry.intersectLineSegment(targetFrom, targetTo, {
      includeLabels: false,
      includeInternal: false
    })
  );
  let targetInt;
  if (intersection.length) {
    targetInt = intersection.sort((p1, p2) => Vec.Dist2(p1, targetFrom) - Vec.Dist2(p2, targetFrom))[0] ?? (targetShapeInfo.isClosed ? void 0 : targetTo);
  }
  if (targetInt === void 0) {
    targetInt = targetShapeInfo.geometry.nearestPoint(targetTo, {
      includeLabels: false,
      includeInternal: false
    });
    if (!Vec.DistMin(targetInt, targetTo, 1)) {
      return;
    }
  }
  const pageInt = Mat.applyToPoint(targetShapeInfo.transform, targetInt);
  const arrowInt = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pageInt);
  point.setTo(arrowInt);
  targetShapeInfo.didIntersect = true;
}
function getCurvedArrowInfo(editor, shape, bindings) {
  const { arrowheadEnd, arrowheadStart } = shape.props;
  const bend = shape.props.bend;
  if (Math.abs(bend) > Math.abs(shape.props.bend * (WAY_TOO_BIG_ARROW_BEND_FACTOR * shape.props.scale))) {
    return getStraightArrowInfo(editor, shape, bindings);
  }
  const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings);
  const med = Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end);
  const distance = Vec.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start);
  const u = Vec.Len(distance) ? distance.uni() : Vec.From(distance);
  const middle = Vec.Add(med, u.per().mul(-bend));
  const startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "start");
  const endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "end");
  const a = terminalsInArrowSpace.start.clone();
  const b = terminalsInArrowSpace.end.clone();
  const c = middle.clone();
  if (Vec.Equals(a, b)) {
    return {
      bindings,
      type: "straight",
      start: {
        handle: a,
        point: a,
        arrowhead: shape.props.arrowheadStart
      },
      end: {
        handle: b,
        point: b,
        arrowhead: shape.props.arrowheadEnd
      },
      middle: c,
      isValid: false,
      length: 0
    };
  }
  const isClockwise = shape.props.bend < 0;
  const distFn = isClockwise ? clockwiseAngleDist : counterClockwiseAngleDist;
  const handleArc = getArcInfo(a, b, c);
  const handle_aCA = Vec.Angle(handleArc.center, a);
  const handle_aCB = Vec.Angle(handleArc.center, b);
  const handle_dAB = distFn(handle_aCA, handle_aCB);
  if (handleArc.length === 0 || handleArc.size === 0 || !isSafeFloat(handleArc.length) || !isSafeFloat(handleArc.size)) {
    return getStraightArrowInfo(editor, shape, bindings);
  }
  const tempA = a.clone();
  const tempB = b.clone();
  const tempC = c.clone();
  const arrowPageTransform = editor.getShapePageTransform(shape);
  let offsetA = 0;
  let offsetB = 0;
  let minLength = MIN_ARROW_LENGTH * shape.props.scale;
  if (startShapeInfo && !startShapeInfo.isExact) {
    const startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA);
    const centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center);
    const endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB);
    const inverseTransform = Mat.Inverse(startShapeInfo.transform);
    const startInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace);
    const centerInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace);
    const endInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace);
    const { isClosed } = startShapeInfo;
    let point;
    let intersections = Array.from(
      startShapeInfo.geometry.intersectCircle(centerInStartShapeLocalSpace, handleArc.radius, {
        includeLabels: false,
        includeInternal: false
      })
    );
    if (intersections.length) {
      const angleToStart = centerInStartShapeLocalSpace.angle(startInStartShapeLocalSpace);
      const angleToEnd = centerInStartShapeLocalSpace.angle(endInStartShapeLocalSpace);
      const dAB2 = distFn(angleToStart, angleToEnd);
      intersections = intersections.filter(
        (pt) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(pt)) <= dAB2
      );
      const targetDist = dAB2 * 0.25;
      intersections.sort(
        isClosed ? (p0, p1) => Math.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) - targetDist) < Math.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) - targetDist) ? -1 : 1 : (p0, p1) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) < distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) ? -1 : 1
      );
      point = intersections[0];
    }
    if (!point) {
      if (isClosed) {
        const nearestPoint = startShapeInfo.geometry.nearestPoint(startInStartShapeLocalSpace, {
          includeInternal: false,
          includeLabels: false
        });
        if (Vec.DistMin(nearestPoint, startInStartShapeLocalSpace, 1)) {
          point = nearestPoint;
        }
      } else {
        point = startInStartShapeLocalSpace;
      }
    }
    if (point) {
      tempA.setTo(
        editor.getPointInShapeSpace(shape, Mat.applyToPoint(startShapeInfo.transform, point))
      );
      startShapeInfo.didIntersect = true;
      if (arrowheadStart !== "none") {
        const strokeOffset = STROKE_SIZES$1[shape.props.size] / 2 + ("size" in startShapeInfo.shape.props ? STROKE_SIZES$1[startShapeInfo.shape.props.size] / 2 : 0);
        offsetA = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale;
        minLength += strokeOffset * shape.props.scale;
      }
    }
  }
  if (endShapeInfo && !endShapeInfo.isExact) {
    const startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA);
    const endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB);
    const centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center);
    const inverseTransform = Mat.Inverse(endShapeInfo.transform);
    const startInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace);
    const centerInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace);
    const endInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace);
    const isClosed = endShapeInfo.isClosed;
    let point;
    let intersections = Array.from(
      endShapeInfo.geometry.intersectCircle(centerInEndShapeLocalSpace, handleArc.radius, {
        includeLabels: false,
        includeInternal: false
      })
    );
    if (intersections.length) {
      const angleToStart = centerInEndShapeLocalSpace.angle(startInEndShapeLocalSpace);
      const angleToEnd = centerInEndShapeLocalSpace.angle(endInEndShapeLocalSpace);
      const dAB2 = distFn(angleToStart, angleToEnd);
      const targetDist = dAB2 * 0.75;
      intersections = intersections.filter(
        (pt) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(pt)) <= dAB2
      );
      intersections.sort(
        isClosed ? (p0, p1) => Math.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) - targetDist) < Math.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) - targetDist) ? -1 : 1 : (p0, p1) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) < distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) ? -1 : 1
      );
      point = intersections[0];
    }
    if (!point) {
      if (isClosed) {
        const nearestPoint = endShapeInfo.geometry.nearestPoint(endInEndShapeLocalSpace, {
          includeInternal: false,
          includeLabels: false
        });
        if (Vec.DistMin(nearestPoint, endInEndShapeLocalSpace, 1)) {
          point = nearestPoint;
        }
      } else {
        point = endInEndShapeLocalSpace;
      }
    }
    if (point) {
      tempB.setTo(
        editor.getPointInShapeSpace(shape, Mat.applyToPoint(endShapeInfo.transform, point))
      );
      endShapeInfo.didIntersect = true;
      if (arrowheadEnd !== "none") {
        const strokeOffset = STROKE_SIZES$1[shape.props.size] / 2 + ("size" in endShapeInfo.shape.props ? STROKE_SIZES$1[endShapeInfo.shape.props.size] / 2 : 0);
        offsetB = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale;
        minLength += strokeOffset * shape.props.scale;
      }
    }
  }
  let aCA = Vec.Angle(handleArc.center, tempA);
  let aCB = Vec.Angle(handleArc.center, tempB);
  let dAB = distFn(aCA, aCB);
  let lAB = dAB * handleArc.radius;
  const tA = tempA.clone();
  const tB = tempB.clone();
  if (offsetA !== 0) {
    tA.setTo(handleArc.center).add(
      Vec.FromAngle(aCA + dAB * (offsetA / lAB * (isClockwise ? 1 : -1))).mul(handleArc.radius)
    );
  }
  if (offsetB !== 0) {
    tB.setTo(handleArc.center).add(
      Vec.FromAngle(aCB + dAB * (offsetB / lAB * (isClockwise ? -1 : 1))).mul(handleArc.radius)
    );
  }
  if (Vec.DistMin(tA, tB, minLength)) {
    if (offsetA !== 0 && offsetB !== 0) {
      offsetA *= -1.5;
      offsetB *= -1.5;
    } else if (offsetA !== 0) {
      offsetA *= -2;
    } else if (offsetB !== 0) {
      offsetB *= -2;
    } else ;
    const minOffsetA = 0.1 - distFn(handle_aCA, aCA) * handleArc.radius;
    const minOffsetB = 0.1 - distFn(aCB, handle_aCB) * handleArc.radius;
    offsetA = Math.max(offsetA, minOffsetA);
    offsetB = Math.max(offsetB, minOffsetB);
  }
  if (offsetA !== 0) {
    tempA.setTo(handleArc.center).add(
      Vec.FromAngle(aCA + dAB * (offsetA / lAB * (isClockwise ? 1 : -1))).mul(handleArc.radius)
    );
  }
  if (offsetB !== 0) {
    tempB.setTo(handleArc.center).add(
      Vec.FromAngle(aCB + dAB * (offsetB / lAB * (isClockwise ? -1 : 1))).mul(handleArc.radius)
    );
  }
  if (startShapeInfo && endShapeInfo && !startShapeInfo.isExact && !endShapeInfo.isExact) {
    aCA = Vec.Angle(handleArc.center, tempA);
    aCB = Vec.Angle(handleArc.center, tempB);
    dAB = distFn(aCA, aCB);
    lAB = dAB * handleArc.radius;
    const relationship = getBoundShapeRelationships(
      editor,
      startShapeInfo.shape.id,
      endShapeInfo.shape.id
    );
    if (relationship === "double-bound" && lAB < 30) {
      tempA.setTo(a);
      tempB.setTo(b);
      tempC.setTo(c);
    } else if (relationship === "safe") {
      if (startShapeInfo && !startShapeInfo.didIntersect) {
        tempA.setTo(a);
      }
      if (endShapeInfo && !endShapeInfo.didIntersect || distFn(handle_aCA, aCA) > distFn(handle_aCA, aCB)) {
        tempB.setTo(handleArc.center).add(
          Vec.FromAngle(
            aCA + dAB * (Math.min(0.9, MIN_ARROW_LENGTH * shape.props.scale / lAB) * (isClockwise ? 1 : -1))
          ).mul(handleArc.radius)
        );
      }
    }
  }
  placeCenterHandle(
    handleArc.center,
    handleArc.radius,
    tempA,
    tempB,
    tempC,
    handle_dAB,
    isClockwise
  );
  if (tempA.equals(tempB)) {
    tempA.setTo(tempC.clone().addXY(1, 1));
    tempB.setTo(tempC.clone().subXY(1, 1));
  }
  a.setTo(tempA);
  b.setTo(tempB);
  c.setTo(tempC);
  const bodyArc = getArcInfo(a, b, c);
  return {
    bindings,
    type: "arc",
    start: {
      point: a,
      handle: terminalsInArrowSpace.start,
      arrowhead: shape.props.arrowheadStart
    },
    end: {
      point: b,
      handle: terminalsInArrowSpace.end,
      arrowhead: shape.props.arrowheadEnd
    },
    middle: c,
    handleArc,
    bodyArc,
    isValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y)
  };
}
function getArcInfo(a, b, c) {
  const center = centerOfCircleFromThreePoints(a, b, c) ?? Vec.Med(a, b);
  const radius = Vec.Dist(center, a);
  const sweepFlag = +Vec.Clockwise(a, c, b);
  const ab = ((a.y - b.y) ** 2 + (a.x - b.x) ** 2) ** 0.5;
  const bc = ((b.y - c.y) ** 2 + (b.x - c.x) ** 2) ** 0.5;
  const ca = ((c.y - a.y) ** 2 + (c.x - a.x) ** 2) ** 0.5;
  const theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2;
  const largeArcFlag = +(PI$1 > theta);
  const size2 = (PI2 - theta) * (sweepFlag ? 1 : -1);
  const length = size2 * radius;
  return {
    center,
    radius,
    size: size2,
    length,
    largeArcFlag,
    sweepFlag
  };
}
function placeCenterHandle(center, radius, tempA, tempB, tempC, originalArcLength, isClockwise) {
  const aCA = Vec.Angle(center, tempA);
  const aCB = Vec.Angle(center, tempB);
  let dAB = clockwiseAngleDist(aCA, aCB);
  if (!isClockwise) dAB = PI2 - dAB;
  tempC.setTo(center).add(Vec.FromAngle(aCA + dAB * (0.5 * (isClockwise ? 1 : -1))).mul(radius));
  if (dAB > originalArcLength) {
    tempC.rotWith(center, PI$1);
    const t2 = tempB.clone();
    tempB.setTo(tempA);
    tempA.setTo(t2);
  }
}
const ElbowArrowSides = ["right", "bottom", "left", "top"];
const ElbowArrowSideDeltas = {
  top: { x: 0, y: -1 },
  right: { x: 1, y: 0 },
  bottom: { x: 0, y: 1 },
  left: { x: -1, y: 0 }
};
const ElbowArrowSideAxes = {
  left: "x",
  right: "x",
  top: "y",
  bottom: "y"
};
const ElbowArrowSideOpposites = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
const ElbowArrowAxes = {
  x: {
    v: (x, y) => new Vec(x, y),
    loEdge: "left",
    hiEdge: "right",
    crossMid: "midY",
    gap: "gapX",
    midRange: "midXRange",
    self: "x",
    cross: "y",
    size: "width"
  },
  y: {
    v: (y, x) => new Vec(x, y),
    loEdge: "top",
    hiEdge: "bottom",
    crossMid: "midX",
    gap: "gapY",
    midRange: "midYRange",
    self: "y",
    cross: "x",
    size: "height"
  }
};
function expandRange(range, amount) {
  const newRange = {
    min: range.min - amount,
    max: range.max + amount
  };
  if (newRange.min > newRange.max) {
    return null;
  }
  return newRange;
}
function subtractRange(a, b) {
  assert(a.min <= a.max && b.min <= b.max);
  if (a.min <= b.min && b.max <= a.max) {
    return [
      { min: a.min, max: b.min },
      { min: b.max, max: a.max }
    ];
  }
  if (b.max <= a.min || b.min >= a.max) {
    return [a];
  }
  if (b.min <= a.min && a.max <= b.max) {
    return [];
  }
  if (isWithinRange(a.min, b)) {
    return [{ min: b.max, max: a.max }];
  }
  if (isWithinRange(a.max, b)) {
    return [{ min: a.min, max: b.min }];
  }
  return [];
}
function createRange(a, b) {
  return { min: Math.min(a, b), max: Math.max(a, b) };
}
function isWithinRange(value, range) {
  return value >= range.min && value <= range.max;
}
function rangeSize(range) {
  return range.max - range.min;
}
function flipEdgeCrossInPlace(edge) {
  if (!edge) return;
  const tmp = edge.cross.min;
  edge.cross.min = -edge.cross.max;
  edge.cross.max = -tmp;
  edge.crossTarget = -edge.crossTarget;
}
function flipEdgeValueInPlace(edge) {
  if (!edge) return;
  edge.value = -edge.value;
  edge.expanded = edge.expanded === null ? null : -edge.expanded;
}
const ElbowArrowTransform = {
  Identity: { x: 1, y: 1, transpose: false },
  Rotate90: { x: -1, y: 1, transpose: true },
  Rotate180: { x: -1, y: -1, transpose: false },
  Rotate270: { x: 1, y: -1, transpose: true },
  FlipY: { x: 1, y: -1, transpose: false }
};
function invertElbowArrowTransform(transform) {
  if (transform.transpose) {
    return {
      x: transform.y,
      y: transform.x,
      transpose: true
    };
  }
  return transform;
}
function transformElbowArrowTransform(a, b) {
  const next = { ...a };
  if (b.transpose) {
    swap(next, "x", "y");
    next.transpose = !next.transpose;
  }
  if (b.x === -1) {
    next.x = -next.x;
  }
  if (b.y === -1) {
    next.y = -next.y;
  }
  return next;
}
function swap(object2, a, b) {
  const temp = object2[a];
  object2[a] = object2[b];
  object2[b] = temp;
}
function transformVecInPlace(transform, point) {
  point.x = transform.x * point.x;
  point.y = transform.y * point.y;
  if (transform.transpose) {
    swap(point, "x", "y");
  }
}
function transformBoxInPlace(transform, box) {
  if (transform.x === -1) {
    box.x = -(box.x + box.width);
  }
  if (transform.y === -1) {
    box.y = -(box.y + box.height);
  }
  if (transform.transpose) {
    swap(box, "x", "y");
    swap(box, "width", "height");
  }
}
function transformEdgesInPlace(transform, edges) {
  if (transform.x === -1) {
    swap(edges, "left", "right");
    flipEdgeCrossInPlace(edges.top);
    flipEdgeCrossInPlace(edges.bottom);
    flipEdgeValueInPlace(edges.left);
    flipEdgeValueInPlace(edges.right);
  }
  if (transform.y === -1) {
    swap(edges, "top", "bottom");
    flipEdgeCrossInPlace(edges.left);
    flipEdgeCrossInPlace(edges.right);
    flipEdgeValueInPlace(edges.top);
    flipEdgeValueInPlace(edges.bottom);
  }
  if (transform.transpose) {
    swap(edges, "left", "top");
    swap(edges, "right", "bottom");
  }
}
class ElbowArrowWorkingInfo {
  options;
  A;
  B;
  common;
  gapX;
  gapY;
  midX;
  midY;
  bias;
  constructor(info) {
    this.options = info.options;
    this.A = info.A;
    this.B = info.B;
    this.common = info.common;
    this.midX = info.midX;
    this.midY = info.midY;
    this.gapX = info.gapX;
    this.gapY = info.gapY;
    this.bias = new Vec(1, 1);
  }
  transform = ElbowArrowTransform.Identity;
  inverse = ElbowArrowTransform.Identity;
  apply(transform) {
    this.transform = transformElbowArrowTransform(transform, this.transform);
    this.inverse = invertElbowArrowTransform(this.transform);
    transformBoxInPlace(transform, this.A.original);
    transformBoxInPlace(transform, this.B.original);
    transformBoxInPlace(transform, this.common.original);
    transformBoxInPlace(transform, this.A.expanded);
    transformBoxInPlace(transform, this.B.expanded);
    transformBoxInPlace(transform, this.common.expanded);
    transformEdgesInPlace(transform, this.A.edges);
    transformEdgesInPlace(transform, this.B.edges);
    transformVecInPlace(transform, this.bias);
    if (transform.x === -1) {
      this.gapX = -this.gapX;
      this.midX = this.midX === null ? null : -this.midX;
    }
    if (transform.y === -1) {
      this.gapY = -this.gapY;
      this.midY = this.midY === null ? null : -this.midY;
    }
    if (transform.transpose) {
      let temp = this.midX;
      this.midX = this.midY;
      this.midY = temp;
      temp = this.gapX;
      this.gapX = this.gapY;
      this.gapY = temp;
    }
  }
  reset() {
    this.apply(this.inverse);
  }
  vec(x, y) {
    const point = new Vec(x, y);
    transformVecInPlace(this.inverse, point);
    return point;
  }
}
const MIN_DISTANCE = 0.01;
class ElbowArrowRouteBuilder {
  constructor(info, name) {
    this.info = info;
    this.name = name;
  }
  points = [];
  add(x, y) {
    this.points.push(this.info.vec(x, y));
    return this;
  }
  _midpointHandle = null;
  midpointHandle(axis) {
    assert(this._midpointHandle === null, "midX/midY called multiple times");
    const point = Vec.Lrp(
      this.points[this.points.length - 2],
      this.points[this.points.length - 1],
      0.5
    );
    this._midpointHandle = {
      axis: this.info.transform.transpose ? axis === "x" ? "y" : "x" : axis,
      point,
      segmentStart: this.points[this.points.length - 2].clone(),
      segmentEnd: this.points[this.points.length - 1].clone()
    };
    return this;
  }
  build() {
    const finalPoints = [];
    for (let i = 0; i < this.points.length; i++) {
      const p0 = this.points[i];
      const p1 = finalPoints[finalPoints.length - 1];
      const p2 = finalPoints[finalPoints.length - 2];
      if (!p1 || !p2) {
        finalPoints.push(p0);
      } else {
        const d1x = Math.abs(p0.x - p1.x);
        const d1y = Math.abs(p0.y - p1.y);
        const d2x = Math.abs(p0.x - p2.x);
        const d2y = Math.abs(p0.y - p2.y);
        if (d1x < MIN_DISTANCE && d1y < MIN_DISTANCE) ;
        else if (d1x < MIN_DISTANCE && d2x < MIN_DISTANCE) {
          p1.y = p0.y;
        } else if (d1y < MIN_DISTANCE && d2y < MIN_DISTANCE) {
          p1.x = p0.x;
        } else {
          finalPoints.push(p0);
        }
      }
    }
    return {
      name: this.name,
      points: finalPoints,
      distance: measureRouteManhattanDistance(finalPoints),
      aEdgePicking: "manual",
      bEdgePicking: "manual",
      skipPointsWhenDrawing: /* @__PURE__ */ new Set(),
      midpointHandle: this._midpointHandle
    };
  }
}
function measureRouteManhattanDistance(path) {
  let distance = 0;
  for (let i = 0; i < path.length - 1; i++) {
    const start = path[i];
    const end = path[i + 1];
    distance += Math.abs(end.x - start.x) + Math.abs(end.y - start.y);
  }
  return distance;
}
function routeRightToLeft(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.left;
  if (!aEdge || !bEdge) return null;
  if (aEdge.crossTarget > bEdge.crossTarget) {
    info.apply(ElbowArrowTransform.FlipY);
  }
  if (info.gapX > 0 && info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 1").add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, bEdge.crossTarget).midpointHandle("x").add(bEdge.value, bEdge.crossTarget).build();
  }
  if (aEdge.expanded === null || bEdge.expanded === null) return null;
  if (info.midY !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 2").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(bEdge.expanded, info.midY).midpointHandle("y").add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  const arrow3Distance = Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.common.expanded.bottom) + Math.abs(info.common.expanded.right - bEdge.expanded) + Math.abs(info.common.expanded.bottom - bEdge.crossTarget) + info.options.expandElbowLegLength + 6;
  const arrow4Distance = info.options.expandElbowLegLength + Math.abs(aEdge.crossTarget - info.common.expanded.top) + Math.abs(aEdge.expanded - info.common.expanded.left) + Math.abs(info.common.expanded.top - bEdge.crossTarget) + Math.abs(info.common.expanded.left - bEdge.value) + // 6 points in this arrow, plus bias towards down/right:
  6 + info.bias.y;
  const arrow5Distance = info.gapX < 0 && info.midX !== null ? info.options.expandElbowLegLength + Math.abs(aEdge.crossTarget - info.A.expanded.bottom) + info.common.expanded.width + Math.abs(info.A.expanded.bottom - info.B.expanded.top) + Math.abs(info.B.expanded.top - bEdge.crossTarget) + info.options.expandElbowLegLength + // 8 points in this arrow
  8 : Infinity;
  if (arrow3Distance < arrow4Distance && arrow3Distance < arrow5Distance) {
    return new ElbowArrowRouteBuilder(info, "to left 3").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, info.common.expanded.bottom).add(bEdge.expanded, info.common.expanded.bottom).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (arrow4Distance < arrow5Distance) {
    return new ElbowArrowRouteBuilder(info, "to left 4").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.common.expanded.top).add(info.common.expanded.left, info.common.expanded.top).add(info.common.expanded.left, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 5").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded.bottom).add(info.midX, info.A.expanded.bottom).add(info.midX, info.B.expanded.top).midpointHandle("y").add(bEdge.expanded, info.B.expanded.top).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  return null;
}
function routeRightToTop(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.top;
  if (!aEdge || !bEdge) return null;
  if (aEdge.crossTarget < (bEdge.expanded ?? bEdge.value) && bEdge.crossTarget > (aEdge.expanded ?? aEdge.value) || info.A.isPoint && info.B.expanded.containsPoint(info.A.original.center)) {
    return new ElbowArrowRouteBuilder(info, "to top 1").add(aEdge.value, aEdge.crossTarget).add(bEdge.crossTarget, aEdge.crossTarget).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (info.gapX > 0 && info.midX !== null && bEdge.expanded !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 2").add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, bEdge.expanded).midpointHandle("x").add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (info.gapY > 0 && aEdge.expanded !== null && bEdge.crossTarget < aEdge.expanded && info.midY !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 3").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(bEdge.crossTarget, info.midY).midpointHandle("y").add(bEdge.crossTarget, bEdge.value).build();
  }
  const arrow4Length = Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.common.expanded.top) + Math.abs(bEdge.crossTarget - info.common.expanded.right) + Math.abs(bEdge.value - info.common.expanded.top);
  const arrow5Length = aEdge.expanded !== null && info.midY !== null && bEdge.expanded !== null ? Math.abs(aEdge.value - aEdge.expanded) + Math.abs(info.B.expanded.left - aEdge.expanded) + Math.abs(info.B.expanded.left - bEdge.crossTarget) + Math.abs(aEdge.crossTarget - info.B.expanded.top) + Math.abs(bEdge.value - bEdge.expanded) : Infinity;
  const arrow6Length = aEdge.expanded !== null && info.midX !== null && bEdge.expanded !== null ? Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.A.expanded.bottom) + Math.abs(aEdge.expanded - bEdge.crossTarget) + Math.abs(info.A.expanded.bottom - bEdge.expanded) + Math.abs(bEdge.expanded - bEdge.value) : Infinity;
  if (arrow4Length < arrow5Length && arrow4Length < arrow6Length) {
    return new ElbowArrowRouteBuilder(info, "to top 4").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, info.common.expanded.top).add(bEdge.crossTarget, info.common.expanded.top).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (bEdge.expanded !== null && aEdge.expanded !== null && info.midY !== null && arrow5Length < arrow6Length) {
    return new ElbowArrowRouteBuilder(info, "to top 5").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(info.B.expanded.left, info.midY).midpointHandle("y").add(info.B.expanded.left, bEdge.expanded).add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (bEdge.expanded !== null && aEdge.expanded !== null && info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 6").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded.bottom).add(info.midX, info.A.expanded.bottom).add(info.midX, bEdge.expanded).midpointHandle("x").add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  return null;
}
function routeRightToBottom(info) {
  info.apply(ElbowArrowTransform.FlipY);
  return routeRightToTop(info);
}
function routeRightToRight(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.right;
  if (!aEdge || !bEdge) return null;
  if ((info.gapX <= 0 || aEdge.crossTarget > info.B.expanded.bottom || aEdge.crossTarget < info.B.expanded.top) && (bEdge.value > info.A.original.left || bEdge.crossTarget > info.A.expanded.bottom || bEdge.crossTarget < info.A.expanded.top)) {
    return new ElbowArrowRouteBuilder(info, "to right 1").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (info.midX === null) return null;
  if (bEdge.expanded !== null && info.gapX >= 0) {
    const viaBottomLength = Math.abs(bEdge.crossTarget - info.B.expanded.bottom) + Math.abs(aEdge.crossTarget - info.B.expanded.bottom);
    const viaTopLength = Math.abs(bEdge.crossTarget - info.B.expanded.top) + Math.abs(aEdge.crossTarget - info.B.expanded.top);
    const topOrBottom = viaBottomLength < viaTopLength ? "bottom" : "top";
    return new ElbowArrowRouteBuilder(info, `to right 2 via ${topOrBottom}`).add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, info.B.expanded[topOrBottom]).midpointHandle("x").add(bEdge.expanded, info.B.expanded[topOrBottom]).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (aEdge.expanded !== null && info.gapX <= 0) {
    const viaBottomLength = Math.abs(bEdge.crossTarget - info.A.expanded.bottom) + Math.abs(aEdge.crossTarget - info.A.expanded.bottom);
    const viaTopLength = Math.abs(bEdge.crossTarget - info.A.expanded.top) + Math.abs(aEdge.crossTarget - info.A.expanded.top);
    const topOrBottom = viaBottomLength < viaTopLength ? "bottom" : "top";
    return new ElbowArrowRouteBuilder(info, `to right 3 via ${topOrBottom}`).add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded[topOrBottom]).add(info.midX, info.A.expanded[topOrBottom]).add(info.midX, bEdge.crossTarget).midpointHandle("x").add(bEdge.value, bEdge.crossTarget).build();
  }
  return null;
}
const routes = {
  top: {
    top: [ElbowArrowTransform.Rotate270, routeRightToRight],
    left: [ElbowArrowTransform.Rotate270, routeRightToTop],
    bottom: [ElbowArrowTransform.Rotate270, routeRightToLeft],
    right: [ElbowArrowTransform.Rotate270, routeRightToBottom]
  },
  right: {
    top: [ElbowArrowTransform.Identity, routeRightToTop],
    right: [ElbowArrowTransform.Identity, routeRightToRight],
    bottom: [ElbowArrowTransform.Identity, routeRightToBottom],
    left: [ElbowArrowTransform.Identity, routeRightToLeft]
  },
  bottom: {
    top: [ElbowArrowTransform.Rotate90, routeRightToLeft],
    left: [ElbowArrowTransform.Rotate90, routeRightToBottom],
    bottom: [ElbowArrowTransform.Rotate90, routeRightToRight],
    right: [ElbowArrowTransform.Rotate90, routeRightToTop]
  },
  left: {
    top: [ElbowArrowTransform.Rotate180, routeRightToBottom],
    left: [ElbowArrowTransform.Rotate180, routeRightToRight],
    bottom: [ElbowArrowTransform.Rotate180, routeRightToTop],
    right: [ElbowArrowTransform.Rotate180, routeRightToLeft]
  }
};
function tryRouteArrow(info, aEdge, bEdge) {
  const [transform, routeFn] = routes[aEdge][bEdge];
  info.apply(transform);
  const route = routeFn(info);
  info.reset();
  return route;
}
function routeArrowWithAutoEdgePicking(info, reason) {
  let idealRoute = null;
  if (
    // +1 to bias us towards the x-axis. without this, we get flicker as we move an arrow locket
    // to 45 deg (as gapx/gapy are almost equal and the result depends on floating point
    // precision)
    Math.abs(info.gapX) + 1 > Math.abs(info.gapY) && info.midX !== null
  ) {
    if (info.gapX > 0) {
      idealRoute = tryRouteArrow(info, "right", "left");
    } else {
      idealRoute = tryRouteArrow(info, "left", "right");
    }
  } else {
    const aRight = info.A.edges.right;
    const aLeft = info.A.edges.left;
    const bTop = info.B.edges.top;
    const bBottom = info.B.edges.bottom;
    if (info.A.isPoint && info.B.isPoint) {
      if (info.gapY > 0) {
        idealRoute = tryRouteArrow(info, "bottom", "top");
      } else {
        idealRoute = tryRouteArrow(info, "top", "bottom");
      }
    } else if (aRight && bTop && (aRight.expanded ?? aRight.value) <= bTop.crossTarget && aRight.crossTarget <= (bTop.expanded ?? bTop.value)) {
      idealRoute = tryRouteArrow(info, "right", "top");
    } else if (aRight && bBottom && (aRight.expanded ?? aRight.value) <= bBottom.crossTarget && aRight.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
      idealRoute = tryRouteArrow(info, "right", "bottom");
    } else if (aLeft && bTop && (aLeft.expanded ?? aLeft.value) >= bTop.crossTarget && aLeft.crossTarget <= (bTop.expanded ?? bTop.value)) {
      idealRoute = tryRouteArrow(info, "left", "top");
    } else if (aLeft && bBottom && (aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget && aLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
      idealRoute = tryRouteArrow(info, "left", "bottom");
    } else if (info.gapY > 0 && info.midY !== null) {
      idealRoute = tryRouteArrow(info, "bottom", "top");
    } else if (info.gapY < 0 && info.midY !== null) {
      idealRoute = tryRouteArrow(info, "top", "bottom");
    }
  }
  if (idealRoute) {
    idealRoute.aEdgePicking = reason;
    idealRoute.bEdgePicking = reason;
    return idealRoute;
  }
  const aAvailableSide = ElbowArrowSides.filter((side) => info.A.edges[side]);
  const bAvailableSides = ElbowArrowSides.filter((side) => info.B.edges[side]);
  const nonPartialRouteCandidates = aAvailableSide.flatMap(
    (aSide) => bAvailableSides.map((bSide) => [aSide, bSide, reason, reason])
  );
  return pickBest(info, nonPartialRouteCandidates);
}
function routeArrowWithPartialEdgePicking(info, aSide) {
  let idealRoute = null;
  const aRight = info.A.edges.right;
  const aLeft = info.A.edges.left;
  const bTop = info.B.edges.top;
  const bBottom = info.B.edges.bottom;
  switch (aSide) {
    case "right":
      if (info.gapX > 0 && info.gapX > Math.abs(info.gapY) && info.midX !== null) {
        idealRoute = tryRouteArrow(info, "right", "left");
      } else if (aRight && bTop && (aRight.expanded ?? aRight.value) <= bTop.crossTarget && aRight.crossTarget <= (bTop.expanded ?? bTop.value)) {
        idealRoute = tryRouteArrow(info, "right", "top");
      } else if (aRight && bBottom && (aRight.expanded ?? aRight.value) <= bBottom.crossTarget && aRight.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
        idealRoute = tryRouteArrow(info, "right", "bottom");
      }
      break;
    case "left":
      if (info.gapX < 0 && Math.abs(info.gapX) > Math.abs(info.gapY) && info.midX !== null) {
        idealRoute = tryRouteArrow(info, "left", "right");
      } else if (aLeft && bTop && (aLeft.expanded ?? aLeft.value) >= bTop.crossTarget && aLeft.crossTarget <= (bTop.expanded ?? bTop.value)) {
        idealRoute = tryRouteArrow(info, "left", "top");
      } else if (aLeft && bBottom && (aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget && aLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
        idealRoute = tryRouteArrow(info, "left", "bottom");
      }
      break;
    case "top":
    case "bottom":
      break;
    default:
      exhaustiveSwitchError(aSide);
  }
  if (idealRoute) {
    idealRoute.aEdgePicking = "manual";
    idealRoute.bEdgePicking = "auto";
    return idealRoute;
  }
  switch (aSide) {
    case "top":
      return pickBest(info, [
        ["top", "bottom", "manual", "auto"],
        ["top", "right", "manual", "auto"],
        ["top", "left", "manual", "auto"],
        ["top", "top", "manual", "auto"]
      ]);
    case "bottom":
      return pickBest(info, [
        ["bottom", "top", "manual", "auto"],
        ["bottom", "right", "manual", "auto"],
        ["bottom", "left", "manual", "auto"],
        ["bottom", "bottom", "manual", "auto"]
      ]);
    case "left":
      return pickBest(info, [
        ["left", "right", "manual", "auto"],
        ["left", "bottom", "manual", "auto"],
        ["left", "left", "manual", "auto"],
        ["left", "top", "manual", "auto"]
      ]);
    case "right":
      return pickBest(info, [
        ["right", "left", "manual", "auto"],
        ["right", "bottom", "manual", "auto"],
        ["right", "right", "manual", "auto"],
        ["right", "top", "manual", "auto"]
      ]);
  }
}
function routeArrowWithManualEdgePicking(info, aSide, bSide) {
  const route = tryRouteArrow(info, aSide, bSide);
  if (route) return route;
  if (info.A.isPoint && info.B.isPoint) {
    return pickBest(info, [
      [ElbowArrowSideOpposites[aSide], ElbowArrowSideOpposites[bSide], "manual", "manual"],
      [aSide, ElbowArrowSideOpposites[bSide], "manual", "auto"],
      [ElbowArrowSideOpposites[aSide], bSide, "auto", "manual"]
    ]);
  } else if (info.A.isPoint) {
    return tryRouteArrow(info, ElbowArrowSideOpposites[aSide], bSide);
  } else if (info.B.isPoint) {
    return tryRouteArrow(info, aSide, ElbowArrowSideOpposites[bSide]);
  }
  return null;
}
function pickBest(info, edges) {
  let bestRoute = null;
  let bestCornerCount = Infinity;
  let bestDistance = Infinity;
  let distanceBias = 0;
  for (const [aSide, bSide, aEdgePicking, bEdgePicking] of edges) {
    distanceBias += 1;
    const route = tryRouteArrow(info, aSide, bSide);
    if (route) {
      route.aEdgePicking = aEdgePicking;
      route.bEdgePicking = bEdgePicking;
      if (route.points.length < bestCornerCount) {
        bestCornerCount = route.points.length;
        bestDistance = route.distance;
        bestRoute = route;
      } else if (route.points.length === bestCornerCount && route.distance + distanceBias < bestDistance) {
        bestDistance = route.distance;
        bestRoute = route;
      }
    }
  }
  return bestRoute;
}
function getElbowArrowInfo(editor, arrow2, bindings) {
  const shapeOptions = editor.getShapeUtil(arrow2.type).options;
  const options = {
    elbowMidpoint: arrow2.props.elbowMidPoint,
    expandElbowLegLength: shapeOptions.expandElbowLegLength[arrow2.props.size] * arrow2.props.scale,
    minElbowLegLength: shapeOptions.minElbowLegLength[arrow2.props.size] * arrow2.props.scale
  };
  let startTerminal = getElbowArrowTerminalInfo(editor, arrow2, bindings.start, arrow2.props.start);
  let endTerminal = getElbowArrowTerminalInfo(editor, arrow2, bindings.end, arrow2.props.end);
  startTerminal = adjustTerminalForUnclosedPathIfNeeded(startTerminal, endTerminal, options);
  endTerminal = adjustTerminalForUnclosedPathIfNeeded(endTerminal, startTerminal, options);
  const swapOrder = !!(!startTerminal.side && endTerminal.side);
  let { aTerminal, bTerminal } = swapOrder ? { aTerminal: endTerminal, bTerminal: startTerminal } : { aTerminal: startTerminal, bTerminal: endTerminal };
  let edgesA = {
    top: getUsableEdge(aTerminal, bTerminal, "top", options),
    right: getUsableEdge(aTerminal, bTerminal, "right", options),
    bottom: getUsableEdge(aTerminal, bTerminal, "bottom", options),
    left: getUsableEdge(aTerminal, bTerminal, "left", options)
  };
  let edgesB = {
    top: getUsableEdge(bTerminal, aTerminal, "top", options),
    right: getUsableEdge(bTerminal, aTerminal, "right", options),
    bottom: getUsableEdge(bTerminal, aTerminal, "bottom", options),
    left: getUsableEdge(bTerminal, aTerminal, "left", options)
  };
  const aIsUsable = hasUsableEdge(edgesA, aTerminal.side);
  const bIsUsable = hasUsableEdge(edgesB, bTerminal.side);
  let needsNewEdges = false;
  if (!aIsUsable || !bIsUsable) {
    needsNewEdges = true;
    if (!aIsUsable) {
      bTerminal = convertTerminalToPoint(bTerminal);
    }
    if (!bIsUsable) {
      aTerminal = convertTerminalToPoint(aTerminal);
    }
    if (bTerminal.bounds.containsPoint(aTerminal.target, options.expandElbowLegLength)) {
      bTerminal = convertTerminalToPoint(bTerminal);
    }
    if (aTerminal.bounds.containsPoint(bTerminal.target, options.expandElbowLegLength)) {
      aTerminal = convertTerminalToPoint(aTerminal);
    }
  }
  if (needsNewEdges) {
    edgesA = {
      top: getUsableEdge(aTerminal, bTerminal, "top", options),
      right: getUsableEdge(aTerminal, bTerminal, "right", options),
      bottom: getUsableEdge(aTerminal, bTerminal, "bottom", options),
      left: getUsableEdge(aTerminal, bTerminal, "left", options)
    };
    edgesB = {
      top: getUsableEdge(bTerminal, aTerminal, "top", options),
      right: getUsableEdge(bTerminal, aTerminal, "right", options),
      bottom: getUsableEdge(bTerminal, aTerminal, "bottom", options),
      left: getUsableEdge(bTerminal, aTerminal, "left", options)
    };
  }
  const expandedA = aTerminal.isPoint ? aTerminal.bounds : aTerminal.bounds.clone().expandBy(options.expandElbowLegLength);
  const expandedB = bTerminal.isPoint ? bTerminal.bounds : bTerminal.bounds.clone().expandBy(options.expandElbowLegLength);
  const common = {
    original: Box.Common([aTerminal.bounds, bTerminal.bounds]),
    expanded: Box.Common([expandedA, expandedB])
  };
  let gapX = bTerminal.bounds.minX - aTerminal.bounds.maxX;
  if (gapX < 0) {
    gapX = aTerminal.bounds.minX - bTerminal.bounds.maxX;
    if (gapX < 0) {
      gapX = 0;
    }
    gapX = -gapX;
  }
  let gapY = bTerminal.bounds.minY - aTerminal.bounds.maxY;
  if (gapY < 0) {
    gapY = aTerminal.bounds.minY - bTerminal.bounds.maxY;
    if (gapY < 0) {
      gapY = 0;
    }
    gapY = -gapY;
  }
  const aMinLength = aTerminal.minEndSegmentLength * 3;
  const bMinLength = bTerminal.minEndSegmentLength * 3;
  const minLegDistanceNeeded = (aTerminal.isPoint ? aMinLength : options.minElbowLegLength) + (bTerminal.isPoint ? bMinLength : options.minElbowLegLength);
  let mxRange = null;
  if (gapX > minLegDistanceNeeded) {
    mxRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.maxX + aMinLength : expandedA.maxX,
      b: bTerminal.isPoint ? bTerminal.bounds.minX - bMinLength : expandedB.minX
    };
  } else if (gapX < -minLegDistanceNeeded) {
    mxRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.minX - aMinLength : expandedA.minX,
      b: bTerminal.isPoint ? bTerminal.bounds.maxX + bMinLength : expandedB.maxX
    };
  }
  let myRange = null;
  if (gapY > minLegDistanceNeeded) {
    myRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.maxY + aMinLength : expandedA.maxY,
      b: bTerminal.isPoint ? bTerminal.bounds.minY - bMinLength : expandedB.minY
    };
  } else if (gapY < -minLegDistanceNeeded) {
    myRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.minY - aMinLength : expandedA.minY,
      b: bTerminal.isPoint ? bTerminal.bounds.maxY + bMinLength : expandedB.maxY
    };
  }
  const midpoint2 = swapOrder ? 1 - options.elbowMidpoint : options.elbowMidpoint;
  const mx = mxRange ? lerp(mxRange.a, mxRange.b, midpoint2) : null;
  const my = myRange ? lerp(myRange.a, myRange.b, midpoint2) : null;
  const info = {
    options,
    swapOrder,
    A: {
      isPoint: aTerminal.isPoint,
      target: aTerminal.target,
      isExact: aTerminal.isExact,
      arrowheadOffset: aTerminal.arrowheadOffset,
      minEndSegmentLength: aTerminal.minEndSegmentLength,
      original: aTerminal.bounds,
      expanded: expandedA,
      edges: edgesA,
      geometry: aTerminal.geometry
    },
    B: {
      isPoint: bTerminal.isPoint,
      target: bTerminal.target,
      isExact: bTerminal.isExact,
      arrowheadOffset: bTerminal.arrowheadOffset,
      minEndSegmentLength: bTerminal.minEndSegmentLength,
      original: bTerminal.bounds,
      expanded: expandedB,
      edges: edgesB,
      geometry: bTerminal.geometry
    },
    common,
    gapX,
    gapY,
    midX: mx,
    midY: my
  };
  const workingInfo = new ElbowArrowWorkingInfo(info);
  const aSide = getSideToUse(aTerminal, bTerminal, info.A.edges);
  const bSide = getSideToUse(bTerminal, aTerminal, info.B.edges);
  let route;
  if (aSide && bSide) {
    route = routeArrowWithManualEdgePicking(workingInfo, aSide, bSide);
  } else if (aSide && !bSide) {
    route = routeArrowWithPartialEdgePicking(workingInfo, aSide);
  }
  if (!route) {
    route = routeArrowWithAutoEdgePicking(workingInfo, aSide || bSide ? "fallback" : "auto");
  }
  if (route) {
    castPathSegmentIntoGeometry("first", info.A, info.B, route);
    castPathSegmentIntoGeometry("last", info.B, info.A, route);
    fixTinyEndNubs(route, aTerminal, bTerminal);
    if (swapOrder) route.points.reverse();
  }
  return {
    ...info,
    route,
    midXRange: mxRange ? swapOrder ? { lo: mxRange.b, hi: mxRange.a } : { lo: mxRange.a, hi: mxRange.b } : null,
    midYRange: myRange ? swapOrder ? { lo: myRange.b, hi: myRange.a } : { lo: myRange.a, hi: myRange.b } : null
  };
}
function getRouteHandlePath(info, route) {
  const startTarget = info.swapOrder ? info.B.target : info.A.target;
  const endTarget = info.swapOrder ? info.A.target : info.B.target;
  const firstSegmentLength = Vec.ManhattanDist(route.points[0], route.points[1]);
  const lastSegmentLength = Vec.ManhattanDist(
    route.points[route.points.length - 2],
    route.points[route.points.length - 1]
  );
  const newFirstSegmentLength = Vec.ManhattanDist(startTarget, route.points[1]);
  const newLastSegmentLength = Vec.ManhattanDist(route.points[route.points.length - 2], endTarget);
  const firstSegmentLengthChange = firstSegmentLength - newFirstSegmentLength;
  const lastSegmentLengthChange = lastSegmentLength - newLastSegmentLength;
  const newPoints = [startTarget, ...route.points, endTarget];
  return {
    name: route.name,
    distance: route.distance + firstSegmentLengthChange + lastSegmentLengthChange,
    points: newPoints.filter((p) => !route.skipPointsWhenDrawing.has(p)),
    aEdgePicking: route.aEdgePicking,
    bEdgePicking: route.bEdgePicking,
    skipPointsWhenDrawing: route.skipPointsWhenDrawing,
    midpointHandle: route.midpointHandle
  };
}
function getEdgeFromNormalizedAnchor(normalizedAnchor) {
  if (approximately(normalizedAnchor.x, 0.5) && approximately(normalizedAnchor.y, 0.5)) {
    return null;
  }
  if (Math.abs(normalizedAnchor.x - 0.5) > // slightly bias towards x arrows to prevent flickering when the anchor is right on the line
  // between the two directions
  Math.abs(normalizedAnchor.y - 0.5) - 1e-4) {
    return normalizedAnchor.x < 0.5 ? "left" : "right";
  }
  return normalizedAnchor.y < 0.5 ? "top" : "bottom";
}
function getElbowArrowTerminalInfo(editor, arrow2, binding, point) {
  const arrowStrokeSize = STROKE_SIZES$1[arrow2.props.size] * arrow2.props.scale / 2;
  const minEndSegmentLength = arrowStrokeSize * arrow2.props.scale * 3;
  if (binding) {
    const target = editor.getShape(binding.toId);
    const geometry = getBindingGeometryInArrowSpace(editor, arrow2, binding.toId, binding.props);
    if (geometry && target) {
      let arrowheadOffset = 0;
      const arrowheadProp = binding.props.terminal === "start" ? "arrowheadStart" : "arrowheadEnd";
      if (arrow2.props[arrowheadProp] !== "none") {
        const targetScale = "scale" in target.props ? target.props.scale : 1;
        const targetStrokeSize = "size" in target.props ? (STROKE_SIZES$1[target.props.size] ?? 0) * targetScale / 2 : 0;
        arrowheadOffset = arrowStrokeSize + targetStrokeSize + BOUND_ARROW_OFFSET * arrow2.props.scale;
      }
      let side = null;
      const targetPoint = geometry.target;
      if (binding.props.isPrecise) {
        side = getEdgeFromNormalizedAnchor(
          Vec.RotWith(
            binding.props.normalizedAnchor,
            { x: 0.5, y: 0.5 },
            geometry.shapeToArrowTransform.rotation()
          )
        );
      }
      return {
        targetShapeId: binding.toId,
        isPoint: false,
        isExact: binding.props.isExact,
        bounds: geometry.bounds,
        geometry: geometry.geometry,
        target: targetPoint,
        arrowheadOffset,
        minEndSegmentLength,
        side,
        snap: binding.props.snap
      };
    }
  }
  return {
    targetShapeId: null,
    bounds: Box.FromCenter(point, { x: 0, y: 0 }),
    geometry: null,
    isExact: false,
    isPoint: true,
    target: Vec.From(point),
    arrowheadOffset: 0,
    minEndSegmentLength,
    side: null,
    snap: "none"
  };
}
function getBindingGeometryInArrowSpace(editor, arrow2, targetId, bindingProps) {
  const hasArrowhead = bindingProps.terminal === "start" ? arrow2.props.arrowheadStart !== "none" : arrow2.props.arrowheadEnd !== "none";
  const targetGeometryInTargetSpace = editor.getShapeGeometry(
    targetId,
    hasArrowhead ? void 0 : { context: "@tldraw/arrow-without-arrowhead" }
  );
  if (!targetGeometryInTargetSpace) {
    return null;
  }
  const arrowTransform = editor.getShapePageTransform(arrow2.id);
  const shapeTransform = editor.getShapePageTransform(targetId);
  const shapeToArrowTransform = arrowTransform.clone().invert().multiply(shapeTransform);
  const targetGeometryInArrowSpace = targetGeometryInTargetSpace.transform(shapeToArrowTransform);
  const center = { x: 0.5, y: 0.5 };
  const normalizedAnchor = bindingProps.isPrecise ? bindingProps.normalizedAnchor : center;
  const targetInShapeSpace = {
    x: lerp(
      targetGeometryInTargetSpace.bounds.minX,
      targetGeometryInTargetSpace.bounds.maxX,
      normalizedAnchor.x
    ),
    y: lerp(
      targetGeometryInTargetSpace.bounds.minY,
      targetGeometryInTargetSpace.bounds.maxY,
      normalizedAnchor.y
    )
  };
  const centerInShapeSpace = {
    x: lerp(
      targetGeometryInTargetSpace.bounds.minX,
      targetGeometryInTargetSpace.bounds.maxX,
      center.x
    ),
    y: lerp(
      targetGeometryInTargetSpace.bounds.minY,
      targetGeometryInTargetSpace.bounds.maxY,
      center.y
    )
  };
  const targetInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, targetInShapeSpace);
  const centerInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, centerInShapeSpace);
  return {
    bounds: targetGeometryInArrowSpace.bounds,
    geometry: targetGeometryInArrowSpace,
    target: targetInArrowSpace,
    center: centerInArrowSpace,
    shapeToArrowTransform
  };
}
const sideProps = {
  top: {
    expand: -1,
    main: "minY",
    opposite: "maxY",
    crossMid: "midX",
    crossMin: "minX",
    crossMax: "maxX",
    bRangeExpand: "max",
    crossAxis: "x"
  },
  bottom: {
    expand: 1,
    main: "maxY",
    opposite: "minY",
    crossMid: "midX",
    crossMin: "minX",
    crossMax: "maxX",
    bRangeExpand: "min",
    crossAxis: "x"
  },
  left: {
    expand: -1,
    main: "minX",
    opposite: "maxX",
    crossMid: "midY",
    crossMin: "minY",
    crossMax: "maxY",
    bRangeExpand: "max",
    crossAxis: "y"
  },
  right: {
    expand: 1,
    main: "maxX",
    opposite: "minX",
    crossMid: "midY",
    crossMin: "minY",
    crossMax: "maxY",
    bRangeExpand: "min",
    crossAxis: "y"
  }
};
function getUsableEdge(a, b, side, options) {
  const props = sideProps[side];
  const isSelfBoundAndShouldRouteExternal = a.targetShapeId === b.targetShapeId && a.targetShapeId !== null && (a.snap === "edge" || a.snap === "edge-point") && (b.snap === "edge" || b.snap === "edge-point");
  const aValue = a.bounds[props.main];
  const aExpanded = a.isPoint ? null : aValue + props.expand * options.expandElbowLegLength;
  const originalACrossRange = createRange(a.bounds[props.crossMin], a.bounds[props.crossMax]);
  let aCrossRange = originalACrossRange;
  if (!aCrossRange) {
    return null;
  }
  assert(originalACrossRange);
  const bRange = createRange(b.bounds[props.main], b.bounds[props.opposite]);
  if (!b.isPoint) {
    bRange[props.bRangeExpand] -= options.minElbowLegLength * 2 * props.expand;
  }
  const bCrossRange = expandRange(
    createRange(b.bounds[props.crossMin], b.bounds[props.crossMax]),
    options.expandElbowLegLength
  );
  assert(bRange && bCrossRange);
  let isPartial = false;
  if (isWithinRange(aValue, bRange) && !a.isPoint && !b.isPoint && !isSelfBoundAndShouldRouteExternal) {
    const subtracted = subtractRange(aCrossRange, bCrossRange);
    switch (subtracted.length) {
      case 0:
        return null;
      case 1:
        isPartial = subtracted[0] !== aCrossRange;
        aCrossRange = subtracted[0];
        break;
      case 2:
        isPartial = true;
        aCrossRange = rangeSize(subtracted[0]) > rangeSize(subtracted[1]) ? subtracted[0] : subtracted[1];
        break;
      default:
        exhaustiveSwitchError(subtracted);
    }
  }
  if (!isWithinRange(a.target[props.crossAxis], aCrossRange)) {
    return null;
  }
  const crossTarget = a.target[props.crossAxis];
  return {
    value: aValue,
    expanded: aExpanded,
    cross: aCrossRange,
    crossTarget,
    isPartial
  };
}
function hasUsableEdge(edges, side) {
  if (side === null) {
    return !!(edges.bottom || edges.left || edges.right || edges.top);
  }
  if (side === "x") {
    return !!edges.left || !!edges.right;
  }
  if (side === "y") {
    return !!edges.top || !!edges.bottom;
  }
  return !!edges[side];
}
function getSideToUse(binding, other, edges) {
  switch (binding.side) {
    case null:
      return null;
    case "x":
      if (binding.bounds.center.x > other.bounds.center.x && edges?.left) {
        return "left";
      } else if (edges?.right) {
        return "right";
      }
      return null;
    case "y":
      if (binding.bounds.center.y > other.bounds.center.y && edges?.top) {
        return "top";
      } else if (edges?.bottom) {
        return "bottom";
      }
      return null;
    default:
      return binding.side;
  }
}
function convertTerminalToPoint(terminal) {
  if (terminal.isPoint) return terminal;
  let side = null;
  let arrowheadOffset = 0;
  if (terminal.snap === "edge" || terminal.snap === "edge-point") {
    arrowheadOffset = terminal.arrowheadOffset;
    if (terminal.side === "x" || terminal.side === "left" || terminal.side === "right") {
      side = "x";
    }
    if (terminal.side === "y" || terminal.side === "top" || terminal.side === "bottom") {
      side = "y";
    }
  }
  return {
    targetShapeId: terminal.targetShapeId,
    side,
    bounds: new Box(terminal.target.x, terminal.target.y, 0, 0),
    geometry: terminal.geometry,
    target: terminal.target,
    arrowheadOffset,
    minEndSegmentLength: terminal.minEndSegmentLength,
    isExact: terminal.isExact,
    isPoint: true,
    snap: terminal.snap
  };
}
function castPathSegmentIntoGeometry(segment, target, other, route) {
  if (!target.geometry) return;
  const point1 = segment === "first" ? route.points[0] : route.points[route.points.length - 1];
  const point2 = segment === "first" ? route.points[1] : route.points[route.points.length - 2];
  const pointToFindClosestIntersectionTo = target.geometry.isClosed ? point2 : target.target;
  const initialDistance = Vec.ManhattanDist(point1, pointToFindClosestIntersectionTo);
  let nearestIntersectionToPoint2 = null;
  let nearestDistanceToPoint2 = Infinity;
  if (target.isExact) {
    nearestIntersectionToPoint2 = target.target;
  } else if (target.geometry) {
    const intersections = target.geometry.intersectLineSegment(point2, target.target, {
      includeLabels: false,
      includeInternal: false
    });
    if (target.geometry.hitTestPoint(
      target.target,
      Math.max(1, target.arrowheadOffset),
      true,
      Geometry2dFilters.EXCLUDE_NON_STANDARD
    )) {
      intersections.push(target.target);
    }
    for (const intersection of intersections) {
      const point2Distance = Vec.ManhattanDist(pointToFindClosestIntersectionTo, intersection);
      if (point2Distance < nearestDistanceToPoint2) {
        nearestDistanceToPoint2 = point2Distance;
        nearestIntersectionToPoint2 = intersection;
      }
    }
  }
  if (nearestIntersectionToPoint2) {
    let offset2 = target.arrowheadOffset;
    const currentFinalSegmentLength = Vec.ManhattanDist(point2, nearestIntersectionToPoint2);
    const minLength = target.arrowheadOffset * 2;
    if (currentFinalSegmentLength < minLength) {
      const targetLength = minLength - target.arrowheadOffset;
      offset2 = currentFinalSegmentLength - targetLength;
    }
    if (offset2 < target.minEndSegmentLength) {
      if (target.geometry.bounds.containsPoint(other.target)) {
        offset2 = Math.max(0, offset2);
      } else {
        offset2 = -target.arrowheadOffset;
      }
    }
    let nudgedPoint = nearestIntersectionToPoint2;
    let shouldAddExtraPointForNudge = false;
    if (!target.isExact && offset2 !== 0) {
      const nudged = Vec.Nudge(nearestIntersectionToPoint2, point2, offset2);
      nudgedPoint = nudged;
      if (offset2 < 0 && !target.geometry.hitTestPoint(nudged, 0, true, Geometry2dFilters.EXCLUDE_NON_STANDARD)) {
        nudgedPoint = nearestIntersectionToPoint2;
      } else {
        if (offset2 < 0) {
          shouldAddExtraPointForNudge = true;
        }
        nudgedPoint = nudged;
      }
    }
    const newDistance = Vec.ManhattanDist(point2, nudgedPoint);
    route.distance += newDistance - initialDistance;
    point1.x = nudgedPoint.x;
    point1.y = nudgedPoint.y;
    if (shouldAddExtraPointForNudge) {
      const midPoint = Vec.Lrp(point2, point1, 0.5);
      route.skipPointsWhenDrawing.add(midPoint);
      route.points.splice(segment === "first" ? 1 : route.points.length - 1, 0, midPoint);
    }
  }
}
function fixTinyEndNubs(route, aTerminal, bTerminal) {
  if (!route) return;
  if (route.points.length >= 3) {
    const a = route.points[0];
    const b = route.points[1];
    const firstSegmentLength = Vec.ManhattanDist(a, b);
    if (firstSegmentLength < aTerminal.minEndSegmentLength) {
      route.points.splice(1, 1);
      if (route.points.length >= 3) {
        const matchAxis = approximately(a.x, b.x) ? "y" : "x";
        route.points[1][matchAxis] = a[matchAxis];
      }
    }
  }
  if (route.points.length >= 3) {
    const a = route.points[route.points.length - 1];
    const b = route.points[route.points.length - 2];
    const lastSegmentLength = Vec.ManhattanDist(a, b);
    if (lastSegmentLength < bTerminal.minEndSegmentLength) {
      route.points.splice(route.points.length - 2, 1);
      if (route.points.length >= 3) {
        const matchAxis = approximately(a.x, b.x) ? "y" : "x";
        route.points[route.points.length - 2][matchAxis] = a[matchAxis];
      }
    }
  }
}
function adjustTerminalForUnclosedPathIfNeeded(terminal, otherTerminal, options) {
  if (!terminal.geometry || terminal.geometry.isClosed) return terminal;
  const normalizedPointAlongPath = terminal.geometry.uninterpolateAlongEdge(
    terminal.target,
    Geometry2dFilters.EXCLUDE_NON_STANDARD
  );
  const prev = terminal.geometry.interpolateAlongEdge(
    normalizedPointAlongPath - 0.01 / terminal.geometry.length
  );
  const next = terminal.geometry.interpolateAlongEdge(
    normalizedPointAlongPath + 0.01 / terminal.geometry.length
  );
  const normal = next.sub(prev).per().uni();
  const axis = Math.abs(normal.x) > Math.abs(normal.y) ? ElbowArrowAxes.x : ElbowArrowAxes.y;
  if (terminal.geometry.bounds.containsPoint(otherTerminal.target, options.expandElbowLegLength)) {
    terminal.side = axis.self;
    return convertTerminalToPoint(terminal);
  }
  const min2 = axis.v(
    terminal.target[axis.self] - terminal.bounds[axis.size] * 2,
    terminal.target[axis.cross]
  );
  const max2 = axis.v(
    terminal.target[axis.self] + terminal.bounds[axis.size] * 2,
    terminal.target[axis.cross]
  );
  let furthestIntersectionTowardsMin = null;
  let furthestIntersectionTowardsMinDistance = 0;
  let furthestIntersectionTowardsMax = null;
  let furthestIntersectionTowardsMaxDistance = 0;
  let side = axis.self;
  for (const intersection of terminal.geometry.intersectLineSegment(
    min2,
    max2,
    Geometry2dFilters.EXCLUDE_NON_STANDARD
  )) {
    if (Math.abs(intersection[axis.self] - terminal.target[axis.self]) < 1) {
      continue;
    }
    if (intersection[axis.self] < terminal.target[axis.self]) {
      if (Vec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMinDistance) {
        furthestIntersectionTowardsMinDistance = Vec.ManhattanDist(intersection, terminal.target);
        furthestIntersectionTowardsMin = intersection;
      }
    } else {
      if (Vec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMaxDistance) {
        furthestIntersectionTowardsMaxDistance = Vec.ManhattanDist(intersection, terminal.target);
        furthestIntersectionTowardsMax = intersection;
      }
    }
  }
  if (furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {
    if (furthestIntersectionTowardsMinDistance > furthestIntersectionTowardsMaxDistance) {
      side = axis.hiEdge;
    } else {
      side = axis.loEdge;
    }
  } else if (furthestIntersectionTowardsMin && !furthestIntersectionTowardsMax) {
    side = axis.hiEdge;
  } else if (!furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {
    side = axis.loEdge;
  }
  terminal.side = side;
  return terminal;
}
const MIN_ARROW_BEND = 8;
function getIsArrowStraight(shape) {
  if (shape.props.kind !== "arc") return false;
  return Math.abs(shape.props.bend) < MIN_ARROW_BEND * shape.props.scale;
}
function getBoundShapeInfoForTerminal(editor, arrow2, terminalName) {
  const binding = editor.getBindingsFromShape(arrow2, "arrow").find((b) => b.props.terminal === terminalName);
  if (!binding) return;
  const boundShape = editor.getShape(binding.toId);
  if (!boundShape) return;
  const transform = editor.getShapePageTransform(boundShape);
  const hasArrowhead = terminalName === "start" ? arrow2.props.arrowheadStart !== "none" : arrow2.props.arrowheadEnd !== "none";
  const geometry = editor.getShapeGeometry(
    boundShape,
    hasArrowhead ? void 0 : { context: "@tldraw/arrow-without-arrowhead" }
  );
  return {
    shape: boundShape,
    transform,
    isClosed: geometry.isClosed,
    isExact: binding.props.isExact,
    didIntersect: false,
    geometry
  };
}
function getArrowTerminalInArrowSpace(editor, arrowPageTransform, binding, forceImprecise) {
  const boundShape = editor.getShape(binding.toId);
  if (!boundShape) {
    return new Vec(0, 0);
  } else {
    const { point, size: size2 } = editor.getShapeGeometry(boundShape).bounds;
    const shapePoint = Vec.Add(
      point,
      Vec.MulV(
        // if the parent is the bound shape, then it's ALWAYS precise
        binding.props.isPrecise || forceImprecise ? binding.props.normalizedAnchor : { x: 0.5, y: 0.5 },
        size2
      )
    );
    const pagePoint = Mat.applyToPoint(editor.getShapePageTransform(boundShape), shapePoint);
    const arrowPoint = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pagePoint);
    return arrowPoint;
  }
}
const arrowBindingsCache = createComputedCache(
  "arrow bindings",
  (editor, arrow2) => {
    const bindings = editor.getBindingsFromShape(arrow2.id, "arrow");
    return {
      start: bindings.find((b) => b.props.terminal === "start"),
      end: bindings.find((b) => b.props.terminal === "end")
    };
  },
  {
    // we only look at the arrow IDs:
    areRecordsEqual: (a, b) => a.id === b.id,
    // the records should stay the same:
    areResultsEqual: (a, b) => a.start === b.start && a.end === b.end
  }
);
function getArrowBindings(editor, shape) {
  return arrowBindingsCache.get(editor, shape.id);
}
const arrowInfoCache = createComputedCache(
  "arrow info",
  (editor, shape) => {
    const bindings = getArrowBindings(editor, shape);
    if (shape.props.kind === "elbow") {
      const elbowInfo = getElbowArrowInfo(editor, shape, bindings);
      if (!elbowInfo?.route) return getStraightArrowInfo(editor, shape, bindings);
      const start = elbowInfo.swapOrder ? elbowInfo.B : elbowInfo.A;
      const end = elbowInfo.swapOrder ? elbowInfo.A : elbowInfo.B;
      return {
        type: "elbow",
        bindings,
        start: {
          handle: start.target,
          point: elbowInfo.route.points[0],
          arrowhead: shape.props.arrowheadStart
        },
        end: {
          handle: end.target,
          point: elbowInfo.route.points[elbowInfo.route.points.length - 1],
          arrowhead: shape.props.arrowheadEnd
        },
        elbow: elbowInfo,
        route: elbowInfo.route,
        isValid: true
      };
    }
    if (getIsArrowStraight(shape)) {
      return getStraightArrowInfo(editor, shape, bindings);
    } else {
      return getCurvedArrowInfo(editor, shape, bindings);
    }
  },
  {
    areRecordsEqual: (a, b) => a.props === b.props,
    areResultsEqual: isEqualAllowingForFloatingPointErrors
  }
);
function getArrowInfo(editor, shape) {
  const id = typeof shape === "string" ? shape : shape.id;
  return arrowInfoCache.get(editor, id);
}
function getArrowTerminalsInArrowSpace(editor, shape, bindings) {
  const arrowPageTransform = editor.getShapePageTransform(shape);
  const boundShapeRelationships = getBoundShapeRelationships(
    editor,
    bindings.start?.toId,
    bindings.end?.toId
  );
  const start = bindings.start ? getArrowTerminalInArrowSpace(
    editor,
    arrowPageTransform,
    bindings.start,
    boundShapeRelationships === "double-bound" || boundShapeRelationships === "start-contains-end"
  ) : Vec.From(shape.props.start);
  const end = bindings.end ? getArrowTerminalInArrowSpace(
    editor,
    arrowPageTransform,
    bindings.end,
    boundShapeRelationships === "double-bound" || boundShapeRelationships === "end-contains-start"
  ) : Vec.From(shape.props.end);
  return { start, end };
}
function createOrUpdateArrowBinding(editor, arrow2, target, props) {
  const arrowId = typeof arrow2 === "string" ? arrow2 : arrow2.id;
  const targetId = typeof target === "string" ? target : target.id;
  const existingMany = editor.getBindingsFromShape(arrowId, "arrow").filter((b) => b.props.terminal === props.terminal);
  if (existingMany.length > 1) {
    editor.deleteBindings(existingMany.slice(1));
  }
  const existing = existingMany[0];
  if (existing) {
    editor.updateBinding({
      ...existing,
      toId: targetId,
      props
    });
  } else {
    editor.createBinding({
      type: "arrow",
      fromId: arrowId,
      toId: targetId,
      props
    });
  }
}
function removeArrowBinding(editor, arrow2, terminal) {
  const existing = editor.getBindingsFromShape(arrow2, "arrow").filter((b) => b.props.terminal === terminal);
  editor.deleteBindings(existing);
}
const MIN_ARROW_LENGTH = 10;
const BOUND_ARROW_OFFSET = 10;
const WAY_TOO_BIG_ARROW_BEND_FACTOR = 10;
const STROKE_SIZES$1 = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
function getBoundShapeRelationships(editor, startShapeId, endShapeId) {
  if (!startShapeId || !endShapeId) return "safe";
  if (startShapeId === endShapeId) return "double-bound";
  const startBounds = editor.getShapePageBounds(startShapeId);
  const endBounds = editor.getShapePageBounds(endShapeId);
  if (startBounds && endBounds) {
    if (startBounds.contains(endBounds)) return "start-contains-end";
    if (endBounds.contains(startBounds)) return "end-contains-start";
  }
  return "safe";
}
function shapesWithUnboundArrows(editor) {
  const selectedShapeIds = editor.getSelectedShapeIds();
  const selectedShapes = selectedShapeIds.map((id) => {
    return editor.getShape(id);
  });
  return selectedShapes.filter((shape) => {
    if (!shape) return false;
    if (editor.isShapeOfType(shape, "arrow")) {
      const bindings = getArrowBindings(editor, shape);
      if (bindings.start || bindings.end) return false;
    }
    return true;
  });
}
const useThreeStackableItems = () => {
  const editor = useEditor();
  return useValue("threeStackableItems", () => shapesWithUnboundArrows(editor).length > 2, [editor]);
};
const useIsInSelectState = () => {
  const editor = useEditor();
  return useValue("isInSelectState", () => editor.isIn("select"), [editor]);
};
const useAllowGroup = () => {
  const editor = useEditor();
  return useValue(
    "allow group",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      if (selectedShapes.length < 2) return false;
      for (const shape of selectedShapes) {
        if (editor.isShapeOfType(shape, "arrow")) {
          const bindings = getArrowBindings(editor, shape);
          if (bindings.start) {
            if (!selectedShapes.some((s) => s.id === bindings.start.toId)) {
              return false;
            }
          }
          if (bindings.end) {
            if (!selectedShapes.some((s) => s.id === bindings.end.toId)) {
              return false;
            }
          }
        }
      }
      return true;
    },
    [editor]
  );
};
const useAllowUngroup = () => {
  const editor = useEditor();
  return useValue(
    "allowUngroup",
    () => editor.getSelectedShapeIds().some((id) => editor.getShape(id)?.type === "group"),
    [editor]
  );
};
const showMenuPaste = typeof window !== "undefined" && "navigator" in window && Boolean(navigator.clipboard) && Boolean(navigator.clipboard.read);
function useAnySelectedShapesCount(min2, max2) {
  const editor = useEditor();
  return useValue(
    "selectedShapes",
    () => {
      const len = editor.getSelectedShapes().length;
      {
        {
          return len >= min2;
        }
      }
    },
    [editor, min2, max2]
  );
}
function useUnlockedSelectedShapesCount(min2, max2) {
  const editor = useEditor();
  return useValue(
    "selectedShapes",
    () => {
      const len = editor.getSelectedShapes().filter((s) => !editor.isShapeOrAncestorLocked(s)).length;
      if (min2 === void 0) {
        {
          return len;
        }
      } else {
        {
          return len >= min2;
        }
      }
    },
    [editor]
  );
}
function useShowAutoSizeToggle() {
  const editor = useEditor();
  return useValue(
    "showAutoSizeToggle",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      return selectedShapes.length === 1 && editor.isShapeOfType(selectedShapes[0], "text") && selectedShapes[0].props.autoSize === false;
    },
    [editor]
  );
}
function useHasLinkShapeSelected() {
  const editor = useEditor();
  return useValue(
    "hasLinkShapeSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      return !!(onlySelectedShape && onlySelectedShape.type !== "embed" && "url" in onlySelectedShape.props && !onlySelectedShape.isLocked);
    },
    [editor]
  );
}
function useOnlyFlippableShape() {
  const editor = useEditor();
  return useValue(
    "onlyFlippableShape",
    () => {
      const shape = editor.getOnlySelectedShape();
      return shape && (editor.isShapeOfType(shape, "group") || editor.isShapeOfType(shape, "image") || editor.isShapeOfType(shape, "arrow") || editor.isShapeOfType(shape, "line") || editor.isShapeOfType(shape, "draw"));
    },
    [editor]
  );
}
function useCanRedo() {
  const editor = useEditor();
  return useValue("useCanRedo", () => editor.getCanRedo(), [editor]);
}
function useCanUndo() {
  const editor = useEditor();
  return useValue("useCanUndo", () => editor.getCanUndo(), [editor]);
}
function DefaultActionsMenuContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AlignMenuItems, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DistributeMenuItems, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StackMenuItems, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ReorderMenuItems, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomOrRotateMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCWMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EditLinkMenuItem$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(GroupOrUngroupMenuItem, {})
  ] });
}
function AlignMenuItems() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const isInSelectState = useIsInSelectState();
  const enabled = twoSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-left", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-horizontal", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-right", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stretch-horizontal", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-top", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-vertical", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-bottom", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stretch-vertical", disabled: !enabled })
  ] });
}
function DistributeMenuItems() {
  const threeSelected = useUnlockedSelectedShapesCount(3);
  const isInSelectState = useIsInSelectState();
  const enabled = threeSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "distribute-horizontal", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "distribute-vertical", disabled: !enabled })
  ] });
}
function StackMenuItems() {
  const threeStackableItems = useThreeStackableItems();
  const isInSelectState = useIsInSelectState();
  const enabled = threeStackableItems && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stack-horizontal", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stack-vertical", disabled: !enabled })
  ] });
}
function ReorderMenuItems() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-to-back", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-backward", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-forward", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-to-front", disabled: !enabled })
  ] });
}
function ZoomOrRotateMenuItem() {
  const breakpoint = useBreakpoint();
  return breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM ? /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomTo100MenuItem$1, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCCWMenuItem, {});
}
function ZoomTo100MenuItem$1() {
  const editor = useEditor();
  const isZoomedTo100 = useValue("zoom is 1", () => editor.getZoomLevel() === 1, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-to-100", disabled: isZoomedTo100 });
}
function RotateCCWMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "rotate-ccw", disabled: !enabled });
}
function RotateCWMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "rotate-cw", disabled: !enabled });
}
function EditLinkMenuItem$1() {
  const showEditLink = useHasLinkShapeSelected();
  const isInSelectState = useIsInSelectState();
  const enabled = showEditLink && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "edit-link", disabled: !enabled });
}
function GroupOrUngroupMenuItem() {
  const allowGroup = useAllowGroup();
  const allowUngroup = useAllowUngroup();
  return allowGroup ? /* @__PURE__ */ jsxRuntimeExports.jsx(GroupMenuItem$1, {}) : allowUngroup ? /* @__PURE__ */ jsxRuntimeExports.jsx(UngroupMenuItem$1, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(GroupMenuItem$1, {});
}
function GroupMenuItem$1() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const isInSelectState = useIsInSelectState();
  const enabled = twoSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "group", disabled: !enabled });
}
function UngroupMenuItem$1() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "ungroup" });
}
const DefaultActionsMenu = reactExports.memo(function DefaultActionsMenu2({
  children
}) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const { orientation } = useTldrawUiOrientation();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const editor = useEditor();
  const isInAcceptableReadonlyState = useValue(
    "should display quick actions when in readonly",
    () => editor.isInAny("hand", "zoom"),
    [editor]
  );
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultActionsMenuContent, {});
  if (isReadonlyMode && !isInAcceptableReadonlyState) return;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: "actions-menu", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiToolbarButton,
      {
        type: "icon",
        "data-testid": "actions-menu.button",
        title: msg2("actions-menu.title"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButtonIcon,
          {
            icon: orientation === "horizontal" ? "dots-vertical" : "dots-horizontal",
            small: true
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiPopoverContent,
      {
        side: orientation === "horizontal" ? breakpoint >= PORTRAIT_BREAKPOINT.TABLET ? "bottom" : "top" : "right",
        sideOffset: 6,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiToolbar,
          {
            ref,
            label: msg2("actions-menu.title"),
            className: "tlui-actions-menu",
            "data-testid": "actions-menu.content",
            orientation: "grid",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "icons", sourceId: "actions-menu", children: content })
          }
        )
      }
    )
  ] });
});
function DefaultContextMenuContent() {
  const editor = useEditor();
  const showCollaborationUi = useShowCollaborationUi();
  const selectToolActive = useValue(
    "isSelectToolActive",
    () => editor.getCurrentToolId() === "select",
    [editor]
  );
  const isSinglePageMode = useValue("isSinglePageMode", () => editor.options.maxPages <= 1, [
    editor
  ]);
  if (!selectToolActive) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    showCollaborationUi && /* @__PURE__ */ jsxRuntimeExports.jsx(CursorChatItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "modify", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(EditMenuSubmenu, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ArrangeMenuSubmenu, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReorderMenuSubmenu, {}),
      !isSinglePageMode && /* @__PURE__ */ jsxRuntimeExports.jsx(MoveToPageMenu, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConversionsMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "select-all", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectAllMenuItem, {}) })
  ] });
}
const DefaultContextMenu = reactExports.memo(function DefaultContextMenu2({
  children,
  disabled = false
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const { Canvas } = useEditorComponents();
  const preventEscapeFromLosingShapeFocus = reactExports.useCallback(
    (e) => {
      if (e.key === "Escape") {
        e.stopPropagation();
        editor.getContainer().focus();
      }
    },
    [editor]
  );
  reactExports.useEffect(() => {
    return () => {
      document.body.removeEventListener("keydown", preventEscapeFromLosingShapeFocus, {
        capture: true
      });
    };
  }, [preventEscapeFromLosingShapeFocus]);
  const cb = reactExports.useCallback(
    (isOpen2) => {
      if (!isOpen2) {
        const onlySelectedShape = editor.getOnlySelectedShape();
        if (onlySelectedShape && editor.isShapeOrAncestorLocked(onlySelectedShape)) {
          editor.setSelectedShapes([]);
        }
        editor.timers.requestAnimationFrame(() => {
          document.body.removeEventListener("keydown", preventEscapeFromLosingShapeFocus, {
            capture: true
          });
        });
      } else {
        document.body.addEventListener("keydown", preventEscapeFromLosingShapeFocus, {
          capture: true
        });
        if (editor.getInstanceState().isCoarsePointer) {
          const selectedShapes = editor.getSelectedShapes();
          const {
            inputs: { currentPagePoint }
          } = editor;
          const shapesAtPoint = editor.getShapesAtPoint(currentPagePoint);
          if (
            // if there are no selected shapes
            !editor.getSelectedShapes().length || // OR if none of the shapes at the point include the selected shape
            !shapesAtPoint.some((s) => selectedShapes.includes(s))
          ) {
            const lockedShapes = shapesAtPoint.filter((s) => editor.isShapeOrAncestorLocked(s));
            if (lockedShapes.length) {
              editor.select(...lockedShapes.map((s) => s.id));
            }
          }
        }
      }
    },
    [editor, preventEscapeFromLosingShapeFocus]
  );
  const container = useContainer();
  const [isOpen, handleOpenChange] = useMenuIsOpen("context menu", cb);
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultContextMenuContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$4, { dir: "ltr", onOpenChange: handleOpenChange, modal: false, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$3, { onContextMenu: void 0, dir: "ltr", disabled, children: Canvas ? /* @__PURE__ */ jsxRuntimeExports.jsx(Canvas, {}) : null }),
    isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2$1, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$3,
      {
        className: "tlui-menu tlui-scrollable",
        "data-testid": "context-menu",
        "aria-label": msg2("context-menu.title"),
        alignOffset: -4,
        collisionPadding: 4,
        onContextMenu: preventDefault,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "context-menu", sourceId: "context-menu", children: content })
      }
    ) })
  ] });
});
const CHAT_MESSAGE_TIMEOUT_CLOSING = 2e3;
const CHAT_MESSAGE_TIMEOUT_CHATTING = 5e3;
const CursorChatBubble = track(function CursorChatBubble2() {
  const editor = useEditor();
  const { isChatting, chatMessage } = editor.getInstanceState();
  const rTimeout = reactExports.useRef(-1);
  const [value, setValue] = reactExports.useState("");
  reactExports.useEffect(() => {
    const closingUp = !isChatting && chatMessage;
    if (closingUp || isChatting) {
      const duration = isChatting ? CHAT_MESSAGE_TIMEOUT_CHATTING : CHAT_MESSAGE_TIMEOUT_CLOSING;
      rTimeout.current = editor.timers.setTimeout(() => {
        editor.updateInstanceState({ chatMessage: "", isChatting: false });
        setValue("");
        editor.focus();
      }, duration);
    }
    return () => {
      clearTimeout(rTimeout.current);
    };
  }, [editor, chatMessage, isChatting]);
  if (isChatting)
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CursorChatInput, { value, setValue, chatMessage });
  return chatMessage.trim() ? /* @__PURE__ */ jsxRuntimeExports.jsx(NotEditingChatMessage, { chatMessage }) : null;
});
function usePositionBubble(ref) {
  const editor = useEditor();
  reactExports.useLayoutEffect(() => {
    const elm = ref.current;
    if (!elm) return;
    const { x, y } = editor.inputs.currentScreenPoint;
    ref.current?.style.setProperty("transform", `translate(${x}px, ${y}px)`);
    function positionChatBubble(e) {
      const { minX, minY } = editor.getViewportScreenBounds();
      ref.current?.style.setProperty(
        "transform",
        `translate(${e.clientX - minX}px, ${e.clientY - minY}px)`
      );
    }
    window.addEventListener("pointermove", positionChatBubble);
    return () => {
      window.removeEventListener("pointermove", positionChatBubble);
    };
  }, [ref, editor]);
}
const NotEditingChatMessage = ({ chatMessage }) => {
  const editor = useEditor();
  const ref = reactExports.useRef(null);
  usePositionBubble(ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: "tl-cursor-chat tl-cursor-chat__bubble",
      style: { backgroundColor: editor.user.getColor() },
      children: chatMessage
    }
  );
};
const CursorChatInput = track(function CursorChatInput2({
  chatMessage,
  value,
  setValue
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const ref = reactExports.useRef(null);
  const placeholder = chatMessage || msg2("cursor-chat.type-to-chat");
  usePositionBubble(ref);
  reactExports.useLayoutEffect(() => {
    const elm = ref.current;
    if (!elm) return;
    const textMeasurement = editor.textMeasure.measureText(value || placeholder, {
      fontFamily: "var(--font-body)",
      fontSize: 12,
      fontWeight: "500",
      fontStyle: "normal",
      maxWidth: null,
      lineHeight: 1,
      padding: "6px"
    });
    elm.style.setProperty("width", textMeasurement.w + "px");
  }, [editor, value, placeholder]);
  reactExports.useLayoutEffect(() => {
    const raf = editor.timers.requestAnimationFrame(() => {
      ref.current?.focus();
    });
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [editor]);
  const stopChatting = reactExports.useCallback(() => {
    editor.updateInstanceState({ isChatting: false });
    editor.focus();
  }, [editor]);
  const handleChange = reactExports.useCallback(
    (e) => {
      const { value: value2 } = e.target;
      setValue(value2.slice(0, 64));
      editor.updateInstanceState({ chatMessage: value2 });
    },
    [editor, setValue]
  );
  const handleKeyDown2 = reactExports.useCallback(
    (e) => {
      const elm = ref.current;
      if (!elm) return;
      const { value: currentValue } = elm;
      switch (e.key) {
        case "Enter": {
          preventDefault(e);
          e.stopPropagation();
          if (!currentValue) {
            stopChatting();
            return;
          }
          setValue("");
          break;
        }
        case "Escape": {
          preventDefault(e);
          e.stopPropagation();
          stopChatting();
          break;
        }
      }
    },
    [stopChatting, setValue]
  );
  const handlePaste = reactExports.useCallback((e) => {
    e.stopPropagation();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      ref,
      className: `tl-cursor-chat`,
      style: { backgroundColor: editor.user.getColor() },
      onBlur: stopChatting,
      onChange: handleChange,
      onKeyDown: handleKeyDown2,
      onPaste: handlePaste,
      value,
      placeholder,
      spellCheck: false
    }
  );
});
function TldrawUiButtonCheck({ checked }) {
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiIcon,
    {
      "data-checked": !!checked,
      label: msg2(checked ? "ui.checked" : "ui.unchecked"),
      icon: checked ? "check" : "none",
      className: "tlui-button__icon",
      small: true
    }
  );
}
function TldrawUiMenuCheckboxItem({
  id,
  kbd: kbd2,
  label,
  lang,
  readonlyOk,
  onSelect,
  toggle = false,
  disabled = false,
  checked = false
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const isReadonlyMode = useReadonly();
  const msg2 = useTranslation();
  if (isReadonlyMode && !readonlyOk) return null;
  const labelToUse = unwrapLabel(label, menuType);
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menuType) {
    case "menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CheckboxItem2,
        {
          dir: "ltr",
          lang,
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          title: labelStr,
          onSelect: (e) => {
            onSelect?.(sourceId);
            preventDefault(e);
          },
          disabled,
          checked,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TldrawUiIcon,
              {
                small: true,
                label: msg2(checked ? "ui.checked" : "ui.unchecked"),
                icon: toggle ? checked ? "toggle-on" : "toggle-off" : checked ? "check" : "none"
              }
            ),
            labelStr && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            kbd2 && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiKbd, { children: kbd2 })
          ]
        }
      );
    }
    case "context-menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CheckboxItem2$1,
        {
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          dir: "ltr",
          lang,
          title: labelStr,
          onSelect: (e) => {
            onSelect(sourceId);
            preventDefault(e);
          },
          disabled,
          checked,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TldrawUiIcon,
              {
                small: true,
                label: msg2(checked ? "ui.checked" : "ui.unchecked"),
                icon: toggle ? checked ? "toggle-on" : "toggle-off" : checked ? "check" : "none"
              }
            ),
            labelStr && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            kbd2 && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiKbd, { children: kbd2 })
          ]
        },
        id
      );
    }
    default: {
      return null;
    }
  }
}
function TldrawUiMenuSubmenu({
  id,
  disabled = false,
  label,
  size: size2 = "small",
  children
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const container = useContainer();
  const msg2 = useTranslation();
  const labelToUse = label ? typeof label === "string" ? label : label[menuType] ?? label["default"] : void 0;
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menuType) {
    case "menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDropdownMenuSub, { id: `${sourceId}-sub.${id}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiDropdownMenuSubTrigger,
          {
            id: `${sourceId}-sub.${id}-button`,
            disabled,
            label: labelStr,
            title: labelStr
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuSubContent, { id: `${sourceId}-sub.${id}-content`, size: size2, children })
      ] });
    }
    case "context-menu": {
      if (disabled) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ContextMenuSubWithMenu, { id: `${sourceId}-sub.${id}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ContextMenuSubTrigger, { dir: "ltr", disabled, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          TldrawUiButton,
          {
            "data-testid": `${sourceId}-sub.${id}-button`,
            type: "menu",
            className: "tlui-menu__submenu__trigger",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: labelStr }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "chevron-right", small: true })
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ContextMenuPortal, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ContextMenuSubContent,
          {
            "data-testid": `${sourceId}-sub.${id}-content`,
            className: "tlui-menu tlui-menu__submenu__content",
            alignOffset: -1,
            sideOffset: -4,
            collisionPadding: 4,
            "data-size": size2,
            children
          }
        ) })
      ] });
    }
    default: {
      return children;
    }
  }
}
function ContextMenuSubWithMenu({ id, children }) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ContextMenuSub, { open, onOpenChange, children });
}
function DefaultDebugMenuContent({
  customDebugFlags,
  customFeatureFlags
}) {
  const editor = useEditor();
  const { addToast } = useToasts();
  const { addDialog } = useDialogs();
  const [error, setError] = React.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "items", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { id: "hard-reset", onSelect: hardResetEditor, label: "Hard reset" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "add-toast",
          onSelect: () => {
            addToast({
              id: uniqueId(),
              title: "Something good happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "success"
            });
            addToast({
              id: uniqueId(),
              title: "Something happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "info",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            });
            addToast({
              id: uniqueId(),
              title: "Something maybe bad happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "warning",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            });
            addToast({
              id: uniqueId(),
              title: "Something bad happened",
              severity: "error",
              keepOpen: true
            });
          },
          label: untranslated("Show toast")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "show-dialog",
          label: "Show dialog",
          onSelect: () => {
            addDialog({
              component: ({ onClose }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                ExampleDialog,
                {
                  displayDontShowAgain: true,
                  onCancel: () => onClose(),
                  onContinue: () => onClose()
                }
              ),
              onClose: () => {
              }
            });
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "create-shapes",
          label: "Create 100 shapes",
          onSelect: () => createNShapes(editor, 100)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "count-nodes",
          label: "Count shapes / nodes",
          onSelect: () => {
            const selectedShapes = editor.getSelectedShapes();
            const shapes = selectedShapes.length === 0 ? editor.getRenderingShapes() : selectedShapes;
            window.alert(
              `Shapes ${shapes.length}, DOM nodes:${document.querySelector(".tl-shapes").querySelectorAll("*")?.length}`
            );
          }
        }
      ),
      (() => {
        if (error) throw Error("oh no!");
        return null;
      })(),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { id: "throw-error", onSelect: () => setError(true), label: "Throw error" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "flags", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DebugFlags, { customDebugFlags }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureFlags, { customFeatureFlags })
    ] })
  ] });
}
function DebugFlags(props) {
  const items = Object.values(props.customDebugFlags ?? debugFlags);
  if (!items.length) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "debug flags", label: "Debug flags", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "debug flags", children: items.map((flag) => /* @__PURE__ */ jsxRuntimeExports.jsx(DebugFlagToggle, { flag }, flag.name)) }) });
}
function FeatureFlags(props) {
  const items = Object.values(props.customFeatureFlags ?? featureFlags);
  if (!items.length) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "feature flags", label: "Feature flags", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "feature flags", children: items.map((flag) => /* @__PURE__ */ jsxRuntimeExports.jsx(DebugFlagToggle, { flag }, flag.name)) }) });
}
function ExampleDialog({
  title = "title",
  body = "hello hello hello",
  cancel = "Cancel",
  confirm = "Continue",
  displayDontShowAgain = false,
  maxWidth = "350",
  onCancel,
  onContinue
}) {
  const [dontShowAgain, setDontShowAgain] = React.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogTitle, { children: title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogCloseButton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogBody, { style: { maxWidth }, children: body }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
      displayDontShowAgain && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TldrawUiButton,
        {
          type: "normal",
          onClick: () => setDontShowAgain(!dontShowAgain),
          style: { marginRight: "auto" },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonCheck, { checked: dontShowAgain }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: "Dont show again" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "normal", onClick: onCancel, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: cancel }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "primary", onClick: async () => onContinue(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: confirm }) })
    ] })
  ] });
}
const DebugFlagToggle = track(function DebugFlagToggle2({
  flag,
  onChange
}) {
  const value = flag.get();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuCheckboxItem,
    {
      id: flag.name,
      title: flag.name,
      label: flag.name.replace(/([a-z0-9])([A-Z])/g, (m) => `${m[0]} ${m[1].toLowerCase()}`).replace(/^[a-z]/, (m) => m.toUpperCase()),
      checked: value,
      onSelect: () => {
        flag.set(!value);
        onChange?.(!value);
      }
    }
  );
});
let t = 0;
function createNShapes(editor, n) {
  const gap = editor.options.adjacentShapeMargin;
  const shapesToCreate = Array(n);
  const cols = Math.floor(Math.sqrt(n));
  for (let i = 0; i < n; i++) {
    t++;
    shapesToCreate[i] = {
      id: createShapeId("box" + t),
      type: "geo",
      x: i % cols * (100 + gap),
      y: Math.floor(i / cols) * (100 + gap)
    };
  }
  editor.run(() => {
    editor.createShapes(shapesToCreate).setSelectedShapes(shapesToCreate.map((s) => s.id));
  });
}
function DefaultDebugMenu({ children }) {
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultDebugMenuContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDropdownMenuRoot, { id: "debug", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "icon", title: "Debug menu", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "dots-horizontal" }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuContent, { side: "top", align: "end", alignOffset: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "menu", sourceId: "debug-panel", children: content }) })
  ] });
}
const DefaultDebugPanel = reactExports.memo(function DefaultDebugPanel2() {
  const { DebugMenu } = useTldrawUiComponents();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { ref, className: "tlui-debug-panel", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CurrentState, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FPS, {}),
    DebugMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(DebugMenu, {})
  ] });
});
function useTick(isEnabled = true) {
  const [_, setTick] = reactExports.useState(0);
  const editor = useEditor();
  reactExports.useEffect(() => {
    if (!isEnabled) return;
    const update = () => setTick((tick2) => tick2 + 1);
    editor.on("tick", update);
    return () => {
      editor.off("tick", update);
    };
  }, [editor, isEnabled]);
}
const CurrentState = track(function CurrentState2() {
  useTick();
  const editor = useEditor();
  const path = editor.getPath();
  const hoverShape = editor.getHoveredShape();
  const selectedShape = editor.getOnlySelectedShape();
  const shape = path === "select.idle" || !path.includes("select.") ? hoverShape : selectedShape;
  const shapeInfo = shape && path.includes("select.") ? ` / ${shape.type || ""}${"geo" in shape.props ? " / " + shape.props.geo : ""} / [${Vec.ToInt(editor.getPointInShapeSpace(shape, editor.inputs.currentPagePoint))}]` : "";
  const ruler = path.startsWith("select.") && !path.includes(".idle") ? ` / [${Vec.ToInt(editor.inputs.originPagePoint)}]  [${Vec.ToInt(
    editor.inputs.currentPagePoint
  )}] = ${Vec.Dist(editor.inputs.originPagePoint, editor.inputs.currentPagePoint).toFixed(0)}` : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-debug-panel__current-state", children: `${path}${shapeInfo}${ruler}` });
});
function FPS() {
  const editor = useEditor();
  const showFps = useValue("show_fps", () => debugFlags.showFps.get(), [debugFlags]);
  const fpsRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!showFps) return;
    const TICK_LENGTH = 250;
    let maxKnownFps = 0;
    let raf = -1;
    let start = performance.now();
    let currentTickLength = 0;
    let framesInCurrentTick = 0;
    let isSlow = false;
    function loop() {
      framesInCurrentTick++;
      currentTickLength = performance.now() - start;
      if (currentTickLength > TICK_LENGTH) {
        const fps = Math.round(
          framesInCurrentTick * (TICK_LENGTH / currentTickLength) * (1e3 / TICK_LENGTH)
        );
        if (fps > maxKnownFps) {
          maxKnownFps = fps;
        }
        const slowFps = maxKnownFps * 0.75;
        if (fps < slowFps && !isSlow || fps >= slowFps && isSlow) {
          isSlow = !isSlow;
        }
        fpsRef.current.innerHTML = `FPS ${fps.toString()}`;
        fpsRef.current.className = `tlui-debug-panel__fps` + (isSlow ? ` tlui-debug-panel__fps__slow` : ``);
        currentTickLength -= TICK_LENGTH;
        framesInCurrentTick = 0;
        start = performance.now();
      }
      raf = editor.timers.requestAnimationFrame(loop);
    }
    loop();
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [showFps, editor]);
  if (!showFps) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: fpsRef });
}
function DefaultFollowingIndicator() {
  const editor = useEditor();
  const followingUserId = useValue("follow", () => editor.getInstanceState().followingUserId, [
    editor
  ]);
  if (!followingUserId) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FollowingIndicatorInner, { userId: followingUserId });
}
function FollowingIndicatorInner({ userId }) {
  const presence = usePresence$1(userId);
  if (!presence) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-following-indicator", style: { borderColor: presence.color } });
}
const DefaultMenuPanel = reactExports.memo(function MenuPanel() {
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const { MainMenu, QuickActions, ActionsMenu, PageMenu } = useTldrawUiComponents();
  const editor = useEditor();
  const isSinglePageMode = useValue("isSinglePageMode", () => editor.options.maxPages <= 1, [
    editor
  ]);
  const showQuickActions = editor.options.actionShortcutsLocation === "menu" ? true : editor.options.actionShortcutsLocation === "toolbar" ? false : breakpoint >= PORTRAIT_BREAKPOINT.TABLET;
  if (!MainMenu && !PageMenu && !showQuickActions) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { ref, className: "tlui-menu-zone", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiRow, { children: [
    MainMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(MainMenu, {}),
    PageMenu && !isSinglePageMode && /* @__PURE__ */ jsxRuntimeExports.jsx(PageMenu, {}),
    showQuickActions ? /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiToolbar, { orientation: "horizontal", label: msg2("actions-menu.title"), children: [
      QuickActions && /* @__PURE__ */ jsxRuntimeExports.jsx(QuickActions, {}),
      ActionsMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(ActionsMenu, {})
    ] }) : null
  ] }) });
});
const TldrawUiDialog = ({ id, component: ModalContent, preventBackgroundClose }) => {
  const { removeDialog } = useDialogs();
  const mouseDownInsideContentRef = reactExports.useRef(false);
  const container = useContainer();
  const handleOpenChange = reactExports.useCallback(
    (isOpen) => {
      if (!isOpen) {
        removeDialog(id);
      }
    },
    [id, removeDialog]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root$4, { onOpenChange: handleOpenChange, defaultOpen: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Overlay,
    {
      dir: "ltr",
      className: "tlui-dialog__overlay",
      onClick: (e) => {
        if (mouseDownInsideContentRef.current) return;
        if (!preventBackgroundClose && e.target === e.currentTarget) handleOpenChange(false);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Content$1,
        {
          dir: "ltr",
          className: "tlui-dialog__content",
          "aria-describedby": void 0,
          onMouseDown: () => mouseDownInsideContentRef.current = true,
          onMouseUp: () => mouseDownInsideContentRef.current = false,
          onInteractOutside: (e) => {
            mouseDownInsideContentRef.current = false;
            if (preventBackgroundClose) {
              e.preventDefault();
            }
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ModalContent,
            {
              onClose: () => {
                mouseDownInsideContentRef.current = false;
                handleOpenChange(false);
              }
            }
          )
        }
      )
    }
  ) }) });
};
const DefaultDialogs = reactExports.memo(function DefaultDialogs2() {
  const { dialogs } = useDialogs();
  const dialogsArray = useValue("dialogs", () => dialogs.get(), [dialogs]);
  return dialogsArray.map((dialog) => /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialog, { ...dialog }, dialog.id));
});
function BackToContent() {
  const editor = useEditor();
  const actions = useActions();
  const [showBackToContent, setShowBackToContent] = reactExports.useState(false);
  const rIsShowing = reactExports.useRef(false);
  useQuickReactor(
    "toggle showback to content",
    () => {
      const showBackToContentPrev = rIsShowing.current;
      const shapeIds = editor.getCurrentPageShapeIds();
      let showBackToContentNow = false;
      if (shapeIds.size) {
        showBackToContentNow = shapeIds.size === editor.getCulledShapes().size;
      }
      if (showBackToContentPrev !== showBackToContentNow) {
        setShowBackToContent(showBackToContentNow);
        rIsShowing.current = showBackToContentNow;
      }
    },
    [editor]
  );
  if (!showBackToContent) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionItem,
    {
      actionId: "back-to-content",
      onSelect: () => {
        actions["back-to-content"].onSelect("helper-buttons");
        setShowBackToContent(false);
      }
    }
  );
}
function ExitPenMode() {
  const editor = useEditor();
  const isPenMode = useValue("is pen mode", () => editor.getInstanceState().isPenMode, [editor]);
  if (!isPenMode) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "exit-pen-mode" });
}
function StopFollowing() {
  const editor = useEditor();
  const actions = useActions();
  const followingUser = useValue(
    "is following user",
    () => !!editor.getInstanceState().followingUserId,
    [editor]
  );
  if (!followingUser) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { ...actions["stop-following"] });
}
function DefaultHelperButtonsContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ExitPenMode, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BackToContent, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StopFollowing, {})
  ] });
}
function DefaultHelperButtons({ children }) {
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultHelperButtonsContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-helper-buttons", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "helper-buttons", sourceId: "helper-buttons", children: content }) });
}
const COLOR_SCHEMES = [
  { colorScheme: "light", label: "theme.light" },
  { colorScheme: "dark", label: "theme.dark" },
  { colorScheme: "system", label: "theme.system" }
];
function ColorSchemeMenu() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const currentColorScheme = useValue(
    "colorScheme",
    () => editor.user.getUserPreferences().colorScheme ?? (editor.user.getIsDarkMode() ? "dark" : "light"),
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "help menu color-scheme", label: "menu.theme", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "theme", children: COLOR_SCHEMES.map(({ colorScheme, label }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuCheckboxItem,
    {
      id: `color-scheme-${colorScheme}`,
      label,
      checked: colorScheme === currentColorScheme,
      readonlyOk: true,
      onSelect: () => {
        editor.user.updateUserPreferences({ colorScheme });
        trackEvent("color-scheme", { source: "menu", value: colorScheme });
      }
    },
    colorScheme
  )) }) });
}
function LanguageMenu() {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const currentLanguage = useValue("locale", () => editor?.user.getLocale(), [editor]);
  if (!editor) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "help menu language", label: "menu.language", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "languages", className: "tlui-language-menu", children: LANGUAGES.map(({ locale, label }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuCheckboxItem,
    {
      id: `language-${locale}`,
      lang: locale,
      title: locale,
      label,
      checked: locale === currentLanguage,
      readonlyOk: true,
      onSelect: () => {
        editor.user.updateUserPreferences({ locale });
        trackEvent("change-language", { source: "menu", locale });
      }
    },
    locale
  )) }) });
}
function DefaultHelpMenuContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageMenu, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardShortcutsMenuItem, {})
  ] });
}
function KeyboardShortcutsMenuItem() {
  const { KeyboardShortcutsDialog } = useTldrawUiComponents();
  const { addDialog } = useDialogs();
  const handleSelect = reactExports.useCallback(() => {
    if (KeyboardShortcutsDialog) addDialog({ component: KeyboardShortcutsDialog });
  }, [addDialog, KeyboardShortcutsDialog]);
  if (!KeyboardShortcutsDialog) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuItem,
    {
      id: "keyboard-shortcuts-button",
      label: "help-menu.keyboard-shortcuts",
      readonlyOk: true,
      onSelect: handleSelect
    }
  );
}
const MODES = ["auto", "trackpad", "mouse"];
function InputModeMenu() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const inputMode = useValue("inputMode", () => editor.user.getUserPreferences().inputMode, [
    editor
  ]);
  const wheelBehavior = useValue("wheelBehavior", () => editor.getCameraOptions().wheelBehavior, [
    editor
  ]);
  const isModeChecked = (mode) => {
    if (mode === "auto") {
      return inputMode === null;
    }
    return inputMode === mode;
  };
  const getLabel2 = (mode, wheelBehavior2) => {
    if (mode === "auto") {
      return `action.toggle-auto-${wheelBehavior2}`;
    }
    return mode === "trackpad" ? "action.toggle-trackpad" : "action.toggle-mouse";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "help menu input-mode", label: "menu.input-mode", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "peripheral-mode", children: MODES.map((mode) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuCheckboxItem,
    {
      id: `peripheral-mode-${mode}`,
      label: getLabel2(mode, wheelBehavior),
      checked: isModeChecked(mode),
      readonlyOk: true,
      onSelect: () => {
        trackEvent("input-mode", { source: "menu", value: mode });
        switch (mode) {
          case "auto":
            editor.user.updateUserPreferences({ inputMode: null });
            break;
          case "trackpad":
            editor.user.updateUserPreferences({ inputMode: "trackpad" });
            break;
          case "mouse":
            editor.user.updateUserPreferences({ inputMode: "mouse" });
            break;
        }
      }
    },
    mode
  )) }) });
}
function DefaultMainMenuContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "basic", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(EditSubmenu, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ViewSubmenu, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ExportFileContentSubMenu, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ExtrasGroup, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PreferencesGroup, {})
  ] });
}
function ExportFileContentSubMenu() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "export-all-as", label: "context-menu.export-all-as", size: "small", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "export-all-as-group", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "export-all-as-svg" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "export-all-as-png" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "export-all-as-bg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleTransparentBgMenuItem, {}) })
  ] });
}
function EditSubmenu() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "edit", label: "menu.edit", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(UndoRedoGroup$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConversionsMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MiscMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LockGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "select-all", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectAllMenuItem, {}) })
  ] });
}
function MiscMenuGroup() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "misc", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GroupMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(UngroupMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EditLinkMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleAutoSizeMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RemoveFrameMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FitFrameToContentMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConvertToEmbedMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConvertToBookmarkMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FlattenMenuItem, {})
  ] });
}
function LockGroup() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "lock", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleLockMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(UnlockAllMenuItem, {})
  ] });
}
function UndoRedoGroup$1() {
  const canUndo = useCanUndo();
  const canRedo = useCanRedo();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "undo-redo", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "undo", disabled: !canUndo }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "redo", disabled: !canRedo })
  ] });
}
function ViewSubmenu() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "view", label: "menu.view", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "view-actions", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-in" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-out" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomTo100MenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomToFitMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomToSelectionMenuItem, {})
  ] }) });
}
function ExtrasGroup() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "insert-embed" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "insert-media" })
  ] });
}
function PreferencesGroup() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "preferences", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "preferences", label: "menu.preferences", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "preferences-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleSnapModeItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleToolLockItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGridItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleWrapModeItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleFocusModeItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleEdgeScrollingItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleDynamicSizeModeItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TogglePasteAtCursorItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleDebugModeItem, {})
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "user-interface-submenus", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(InputModeMenu, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ColorSchemeMenu, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AccessibilityMenu, {})
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageMenu, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardShortcutsMenuItem, {})
  ] });
}
const DefaultMainMenu = reactExports.memo(function DefaultMainMenu2({ children }) {
  const container = useContainer();
  const [isOpen, onOpenChange] = useMenuIsOpen("main menu");
  const msg2 = useTranslation();
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultMainMenuContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$3, { dir: "ltr", open: isOpen, onOpenChange, modal: false, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$2, { asChild: true, dir: "ltr", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "icon", "data-testid": "main-menu.button", title: msg2("menu.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "menu", small: true }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$2,
      {
        className: "tlui-menu",
        side: "bottom",
        align: "start",
        collisionPadding: 4,
        alignOffset: 0,
        sideOffset: 6,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "menu", sourceId: "main-menu", children: content })
      }
    ) })
  ] });
});
const memo = {};
function getRgba(colorString) {
  if (memo[colorString]) {
    return memo[colorString];
  }
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  context.fillStyle = colorString;
  context.fillRect(0, 0, 1, 1);
  const [r, g, b, a] = context.getImageData(0, 0, 1, 1).data;
  const result = new Float32Array([r / 255, g / 255, b / 255, a / 255]);
  memo[colorString] = result;
  return result;
}
const numArcSegmentsPerCorner = 10;
const roundedRectangleDataSize = (
  // num triangles in corners
  // num triangles in outer rects
  4 * 6 * numArcSegmentsPerCorner + // num triangles in center rect
  12 + 4 * 12
);
function pie(array2, {
  center,
  radius,
  numArcSegments = 20,
  startAngle = 0,
  endAngle = PI2,
  offset: offset2 = 0
}) {
  const angle = (endAngle - startAngle) / numArcSegments;
  let i = offset2;
  for (let a = startAngle; a < endAngle; a += angle) {
    array2[i++] = center.x;
    array2[i++] = center.y;
    array2[i++] = center.x + Math.cos(a) * radius;
    array2[i++] = center.y + Math.sin(a) * radius;
    array2[i++] = center.x + Math.cos(a + angle) * radius;
    array2[i++] = center.y + Math.sin(a + angle) * radius;
  }
  return array2;
}
function rectangle(array2, offset2, x, y, w, h2) {
  array2[offset2++] = x;
  array2[offset2++] = y;
  array2[offset2++] = x;
  array2[offset2++] = y + h2;
  array2[offset2++] = x + w;
  array2[offset2++] = y;
  array2[offset2++] = x + w;
  array2[offset2++] = y;
  array2[offset2++] = x;
  array2[offset2++] = y + h2;
  array2[offset2++] = x + w;
  array2[offset2++] = y + h2;
}
function roundedRectangle(data, box, radius) {
  const numArcSegments = numArcSegmentsPerCorner;
  radius = Math.min(radius, Math.min(box.w, box.h) / 2);
  const innerBox = Box.ExpandBy(box, -radius);
  if (innerBox.w <= 0 || innerBox.h <= 0) {
    pie(data, { center: box.center, radius, numArcSegments: numArcSegmentsPerCorner * 4 });
    return numArcSegmentsPerCorner * 4 * 6;
  }
  let offset2 = 0;
  rectangle(data, offset2, innerBox.minX, innerBox.minY, innerBox.w, innerBox.h);
  offset2 += 12;
  rectangle(data, offset2, innerBox.minX, box.minY, innerBox.w, radius);
  offset2 += 12;
  rectangle(data, offset2, innerBox.maxX, innerBox.minY, radius, innerBox.h);
  offset2 += 12;
  rectangle(data, offset2, innerBox.minX, innerBox.maxY, innerBox.w, radius);
  offset2 += 12;
  rectangle(data, offset2, box.minX, innerBox.minY, radius, innerBox.h);
  offset2 += 12;
  pie(data, {
    numArcSegments,
    offset: offset2,
    center: innerBox.point,
    radius,
    startAngle: PI$1,
    endAngle: PI$1 * 1.5
  });
  offset2 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset2,
    center: Vec.Add(innerBox.point, new Vec(innerBox.w, 0)),
    radius,
    startAngle: PI$1 * 1.5,
    endAngle: PI2
  });
  offset2 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset2,
    center: Vec.Add(innerBox.point, innerBox.size),
    radius,
    startAngle: 0,
    endAngle: HALF_PI
  });
  offset2 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset2,
    center: Vec.Add(innerBox.point, new Vec(0, innerBox.h)),
    radius,
    startAngle: HALF_PI,
    endAngle: PI$1
  });
  return roundedRectangleDataSize;
}
function setupWebGl(canvas) {
  if (!canvas) throw new Error("Canvas element not found");
  const context = canvas.getContext("webgl2", {
    premultipliedAlpha: false
  });
  if (!context) throw new Error("Failed to get webgl2 context");
  const vertexShaderSourceCode = `#version 300 es
  precision mediump float;
  
  in vec2 shapeVertexPosition;

	uniform vec4 canvasPageBounds;

	// taken (with thanks) from
	// https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html
  void main() {
		// convert the position from pixels to 0.0 to 1.0
		vec2 zeroToOne = (shapeVertexPosition - canvasPageBounds.xy) / canvasPageBounds.zw;
	
		// convert from 0->1 to 0->2
		vec2 zeroToTwo = zeroToOne * 2.0;
	
		// convert from 0->2 to -1->+1 (clipspace)
		vec2 clipSpace = zeroToTwo - 1.0;
	
		gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
  }`;
  const vertexShader = context.createShader(context.VERTEX_SHADER);
  if (!vertexShader) {
    throw new Error("Failed to create vertex shader");
  }
  context.shaderSource(vertexShader, vertexShaderSourceCode);
  context.compileShader(vertexShader);
  if (!context.getShaderParameter(vertexShader, context.COMPILE_STATUS)) {
    throw new Error("Failed to compile vertex shader");
  }
  const fragmentShaderSourceCode = `#version 300 es
  precision mediump float;
  
	uniform vec4 fillColor;
  out vec4 outputColor;

  void main() {
	outputColor = fillColor;
  }`;
  const fragmentShader = context.createShader(context.FRAGMENT_SHADER);
  if (!fragmentShader) {
    throw new Error("Failed to create fragment shader");
  }
  context.shaderSource(fragmentShader, fragmentShaderSourceCode);
  context.compileShader(fragmentShader);
  if (!context.getShaderParameter(fragmentShader, context.COMPILE_STATUS)) {
    throw new Error("Failed to compile fragment shader");
  }
  const program = context.createProgram();
  if (!program) {
    throw new Error("Failed to create program");
  }
  context.attachShader(program, vertexShader);
  context.attachShader(program, fragmentShader);
  context.linkProgram(program);
  if (!context.getProgramParameter(program, context.LINK_STATUS)) {
    throw new Error("Failed to link program");
  }
  context.useProgram(program);
  const shapeVertexPositionAttributeLocation = context.getAttribLocation(
    program,
    "shapeVertexPosition"
  );
  if (shapeVertexPositionAttributeLocation < 0) {
    throw new Error("Failed to get shapeVertexPosition attribute location");
  }
  context.enableVertexAttribArray(shapeVertexPositionAttributeLocation);
  const canvasPageBoundsLocation = context.getUniformLocation(program, "canvasPageBounds");
  const fillColorLocation = context.getUniformLocation(program, "fillColor");
  const selectedShapesBuffer = context.createBuffer();
  if (!selectedShapesBuffer) throw new Error("Failed to create buffer");
  const unselectedShapesBuffer = context.createBuffer();
  if (!unselectedShapesBuffer) throw new Error("Failed to create buffer");
  return {
    context,
    selectedShapes: allocateBuffer(context, 1024),
    unselectedShapes: allocateBuffer(context, 4096),
    viewport: allocateBuffer(context, roundedRectangleDataSize),
    collaborators: allocateBuffer(context, 1024),
    prepareTriangles(stuff, len) {
      context.bindBuffer(context.ARRAY_BUFFER, stuff.buffer);
      context.bufferData(context.ARRAY_BUFFER, stuff.vertices, context.STATIC_DRAW, 0, len);
      context.enableVertexAttribArray(shapeVertexPositionAttributeLocation);
      context.vertexAttribPointer(
        shapeVertexPositionAttributeLocation,
        2,
        context.FLOAT,
        false,
        0,
        0
      );
    },
    drawTrianglesTransparently(len) {
      context.enable(context.BLEND);
      context.blendFunc(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA);
      context.drawArrays(context.TRIANGLES, 0, len / 2);
      context.disable(context.BLEND);
    },
    drawTriangles(len) {
      context.drawArrays(context.TRIANGLES, 0, len / 2);
    },
    setFillColor(color) {
      context.uniform4fv(fillColorLocation, color);
    },
    setCanvasPageBounds(bounds) {
      context.uniform4fv(canvasPageBoundsLocation, bounds);
    }
  };
}
function allocateBuffer(context, size2) {
  const buffer = context.createBuffer();
  if (!buffer) throw new Error("Failed to create buffer");
  return { buffer, vertices: new Float32Array(size2) };
}
function appendVertices(bufferStuff, offset2, data) {
  let len = bufferStuff.vertices.length;
  while (len < offset2 + data.length) {
    len *= 2;
  }
  if (len != bufferStuff.vertices.length) {
    const newVertices = new Float32Array(len);
    newVertices.set(bufferStuff.vertices);
    bufferStuff.vertices = newVertices;
  }
  bufferStuff.vertices.set(data, offset2);
}
var __create$2 = Object.create;
var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __knownSymbol$2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$2 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$2 = (base2) => [, , , __create$2(null)];
var __decoratorStrings$2 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$2 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$2("Function expected") : fn;
var __decoratorContext$2 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings$2[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError$2("Already initialized") : fns.push(__expectFn$2(fn || null)) });
var __decoratorMetadata$2 = (array2, target) => __defNormalProp$2(target, __knownSymbol$2("metadata"), array2[3]);
var __runInitializers$2 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$2 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings$2[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$2(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$2(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$2(it) && (desc[key] = it);
  }
  return desc && __defProp$5(target, name, desc), target;
};
var __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
var _render_dec, _getCanvasPageBoundsArray_dec, _getZoom_dec, _getCanvasPageBounds_dec, _getCanvasClientPosition_dec, _getCanvasSize_dec, _getContentScreenBounds_dec, _getContentPageBounds_dec, _getDpr_dec, _close_dec, _init$2;
_close_dec = [bind$1], _getDpr_dec = [computed], _getContentPageBounds_dec = [computed], _getContentScreenBounds_dec = [computed], _getCanvasSize_dec = [computed], _getCanvasClientPosition_dec = [computed], _getCanvasPageBounds_dec = [computed], _getZoom_dec = [computed], _getCanvasPageBoundsArray_dec = [computed], _render_dec = [bind$1];
class MinimapManager {
  constructor(editor, elem, container) {
    this.editor = editor;
    this.elem = elem;
    this.container = container;
    __runInitializers$2(_init$2, 5, this);
    __publicField$2(this, "disposables", []);
    __publicField$2(this, "gl");
    __publicField$2(this, "shapeGeometryCache");
    __publicField$2(this, "colors");
    __publicField$2(this, "id", uniqueId());
    __publicField$2(this, "canvasBoundingClientRect", atom("canvasBoundingClientRect", new Box()));
    __publicField$2(this, "originPagePoint", new Vec());
    __publicField$2(this, "originPageCenter", new Vec());
    __publicField$2(this, "isInViewport", false);
    this.gl = setupWebGl(elem);
    this.shapeGeometryCache = editor.store.createComputedCache("webgl-geometry", (r) => {
      const bounds = editor.getShapeMaskedPageBounds(r.id);
      if (!bounds) return null;
      const arr = new Float32Array(12);
      rectangle(arr, 0, bounds.x, bounds.y, bounds.w, bounds.h);
      return arr;
    });
    this.colors = this._getColors();
    this.disposables.push(this._listenForCanvasResize(), react("minimap render", this.render));
  }
  close() {
    return this.disposables.forEach((d) => d());
  }
  _getColors() {
    const style2 = getComputedStyle(this.editor.getContainer());
    return {
      shapeFill: getRgba(style2.getPropertyValue("--tl-color-text-3").trim()),
      selectFill: getRgba(style2.getPropertyValue("--tl-color-selected").trim()),
      viewportFill: getRgba(style2.getPropertyValue("--tl-color-muted-1").trim()),
      background: getRgba(style2.getPropertyValue("--tl-color-low").trim())
    };
  }
  // this should be called after dark/light mode changes have propagated to the dom
  updateColors() {
    this.colors = this._getColors();
  }
  getDpr() {
    return this.editor.getInstanceState().devicePixelRatio;
  }
  getContentPageBounds() {
    const viewportPageBounds = this.editor.getViewportPageBounds();
    const commonShapeBounds = this.editor.getCurrentPageBounds();
    return commonShapeBounds ? Box.Expand(commonShapeBounds, viewportPageBounds) : viewportPageBounds;
  }
  getContentScreenBounds() {
    const contentPageBounds = this.getContentPageBounds();
    const topLeft = this.editor.pageToScreen(contentPageBounds.point);
    const bottomRight = this.editor.pageToScreen(
      new Vec(contentPageBounds.maxX, contentPageBounds.maxY)
    );
    return new Box(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
  }
  _getCanvasBoundingRect() {
    const { x, y, width, height } = this.elem.getBoundingClientRect();
    return new Box(x, y, width, height);
  }
  getCanvasScreenBounds() {
    return this.canvasBoundingClientRect.get();
  }
  _listenForCanvasResize() {
    const observer = new ResizeObserver(() => {
      const rect = this._getCanvasBoundingRect();
      this.canvasBoundingClientRect.set(rect);
    });
    observer.observe(this.elem);
    observer.observe(this.container);
    return () => observer.disconnect();
  }
  getCanvasSize() {
    const rect = this.canvasBoundingClientRect.get();
    const dpr = this.getDpr();
    return new Vec(rect.width * dpr, rect.height * dpr);
  }
  getCanvasClientPosition() {
    return this.canvasBoundingClientRect.get().point;
  }
  getCanvasPageBounds() {
    const canvasScreenBounds = this.getCanvasScreenBounds();
    const contentPageBounds = this.getContentPageBounds();
    const aspectRatio = canvasScreenBounds.width / canvasScreenBounds.height;
    let targetWidth = contentPageBounds.width;
    let targetHeight = targetWidth / aspectRatio;
    if (targetHeight < contentPageBounds.height) {
      targetHeight = contentPageBounds.height;
      targetWidth = targetHeight * aspectRatio;
    }
    const box = new Box(0, 0, targetWidth, targetHeight);
    box.center = contentPageBounds.center;
    return box;
  }
  getZoom() {
    return this.getCanvasPageBounds().width / this.getCanvasScreenBounds().width;
  }
  getCanvasPageBoundsArray() {
    const { x, y, w, h: h2 } = this.getCanvasPageBounds();
    return new Float32Array([x, y, w, h2]);
  }
  getMinimapPagePoint(clientX, clientY) {
    const canvasPageBounds = this.getCanvasPageBounds();
    const canvasScreenBounds = this.getCanvasScreenBounds();
    let x = clientX - canvasScreenBounds.x;
    let y = clientY - canvasScreenBounds.y;
    x *= canvasPageBounds.width / canvasScreenBounds.width;
    y *= canvasPageBounds.height / canvasScreenBounds.height;
    x += canvasPageBounds.minX;
    y += canvasPageBounds.minY;
    return new Vec(x, y, 1);
  }
  minimapScreenPointToPagePoint(x, y, shiftKey = false, clampToBounds = false) {
    const { editor } = this;
    const vpPageBounds = editor.getViewportPageBounds();
    let { x: px, y: py } = this.getMinimapPagePoint(x, y);
    if (clampToBounds) {
      const shapesPageBounds = this.editor.getCurrentPageBounds() ?? new Box();
      const minX = shapesPageBounds.minX - vpPageBounds.width / 2;
      const maxX = shapesPageBounds.maxX + vpPageBounds.width / 2;
      const minY = shapesPageBounds.minY - vpPageBounds.height / 2;
      const maxY = shapesPageBounds.maxY + vpPageBounds.height / 2;
      const lx = Math.max(0, minX + vpPageBounds.width - px);
      const rx = Math.max(0, -(maxX - vpPageBounds.width - px));
      const ly = Math.max(0, minY + vpPageBounds.height - py);
      const ry = Math.max(0, -(maxY - vpPageBounds.height - py));
      px += (lx - rx) / 2;
      py += (ly - ry) / 2;
      px = clamp$3(px, minX, maxX);
      py = clamp$3(py, minY, maxY);
    }
    if (shiftKey) {
      const { originPagePoint } = this;
      const dx = Math.abs(px - originPagePoint.x);
      const dy = Math.abs(py - originPagePoint.y);
      if (dx > dy) {
        py = originPagePoint.y;
      } else {
        px = originPagePoint.x;
      }
    }
    return new Vec(px, py);
  }
  render() {
    const context = this.gl.context;
    const canvasSize = this.getCanvasSize();
    this.gl.setCanvasPageBounds(this.getCanvasPageBoundsArray());
    this.elem.width = canvasSize.x;
    this.elem.height = canvasSize.y;
    context.viewport(0, 0, canvasSize.x, canvasSize.y);
    context.clearColor(
      this.colors.background[0],
      this.colors.background[1],
      this.colors.background[2],
      1
    );
    context.clear(context.COLOR_BUFFER_BIT);
    const selectedShapes = new Set(this.editor.getSelectedShapeIds());
    const colors = this.colors;
    let selectedShapeOffset = 0;
    let unselectedShapeOffset = 0;
    const ids = this.editor.getCurrentPageShapeIdsSorted();
    for (let i = 0, len = ids.length; i < len; i++) {
      const shapeId = ids[i];
      const geometry = this.shapeGeometryCache.get(shapeId);
      if (!geometry) continue;
      const len2 = geometry.length;
      const shape = this.editor.getShape(shapeId);
      if (shape) {
        const shapeUtil = this.editor.getShapeUtil(shape.type);
        if (shapeUtil.hideInMinimap?.(shape)) continue;
      }
      if (selectedShapes.has(shapeId)) {
        appendVertices(this.gl.selectedShapes, selectedShapeOffset, geometry);
        selectedShapeOffset += len2;
      } else {
        appendVertices(this.gl.unselectedShapes, unselectedShapeOffset, geometry);
        unselectedShapeOffset += len2;
      }
    }
    this.drawShapes(this.gl.unselectedShapes, unselectedShapeOffset, colors.shapeFill);
    this.drawShapes(this.gl.selectedShapes, selectedShapeOffset, colors.selectFill);
    this.drawViewport();
    this.drawCollaborators();
  }
  drawShapes(stuff, len, color) {
    this.gl.prepareTriangles(stuff, len);
    this.gl.setFillColor(color);
    this.gl.drawTriangles(len);
  }
  drawViewport() {
    const viewport = this.editor.getViewportPageBounds();
    const len = roundedRectangle(this.gl.viewport.vertices, viewport, 4 * this.getZoom());
    this.gl.prepareTriangles(this.gl.viewport, len);
    this.gl.setFillColor(this.colors.viewportFill);
    this.gl.drawTrianglesTransparently(len);
    if (tlenv.isSafari) {
      this.gl.drawTrianglesTransparently(len);
      this.gl.drawTrianglesTransparently(len);
      this.gl.drawTrianglesTransparently(len);
    }
  }
  drawCollaborators() {
    const collaborators = this.editor.getCollaboratorsOnCurrentPage();
    if (!collaborators.length) return;
    const numSegmentsPerCircle = 20;
    const dataSizePerCircle = numSegmentsPerCircle * 6;
    const totalSize = dataSizePerCircle * collaborators.length;
    if (this.gl.collaborators.vertices.length < totalSize) {
      this.gl.collaborators.vertices = new Float32Array(totalSize);
    }
    const vertices = this.gl.collaborators.vertices;
    let offset2 = 0;
    const zoom = this.getZoom();
    for (const { cursor } of collaborators) {
      if (!cursor) continue;
      pie(vertices, {
        center: Vec.From(cursor),
        radius: 3 * zoom,
        offset: offset2,
        numArcSegments: numSegmentsPerCircle
      });
      offset2 += dataSizePerCircle;
    }
    this.gl.prepareTriangles(this.gl.collaborators, totalSize);
    offset2 = 0;
    for (const { color } of collaborators) {
      this.gl.setFillColor(getRgba(color));
      this.gl.context.drawArrays(this.gl.context.TRIANGLES, offset2 / 2, dataSizePerCircle / 2);
      offset2 += dataSizePerCircle;
    }
  }
}
_init$2 = __decoratorStart$2();
__decorateElement$2(_init$2, 1, "close", _close_dec, MinimapManager);
__decorateElement$2(_init$2, 1, "getDpr", _getDpr_dec, MinimapManager);
__decorateElement$2(_init$2, 1, "getContentPageBounds", _getContentPageBounds_dec, MinimapManager);
__decorateElement$2(_init$2, 1, "getContentScreenBounds", _getContentScreenBounds_dec, MinimapManager);
__decorateElement$2(_init$2, 1, "getCanvasSize", _getCanvasSize_dec, MinimapManager);
__decorateElement$2(_init$2, 1, "getCanvasClientPosition", _getCanvasClientPosition_dec, MinimapManager);
__decorateElement$2(_init$2, 1, "getCanvasPageBounds", _getCanvasPageBounds_dec, MinimapManager);
__decorateElement$2(_init$2, 1, "getZoom", _getZoom_dec, MinimapManager);
__decorateElement$2(_init$2, 1, "getCanvasPageBoundsArray", _getCanvasPageBoundsArray_dec, MinimapManager);
__decorateElement$2(_init$2, 1, "render", _render_dec, MinimapManager);
__decoratorMetadata$2(_init$2, MinimapManager);
function DefaultMinimap() {
  const editor = useEditor();
  const container = useContainer();
  const msg2 = useTranslation();
  const rCanvas = reactExports.useRef(null);
  const rPointing = reactExports.useRef(false);
  const minimapRef = reactExports.useRef();
  reactExports.useEffect(() => {
    try {
      const minimap = new MinimapManager(editor, rCanvas.current, container);
      minimapRef.current = minimap;
      return minimapRef.current.close;
    } catch (e) {
      editor.annotateError(e, {
        origin: "minimap",
        willCrashApp: false
      });
      editor.timers.setTimeout(() => {
        throw e;
      });
    }
  }, [editor, container]);
  const onDoubleClick = reactExports.useCallback(
    (e) => {
      if (!editor.getCurrentPageShapeIds().size) return;
      if (!minimapRef.current) return;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        false
      );
      const clampedPoint = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        true
      );
      minimapRef.current.originPagePoint.setTo(clampedPoint);
      minimapRef.current.originPageCenter.setTo(editor.getViewportPageBounds().center);
      editor.centerOnPoint(point, { animation: { duration: editor.options.animationMediumMs } });
    },
    [editor]
  );
  const onPointerDown = reactExports.useCallback(
    (e) => {
      if (!minimapRef.current) return;
      const elm = e.currentTarget;
      setPointerCapture(elm, e);
      if (!editor.getCurrentPageShapeIds().size) return;
      rPointing.current = true;
      minimapRef.current.isInViewport = false;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        false
      );
      const _vpPageBounds = editor.getViewportPageBounds();
      const commonBounds = minimapRef.current.getContentPageBounds();
      const allowedBounds = new Box(
        commonBounds.x - _vpPageBounds.width / 2,
        commonBounds.y - _vpPageBounds.height / 2,
        commonBounds.width + _vpPageBounds.width,
        commonBounds.height + _vpPageBounds.height
      );
      if (allowedBounds.containsPoint(point) && !_vpPageBounds.containsPoint(point)) {
        minimapRef.current.isInViewport = _vpPageBounds.containsPoint(point);
        const delta = Vec.Sub(_vpPageBounds.center, _vpPageBounds.point);
        const pagePoint = Vec.Add(point, delta);
        minimapRef.current.originPagePoint.setTo(pagePoint);
        minimapRef.current.originPageCenter.setTo(point);
        editor.centerOnPoint(point, { animation: { duration: editor.options.animationMediumMs } });
      } else {
        const clampedPoint = minimapRef.current.minimapScreenPointToPagePoint(
          e.clientX,
          e.clientY,
          false,
          true
        );
        minimapRef.current.isInViewport = _vpPageBounds.containsPoint(clampedPoint);
        minimapRef.current.originPagePoint.setTo(clampedPoint);
        minimapRef.current.originPageCenter.setTo(_vpPageBounds.center);
      }
      function release(e2) {
        if (elm) {
          releasePointerCapture(elm, e2);
        }
        rPointing.current = false;
        document.body.removeEventListener("pointerup", release);
      }
      document.body.addEventListener("pointerup", release);
    },
    [editor]
  );
  const onPointerMove = reactExports.useCallback(
    (e) => {
      if (!minimapRef.current) return;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        e.shiftKey,
        true
      );
      if (rPointing.current) {
        if (minimapRef.current.isInViewport) {
          const delta = minimapRef.current.originPagePoint.clone().sub(minimapRef.current.originPageCenter);
          editor.centerOnPoint(Vec.Sub(point, delta));
          return;
        }
        editor.centerOnPoint(point);
      }
      const pagePoint = minimapRef.current.getMinimapPagePoint(e.clientX, e.clientY);
      const screenPoint = editor.pageToScreen(pagePoint);
      const info = {
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        ...getPointerInfo(editor, e),
        point: screenPoint,
        isPen: editor.getInstanceState().isPenMode
      };
      editor.dispatch(info);
    },
    [editor]
  );
  const onWheel = reactExports.useCallback(
    (e) => {
      const offset2 = normalizeWheel(e);
      editor.dispatch({
        type: "wheel",
        name: "wheel",
        delta: offset2,
        point: new Vec(e.clientX, e.clientY),
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      });
    },
    [editor]
  );
  const isDarkMode = useIsDarkMode();
  reactExports.useEffect(() => {
    editor.timers.setTimeout(() => {
      minimapRef.current?.updateColors();
      minimapRef.current?.render();
    });
  }, [isDarkMode, editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-minimap", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "canvas",
    {
      role: "img",
      "aria-label": msg2("navigation-zone.minimap"),
      "data-testid": "minimap.canvas",
      ref: rCanvas,
      className: "tlui-minimap__canvas",
      onDoubleClick,
      onPointerMove,
      onPointerDown,
      onWheelCapture: onWheel
    }
  ) });
}
function useLocalStorageState(key, defaultValue) {
  const [state, setState] = React.useState(defaultValue);
  React.useLayoutEffect(() => {
    const value = getFromLocalStorage(key);
    if (value) {
      try {
        setState(JSON.parse(value));
      } catch {
        console.error(`Could not restore value ${key} from local storage.`);
      }
    }
  }, [key]);
  const updateValue = React.useCallback(
    (setter) => {
      setState((s) => {
        const value = typeof setter === "function" ? setter(s) : setter;
        setInLocalStorage(key, JSON.stringify(value));
        return value;
      });
    },
    [key]
  );
  return [state, updateValue];
}
const DefaultNavigationPanel = reactExports.memo(function DefaultNavigationPanel2() {
  const actions = useActions();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const [collapsed, setCollapsed] = useLocalStorageState("minimap", true);
  const toggleMinimap = reactExports.useCallback(() => {
    setCollapsed((s) => !s);
  }, [setCollapsed]);
  const { ZoomMenu, Minimap } = useTldrawUiComponents();
  if (breakpoint < PORTRAIT_BREAKPOINT.MOBILE) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, className: "tlui-navigation-panel", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { orientation: "horizontal", label: msg2("navigation-zone.title"), children: ZoomMenu && breakpoint < PORTRAIT_BREAKPOINT.TABLET ? /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomMenu, {}) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      !collapsed && /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.zoom-out",
          title: `${msg2(unwrapLabel(actions["zoom-out"].label))} ${kbdStr(actions["zoom-out"].kbd)}`,
          onClick: () => actions["zoom-out"].onSelect("navigation-zone"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "minus" })
        }
      ),
      ZoomMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomMenu, {}, "zoom-menu"),
      !collapsed && /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.zoom-in",
          title: `${msg2(unwrapLabel(actions["zoom-in"].label))} ${kbdStr(actions["zoom-in"].kbd)}`,
          onClick: () => actions["zoom-in"].onSelect("navigation-zone"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "plus" })
        }
      ),
      Minimap && /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.toggle-button",
          title: msg2("navigation-zone.toggle-minimap"),
          onClick: toggleMinimap,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: collapsed ? "chevron-right" : "chevron-left" })
        }
      )
    ] }) }),
    Minimap && breakpoint >= PORTRAIT_BREAKPOINT.TABLET && !collapsed && /* @__PURE__ */ jsxRuntimeExports.jsx(Minimap, {})
  ] });
});
const PageItemInput = function PageItemInput2({
  name,
  id,
  isCurrentPage,
  onCancel,
  onComplete
}) {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const rInput = reactExports.useRef(null);
  const rMark = reactExports.useRef(null);
  const handleFocus = reactExports.useCallback(() => {
    rMark.current = editor.markHistoryStoppingPoint("rename page");
  }, [editor]);
  const handleChange = reactExports.useCallback(
    (value) => {
      editor.renamePage(id, value || "New Page");
      trackEvent("rename-page", { source: "page-menu" });
    },
    [editor, id, trackEvent]
  );
  const handleCancel = reactExports.useCallback(() => {
    if (rMark.current) {
      editor.bailToMark(rMark.current);
    }
    onCancel();
  }, [editor, onCancel]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiInput,
    {
      className: "tlui-page-menu__item__input",
      ref: (el) => rInput.current = el,
      defaultValue: name,
      onValueChange: handleChange,
      onComplete,
      onCancel: handleCancel,
      onFocus: handleFocus,
      shouldManuallyMaintainScrollPositionWhenFocused: true,
      autoFocus: isCurrentPage,
      autoSelect: true
    }
  );
};
const onMovePage = (editor, id, from2, to, trackEvent) => {
  let index2;
  const pages = editor.getPages();
  const below = from2 > to ? pages[to - 1] : pages[to];
  const above = from2 > to ? pages[to] : pages[to + 1];
  if (below && !above) {
    index2 = getIndexAbove(below.index);
  } else if (!below && above) {
    index2 = getIndexBelow(pages[0].index);
  } else {
    index2 = getIndexBetween(below.index, above.index);
  }
  if (index2 !== pages[from2].index) {
    editor.markHistoryStoppingPoint("moving page");
    editor.updatePage({
      id,
      index: index2
    });
    trackEvent("move-page", { source: "page-menu" });
  }
};
const PageItemSubmenu = track(function PageItemSubmenu2({
  index: index2,
  listSize,
  item,
  onRename
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const pages = editor.getPages();
  const trackEvent = useUiEvents();
  const onDuplicate = reactExports.useCallback(() => {
    editor.markHistoryStoppingPoint("creating page");
    const newId = PageRecordType.createId();
    editor.duplicatePage(item.id, newId);
    trackEvent("duplicate-page", { source: "page-menu" });
  }, [editor, item, trackEvent]);
  const onMoveUp = reactExports.useCallback(() => {
    onMovePage(editor, item.id, index2, index2 - 1, trackEvent);
  }, [editor, item, index2, trackEvent]);
  const onMoveDown = reactExports.useCallback(() => {
    onMovePage(editor, item.id, index2, index2 + 1, trackEvent);
  }, [editor, item, index2, trackEvent]);
  const onDelete = reactExports.useCallback(() => {
    editor.markHistoryStoppingPoint("deleting page");
    editor.deletePage(item.id);
    trackEvent("delete-page", { source: "page-menu" });
  }, [editor, item, trackEvent]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDropdownMenuRoot, { id: `page item submenu ${index2}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "icon", title: msg2("page-menu.submenu.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "dots-vertical", small: true }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuContent, { alignOffset: 0, side: "right", sideOffset: -4, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuContextProvider, { type: "menu", sourceId: "page-menu", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "modify", children: [
        onRename && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { id: "rename", label: "page-menu.submenu.rename", onSelect: onRename }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiMenuItem,
          {
            id: "duplicate",
            label: "page-menu.submenu.duplicate-page",
            onSelect: onDuplicate,
            disabled: pages.length >= editor.options.maxPages
          }
        ),
        index2 > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiMenuItem,
          {
            id: "move-up",
            onSelect: onMoveUp,
            label: "page-menu.submenu.move-up"
          }
        ),
        index2 < listSize - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiMenuItem,
          {
            id: "move-down",
            label: "page-menu.submenu.move-down",
            onSelect: onMoveDown
          }
        )
      ] }),
      listSize > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "delete", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { id: "delete", onSelect: onDelete, label: "page-menu.submenu.delete" }) })
    ] }) })
  ] });
});
const DefaultPageMenu = reactExports.memo(function DefaultPageMenu2() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const handleOpenChange = reactExports.useCallback(() => setIsEditing(false), []);
  const [isOpen, onOpenChange] = useMenuIsOpen("page-menu", handleOpenChange);
  const ITEM_HEIGHT = 36;
  const rSortableContainer = reactExports.useRef(null);
  const pages = useValue("pages", () => editor.getPages(), [editor]);
  const currentPage = useValue("currentPage", () => editor.getCurrentPage(), [editor]);
  const currentPageId = useValue("currentPageId", () => editor.getCurrentPageId(), [editor]);
  const isReadonlyMode = useReadonly();
  const maxPageCountReached = useValue(
    "maxPageCountReached",
    () => editor.getPages().length >= editor.options.maxPages,
    [editor]
  );
  const isCoarsePointer = useValue(
    "isCoarsePointer",
    () => editor.getInstanceState().isCoarsePointer,
    [editor]
  );
  const [isEditing, setIsEditing] = reactExports.useState(false);
  reactExports.useEffect(
    function closePageMenuOnEnterPressAfterPressingEnterToConfirmRename() {
      function handleKeyDown22() {
        if (isEditing) return;
        if (document.activeElement === document.body) {
          editor.menus.clearOpenMenus();
        }
      }
      document.addEventListener("keydown", handleKeyDown22, { passive: true });
      return () => {
        document.removeEventListener("keydown", handleKeyDown22);
      };
    },
    [editor, isEditing]
  );
  const toggleEditing = reactExports.useCallback(() => {
    if (isReadonlyMode) return;
    setIsEditing((s) => !s);
  }, [isReadonlyMode]);
  const rMutables = reactExports.useRef({
    isPointing: false,
    status: "idle",
    pointing: null,
    startY: 0,
    startIndex: 0,
    dragIndex: 0
  });
  const [sortablePositionItems, setSortablePositionItems] = reactExports.useState(
    Object.fromEntries(
      pages.map((page, i) => [page.id, { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
    )
  );
  reactExports.useLayoutEffect(() => {
    setSortablePositionItems(
      Object.fromEntries(
        pages.map((page, i) => [page.id, { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
      )
    );
  }, [ITEM_HEIGHT, pages]);
  reactExports.useEffect(() => {
    if (!isOpen) return;
    editor.timers.requestAnimationFrame(() => {
      const elm = document.querySelector(`[data-pageid="${currentPageId}"]`);
      if (elm) {
        elm.querySelector("button")?.focus();
        const container = rSortableContainer.current;
        if (!container) return;
        const elmTopPosition = elm.offsetTop;
        const containerScrollTopPosition = container.scrollTop;
        if (elmTopPosition < containerScrollTopPosition) {
          container.scrollTo({ top: elmTopPosition });
        }
        const elmBottomPosition = elmTopPosition + ITEM_HEIGHT;
        const containerScrollBottomPosition = container.scrollTop + container.offsetHeight;
        if (elmBottomPosition > containerScrollBottomPosition) {
          container.scrollTo({ top: elmBottomPosition - container.offsetHeight });
        }
      }
    });
  }, [ITEM_HEIGHT, currentPageId, isOpen, editor]);
  const handlePointerDown = reactExports.useCallback(
    (e) => {
      const { clientY, currentTarget } = e;
      const {
        dataset: { id, index: index2 }
      } = currentTarget;
      if (!id || !index2) return;
      const mut = rMutables.current;
      setPointerCapture(e.currentTarget, e);
      mut.status = "pointing";
      mut.pointing = { id, index: +index2 };
      const current = sortablePositionItems[id];
      const dragY = current.y;
      mut.startY = clientY;
      mut.startIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1));
    },
    [ITEM_HEIGHT, pages.length, sortablePositionItems]
  );
  const handlePointerMove = reactExports.useCallback(
    (e) => {
      const mut = rMutables.current;
      if (mut.status === "pointing") {
        const { clientY } = e;
        const offset2 = clientY - mut.startY;
        if (Math.abs(offset2) > 5) {
          mut.status = "dragging";
        }
      }
      if (mut.status === "dragging") {
        const { clientY } = e;
        const offsetY = clientY - mut.startY;
        const current = sortablePositionItems[mut.pointing.id];
        const { startIndex, pointing } = mut;
        const dragY = current.y + offsetY;
        const dragIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1));
        const next = { ...sortablePositionItems };
        next[pointing.id] = {
          y: current.y,
          offsetY,
          isSelected: true
        };
        if (dragIndex !== mut.dragIndex) {
          mut.dragIndex = dragIndex;
          for (let i = 0; i < pages.length; i++) {
            const item = pages[i];
            if (item.id === mut.pointing.id) {
              continue;
            }
            let { y } = next[item.id];
            if (dragIndex === startIndex) {
              y = i * ITEM_HEIGHT;
            } else if (dragIndex < startIndex) {
              if (dragIndex <= i && i < startIndex) {
                y = (i + 1) * ITEM_HEIGHT;
              } else {
                y = i * ITEM_HEIGHT;
              }
            } else if (dragIndex > startIndex) {
              if (dragIndex >= i && i > startIndex) {
                y = (i - 1) * ITEM_HEIGHT;
              } else {
                y = i * ITEM_HEIGHT;
              }
            }
            if (y !== next[item.id].y) {
              next[item.id] = { y, offsetY: 0, isSelected: true };
            }
          }
        }
        setSortablePositionItems(next);
      }
    },
    [ITEM_HEIGHT, pages, sortablePositionItems]
  );
  const handlePointerUp = reactExports.useCallback(
    (e) => {
      const mut = rMutables.current;
      if (mut.status === "dragging") {
        const { id, index: index2 } = mut.pointing;
        onMovePage(editor, id, index2, mut.dragIndex, trackEvent);
      }
      releasePointerCapture(e.currentTarget, e);
      mut.status = "idle";
    },
    [editor, trackEvent]
  );
  const handleKeyDown2 = reactExports.useCallback(
    (e) => {
      const mut = rMutables.current;
      if (e.key === "Escape") {
        if (mut.status === "dragging") {
          setSortablePositionItems(
            Object.fromEntries(
              pages.map((page, i) => [
                page.id,
                { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }
              ])
            )
          );
        }
        mut.status = "idle";
      }
    },
    [ITEM_HEIGHT, pages]
  );
  const handleCreatePageClick = reactExports.useCallback(() => {
    if (isReadonlyMode) return;
    editor.run(() => {
      editor.markHistoryStoppingPoint("creating page");
      const newPageId = PageRecordType.createId();
      editor.createPage({ name: msg2("page-menu.new-page-initial-name"), id: newPageId });
      editor.setCurrentPage(newPageId);
      setIsEditing(true);
      editor.timers.requestAnimationFrame(() => {
        const elm = document.querySelector(`[data-pageid="${newPageId}"]`);
        if (elm) {
          elm.querySelector("button")?.focus();
        }
      });
    });
    trackEvent("new-page", { source: "page-menu" });
  }, [editor, msg2, isReadonlyMode, trackEvent]);
  const changePage = reactExports.useCallback(
    (id) => {
      editor.setCurrentPage(id);
      trackEvent("change-page", { source: "page-menu" });
    },
    [editor, trackEvent]
  );
  const renamePage = reactExports.useCallback(
    (id, name) => {
      editor.renamePage(id, name);
      trackEvent("rename-page", { source: "page-menu" });
    },
    [editor, trackEvent]
  );
  const shouldUseWindowPrompt = breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM && isCoarsePointer;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: "pages", onOpenChange, open: isOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { "data-testid": "main.page-menu", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      TldrawUiButton,
      {
        type: "menu",
        title: currentPage.name,
        "data-testid": "page-menu.button",
        className: "tlui-page-menu__trigger",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-page-menu__name", children: currentPage.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "chevron-down", small: true })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiPopoverContent,
      {
        side: "bottom",
        align: "start",
        sideOffset: 0,
        disableEscapeKeyDown: isEditing,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-page-menu__wrapper", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-page-menu__header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-page-menu__header__title", children: msg2("page-menu.title") }),
            !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiRow, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TldrawUiButton,
                {
                  type: "icon",
                  "data-testid": "page-menu.edit",
                  title: msg2(isEditing ? "page-menu.edit-done" : "page-menu.edit-start"),
                  onClick: toggleEditing,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: isEditing ? "check" : "edit" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TldrawUiButton,
                {
                  type: "icon",
                  "data-testid": "page-menu.create",
                  title: msg2(
                    maxPageCountReached ? "page-menu.max-page-count-reached" : "page-menu.create-new-page"
                  ),
                  disabled: maxPageCountReached,
                  onClick: handleCreatePageClick,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "plus" })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              "data-testid": "page-menu.list",
              className: "tlui-page-menu__list tlui-menu__group",
              style: { height: ITEM_HEIGHT * pages.length + 4 },
              ref: rSortableContainer,
              children: pages.map((page, index2) => {
                const position = sortablePositionItems[page.id] ?? {
                  offsetY: 0
                };
                return isEditing ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    "data-testid": "page-menu.item",
                    "data-pageid": page.id,
                    className: "tlui-page_menu__item__sortable",
                    style: {
                      zIndex: page.id === currentPage.id ? 888 : index2,
                      transform: `translate(0px, ${position.y + position.offsetY}px)`
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        TldrawUiButton,
                        {
                          type: "icon",
                          tabIndex: -1,
                          className: "tlui-page_menu__item__sortable__handle",
                          onPointerDown: handlePointerDown,
                          onPointerUp: handlePointerUp,
                          onPointerMove: handlePointerMove,
                          onKeyDown: handleKeyDown2,
                          "data-id": page.id,
                          "data-index": index2,
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "drag-handle-dots" })
                        }
                      ),
                      shouldUseWindowPrompt ? (
                        // sigh, this is a workaround for iOS Safari
                        // because the device and the radix popover seem
                        // to be fighting over scroll position. Nothing
                        // else seems to work!
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiButton, {
                          type: "normal",
                          className: "tlui-page-menu__item__button",
                          onClick: () => {
                            const name = window.prompt(msg2("action.rename"), page.name);
                            if (name && name !== page.name) {
                              renamePage(page.id, name);
                            }
                          },
                          onDoubleClick: toggleEditing,
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonCheck, { checked: page.id === currentPage.id }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: page.name })
                          ]
                        })
                      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: "tlui-page_menu__item__sortable__title",
                          style: { height: ITEM_HEIGHT },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                            PageItemInput,
                            {
                              id: page.id,
                              name: page.name,
                              isCurrentPage: page.id === currentPage.id,
                              onComplete: () => {
                                setIsEditing(false);
                              },
                              onCancel: () => {
                                setIsEditing(false);
                              }
                            }
                          )
                        }
                      ),
                      !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-page_menu__item__submenu", "data-isediting": isEditing, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PageItemSubmenu, { index: index2, item: page, listSize: pages.length }) })
                    ]
                  },
                  page.id + "_editing"
                ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    "data-pageid": page.id,
                    "data-testid": "page-menu.item",
                    className: "tlui-page-menu__item",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        TldrawUiButton,
                        {
                          type: "normal",
                          className: "tlui-page-menu__item__button",
                          onClick: () => changePage(page.id),
                          onDoubleClick: toggleEditing,
                          title: msg2("page-menu.go-to-page"),
                          onKeyDown: (e) => {
                            if (e.key === "Enter") {
                              if (page.id === currentPage.id) {
                                toggleEditing();
                                editor.markEventAsHandled(e);
                              }
                            }
                          },
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonCheck, { checked: page.id === currentPage.id }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: page.name })
                          ]
                        }
                      ),
                      !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-page_menu__item__submenu", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        PageItemSubmenu,
                        {
                          index: index2,
                          item: page,
                          listSize: pages.length,
                          onRename: () => {
                            if (shouldUseWindowPrompt) {
                              const name = window.prompt(msg2("action.rename"), page.name);
                              if (name && name !== page.name) {
                                renamePage(page.id, name);
                              }
                            } else {
                              setIsEditing(true);
                              if (currentPageId !== page.id) {
                                changePage(page.id);
                              }
                            }
                          }
                        }
                      ) })
                    ]
                  },
                  page.id
                );
              })
            }
          )
        ] })
      }
    )
  ] });
});
function DefaultQuickActionsContent() {
  const editor = useEditor();
  const isReadonlyMode = useReadonly();
  const isInAcceptableReadonlyState = useValue(
    "should display quick actions",
    () => editor.isInAny("select", "hand", "zoom"),
    [editor]
  );
  if (isReadonlyMode && !isInAcceptableReadonlyState) return;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(UndoRedoGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteDuplicateGroup, {})
  ] });
}
function DeleteDuplicateGroup() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const selectDependentActionsEnabled = oneSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "delete", disabled: !selectDependentActionsEnabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "duplicate", disabled: !selectDependentActionsEnabled })
  ] });
}
function UndoRedoGroup() {
  const canUndo = useCanUndo();
  const canRedo = useCanRedo();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "undo", disabled: !canUndo }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "redo", disabled: !canRedo })
  ] });
}
const DefaultQuickActions = reactExports.memo(function DefaultQuickActions2({
  children
}) {
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultQuickActionsContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "small-icons", sourceId: "quick-actions", children: content });
});
function PeopleMenuAvatar({ userId }) {
  const presence = usePresence$1(userId);
  if (!presence) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "tlui-people-menu__avatar",
      style: {
        backgroundColor: presence.color
      },
      children: presence.userName?.[0] ?? ""
    },
    userId
  );
}
const PeopleMenuItem = track(function PeopleMenuItem2({ userId }) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const trackEvent = useUiEvents();
  const presence = usePresence$1(userId);
  const handleFollowClick = reactExports.useCallback(() => {
    if (editor.getInstanceState().followingUserId === userId) {
      editor.stopFollowingUser();
      trackEvent("stop-following", { source: "people-menu" });
    } else {
      editor.startFollowingUser(userId);
      trackEvent("start-following", { source: "people-menu" });
    }
  }, [editor, userId, trackEvent]);
  const theyAreFollowingYou = presence?.followingUserId === editor.user.getId();
  const youAreFollowingThem = editor.getInstanceState().followingUserId === userId;
  if (!presence) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TldrawUiRow,
    {
      className: "tlui-people-menu__item",
      "data-follow": youAreFollowingThem || theyAreFollowingYou,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          TldrawUiButton,
          {
            type: "menu",
            className: "tlui-people-menu__item__button",
            onClick: () => editor.zoomToUser(userId),
            onDoubleClick: handleFollowClick,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiIcon, { label: msg2("people-menu.avatar-color"), icon: "color", color: presence.color }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-people-menu__name", children: presence.userName?.trim() || msg2("people-menu.anonymous-user") })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButton,
          {
            type: "icon",
            className: "tlui-people-menu__item__follow",
            title: theyAreFollowingYou ? msg2("people-menu.leading") : youAreFollowingThem ? msg2("people-menu.following") : msg2("people-menu.follow"),
            onClick: handleFollowClick,
            disabled: theyAreFollowingYou,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TldrawUiButtonIcon,
              {
                icon: theyAreFollowingYou ? "leading" : youAreFollowingThem ? "following" : "follow"
              }
            )
          }
        )
      ]
    }
  );
});
function PeopleMenuMore({ count: count2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-people-menu__avatar tlui-people-menu__more", children: Math.abs(count2) });
}
const UserPresenceColorPicker = track(function UserPresenceColorPicker2() {
  const editor = useEditor();
  const container = useContainer();
  const msg2 = useTranslation();
  const trackEvent = useUiEvents();
  const rPointing = reactExports.useRef(false);
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const handleOpenChange = reactExports.useCallback((isOpen2) => {
    setIsOpen(isOpen2);
  }, []);
  const value = editor.user.getColor();
  const onValueChange = reactExports.useCallback(
    (item) => {
      editor.user.updateUserPreferences({ color: item });
      trackEvent("set-color", { source: "people-menu" });
    },
    [editor, trackEvent]
  );
  const {
    handleButtonClick,
    handleButtonPointerDown,
    handleButtonPointerEnter,
    handleButtonPointerUp
  } = React.useMemo(() => {
    const handlePointerUp = () => {
      rPointing.current = false;
      window.removeEventListener("pointerup", handlePointerUp);
    };
    const handleButtonClick2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      if (value === id) return;
      onValueChange(id);
    };
    const handleButtonPointerDown2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      onValueChange(id);
      rPointing.current = true;
      window.addEventListener("pointerup", handlePointerUp);
    };
    const handleButtonPointerEnter2 = (e) => {
      if (!rPointing.current) return;
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      onValueChange(id);
    };
    const handleButtonPointerUp2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      onValueChange(id);
    };
    return {
      handleButtonClick: handleButtonClick2,
      handleButtonPointerDown: handleButtonPointerDown2,
      handleButtonPointerEnter: handleButtonPointerEnter2,
      handleButtonPointerUp: handleButtonPointerUp2
    };
  }, [value, onValueChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$2, { onOpenChange: handleOpenChange, open: isOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$1, { dir: "ltr", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        type: "icon",
        className: "tlui-people-menu__user__color",
        style: { color: editor.user.getColor() },
        title: msg2("people-menu.change-color"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "color" })
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$1,
      {
        dir: "ltr",
        className: "tlui-menu tlui-people-menu__user__color-picker",
        align: "start",
        side: "left",
        sideOffset: 8,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiGrid, { children: USER_COLORS.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButton,
          {
            type: "icon",
            "data-id": item,
            "data-testid": item,
            "aria-label": item,
            isActive: value === item,
            title: item,
            style: { color: item },
            onPointerEnter: handleButtonPointerEnter,
            onPointerDown: handleButtonPointerDown,
            onPointerUp: handleButtonPointerUp,
            onClick: handleButtonClick,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "color" })
          },
          item
        )) })
      }
    ) })
  ] });
});
function UserPresenceEditor() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const userName = useValue("userName", () => editor.user.getName(), []);
  const msg2 = useTranslation();
  const rOriginalName = reactExports.useRef(userName);
  const rCurrentName = reactExports.useRef(userName);
  const [isEditingName, setIsEditingName] = reactExports.useState(false);
  const toggleEditingName = reactExports.useCallback(() => {
    setIsEditingName((s) => !s);
  }, []);
  const handleValueChange = reactExports.useCallback(
    (value) => {
      rCurrentName.current = value;
      editor.user.updateUserPreferences({ name: value });
    },
    [editor]
  );
  const handleBlur = reactExports.useCallback(() => {
    if (rOriginalName.current === rCurrentName.current) return;
    trackEvent("change-user-name", { source: "people-menu" });
    rOriginalName.current = rCurrentName.current;
  }, [trackEvent]);
  const handleCancel = reactExports.useCallback(() => {
    setIsEditingName(false);
    editor.user.updateUserPreferences({ name: rOriginalName.current });
    editor.menus.clearOpenMenus();
  }, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-people-menu__user", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(UserPresenceColorPicker, {}),
    isEditingName ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiInput,
      {
        className: "tlui-people-menu__user__input",
        defaultValue: userName,
        onValueChange: handleValueChange,
        onComplete: toggleEditingName,
        onCancel: handleCancel,
        onBlur: handleBlur,
        shouldManuallyMaintainScrollPositionWhenFocused: true,
        autoFocus: true,
        autoSelect: true
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "tlui-people-menu__user__name",
          onDoubleClick: () => {
            if (!isEditingName) setIsEditingName(true);
          },
          children: userName || msg2("people-menu.anonymous-user")
        }
      ),
      !userName ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-people-menu__user__label", children: msg2("people-menu.user") }) : null
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        type: "icon",
        className: "tlui-people-menu__user__edit",
        "data-testid": "people-menu.change-name",
        title: msg2("people-menu.change-name"),
        onClick: toggleEditingName,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: isEditingName ? "check" : "edit" })
      }
    )
  ] });
}
function PeopleMenu({ children }) {
  const msg2 = useTranslation();
  const container = useContainer();
  const editor = useEditor();
  const userIds = usePeerIds();
  const userColor = useValue("user", () => editor.user.getColor(), [editor]);
  const userName = useValue("user", () => editor.user.getName(), [editor]);
  const [isOpen, onOpenChange] = useMenuIsOpen("people menu");
  const breakpoint = useBreakpoint();
  const maxAvatars = breakpoint <= PORTRAIT_BREAKPOINT.MOBILE_XS ? 1 : 5;
  if (!userIds.length) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$2, { onOpenChange, open: isOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$1, { dir: "ltr", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "tlui-people-menu__avatars-button", title: msg2("people-menu.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-people-menu__avatars", children: [
      userIds.slice(-maxAvatars).map((userId) => /* @__PURE__ */ jsxRuntimeExports.jsx(PeopleMenuAvatar, { userId }, userId)),
      userIds.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "tlui-people-menu__avatar",
          style: {
            backgroundColor: userColor
          },
          children: userName?.[0] ?? ""
        }
      ),
      userIds.length > maxAvatars && /* @__PURE__ */ jsxRuntimeExports.jsx(PeopleMenuMore, { count: userIds.length - maxAvatars })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$1,
      {
        dir: "ltr",
        className: "tlui-menu",
        side: "bottom",
        sideOffset: 2,
        collisionPadding: 4,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-people-menu__wrapper", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-people-menu__section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserPresenceEditor, {}) }),
          userIds.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-people-menu__section", children: userIds.map((userId) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(PeopleMenuItem, { userId }, userId + "_presence");
          }) }),
          children
        ] })
      }
    ) })
  ] });
}
function DefaultSharePanel() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-share-zone", draggable: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PeopleMenu, {}) });
}
const selectToolStyles = Object.freeze([
  DefaultColorStyle,
  DefaultDashStyle,
  DefaultFillStyle,
  DefaultSizeStyle
]);
function useRelevantStyles(stylesToCheck = selectToolStyles) {
  const editor = useEditor();
  return useValue(
    "getRelevantStyles",
    () => {
      const styles = new SharedStyleMap(editor.getSharedStyles());
      const isInShapeSpecificTool = !!editor.root.getCurrent()?.shapeType;
      const hasShapesSelected = editor.isIn("select") && editor.getSelectedShapeIds().length > 0;
      if (styles.size === 0 && editor.isIn("select") && editor.getSelectedShapeIds().length === 0) {
        for (const style2 of stylesToCheck) {
          styles.applyValue(style2, editor.getStyleForNextShape(style2));
        }
      }
      if (isInShapeSpecificTool || hasShapesSelected || styles.size > 0) {
        return styles;
      }
      return null;
    },
    [editor]
  );
}
const STYLES = {
  color: [
    { value: "black", icon: "color" },
    { value: "grey", icon: "color" },
    { value: "light-violet", icon: "color" },
    { value: "violet", icon: "color" },
    { value: "blue", icon: "color" },
    { value: "light-blue", icon: "color" },
    { value: "yellow", icon: "color" },
    { value: "orange", icon: "color" },
    { value: "green", icon: "color" },
    { value: "light-green", icon: "color" },
    { value: "light-red", icon: "color" },
    { value: "red", icon: "color" }
  ],
  fill: [
    { value: "none", icon: "fill-none" },
    { value: "semi", icon: "fill-semi" },
    { value: "solid", icon: "fill-solid" },
    { value: "pattern", icon: "fill-pattern" }
    // { value: 'fill', icon: 'fill-fill' },
  ],
  dash: [
    { value: "draw", icon: "dash-draw" },
    { value: "dashed", icon: "dash-dashed" },
    { value: "dotted", icon: "dash-dotted" },
    { value: "solid", icon: "dash-solid" }
  ],
  size: [
    { value: "s", icon: "size-small" },
    { value: "m", icon: "size-medium" },
    { value: "l", icon: "size-large" },
    { value: "xl", icon: "size-extra-large" }
  ],
  font: [
    { value: "draw", icon: "font-draw" },
    { value: "sans", icon: "font-sans" },
    { value: "serif", icon: "font-serif" },
    { value: "mono", icon: "font-mono" }
  ],
  textAlign: [
    { value: "start", icon: "text-align-left" },
    { value: "middle", icon: "text-align-center" },
    { value: "end", icon: "text-align-right" }
  ],
  horizontalAlign: [
    { value: "start", icon: "horizontal-align-start" },
    { value: "middle", icon: "horizontal-align-middle" },
    { value: "end", icon: "horizontal-align-end" }
  ],
  verticalAlign: [
    { value: "start", icon: "vertical-align-start" },
    { value: "middle", icon: "vertical-align-middle" },
    { value: "end", icon: "vertical-align-end" }
  ],
  geo: [
    { value: "rectangle", icon: "geo-rectangle" },
    { value: "ellipse", icon: "geo-ellipse" },
    { value: "triangle", icon: "geo-triangle" },
    { value: "diamond", icon: "geo-diamond" },
    { value: "star", icon: "geo-star" },
    { value: "pentagon", icon: "geo-pentagon" },
    { value: "hexagon", icon: "geo-hexagon" },
    { value: "octagon", icon: "geo-octagon" },
    { value: "rhombus", icon: "geo-rhombus" },
    { value: "rhombus-2", icon: "geo-rhombus-2" },
    { value: "oval", icon: "geo-oval" },
    { value: "trapezoid", icon: "geo-trapezoid" },
    { value: "arrow-left", icon: "geo-arrow-left" },
    { value: "arrow-up", icon: "geo-arrow-up" },
    { value: "arrow-down", icon: "geo-arrow-down" },
    { value: "arrow-right", icon: "geo-arrow-right" },
    { value: "cloud", icon: "geo-cloud" },
    { value: "x-box", icon: "geo-x-box" },
    { value: "check-box", icon: "geo-check-box" },
    { value: "heart", icon: "geo-heart" }
  ],
  arrowKind: [
    { value: "arc", icon: "arrow-arc" },
    { value: "elbow", icon: "arrow-elbow" }
  ],
  arrowheadStart: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  arrowheadEnd: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  spline: [
    { value: "line", icon: "spline-line" },
    { value: "cubic", icon: "spline-cubic" }
  ]
};
const TldrawUiSlider = React.forwardRef(function Slider2({
  onHistoryMark,
  title,
  min: min2,
  steps,
  value,
  label,
  onValueChange,
  ["data-testid"]: testId,
  ariaValueModifier = 1
}, ref) {
  const msg2 = useTranslation();
  const [titleAndLabel, setTitleAndLabel] = reactExports.useState("");
  const [tabIndex, setTabIndex] = reactExports.useState(-1);
  reactExports.useEffect(() => {
    setTabIndex(0);
  }, []);
  const handleValueChange = reactExports.useCallback(
    (value2) => {
      onValueChange(value2[0]);
    },
    [onValueChange]
  );
  const handlePointerDown = reactExports.useCallback(() => {
    tooltipManager.hideAllTooltips();
    onHistoryMark?.("click slider");
  }, [onHistoryMark]);
  reactExports.useEffect(() => {
    const timeout = tltime.setTimeout(
      "set title and label",
      () => {
        setTitleAndLabel(title + "  " + msg2(label));
      },
      0
    );
    return () => clearTimeout(timeout);
  }, [label, msg2, title]);
  const handleKeyEvent = reactExports.useCallback((event) => {
    if (event.key === "Tab") {
      event.stopPropagation();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-slider__container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiTooltip, { content: titleAndLabel, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Root,
    {
      "data-testid": testId,
      className: "tlui-slider",
      dir: "ltr",
      min: min2 ?? 0,
      max: steps,
      step: 1,
      value: value !== null ? [value] : void 0,
      onPointerDown: handlePointerDown,
      onValueChange: handleValueChange,
      onKeyDownCapture: handleKeyEvent,
      onKeyUpCapture: handleKeyEvent,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Track, { className: "tlui-slider__track", dir: "ltr", children: value !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(Range$1, { className: "tlui-slider__range", dir: "ltr" }) }),
        value !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Thumb,
          {
            "aria-valuemin": (min2 ?? 0) * ariaValueModifier,
            "aria-valuenow": value * ariaValueModifier,
            "aria-valuemax": steps * ariaValueModifier,
            "aria-label": titleAndLabel,
            className: "tlui-slider__thumb",
            dir: "ltr",
            ref,
            tabIndex
          }
        )
      ]
    }
  ) }) });
});
function useDefaultColorTheme() {
  return getDefaultColorTheme({ isDarkMode: useIsDarkMode() });
}
const StylePanelContext = reactExports.createContext(null);
function StylePanelContextProvider({ children, styles }) {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const onHistoryMark = reactExports.useCallback((id) => editor.markHistoryStoppingPoint(id), [editor]);
  const enhancedA11yMode = useValue("enhancedA11yMode", () => editor.user.getEnhancedA11yMode(), [
    editor
  ]);
  const onValueChange = reactExports.useCallback(
    function(style2, value) {
      editor.run(() => {
        if (editor.isIn("select")) {
          editor.setStyleForSelectedShapes(style2, value);
        }
        editor.setStyleForNextShapes(style2, value);
        editor.updateInstanceState({ isChangingStyle: true });
      });
      trackEvent("set-style", { source: "style-panel", id: style2.id, value });
    },
    [editor, trackEvent]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StylePanelContext.Provider,
    {
      value: {
        styles,
        enhancedA11yMode,
        onHistoryMark,
        onValueChange
      },
      children
    }
  );
}
function useStylePanelContext() {
  const context = reactExports.useContext(StylePanelContext);
  if (!context) {
    throw new Error("useStylePanelContext must be used within a StylePanelContextProvider");
  }
  return context;
}
function StylePanelSubheading({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "tlui-style-panel__subheading", children });
}
function StylePanelButtonPickerInner(props) {
  const { enhancedA11yMode } = useStylePanelContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    enhancedA11yMode && /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelSubheading, { children: props.title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: props.title, children: /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelButtonPickerInline, { ...props }) })
  ] });
}
function StylePanelButtonPickerInlineInner(props) {
  const ctx = useStylePanelContext();
  const {
    uiType,
    items,
    title,
    style: style2,
    value,
    onValueChange = ctx.onValueChange,
    onHistoryMark = ctx.onHistoryMark
  } = props;
  const theme = useDefaultColorTheme();
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const rPointing = reactExports.useRef(false);
  const rPointingOriginalActiveElement = reactExports.useRef(null);
  const {
    handleButtonClick,
    handleButtonPointerDown,
    handleButtonPointerEnter,
    handleButtonPointerUp
  } = reactExports.useMemo(() => {
    const handlePointerUp = () => {
      rPointing.current = false;
      window.removeEventListener("pointerup", handlePointerUp);
      const origActiveEl = rPointingOriginalActiveElement.current;
      if (origActiveEl && (["TEXTAREA", "INPUT"].includes(origActiveEl.nodeName) || origActiveEl.isContentEditable)) {
        origActiveEl.focus();
      } else if (breakpoint >= PORTRAIT_BREAKPOINT.TABLET_SM) {
        editor.getContainer().focus();
      }
      rPointingOriginalActiveElement.current = null;
    };
    const handleButtonClick2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (value.type === "shared" && value.value === id) return;
      onHistoryMark?.("point picker item");
      onValueChange(style2, id);
    };
    const handleButtonPointerDown2 = (e) => {
      const { id } = e.currentTarget.dataset;
      onHistoryMark?.("point picker item");
      onValueChange(style2, id);
      rPointing.current = true;
      rPointingOriginalActiveElement.current = document.activeElement;
      window.addEventListener("pointerup", handlePointerUp);
    };
    const handleButtonPointerEnter2 = (e) => {
      if (!rPointing.current) return;
      const { id } = e.currentTarget.dataset;
      onValueChange(style2, id);
    };
    const handleButtonPointerUp2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (value.type === "shared" && value.value === id) return;
      onValueChange(style2, id);
    };
    return {
      handleButtonClick: handleButtonClick2,
      handleButtonPointerDown: handleButtonPointerDown2,
      handleButtonPointerEnter: handleButtonPointerEnter2,
      handleButtonPointerUp: handleButtonPointerUp2
    };
  }, [editor, breakpoint, value, onHistoryMark, onValueChange, style2]);
  const Layout2 = items.length > 4 ? TldrawUiGrid : TldrawUiRow;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiToolbarToggleGroup,
    {
      "data-testid": `style.${uiType}`,
      type: "single",
      value: value.type === "shared" ? value.value : null,
      asChild: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout2, { children: items.map((item) => {
        const isActive2 = value.type === "shared" && value.value === item.value;
        const label = title + "  " + msg2(`${uiType}-style.${item.value}`);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiToolbarToggleItem,
          {
            type: "icon",
            "data-id": item.value,
            "data-testid": `style.${uiType}.${item.value}`,
            "aria-label": label + (isActive2 ? ` (${msg2("style-panel.selected")})` : ""),
            tooltip: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: label }),
              isActive2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                "(",
                msg2("style-panel.selected"),
                ")"
              ] }) : null
            ] }),
            value: item.value,
            "data-state": value.type === "shared" && value.value === item.value ? "on" : "off",
            "data-isactive": isActive2,
            title: label,
            style: style2 === DefaultColorStyle ? { color: getColorValue(theme, item.value, "solid") } : void 0,
            onPointerEnter: handleButtonPointerEnter,
            onPointerDown: handleButtonPointerDown,
            onPointerUp: handleButtonPointerUp,
            onClick: handleButtonClick,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: item.icon })
          },
          item.value
        );
      }) })
    }
  );
}
const StylePanelButtonPicker = reactExports.memo(StylePanelButtonPickerInner);
const StylePanelButtonPickerInline = reactExports.memo(StylePanelButtonPickerInlineInner);
function StylePanelDoubleDropdownPickerInner(props) {
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-style-panel__double-select-picker", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { title: msg2(props.label), className: "tlui-style-panel__double-select-picker-label", children: msg2(props.label) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { orientation: "horizontal", label: msg2(props.label), children: /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelDoubleDropdownPickerInline, { ...props }) })
  ] });
}
function StylePanelDoubleDropdownPickerInlineInner(props) {
  const ctx = useStylePanelContext();
  const {
    uiTypeA,
    uiTypeB,
    labelA,
    labelB,
    itemsA,
    itemsB,
    styleA,
    styleB,
    valueA,
    valueB,
    onValueChange = ctx.onValueChange
  } = props;
  const editor = useEditor();
  const msg2 = useTranslation();
  const [isOpenA, setIsOpenA] = reactExports.useState(false);
  const [isOpenB, setIsOpenB] = reactExports.useState(false);
  const iconA = reactExports.useMemo(
    () => itemsA.find((item) => valueA.type === "shared" && valueA.value === item.value)?.icon ?? "mixed",
    [itemsA, valueA]
  );
  const iconB = reactExports.useMemo(
    () => itemsB.find((item) => valueB.type === "shared" && valueB.value === item.value)?.icon ?? "mixed",
    [itemsB, valueB]
  );
  if (valueA === void 0 && valueB === void 0) return null;
  const idA = `style panel ${uiTypeA} A`;
  const idB = `style panel ${uiTypeB} B`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: idA, open: isOpenA, onOpenChange: setIsOpenA, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": `style.${uiTypeA}`,
          title: msg2(labelA) + "  " + (valueA === null || valueA.type === "mixed" ? msg2("style-panel.mixed") : msg2(`${uiTypeA}-style.${valueA.value}`)),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: iconA, small: true, invertIcon: true })
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverContent, { side: "left", align: "center", sideOffset: 80, alignOffset: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { orientation: "grid", label: msg2(labelA), children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: itemsA.map((item) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiToolbarButton,
          {
            "data-testid": `style.${uiTypeA}.${item.value}`,
            type: "icon",
            onClick: () => {
              onValueChange(styleA, item.value);
              tlmenus.deleteOpenMenu(idA, editor.contextId);
              setIsOpenA(false);
            },
            title: `${msg2(labelA)}  ${msg2(`${uiTypeA}-style.${item.value}`)}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: item.icon, invertIcon: true })
          },
          item.value
        );
      }) }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: idB, open: isOpenB, onOpenChange: setIsOpenB, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": `style.${uiTypeB}`,
          title: msg2(labelB) + "  " + (valueB === null || valueB.type === "mixed" ? msg2("style-panel.mixed") : msg2(`${uiTypeB}-style.${valueB.value}`)),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: iconB, small: true })
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverContent, { side: "left", align: "center", sideOffset: 116, alignOffset: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { orientation: "grid", label: msg2(labelB), children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: itemsB.map((item) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiToolbarButton,
          {
            type: "icon",
            title: `${msg2(labelB)}  ${msg2(`${uiTypeB}-style.${item.value}`)}`,
            "data-testid": `style.${uiTypeB}.${item.value}`,
            onClick: () => {
              onValueChange(styleB, item.value);
              tlmenus.deleteOpenMenu(idB, editor.contextId);
              setIsOpenB(false);
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: item.icon })
          },
          item.value
        );
      }) }) }) })
    ] })
  ] });
}
const StylePanelDoubleDropdownPicker = reactExports.memo(StylePanelDoubleDropdownPickerInner);
const StylePanelDoubleDropdownPickerInline = reactExports.memo(
  StylePanelDoubleDropdownPickerInlineInner
);
function StylePanelDropdownPickerInner(props) {
  const msg2 = useTranslation();
  const toolbarLabel = props.label ? msg2(props.label) : msg2(`style-panel.${props.stylePanelType}`);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: toolbarLabel, children: /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelDropdownPickerInline, { ...props }) });
}
function StylePanelDropdownPickerInlineInner(props) {
  const ctx = useStylePanelContext();
  const {
    id,
    label,
    uiType,
    stylePanelType,
    style: style2,
    items,
    type,
    value,
    onValueChange = ctx.onValueChange
  } = props;
  const msg2 = useTranslation();
  const editor = useEditor();
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const icon = reactExports.useMemo(
    () => items.find((item) => value.type === "shared" && item.value === value.value)?.icon,
    [items, value]
  );
  const stylePanelName = msg2(`style-panel.${stylePanelType}`);
  const titleStr = value.type === "mixed" ? msg2("style-panel.mixed") : stylePanelName + "  " + msg2(`${uiType}-style.${value.value}`);
  const labelStr = label ? msg2(label) : "";
  const popoverId = `style panel ${id}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TldrawUiPopover,
    {
      id: popoverId,
      open: isOpen,
      onOpenChange: setIsOpen,
      className: "tlui-style-panel__dropdown-picker",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          TldrawUiToolbarButton,
          {
            type,
            "data-testid": `style.${uiType}`,
            "data-direction": "left",
            title: titleStr,
            children: [
              labelStr && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: labelStr }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: icon ?? "mixed" })
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverContent, { side: "left", align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { orientation: items.length > 4 ? "grid" : "horizontal", label: labelStr, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: items.map((item) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            TldrawUiToolbarButton,
            {
              type: "icon",
              "data-testid": `style.${uiType}.${item.value}`,
              title: stylePanelName + "  " + msg2(`${uiType}-style.${item.value}`),
              isActive: icon === item.icon,
              onClick: () => {
                ctx.onHistoryMark("select style dropdown item");
                onValueChange(style2, item.value);
                tlmenus.deleteOpenMenu(popoverId, editor.contextId);
                setIsOpen(false);
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: item.icon })
            },
            item.value
          );
        }) }) }) })
      ]
    }
  );
}
const StylePanelDropdownPicker = reactExports.memo(StylePanelDropdownPickerInner);
const StylePanelDropdownPickerInline = reactExports.memo(StylePanelDropdownPickerInlineInner);
function DefaultStylePanelContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(StylePanelSection, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelColorPicker, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelOpacityPicker, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(StylePanelSection, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelFillPicker, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelDashPicker, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelSizePicker, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(StylePanelSection, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelFontPicker, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelTextAlignPicker, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelLabelAlignPicker, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(StylePanelSection, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelGeoShapePicker, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelArrowKindPicker, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelArrowheadPicker, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelSplinePicker, {})
    ] })
  ] });
}
function StylePanelSection({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-style-panel__section", children });
}
function StylePanelColorPicker() {
  const { styles } = useStylePanelContext();
  const msg2 = useTranslation();
  const color = styles.get(DefaultColorStyle);
  if (color === void 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StylePanelButtonPicker,
    {
      title: msg2("style-panel.color"),
      uiType: "color",
      style: DefaultColorStyle,
      items: STYLES.color,
      value: color
    }
  );
}
const tldrawSupportedOpacities = [0.1, 0.25, 0.5, 0.75, 1];
function StylePanelOpacityPicker() {
  const editor = useEditor();
  const { onHistoryMark, enhancedA11yMode } = useStylePanelContext();
  const opacity = useValue("opacity", () => editor.getSharedOpacity(), [editor]);
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const handleOpacityValueChange = React.useCallback(
    (value) => {
      const item = tldrawSupportedOpacities[value];
      editor.run(() => {
        if (editor.isIn("select")) {
          editor.setOpacityForSelectedShapes(item);
        }
        editor.setOpacityForNextShapes(item);
        editor.updateInstanceState({ isChangingStyle: true });
      });
      trackEvent("set-style", { source: "style-panel", id: "opacity", value });
    },
    [editor, trackEvent]
  );
  if (opacity === void 0) return null;
  const opacityIndex = opacity.type === "mixed" ? -1 : tldrawSupportedOpacities.indexOf(
    minBy(
      tldrawSupportedOpacities,
      (supportedOpacity) => Math.abs(supportedOpacity - opacity.value)
    )
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    enhancedA11yMode && /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelSubheading, { children: msg2("style-panel.opacity") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiSlider,
      {
        "data-testid": "style.opacity",
        value: opacityIndex >= 0 ? opacityIndex : tldrawSupportedOpacities.length - 1,
        label: opacity.type === "mixed" ? "style-panel.mixed" : `opacity-style.${opacity.value}`,
        onValueChange: handleOpacityValueChange,
        steps: tldrawSupportedOpacities.length - 1,
        title: msg2("style-panel.opacity"),
        onHistoryMark,
        ariaValueModifier: 25
      }
    )
  ] });
}
function StylePanelFillPicker() {
  const { styles } = useStylePanelContext();
  const msg2 = useTranslation();
  const fill = styles.get(DefaultFillStyle);
  if (fill === void 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StylePanelButtonPicker,
    {
      title: msg2("style-panel.fill"),
      uiType: "fill",
      style: DefaultFillStyle,
      items: STYLES.fill,
      value: fill
    }
  );
}
function StylePanelDashPicker() {
  const { styles } = useStylePanelContext();
  const msg2 = useTranslation();
  const dash = styles.get(DefaultDashStyle);
  if (dash === void 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StylePanelButtonPicker,
    {
      title: msg2("style-panel.dash"),
      uiType: "dash",
      style: DefaultDashStyle,
      items: STYLES.dash,
      value: dash
    }
  );
}
function StylePanelSizePicker() {
  const editor = useEditor();
  const { styles, onValueChange } = useStylePanelContext();
  const msg2 = useTranslation();
  const size2 = styles.get(DefaultSizeStyle);
  if (size2 === void 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StylePanelButtonPicker,
    {
      title: msg2("style-panel.size"),
      uiType: "size",
      style: DefaultSizeStyle,
      items: STYLES.size,
      value: size2,
      onValueChange: (style2, value) => {
        onValueChange(style2, value);
        const selectedShapeIds = editor.getSelectedShapeIds();
        if (selectedShapeIds.length > 0) {
          kickoutOccludedShapes(editor, selectedShapeIds);
        }
      }
    }
  );
}
function StylePanelFontPicker() {
  const { styles } = useStylePanelContext();
  const msg2 = useTranslation();
  const font = styles.get(DefaultFontStyle);
  if (font === void 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StylePanelButtonPicker,
    {
      title: msg2("style-panel.font"),
      uiType: "font",
      style: DefaultFontStyle,
      items: STYLES.font,
      value: font
    }
  );
}
function StylePanelTextAlignPicker() {
  const { styles, enhancedA11yMode } = useStylePanelContext();
  const msg2 = useTranslation();
  const textAlign = styles.get(DefaultTextAlignStyle);
  if (textAlign === void 0) return null;
  const title = msg2("style-panel.align");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    enhancedA11yMode && /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelSubheading, { children: title }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiToolbar, { orientation: "horizontal", label: title, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        StylePanelButtonPickerInline,
        {
          title,
          uiType: "align",
          style: DefaultTextAlignStyle,
          items: STYLES.textAlign,
          value: textAlign
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          title: msg2("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "vertical-align-middle" })
        }
      )
    ] })
  ] });
}
function StylePanelLabelAlignPicker() {
  const { styles, enhancedA11yMode } = useStylePanelContext();
  const msg2 = useTranslation();
  const labelAlign = styles.get(DefaultHorizontalAlignStyle);
  const verticalLabelAlign = styles.get(DefaultVerticalAlignStyle);
  if (labelAlign === void 0) return null;
  const title = msg2("style-panel.label-align");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    enhancedA11yMode && /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelSubheading, { children: title }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiToolbar, { orientation: "horizontal", label: title, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        StylePanelButtonPickerInline,
        {
          title,
          uiType: "align",
          style: DefaultHorizontalAlignStyle,
          items: STYLES.horizontalAlign,
          value: labelAlign
        }
      ),
      verticalLabelAlign === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          title: msg2("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "vertical-align-middle" })
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        StylePanelDropdownPickerInline,
        {
          type: "icon",
          id: "geo-vertical-alignment",
          uiType: "verticalAlign",
          stylePanelType: "vertical-align",
          style: DefaultVerticalAlignStyle,
          items: STYLES.verticalAlign,
          value: verticalLabelAlign
        }
      )
    ] })
  ] });
}
function StylePanelGeoShapePicker() {
  const { styles } = useStylePanelContext();
  const geo = styles.get(GeoShapeGeoStyle);
  if (geo === void 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StylePanelDropdownPicker,
    {
      label: "style-panel.geo",
      type: "menu",
      id: "geo",
      uiType: "geo",
      stylePanelType: "geo",
      style: GeoShapeGeoStyle,
      items: STYLES.geo,
      value: geo
    }
  );
}
function StylePanelArrowKindPicker() {
  const { styles } = useStylePanelContext();
  const arrowKind = styles.get(ArrowShapeKindStyle);
  if (arrowKind === void 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StylePanelDropdownPicker,
    {
      id: "arrow-kind",
      type: "menu",
      label: "style-panel.arrow-kind",
      uiType: "arrow-kind",
      stylePanelType: "arrow-kind",
      style: ArrowShapeKindStyle,
      items: STYLES.arrowKind,
      value: arrowKind
    }
  );
}
function StylePanelArrowheadPicker() {
  const { styles } = useStylePanelContext();
  const arrowheadEnd = styles.get(ArrowShapeArrowheadEndStyle);
  const arrowheadStart = styles.get(ArrowShapeArrowheadStartStyle);
  if (arrowheadEnd === void 0 || arrowheadStart === void 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StylePanelDoubleDropdownPicker,
    {
      label: "style-panel.arrowheads",
      uiTypeA: "arrowheadStart",
      styleA: ArrowShapeArrowheadStartStyle,
      itemsA: STYLES.arrowheadStart,
      valueA: arrowheadStart,
      uiTypeB: "arrowheadEnd",
      styleB: ArrowShapeArrowheadEndStyle,
      itemsB: STYLES.arrowheadEnd,
      valueB: arrowheadEnd,
      labelA: "style-panel.arrowhead-start",
      labelB: "style-panel.arrowhead-end"
    }
  );
}
function StylePanelSplinePicker() {
  const { styles } = useStylePanelContext();
  const spline = styles.get(LineShapeSplineStyle);
  if (spline === void 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StylePanelDropdownPicker,
    {
      type: "menu",
      id: "spline",
      uiType: "spline",
      stylePanelType: "spline",
      label: "style-panel.spline",
      style: LineShapeSplineStyle,
      items: STYLES.spline,
      value: spline
    }
  );
}
const DefaultStylePanel = reactExports.memo(function DefaultStylePanel2({
  isMobile,
  styles,
  children
}) {
  const editor = useEditor();
  const enhancedA11yMode = useValue("enhancedA11yMode", () => editor.user.getEnhancedA11yMode(), [
    editor
  ]);
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const handlePointerOut = reactExports.useCallback(() => {
    if (!isMobile) {
      editor.updateInstanceState({ isChangingStyle: false });
    }
  }, [editor, isMobile]);
  const defaultStyles = useRelevantStyles();
  if (styles === void 0) {
    styles = defaultStyles;
  }
  reactExports.useEffect(() => {
    function handleKeyDown2(event) {
      if (event.key === "Escape" && ref.current?.contains(document.activeElement)) {
        event.stopPropagation();
        editor.getContainer().focus();
      }
    }
    const stylePanelContainerEl = ref.current;
    stylePanelContainerEl?.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => {
      stylePanelContainerEl?.removeEventListener("keydown", handleKeyDown2, { capture: true });
    };
  }, [editor]);
  return styles && /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      "data-testid": "style.panel",
      className: classNames("tlui-style-panel", { "tlui-style-panel__wrapper": !isMobile }),
      "data-ismobile": isMobile,
      "data-enhanced-a11y-mode": enhancedA11yMode,
      onPointerLeave: handlePointerOut,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanelContextProvider, { styles, children: children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultStylePanelContent, {}) })
    }
  );
});
const DEFAULT_TOAST_DURATION = 4e3;
const SEVERITY_TO_ICON = {
  success: "check-circle",
  warning: "warning-triangle",
  error: "cross-circle",
  info: "info-circle"
};
function TldrawUiToast({ toast }) {
  const { removeToast } = useToasts();
  const msg2 = useTranslation();
  const onOpenChange = (isOpen) => {
    if (!isOpen) {
      removeToast(toast.id);
    }
  };
  const hasActions = toast.actions && toast.actions.length > 0;
  const icon = toast.icon || toast.severity && SEVERITY_TO_ICON[toast.severity];
  const iconLabel = toast.iconLabel || (toast.severity ? msg2(`toast.${toast.severity}`) : "");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Root2$1,
    {
      onOpenChange,
      className: "tlui-toast__container",
      duration: toast.keepOpen ? Infinity : DEFAULT_TOAST_DURATION,
      "data-severity": toast.severity,
      children: [
        icon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-toast__icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiIcon, { label: iconLabel, icon }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "tlui-toast__main",
            "data-title": !!toast.title,
            "data-description": !!toast.description,
            "data-actions": !!toast.actions,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-toast__content", children: [
                toast.title && /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { className: "tlui-toast__title", children: toast.title }),
                toast.description && /* @__PURE__ */ jsxRuntimeExports.jsx(Description, { className: "tlui-toast__description", children: toast.description })
              ] }),
              toast.actions && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-toast__actions", children: [
                toast.actions.map((action, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(Action, { altText: action.label, asChild: true, onClick: action.onClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: action.type, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: action.label }) }) }, i)),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Close, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TldrawUiButton,
                  {
                    type: "normal",
                    className: "tlui-toast__close",
                    style: { marginLeft: "auto" },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: toast.closeLabel ?? msg2("toast.close") })
                  }
                ) })
              ] })
            ]
          }
        ),
        !hasActions && /* @__PURE__ */ jsxRuntimeExports.jsx(Close, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "normal", className: "tlui-toast__close", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: toast.closeLabel ?? msg2("toast.close") }) }) })
      ]
    }
  );
}
const DefaultToasts = reactExports.memo(function TldrawUiToasts() {
  const { toasts } = useToasts();
  const toastsArray = useValue("toasts", () => toasts.get(), []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    toastsArray.map((toast) => /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToast, { toast }, toast.id)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToastViewport, { className: "tlui-toast__viewport" })
  ] });
});
const MOVE_TIMEOUT = 150;
const HIDE_VISIBILITY_TIMEOUT = 16;
const SHOW_VISIBILITY_TIMEOUT = 16;
const MIN_DISTANCE_TO_REPOSITION_SQUARED = 16 ** 2;
const TOOLBAR_GAP = 8;
const SCREEN_MARGIN = 16;
const TldrawUiContextualToolbar = ({
  children,
  className,
  isMousingDown,
  getSelectionBounds,
  changeOnlyWhenYChanges = false,
  label
}) => {
  const editor = useEditor();
  const toolbarRef = reactExports.useRef(null);
  usePassThroughWheelEvents(toolbarRef);
  usePassThroughMouseOverEvents(toolbarRef);
  const { isVisible, isInteractive, hide: hide2, show, position, move } = useToolbarVisibilityStateMachine(changeOnlyWhenYChanges);
  const rCouldShowToolbar = reactExports.useRef(false);
  const [hasValidToolbarPosition, setHasValidToolbarPosition] = reactExports.useState(false);
  const contentSizeUpdateCounter = useAtom("content size update counter", 0);
  reactExports.useEffect(() => {
    assert(toolbarRef.current);
    const observer = new ResizeObserver(() => {
      contentSizeUpdateCounter.update((n) => n + 1);
    });
    observer.observe(toolbarRef.current);
    return () => observer.disconnect();
  }, [contentSizeUpdateCounter]);
  reactExports.useEffect(() => {
    let lastContentSizeUpdateCounter = contentSizeUpdateCounter.get();
    return react("toolbar position", function updateToolbarPositionAndDisplay() {
      const toolbarElm = toolbarRef.current;
      if (!toolbarElm) return;
      const nextContentSizeUpdateCounter = contentSizeUpdateCounter.get();
      editor.getCamera();
      contentSizeUpdateCounter.get();
      const position2 = getToolbarScreenPosition(editor, toolbarElm, getSelectionBounds);
      if (!position2) {
        if (rCouldShowToolbar.current) {
          rCouldShowToolbar.current = false;
          setHasValidToolbarPosition(false);
        }
      } else {
        const cameraState2 = editor.getCameraState();
        if (cameraState2 === "moving") {
          const elm = toolbarRef.current;
          elm.style.setProperty("transform", `translate(${position2.x}px, ${position2.y}px)`);
        } else {
          const moveImmediately = lastContentSizeUpdateCounter !== nextContentSizeUpdateCounter;
          move(position2.x, position2.y, moveImmediately);
        }
        if (!rCouldShowToolbar.current) {
          rCouldShowToolbar.current = true;
          setHasValidToolbarPosition(true);
        }
      }
      lastContentSizeUpdateCounter = nextContentSizeUpdateCounter;
    });
  }, [editor, getSelectionBounds, contentSizeUpdateCounter, move]);
  const cameraState = useValue("camera state", () => editor.getCameraState(), [editor]);
  reactExports.useEffect(() => {
    if (isMousingDown || !hasValidToolbarPosition) {
      hide2();
      return;
    }
    show();
  }, [hasValidToolbarPosition, cameraState, isMousingDown, show, hide2]);
  reactExports.useLayoutEffect(() => {
    const elm = toolbarRef.current;
    if (!elm) return;
    elm.dataset.visible = `${isVisible}`;
  }, [isVisible, position]);
  reactExports.useLayoutEffect(() => {
    const elm = toolbarRef.current;
    if (!elm) return;
    elm.style.setProperty("transform", `translate(${position.x}px, ${position.y}px)`);
  }, [position]);
  reactExports.useLayoutEffect(() => {
    const elm = toolbarRef.current;
    if (!elm) return;
    elm.dataset.interactive = `${isInteractive}`;
  }, [isInteractive]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: toolbarRef,
      "data-interactive": false,
      "data-visible": false,
      "data-testid": "contextual-toolbar",
      className: classNames("tlui-contextual-toolbar", className),
      onPointerDown: editor.markEventAsHandled,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbar,
        {
          orientation: "horizontal",
          className: "tlui-menu",
          label,
          tooltipSide: "top",
          children
        }
      )
    }
  );
};
function rectToBox(rect) {
  return new Box(rect.x, rect.y, rect.width, rect.height);
}
function getToolbarScreenPosition(editor, toolbarElm, getSelectionBounds) {
  const selectionBounds = getSelectionBounds()?.clone();
  if (!selectionBounds) return;
  const vsb = editor.getViewportScreenBounds();
  selectionBounds.x -= vsb.x;
  selectionBounds.y -= vsb.y;
  if (selectionBounds.midY < SCREEN_MARGIN || selectionBounds.midY > vsb.h - SCREEN_MARGIN || selectionBounds.midX < SCREEN_MARGIN || selectionBounds.midX > vsb.w - SCREEN_MARGIN) {
    return;
  }
  const toolbarBounds = rectToBox(toolbarElm.getBoundingClientRect());
  if (!toolbarBounds.width || !toolbarBounds.height) return;
  const { scrollLeft, scrollTop } = editor.getContainer();
  let x = selectionBounds.midX - toolbarBounds.w / 2;
  let y = selectionBounds.y - toolbarBounds.h - TOOLBAR_GAP;
  x = clamp$3(x, SCREEN_MARGIN, vsb.w - toolbarBounds.w - SCREEN_MARGIN);
  y = clamp$3(y, SCREEN_MARGIN, vsb.h - toolbarBounds.h - SCREEN_MARGIN);
  x += scrollLeft;
  y += scrollTop;
  x = Math.round(x);
  y = Math.round(y);
  return { x, y };
}
function sufficientlyDistant(curr, next, changeOnlyWhenYChanges) {
  if (changeOnlyWhenYChanges) {
    return Vec.Sub(next, curr).y ** 2 >= MIN_DISTANCE_TO_REPOSITION_SQUARED;
  }
  return Vec.Len2(Vec.Sub(next, curr)) >= MIN_DISTANCE_TO_REPOSITION_SQUARED;
}
function useToolbarVisibilityStateMachine(changeOnlyWhenYChanges) {
  const editor = useEditor();
  const rState = reactExports.useRef({ name: "hidden" });
  const [isInteractive, setIsInteractive] = reactExports.useState(false);
  const [isVisible, setIsVisible] = reactExports.useState(false);
  const [position, setPosition] = reactExports.useState({ x: -1e3, y: -1e3 });
  const rCurrPosition = reactExports.useRef(new Vec(-1e3, -1e3));
  const rNextPosition = reactExports.useRef(new Vec(-1e3, -1e3));
  const rStableVisibilityTimeout = reactExports.useRef(-1);
  const rStablePositionTimeout = reactExports.useRef(-1);
  const move = reactExports.useCallback(
    (x, y, immediate = false) => {
      rNextPosition.current.x = x;
      rNextPosition.current.y = y;
      if (rState.current.name === "hidden" || rState.current.name === "showing") return;
      clearTimeout(rStablePositionTimeout.current);
      const flushMove = () => {
        if (rState.current.name === "shown" && sufficientlyDistant(rNextPosition.current, rCurrPosition.current, changeOnlyWhenYChanges)) {
          const { x: x2, y: y2 } = rNextPosition.current;
          rCurrPosition.current = new Vec(x2, y2);
          if (immediate) {
            reactDomExports.flushSync(() => setPosition({ x: x2, y: y2 }));
          } else {
            setPosition({ x: x2, y: y2 });
          }
        }
      };
      if (immediate) {
        flushMove();
      } else {
        rStablePositionTimeout.current = editor.timers.setTimeout(flushMove, MOVE_TIMEOUT);
      }
    },
    [editor, changeOnlyWhenYChanges]
  );
  const hide2 = reactExports.useCallback(
    (immediate = false) => {
      switch (rState.current.name) {
        case "showing": {
          clearTimeout(rStableVisibilityTimeout.current);
          rState.current = { name: "hidden" };
          break;
        }
        case "shown": {
          rState.current = { name: "hiding" };
          setIsInteractive(false);
          if (immediate) {
            rState.current = { name: "hidden" };
            setIsVisible(false);
          } else {
            rStableVisibilityTimeout.current = editor.timers.setTimeout(() => {
              rState.current = { name: "hidden" };
              setIsVisible(false);
            }, HIDE_VISIBILITY_TIMEOUT);
          }
          break;
        }
      }
    },
    [editor]
  );
  const show = reactExports.useCallback(() => {
    switch (rState.current.name) {
      case "hidden": {
        rState.current = { name: "showing" };
        rStableVisibilityTimeout.current = editor.timers.setTimeout(() => {
          const { x, y } = rNextPosition.current;
          rCurrPosition.current = new Vec(x, y);
          setPosition({ x, y });
          rState.current = { name: "shown" };
          setIsVisible(true);
          setIsInteractive(true);
        }, SHOW_VISIBILITY_TIMEOUT);
        break;
      }
      case "hiding": {
        clearTimeout(rStableVisibilityTimeout.current);
        rState.current = { name: "shown" };
        setIsInteractive(true);
        move(rNextPosition.current.x, rNextPosition.current.y);
        break;
      }
    }
  }, [editor, move]);
  return { isVisible, isInteractive, show, hide: hide2, move, position };
}
function AltTextEditor({ shapeId, onClose, source }) {
  const editor = useEditor();
  const [altText, setAltText] = reactExports.useState(() => {
    const shape = editor.getShape(shapeId);
    if (!shape) return "";
    if (!("altText" in shape.props)) throw Error("Shape does not have altText property");
    return shape.props.altText || "";
  });
  const msg2 = useTranslation();
  const ref = reactExports.useRef(null);
  const trackEvent = useUiEvents();
  const isReadonly = editor.getIsReadonly();
  const handleValueChange = (value) => setAltText(value);
  const handleComplete = () => {
    trackEvent("set-alt-text", { source });
    const shape = editor.getShape(shapeId);
    if (!shape) return;
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: { altText }
      }
    ]);
    onClose();
  };
  const handleConfirm = () => handleComplete();
  const handleAltTextCancel = reactExports.useCallback(() => onClose(), [onClose]);
  reactExports.useEffect(() => {
    ref.current?.select();
    function handleKeyDown2(event) {
      if (event.key === "Escape") {
        event.stopPropagation();
        handleAltTextCancel();
      }
    }
    document.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown2, { capture: true });
    };
  }, [handleAltTextCancel]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiInput,
      {
        ref,
        className: "tlui-media__toolbar-alt-text-input",
        "data-testid": "media-toolbar.alt-text-input",
        value: altText,
        placeholder: msg2("tool.media-alt-text-desc"),
        "aria-label": msg2("tool.media-alt-text-desc"),
        onValueChange: handleValueChange,
        onComplete: handleComplete,
        onCancel: handleAltTextCancel,
        disabled: isReadonly
      }
    ),
    !isReadonly && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        title: msg2("tool.media-alt-text-confirm"),
        "data-testid": "tool.media-alt-text-confirm",
        type: "icon",
        onPointerDown: preventDefault,
        onClick: handleConfirm,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "check" })
      }
    )
  ] });
}
const MIN_CROP_SIZE = 8;
function getDefaultCrop() {
  return {
    topLeft: { x: 0, y: 0 },
    bottomRight: { x: 1, y: 1 }
  };
}
const ASPECT_RATIO_OPTIONS = [
  "original",
  "square",
  "circle",
  "landscape",
  "portrait",
  "wide"
];
const ASPECT_RATIO_TO_VALUE = {
  original: 0,
  square: 1,
  circle: 1,
  landscape: 4 / 3,
  portrait: 3 / 4,
  wide: 16 / 9
};
function getUncroppedSize(shapeSize, crop) {
  if (!crop) return { w: shapeSize.w, h: shapeSize.h };
  const w = shapeSize.w / (crop.bottomRight.x - crop.topLeft.x);
  const h2 = shapeSize.h / (crop.bottomRight.y - crop.topLeft.y);
  return { w, h: h2 };
}
function getCropDimensions(crop) {
  return {
    width: crop.bottomRight.x - crop.topLeft.x,
    height: crop.bottomRight.y - crop.topLeft.y
  };
}
function getCropCenter(crop) {
  const { width, height } = getCropDimensions(crop);
  return {
    x: crop.topLeft.x + width / 2,
    y: crop.topLeft.y + height / 2
  };
}
function createCropAroundCenter(centerX, centerY, width, height, isCircle) {
  const topLeftX = Math.max(0, Math.min(1 - width, centerX - width / 2));
  const topLeftY = Math.max(0, Math.min(1 - height, centerY - height / 2));
  return {
    topLeft: { x: topLeftX, y: topLeftY },
    bottomRight: { x: topLeftX + width, y: topLeftY + height },
    isCircle
  };
}
function getCropBox(shape, info, opts = {}) {
  const { handle, change, crop, aspectRatioLocked } = info;
  const { w, h: h2 } = info.uncroppedSize;
  const { minWidth = MIN_CROP_SIZE, minHeight = MIN_CROP_SIZE } = opts;
  if (w < minWidth || h2 < minHeight || change.x === 0 && change.y === 0) {
    return;
  }
  const prevCropBox = new Box(
    crop.topLeft.x * w,
    crop.topLeft.y * h2,
    (crop.bottomRight.x - crop.topLeft.x) * w,
    (crop.bottomRight.y - crop.topLeft.y) * h2
  );
  const targetRatio = prevCropBox.aspectRatio;
  const tempBox = prevCropBox.clone();
  if (handle === "top_left" || handle === "bottom_left" || handle === "left") {
    tempBox.x = clamp$3(tempBox.x + change.x, 0, prevCropBox.maxX - minWidth);
    tempBox.w = prevCropBox.maxX - tempBox.x;
  } else if (handle === "top_right" || handle === "bottom_right" || handle === "right") {
    const tempRight = clamp$3(tempBox.maxX + change.x, prevCropBox.x + minWidth, w);
    tempBox.w = tempRight - tempBox.x;
  }
  if (handle === "top_left" || handle === "top_right" || handle === "top") {
    tempBox.y = clamp$3(tempBox.y + change.y, 0, prevCropBox.maxY - minHeight);
    tempBox.h = prevCropBox.maxY - tempBox.y;
  } else if (handle === "bottom_left" || handle === "bottom_right" || handle === "bottom") {
    const tempBottom = clamp$3(tempBox.maxY + change.y, prevCropBox.y + minHeight, h2);
    tempBox.h = tempBottom - tempBox.y;
  }
  if (aspectRatioLocked) {
    const isXLimiting = tempBox.aspectRatio > targetRatio;
    if (isXLimiting) {
      tempBox.h = tempBox.w / targetRatio;
    } else {
      tempBox.w = tempBox.h * targetRatio;
    }
    switch (handle) {
      case "top_left": {
        tempBox.x = prevCropBox.maxX - tempBox.w;
        tempBox.y = prevCropBox.maxY - tempBox.h;
        if (tempBox.x <= 0) {
          tempBox.x = 0;
          tempBox.w = prevCropBox.maxX - tempBox.x;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.y = prevCropBox.maxY - tempBox.h;
        }
        if (tempBox.y <= 0) {
          tempBox.y = 0;
          tempBox.h = prevCropBox.maxY - tempBox.y;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.x = prevCropBox.maxX - tempBox.w;
        }
        break;
      }
      case "top_right": {
        tempBox.x = prevCropBox.x;
        tempBox.y = prevCropBox.maxY - tempBox.h;
        if (tempBox.maxX >= w) {
          tempBox.w = w - prevCropBox.x;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.y = prevCropBox.maxY - tempBox.h;
        }
        if (tempBox.y <= 0) {
          tempBox.y = 0;
          tempBox.h = prevCropBox.maxY - tempBox.y;
          tempBox.w = tempBox.h * targetRatio;
        }
        break;
      }
      case "bottom_left": {
        tempBox.x = prevCropBox.maxX - tempBox.w;
        tempBox.y = prevCropBox.y;
        if (tempBox.x <= 0) {
          tempBox.x = 0;
          tempBox.w = prevCropBox.maxX - tempBox.x;
          tempBox.h = tempBox.w / targetRatio;
        }
        if (tempBox.maxY >= h2) {
          tempBox.h = h2 - prevCropBox.y;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.x = prevCropBox.maxX - tempBox.w;
        }
        break;
      }
      case "bottom_right": {
        tempBox.x = prevCropBox.x;
        tempBox.y = prevCropBox.y;
        if (tempBox.maxX >= w) {
          tempBox.w = w - prevCropBox.x;
          tempBox.h = tempBox.w / targetRatio;
        }
        if (tempBox.maxY >= h2) {
          tempBox.h = h2 - prevCropBox.y;
          tempBox.w = tempBox.h * targetRatio;
        }
        break;
      }
      case "top": {
        tempBox.h = prevCropBox.maxY - tempBox.y;
        tempBox.w = tempBox.h * targetRatio;
        tempBox.x -= (tempBox.w - prevCropBox.w) / 2;
        if (tempBox.x <= 0) {
          const leftSide = prevCropBox.midX;
          tempBox.w = leftSide * 2;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.x = 0;
        }
        if (tempBox.maxX >= w) {
          const rightSide = w - prevCropBox.midX;
          tempBox.w = rightSide * 2;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.x = w - tempBox.w;
        }
        tempBox.y = prevCropBox.maxY - tempBox.h;
        break;
      }
      case "right": {
        tempBox.w = tempBox.maxX - prevCropBox.x;
        tempBox.h = tempBox.w / targetRatio;
        tempBox.y -= (tempBox.h - prevCropBox.h) / 2;
        if (tempBox.y <= 0) {
          const topSide = prevCropBox.midY;
          tempBox.h = topSide * 2;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.y = 0;
        }
        if (tempBox.maxY >= h2) {
          const bottomSide = h2 - prevCropBox.midY;
          tempBox.h = bottomSide * 2;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.y = h2 - tempBox.h;
        }
        break;
      }
      case "bottom": {
        tempBox.h = tempBox.maxY - prevCropBox.y;
        tempBox.w = tempBox.h * targetRatio;
        tempBox.x -= (tempBox.w - prevCropBox.w) / 2;
        if (tempBox.x <= 0) {
          const leftSide = prevCropBox.midX;
          tempBox.w = leftSide * 2;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.x = 0;
        }
        if (tempBox.maxX >= w) {
          const rightSide = w - prevCropBox.midX;
          tempBox.w = rightSide * 2;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.x = w - tempBox.w;
        }
        break;
      }
      case "left": {
        tempBox.w = prevCropBox.maxX - tempBox.x;
        tempBox.h = tempBox.w / targetRatio;
        tempBox.y -= (tempBox.h - prevCropBox.h) / 2;
        if (tempBox.y <= 0) {
          const topSide = prevCropBox.midY;
          tempBox.h = topSide * 2;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.y = 0;
        }
        if (tempBox.maxY >= h2) {
          const bottomSide = h2 - prevCropBox.midY;
          tempBox.h = bottomSide * 2;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.y = h2 - tempBox.h;
        }
        tempBox.x = prevCropBox.maxX - tempBox.w;
        break;
      }
    }
  }
  const newCrop = {
    topLeft: { x: tempBox.x / w, y: tempBox.y / h2 },
    bottomRight: { x: tempBox.maxX / w, y: tempBox.maxY / h2 },
    isCircle: crop.isCircle
  };
  if (newCrop.topLeft.x === crop.topLeft.x && newCrop.topLeft.y === crop.topLeft.y && newCrop.bottomRight.x === crop.bottomRight.x && newCrop.bottomRight.y === crop.bottomRight.y) {
    return;
  }
  const newPoint = new Vec(tempBox.x - crop.topLeft.x * w, tempBox.y - crop.topLeft.y * h2).rot(shape.rotation).add(shape);
  return {
    id: shape.id,
    type: shape.type,
    x: newPoint.x,
    y: newPoint.y,
    props: {
      w: tempBox.w,
      h: tempBox.h,
      crop: newCrop
    }
  };
}
function calculateCropChange(imageShape, newCropWidth, newCropHeight, centerOnCurrentCrop = true, isCircle = false) {
  const { w, h: h2 } = getUncroppedSize(imageShape.props, imageShape.props.crop ?? getDefaultCrop());
  const currentCrop = imageShape.props.crop || getDefaultCrop();
  const imageCenterX = imageShape.x + imageShape.props.w / 2;
  const imageCenterY = imageShape.y + imageShape.props.h / 2;
  let cropCenterX, cropCenterY;
  if (centerOnCurrentCrop) {
    const { x, y } = getCropCenter(currentCrop);
    cropCenterX = x;
    cropCenterY = y;
  } else {
    cropCenterX = 0.5;
    cropCenterY = 0.5;
  }
  const newCrop = createCropAroundCenter(
    cropCenterX,
    cropCenterY,
    newCropWidth,
    newCropHeight,
    isCircle
  );
  const croppedW = newCropWidth * w;
  const croppedH = newCropHeight * h2;
  return {
    crop: newCrop,
    w: croppedW,
    h: croppedH,
    x: imageCenterX - croppedW / 2,
    y: imageCenterY - croppedH / 2
  };
}
const MAX_ZOOM = 3;
function getCroppedImageDataWhenZooming(zoom, imageShape, maxZoom) {
  const oldCrop = imageShape.props.crop || getDefaultCrop();
  const { width: oldWidth, height: oldHeight } = getCropDimensions(oldCrop);
  const aspectRatio = oldWidth / oldHeight;
  const derivedMaxZoom = maxZoom ? 1 / (1 - maxZoom) : MAX_ZOOM;
  const zoomScale = 1 + zoom * (derivedMaxZoom - 1);
  let newWidth, newHeight;
  if (aspectRatio > 1) {
    newWidth = Math.min(1, 1 / zoomScale);
    newHeight = newWidth / aspectRatio;
  } else {
    newHeight = Math.min(1, 1 / zoomScale);
    newWidth = newHeight * aspectRatio;
  }
  const result = calculateCropChange(imageShape, newWidth, newHeight, true, oldCrop.isCircle);
  const scaleFactor = Math.min(MAX_ZOOM, oldWidth / newWidth);
  result.w *= scaleFactor;
  result.h *= scaleFactor;
  const imageCenterX = imageShape.x + imageShape.props.w / 2;
  const imageCenterY = imageShape.y + imageShape.props.h / 2;
  result.x = imageCenterX - result.w / 2;
  result.y = imageCenterY - result.h / 2;
  return result;
}
function getCroppedImageDataForReplacedImage(imageShape, newImageWidth, newImageHeight) {
  const defaultCrop = getDefaultCrop();
  const currentCrop = imageShape.props.crop || defaultCrop;
  const origDisplayW = imageShape.props.w;
  const origDisplayH = imageShape.props.h;
  const newImageAspectRatio = newImageWidth / newImageHeight;
  let crop = defaultCrop;
  let newDisplayW = origDisplayW;
  let newDisplayH = origDisplayH;
  const isOriginalCrop = isEqual(imageShape.props.crop, defaultCrop);
  if (isOriginalCrop) {
    newDisplayW = origDisplayW;
    newDisplayH = origDisplayW * newImageHeight / newImageWidth;
  } else {
    const { w: uncroppedW, h: uncroppedH } = getUncroppedSize(
      imageShape.props,
      imageShape.props.crop || getDefaultCrop()
      // Use the ACTUAL current crop to correctly infer uncropped size
    );
    const { width: cropW, height: cropH } = getCropDimensions(currentCrop);
    const targetRatio = cropW / cropH;
    const oldImageAspectRatio = uncroppedW / uncroppedH;
    let newRelativeWidth;
    let newRelativeHeight;
    const currentCropCenter = getCropCenter(currentCrop);
    newRelativeWidth = cropW;
    const ratioConversion = newImageAspectRatio / oldImageAspectRatio / targetRatio;
    newRelativeHeight = newRelativeWidth * ratioConversion;
    const maxRatioConversion = MAX_ZOOM / (MAX_ZOOM - 1);
    if (ratioConversion > maxRatioConversion) {
      const minDimension = 1 / MAX_ZOOM;
      if (1 / newRelativeHeight < 1 / newRelativeWidth) {
        const scale = newRelativeHeight / minDimension;
        newRelativeHeight = newRelativeHeight / scale;
        newRelativeWidth = newRelativeWidth / scale;
      } else {
        const scale = newRelativeWidth / minDimension;
        newRelativeWidth = newRelativeWidth / scale;
        newRelativeHeight = newRelativeHeight / scale;
      }
    }
    newRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth));
    newRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight));
    crop = createCropAroundCenter(
      currentCropCenter.x,
      currentCropCenter.y,
      newRelativeWidth,
      newRelativeHeight,
      currentCrop.isCircle
    );
  }
  const pageCenterX = imageShape.x + origDisplayW / 2;
  const pageCenterY = imageShape.y + origDisplayH / 2;
  const newX = pageCenterX - newDisplayW / 2;
  const newY = pageCenterY - newDisplayH / 2;
  return {
    crop,
    w: newDisplayW,
    h: newDisplayH,
    x: newX,
    y: newY
  };
}
function getCroppedImageDataForAspectRatio(aspectRatioOption, imageShape) {
  if (aspectRatioOption === "original") {
    const { w, h: h2 } = getUncroppedSize(imageShape.props, imageShape.props.crop ?? getDefaultCrop());
    const imageCenterX = imageShape.x + imageShape.props.w / 2;
    const imageCenterY = imageShape.y + imageShape.props.h / 2;
    return {
      crop: getDefaultCrop(),
      w,
      h: h2,
      x: imageCenterX - w / 2,
      y: imageCenterY - h2 / 2
    };
  }
  const targetRatio = ASPECT_RATIO_TO_VALUE[aspectRatioOption];
  const isCircle = aspectRatioOption === "circle";
  const { w: uncroppedW, h: uncroppedH } = getUncroppedSize(
    imageShape.props,
    imageShape.props.crop || getDefaultCrop()
    // Use the ACTUAL current crop to correctly infer uncropped size
  );
  const imageAspectRatio = uncroppedW / uncroppedH;
  const currentCrop = imageShape.props.crop || getDefaultCrop();
  const { width: cropW, height: cropH } = getCropDimensions(currentCrop);
  const currentCropCenter = getCropCenter(currentCrop);
  const currentCropZoom = Math.min(1 / cropW, 1 / cropH);
  let newRelativeWidth;
  let newRelativeHeight;
  if (imageAspectRatio === 0 || !Number.isFinite(imageAspectRatio) || targetRatio === 0) {
    newRelativeWidth = 1;
    newRelativeHeight = 1;
  } else {
    const currentAbsoluteWidth = cropW * uncroppedW;
    const currentAbsoluteHeight = cropH * uncroppedH;
    const longestCurrentDimension = Math.max(currentAbsoluteWidth, currentAbsoluteHeight);
    const isWidthLongest = currentAbsoluteWidth >= currentAbsoluteHeight;
    let newAbsoluteWidth;
    let newAbsoluteHeight;
    if (isWidthLongest) {
      newAbsoluteWidth = longestCurrentDimension;
      newAbsoluteHeight = newAbsoluteWidth / targetRatio;
    } else {
      newAbsoluteHeight = longestCurrentDimension;
      newAbsoluteWidth = newAbsoluteHeight * targetRatio;
    }
    newRelativeWidth = newAbsoluteWidth / uncroppedW;
    newRelativeHeight = newAbsoluteHeight / uncroppedH;
    if (newRelativeWidth > 1) {
      newRelativeWidth = 1;
      newRelativeHeight = imageAspectRatio / targetRatio;
    }
    if (newRelativeHeight > 1) {
      newRelativeHeight = 1;
      newRelativeWidth = targetRatio / imageAspectRatio;
    }
    newRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth));
    newRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight));
  }
  const newCropZoom = Math.min(1 / newRelativeWidth, 1 / newRelativeHeight);
  newRelativeWidth *= newCropZoom / currentCropZoom;
  newRelativeHeight *= newCropZoom / currentCropZoom;
  newRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth));
  newRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight));
  const newCrop = createCropAroundCenter(
    currentCropCenter.x,
    currentCropCenter.y,
    newRelativeWidth,
    newRelativeHeight,
    isCircle
  );
  const finalRelativeWidth = newCrop.bottomRight.x - newCrop.topLeft.x;
  const finalRelativeHeight = newCrop.bottomRight.y - newCrop.topLeft.y;
  const baseW = finalRelativeWidth * uncroppedW;
  const baseH = finalRelativeHeight * uncroppedH;
  let currentScale = 1;
  if (cropW > 0) {
    currentScale = imageShape.props.w / (cropW * uncroppedW);
  } else if (cropH > 0) {
    currentScale = imageShape.props.h / (cropH * uncroppedH);
  }
  const newW = baseW * currentScale;
  const newH = baseH * currentScale;
  const currentCenterXPage = imageShape.x + imageShape.props.w / 2;
  const currentCenterYPage = imageShape.y + imageShape.props.h / 2;
  const newX = currentCenterXPage - newW / 2;
  const newY = currentCenterYPage - newH / 2;
  return {
    crop: newCrop,
    w: newW,
    h: newH,
    x: newX,
    y: newY
  };
}
const DefaultImageToolbarContent = track(function DefaultImageToolbarContent2({
  imageShapeId,
  isManipulating,
  onEditAltTextStart,
  onManipulatingStart,
  onManipulatingEnd
}) {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const source = "image-toolbar";
  const sliderRef = reactExports.useRef(null);
  const isReadonly = editor.getIsReadonly();
  const crop = useValue("crop", () => editor.getShape(imageShapeId).props.crop, [
    editor,
    imageShapeId
  ]);
  const zoom = crop ? Math.min(1 - (crop.bottomRight.x - crop.topLeft.x), 1 - (crop.bottomRight.y - crop.topLeft.y)) : 0;
  const [maxZoom, setMaxZoom] = reactExports.useState(
    crop ? Math.max(zoom, 1 - 1 / MAX_ZOOM) : MAX_ZOOM
  );
  const actions = useActions();
  reactExports.useEffect(() => {
    setMaxZoom(crop ? Math.max(zoom, 1 - 1 / MAX_ZOOM) : MAX_ZOOM);
  }, [crop, zoom, maxZoom]);
  const onHistoryMark = reactExports.useCallback((id) => editor.markHistoryStoppingPoint(id), [editor]);
  const easeZoom = reactExports.useCallback((value, maxValue) => {
    const maxRatioConversion = MAX_ZOOM / (MAX_ZOOM - 1);
    return Math.pow(value / maxValue, maxRatioConversion) * maxValue;
  }, []);
  const displayValue = crop && maxZoom ? modulate(
    easeZoom(zoom, maxZoom),
    [0, maxZoom],
    [0, 100],
    true
    /* clamp */
  ) : 0;
  const handleZoomChange = reactExports.useCallback(
    (value) => {
      editor.setCurrentTool("select.crop.idle");
      const sliderPercent = value / 100;
      const maxDimension = 1 - 1 / MAX_ZOOM;
      const clampedMaxZoom = Math.min(maxDimension, maxZoom ?? maxDimension);
      const maxRatioConversion = MAX_ZOOM / (MAX_ZOOM - 1);
      const zOut = Math.pow(sliderPercent, 1 / maxRatioConversion) * clampedMaxZoom;
      const zoom2 = zOut >= 1 ? 1 : zOut / (2 * (1 - zOut));
      const imageShape = editor.getShape(imageShapeId);
      if (!imageShape) return;
      const change = getCroppedImageDataWhenZooming(zoom2, imageShape, maxZoom);
      editor.updateShape({
        id: imageShape.id,
        type: imageShape.type,
        x: change.x,
        y: change.y,
        props: {
          w: change.w,
          h: change.h,
          crop: change.crop
        }
      });
      trackEvent("set-style", { source: "image-toolbar", id: "zoom", value });
    },
    [editor, trackEvent, imageShapeId, maxZoom]
  );
  const handleImageReplace = reactExports.useCallback(
    () => actions["image-replace"].onSelect("image-toolbar"),
    [actions]
  );
  const handleImageDownload = reactExports.useCallback(
    () => actions["download-original"].onSelect("image-toolbar"),
    [actions]
  );
  const handleAspectRatioChange = (aspectRatio) => {
    const imageShape = editor.getShape(imageShapeId);
    if (!imageShape) return;
    editor.run(() => {
      editor.setCurrentTool("select.crop.idle");
      const change = getCroppedImageDataForAspectRatio(aspectRatio, imageShape);
      editor.markHistoryStoppingPoint("aspect ratio");
      editor.updateShape({
        id: imageShapeId,
        type: "image",
        x: change.x,
        y: change.y,
        props: {
          crop: change.crop,
          w: change.w,
          h: change.h
        }
      });
      kickoutOccludedShapes(editor, [imageShapeId]);
    });
  };
  const altText = useValue(
    "altText",
    () => editor.getShape(imageShapeId).props.altText,
    [editor, imageShapeId]
  );
  const shapeAspectRatio = useValue(
    "shapeAspectRatio",
    () => {
      const imageShape = editor.getShape(imageShapeId);
      return imageShape.props.w / imageShape.props.h;
    },
    [editor, imageShapeId]
  );
  const isOriginalCrop = !crop || isEqual(crop, getDefaultCrop());
  reactExports.useEffect(() => {
    if (isManipulating) {
      editor.timers.setTimeout(() => sliderRef.current?.focus(), 0);
    }
  }, [editor, isManipulating]);
  reactExports.useEffect(() => {
    function handleKeyDown2(e) {
      if (isManipulating) {
        if (e.key === "Escape") {
          editor.cancel();
          onManipulatingEnd();
        } else if (e.key === "Enter") {
          editor.complete();
          onManipulatingEnd();
        }
      }
    }
    const elm = sliderRef.current;
    if (elm) {
      elm.addEventListener("keydown", handleKeyDown2);
    }
    return () => {
      if (elm) {
        elm.removeEventListener("keydown", handleKeyDown2);
      }
    };
  }, [editor, isManipulating, onManipulatingEnd]);
  if (isManipulating) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiSlider,
        {
          ref: sliderRef,
          value: displayValue,
          label: "tool.image-zoom",
          onValueChange: handleZoomChange,
          onHistoryMark,
          min: 0,
          steps: 100,
          "data-testid": "tool.image-zoom",
          title: msg2("tool.image-zoom")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDropdownMenuRoot, { id: "image-toolbar-aspect-ratio", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiToolbarButton,
          {
            title: msg2("tool.aspect-ratio"),
            type: "icon",
            "data-testid": "tool.image-aspect-ratio",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "corners" })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuContent, { side: "top", align: "center", children: ASPECT_RATIO_OPTIONS.map((aspectRatio) => {
          let checked = false;
          if (isOriginalCrop) {
            if (aspectRatio === "original") {
              checked = true;
            }
          } else {
            if (aspectRatio === "circle") {
              checked = !!crop.isCircle;
            } else if (aspectRatio === "square") {
              checked = !crop?.isCircle && approximately(shapeAspectRatio, ASPECT_RATIO_TO_VALUE[aspectRatio], 0.1);
            } else if (aspectRatio === "original") {
              checked = false;
            } else {
              checked = !isOriginalCrop && approximately(shapeAspectRatio, ASPECT_RATIO_TO_VALUE[aspectRatio], 0.01);
            }
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            TldrawUiDropdownMenuCheckboxItem,
            {
              onSelect: () => handleAspectRatioChange(aspectRatio),
              checked,
              title: msg2(`tool.aspect-ratio.${aspectRatio}`),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2(`tool.aspect-ratio.${aspectRatio}`) })
            },
            aspectRatio
          );
        }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          onClick: onManipulatingEnd,
          "data-testid": "tool.image-crop-confirm",
          style: { borderLeft: "1px solid var(--tl-color-divider)", marginLeft: "2px" },
          title: msg2("tool.image-crop-confirm"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "check" })
        }
      )
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !isReadonly && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiToolbarButton,
      {
        type: "icon",
        "data-testid": "tool.image-replace",
        onClick: handleImageReplace,
        title: msg2("tool.replace-media"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "tool-media" })
      }
    ),
    !isReadonly && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiToolbarButton,
      {
        type: "icon",
        title: msg2("tool.image-crop"),
        onClick: onManipulatingStart,
        "data-testid": "tool.image-crop",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "crop" })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiToolbarButton,
      {
        type: "icon",
        title: msg2("action.download-original"),
        onClick: handleImageDownload,
        "data-testid": "tool.image-download",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "download" })
      }
    ),
    (altText || !isReadonly) && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiToolbarButton,
      {
        type: "icon",
        title: msg2("tool.media-alt-text"),
        "data-testid": "tool.image-alt-text",
        onClick: () => {
          trackEvent("alt-text-start", { source });
          onEditAltTextStart();
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "alt" })
      }
    )
  ] });
});
function DefaultImageToolbar({ children }) {
  const editor = useEditor();
  const imageShapeId = useValue(
    "imageShape",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape || onlySelectedShape.type !== "image") return null;
      return onlySelectedShape.id;
    },
    [editor]
  );
  const showToolbar = useValue(
    "showToolbar",
    () => editor.isInAny("select.idle", "select.pointing_shape", "select.crop"),
    [editor]
  );
  const isLocked = useValue(
    "locked",
    () => imageShapeId ? editor.getShape(imageShapeId)?.isLocked : false,
    [editor, imageShapeId]
  );
  if (!imageShapeId || !showToolbar || isLocked) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ContextualToolbarInner$2, { imageShapeId, children }, imageShapeId);
}
function ContextualToolbarInner$2({
  children,
  imageShapeId
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const isChangingCrop = useValue(
    "editor path",
    () => editor.isInAny(
      "select.crop.cropping",
      "select.crop.pointing_crop_handle",
      "select.crop.translating_crop"
    ),
    [editor]
  );
  const camera = useValue("camera", () => editor.getCamera(), [editor]);
  const isInCropTool = useValue("editor path", () => editor.isIn("select.crop."), [editor]);
  const previousSelectionBounds = reactExports.useRef();
  const handleManipulatingEnd = reactExports.useCallback(() => {
    editor.setCroppingShape(null);
    editor.setCurrentTool("select.idle");
  }, [editor]);
  const [isEditingAltText, setIsEditingAltText] = reactExports.useState(false);
  const handleEditAltTextStart = reactExports.useCallback(() => setIsEditingAltText(true), []);
  const handleManipulatingStart = reactExports.useCallback(
    () => editor.setCurrentTool("select.crop.idle"),
    [editor]
  );
  const onEditAltTextClose = reactExports.useCallback(() => setIsEditingAltText(false), []);
  reactExports.useEffect(() => {
    previousSelectionBounds.current = void 0;
  }, [camera]);
  const getSelectionBounds = reactExports.useCallback(() => {
    if (isInCropTool && previousSelectionBounds.current) {
      return previousSelectionBounds.current;
    }
    const fullBounds = editor.getSelectionScreenBounds();
    if (!fullBounds) return void 0;
    const bounds = new Box(fullBounds.x, fullBounds.y, fullBounds.width, 0);
    previousSelectionBounds.current = bounds;
    return bounds;
  }, [editor, isInCropTool]);
  if (isChangingCrop) {
    previousSelectionBounds.current = void 0;
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiContextualToolbar,
    {
      className: "tlui-image__toolbar",
      getSelectionBounds,
      label: msg2("tool.image-toolbar-title"),
      children: children ? children : isEditingAltText ? /* @__PURE__ */ jsxRuntimeExports.jsx(AltTextEditor, { shapeId: imageShapeId, onClose: onEditAltTextClose, source: "image-toolbar" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        DefaultImageToolbarContent,
        {
          imageShapeId,
          isManipulating: isInCropTool,
          onEditAltTextStart: handleEditAltTextStart,
          onManipulatingStart: handleManipulatingStart,
          onManipulatingEnd: handleManipulatingEnd
        }
      )
    }
  );
}
var __defProp$4 = Object.defineProperty;
var __export$2 = (target, all) => {
  for (var name in all)
    __defProp$4(target, name, { get: all[name], enumerable: true });
};
function createChainableState$1(config) {
  const { state, transaction: transaction2 } = config;
  let { selection } = transaction2;
  let { doc: doc2 } = transaction2;
  let { storedMarks } = transaction2;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction2.selection;
      doc2 = transaction2.doc;
      storedMarks = transaction2.storedMarks;
      return transaction2;
    }
  };
}
var CommandManager$1 = class CommandManager2 {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args) => {
          const callback = command2(...args)(props);
          if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr2);
          }
          return callback;
        };
        return [name, method];
      })
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run3 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain2 = {
      ...Object.fromEntries(
        Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args) => {
            const props = this.buildProps(tr2, shouldDispatch);
            const callback = command2(...args)(props);
            callbacks.push(callback);
            return chain2;
          };
          return [name, chainedCommand];
        })
      ),
      run: run3
    };
    return chain2;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch2 = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch2);
    const formattedCommands = Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
      })
    );
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch2)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState$1({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          })
        );
      }
    };
    return props;
  }
};
function combineTransactionSteps$1(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction2) => {
    transaction2.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
var removeWhitespaces$1 = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces$1(child);
    }
  }
  return node;
};
function elementFromString$1(value) {
  if (typeof window === "undefined") {
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  }
  const wrappedValue = `<body>${value}</body>`;
  const html2 = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces$1(html2);
}
function createNodeFromContent$1(content, schema, options) {
  if (content instanceof Node$1 || content instanceof Fragment) {
    return content;
  }
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent$1("", schema, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser$1.fromSchema(contentCheckSchema).parseSlice(elementFromString$1(content), options.parseOptions);
      } else {
        DOMParser$1.fromSchema(contentCheckSchema).parse(elementFromString$1(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${invalidContent}`)
        });
      }
    }
    const parser = DOMParser$1.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(elementFromString$1(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString$1(content), options.parseOptions);
  }
  return createNodeFromContent$1("", schema, options);
}
function createDocument$1(content, schema, parseOptions = {}, options = {}) {
  return createNodeFromContent$1(content, schema, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options.errorOnInvalidContent
  });
}
function defaultBlockAt$1(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findParentNodeClosestToPos$1($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode$1(predicate) {
  return (selection) => findParentNodeClosestToPos$1(selection.$from, predicate);
}
function getExtensionField$1(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField$1(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField$1(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function flattenExtensions$1(extensions) {
  return extensions.map((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addExtensions = getExtensionField$1(extension, "addExtensions", context);
    if (addExtensions) {
      return [extension, ...flattenExtensions$1(addExtensions())];
    }
    return extension;
  }).flat(10);
}
function getHTMLFromFragment$1(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function isFunction$1(value) {
  return typeof value === "function";
}
function callOrReturn$1(value, context = void 0, ...props) {
  if (isFunction$1(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject$1(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function splitExtensions$1(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions$1(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions$1(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    validate: void 0,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField$1(
      extension,
      "addGlobalAttributes",
      context
    );
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField$1(
      extension,
      "addAttributes",
      context
    );
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function mergeAttributes$1(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        newStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes$1(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes$1(attributes, attribute), {});
}
function fromString$1(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule$1(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString$1(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem$1(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject$1(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions$1(extensions, editor) {
  var _a2;
  const allAttributes = getAttributesFromExtensions$1(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions$1(extensions);
  const topNode = (_a2 = nodeExtensions.find((extension) => getExtensionField$1(extension, "topNode"))) == null ? void 0 : _a2.name;
  const nodes = Object.fromEntries(
    nodeExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraNodeFields = extensions.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField$1(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem$1({
        ...extraNodeFields,
        content: callOrReturn$1(getExtensionField$1(extension, "content", context)),
        marks: callOrReturn$1(getExtensionField$1(extension, "marks", context)),
        group: callOrReturn$1(getExtensionField$1(extension, "group", context)),
        inline: callOrReturn$1(getExtensionField$1(extension, "inline", context)),
        atom: callOrReturn$1(getExtensionField$1(extension, "atom", context)),
        selectable: callOrReturn$1(getExtensionField$1(extension, "selectable", context)),
        draggable: callOrReturn$1(getExtensionField$1(extension, "draggable", context)),
        code: callOrReturn$1(getExtensionField$1(extension, "code", context)),
        whitespace: callOrReturn$1(getExtensionField$1(extension, "whitespace", context)),
        linebreakReplacement: callOrReturn$1(
          getExtensionField$1(extension, "linebreakReplacement", context)
        ),
        defining: callOrReturn$1(getExtensionField$1(extension, "defining", context)),
        isolating: callOrReturn$1(getExtensionField$1(extension, "isolating", context)),
        attrs: Object.fromEntries(
          extensionAttributes.map((extensionAttribute) => {
            var _a22, _b;
            return [
              extensionAttribute.name,
              { default: (_a22 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a22.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }
            ];
          })
        )
      });
      const parseHTML = callOrReturn$1(getExtensionField$1(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule$1(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField$1(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node) => renderHTML({
          node,
          HTMLAttributes: getRenderedAttributes$1(node, extensionAttributes)
        });
      }
      const renderText = getExtensionField$1(extension, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension.name, schema];
    })
  );
  const marks = Object.fromEntries(
    markExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraMarkFields = extensions.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField$1(e, "extendMarkSchema", context);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem$1({
        ...extraMarkFields,
        inclusive: callOrReturn$1(getExtensionField$1(extension, "inclusive", context)),
        excludes: callOrReturn$1(getExtensionField$1(extension, "excludes", context)),
        group: callOrReturn$1(getExtensionField$1(extension, "group", context)),
        spanning: callOrReturn$1(getExtensionField$1(extension, "spanning", context)),
        code: callOrReturn$1(getExtensionField$1(extension, "code", context)),
        attrs: Object.fromEntries(
          extensionAttributes.map((extensionAttribute) => {
            var _a22, _b;
            return [
              extensionAttribute.name,
              { default: (_a22 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a22.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }
            ];
          })
        )
      });
      const parseHTML = callOrReturn$1(getExtensionField$1(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule$1(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField$1(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark) => renderHTML({
          mark,
          HTMLAttributes: getRenderedAttributes$1(mark, extensionAttributes)
        });
      }
      return [extension.name, schema];
    })
  );
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function findDuplicates$1(items) {
  const filtered = items.filter((el, index2) => items.indexOf(el) !== index2);
  return Array.from(new Set(filtered));
}
function sortExtensions$1(extensions) {
  const defaultPriority = 100;
  return extensions.sort((a, b) => {
    const priorityA = getExtensionField$1(a, "priority") || defaultPriority;
    const priorityB = getExtensionField$1(b, "priority") || defaultPriority;
    if (priorityA > priorityB) {
      return -1;
    }
    if (priorityA < priorityB) {
      return 1;
    }
    return 0;
  });
}
function resolveExtensions$1(extensions) {
  const resolvedExtensions = sortExtensions$1(flattenExtensions$1(extensions));
  const duplicatedNames = findDuplicates$1(resolvedExtensions.map((extension) => extension.name));
  if (duplicatedNames.length) {
    console.warn(
      `[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`
    );
  }
  return resolvedExtensions;
}
function getSchema(extensions, editor) {
  const resolvedExtensions = resolveExtensions$1(extensions);
  return getSchemaByResolvedExtensions$1(resolvedExtensions, editor);
}
function generateHTML(doc2, extensions) {
  const schema = getSchema(extensions);
  const contentNode = Node$1.fromJSON(schema, doc2);
  return getHTMLFromFragment$1(contentNode.content, schema);
}
function generateJSON(html2, extensions) {
  const schema = getSchema(extensions);
  const dom = elementFromString$1(html2);
  return DOMParser$1.fromSchema(schema).parse(dom).toJSON();
}
function getTextBetween$1(startNode, range, options) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text = "";
  startNode.nodesBetween(from2, to, (node, pos, parent, index2) => {
    var _a2;
    if (node.isBlock && pos > from2) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers == null ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index: index2,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a2 = node == null ? void 0 : node.text) == null ? void 0 : _a2.slice(Math.max(from2, pos) - pos, to - pos);
    }
  });
  return text;
}
function getText$1(node, options) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween$1(node, range, options);
}
function getTextSerializersFromSchema$1(schema) {
  return Object.fromEntries(
    Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText])
  );
}
function generateText(doc2, extensions, options) {
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  const schema = getSchema(extensions);
  const contentNode = Node$1.fromJSON(schema, doc2);
  return getText$1(contentNode, {
    blockSeparator,
    textSerializers: {
      ...getTextSerializersFromSchema$1(schema),
      ...textSerializers
    }
  });
}
function getMarkType$1(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
function getMarkAttributes$1(state, typeOrName) {
  const type = getMarkType$1(typeOrName, state.schema);
  const { from: from2, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function getNodeType$1(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function getSchemaTypeNameByName$1(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function removeDuplicates$1(array2, by = JSON.stringify) {
  const seen = {};
  return array2.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges$1(changes) {
  const uniqueChanges = removeDuplicates$1(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index2) => {
    const rest = uniqueChanges.filter((_, i) => i !== index2);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges$1(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index2) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index2];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index2).map(from2, -1);
      const newEnd = mapping.slice(index2).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges$1(changes);
}
function isRegExp$1(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
function objectIncludes$1(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp$1(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet$1(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes$1(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
      attributes
    );
  });
}
function isMarkInSet$1(marks, type, attributes = {}) {
  return !!findMarkInSet$1(marks, type, attributes);
}
function getMarkRange$1($pos, type, attributes) {
  var _a2;
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a2 = start.node.marks[0]) == null ? void 0 : _a2.attrs);
  const mark = findMarkInSet$1([...start.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  while (startIndex > 0 && isMarkInSet$1([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet$1([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getSplittedAttributes$1(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(
    Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    })
  );
}
function isMarkActive$1(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType$1(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes$1(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(
        ...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        }))
      );
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes$1(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isNodeActive$1(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType$1(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes$1(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
function isList$1(name, extensions) {
  const { nodeExtensions } = splitExtensions$1(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn$1(getExtensionField$1(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty$1(node, {
  checkChildren = true,
  ignoreWhitespace = false
} = {}) {
  var _a2;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a2 = node.text) != null ? _a2 : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty$1(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isTextSelection$1(value) {
  return value instanceof TextSelection;
}
function minMax$1(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition$1(doc2, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc2);
  const selectionAtEnd = Selection.atEnd(doc2);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc2, minMax$1(0, minPos, maxPos), minMax$1(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax$1(position, minPos, maxPos), minMax$1(position, minPos, maxPos));
}
function selectionToInsertionEnd$1(tr2, startLen, bias) {
  const last2 = tr2.steps.length - 1;
  if (last2 < startLen) {
    return;
  }
  const step = tr2.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr2.mapping.maps[last2];
  let end = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
function getType$1(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject$1(value) {
  if (getType$1(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep$1(target, source) {
  const output = { ...target };
  if (isPlainObject$1(target) && isPlainObject$1(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject$1(source[key]) && isPlainObject$1(target[key])) {
        output[key] = mergeDeep$1(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var Extendable$1 = class Extendable2 {
  constructor(config = {}) {
    this.type = "extendable";
    this.parent = null;
    this.child = null;
    this.name = "";
    this.config = {
      name: this.name
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
  }
  get options() {
    return {
      ...callOrReturn$1(
        getExtensionField$1(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...callOrReturn$1(
        getExtensionField$1(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep$1(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new this.constructor({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = "name" in extendedConfig ? extendedConfig.name : extension.parent.name;
    return extension;
  }
};
var extensions_exports$1 = {};
__export$2(extensions_exports$1, {
  ClipboardTextSerializer: () => ClipboardTextSerializer$1,
  Commands: () => Commands$1,
  Delete: () => Delete$1,
  Drop: () => Drop$1,
  Editable: () => Editable$1,
  FocusEvents: () => FocusEvents$1,
  Keymap: () => Keymap$1,
  Paste: () => Paste$1,
  Tabindex: () => Tabindex$1,
  focusEventsPluginKey: () => focusEventsPluginKey$1
});
var Extension$1 = class _Extension2 extends Extendable$1 {
  constructor() {
    super(...arguments);
    this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Extension2(resolvedConfig);
  }
  configure(options) {
    return super.configure(options);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
var ClipboardTextSerializer$1 = Extension$1.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc2, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema$1(schema);
            const range = { from: from2, to };
            return getTextBetween$1(doc2, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var commands_exports$1 = {};
__export$2(commands_exports$1, {
  blur: () => blur$1,
  clearContent: () => clearContent$1,
  clearNodes: () => clearNodes$1,
  command: () => command$1,
  createParagraphNear: () => createParagraphNear$1,
  cut: () => cut$1,
  deleteCurrentNode: () => deleteCurrentNode$1,
  deleteNode: () => deleteNode$1,
  deleteRange: () => deleteRange$1,
  deleteSelection: () => deleteSelection$1,
  enter: () => enter$1,
  exitCode: () => exitCode$1,
  extendMarkRange: () => extendMarkRange$1,
  first: () => first$1,
  focus: () => focus$1,
  forEach: () => forEach$1,
  insertContent: () => insertContent$1,
  insertContentAt: () => insertContentAt$1,
  joinBackward: () => joinBackward$1,
  joinDown: () => joinDown$1,
  joinForward: () => joinForward$1,
  joinItemBackward: () => joinItemBackward$1,
  joinItemForward: () => joinItemForward$1,
  joinTextblockBackward: () => joinTextblockBackward$1,
  joinTextblockForward: () => joinTextblockForward$1,
  joinUp: () => joinUp$1,
  keyboardShortcut: () => keyboardShortcut$1,
  lift: () => lift$1,
  liftEmptyBlock: () => liftEmptyBlock$1,
  liftListItem: () => liftListItem$1,
  newlineInCode: () => newlineInCode$1,
  resetAttributes: () => resetAttributes$1,
  scrollIntoView: () => scrollIntoView$1,
  selectAll: () => selectAll$1,
  selectNodeBackward: () => selectNodeBackward$1,
  selectNodeForward: () => selectNodeForward$1,
  selectParentNode: () => selectParentNode$1,
  selectTextblockEnd: () => selectTextblockEnd$1,
  selectTextblockStart: () => selectTextblockStart$1,
  setContent: () => setContent$1,
  setMark: () => setMark$1,
  setMeta: () => setMeta$1,
  setNode: () => setNode$1,
  setNodeSelection: () => setNodeSelection$1,
  setTextSelection: () => setTextSelection$1,
  sinkListItem: () => sinkListItem$1,
  splitBlock: () => splitBlock$1,
  splitListItem: () => splitListItem$1,
  toggleList: () => toggleList$1,
  toggleMark: () => toggleMark$1,
  toggleNode: () => toggleNode$1,
  toggleWrap: () => toggleWrap$1,
  undoInputRule: () => undoInputRule$1,
  unsetAllMarks: () => unsetAllMarks$1,
  unsetMark: () => unsetMark$1,
  updateAttributes: () => updateAttributes$1,
  wrapIn: () => wrapIn$1,
  wrapInList: () => wrapInList$1
});
var blur$1 = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a2;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a2 = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
    }
  });
  return true;
};
var clearContent$1 = (emitUpdate = true) => ({ commands }) => {
  return commands.setContent("", { emitUpdate });
};
var clearNodes$1 = () => ({ state, tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr2;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command$1 = (fn) => (props) => {
  return fn(props);
};
var createParagraphNear$1 = () => ({ state, dispatch: dispatch2 }) => {
  return createParagraphNear$3(state, dispatch2);
};
var cut$1 = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(Math.max(newPos - 1, 0))));
  return true;
};
var deleteCurrentNode$1 = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode$1 = (typeOrName) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange$1 = (range) => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { from: from2, to } = range;
  if (dispatch2) {
    tr2.delete(from2, to);
  }
  return true;
};
var deleteSelection$1 = () => ({ state, dispatch: dispatch2 }) => {
  return deleteSelection$3(state, dispatch2);
};
var enter$1 = () => ({ commands }) => {
  return commands.keyboardShortcut("Enter");
};
var exitCode$1 = () => ({ state, dispatch: dispatch2 }) => {
  return exitCode$3(state, dispatch2);
};
var extendMarkRange$1 = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getMarkType$1(typeOrName, state.schema);
  const { doc: doc2, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch2) {
    const range = getMarkRange$1($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc2, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
var first$1 = (commands) => (props) => {
  const items = typeof commands === "function" ? commands(props) : commands;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
function isAndroid$1() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS$1() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus$1 = (position = null, options = {}) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS$1() || isAndroid$1()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options == null ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch2 && position === null && !isTextSelection$1(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition$1(tr2.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch2) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach$1 = (items, fn) => (props) => {
  return items.every((item, index2) => fn(item, { ...props, index: index2 }));
};
var insertContent$1 = (value, options) => ({ tr: tr2, commands }) => {
  return commands.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
};
var isFragment$1 = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
var insertContentAt$1 = (position, value, options) => ({ tr: tr2, dispatch: dispatch2, editor }) => {
  var _a2;
  if (dispatch2) {
    options = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content;
    const emitContentError = (error) => {
      editor.emit("contentError", {
        editor,
        error,
        disableCollaboration: () => {
          if ("collaboration" in editor.storage && typeof editor.storage.collaboration === "object" && editor.storage.collaboration) {
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
    };
    const parseOptions = {
      preserveWhitespace: "full",
      ...options.parseOptions
    };
    if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {
      try {
        createNodeFromContent$1(value, editor.schema, {
          parseOptions,
          errorOnInvalidContent: true
        });
      } catch (e) {
        emitContentError(e);
      }
    }
    try {
      content = createNodeFromContent$1(value, editor.schema, {
        parseOptions,
        errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) != null ? _a2 : editor.options.enableContentCheck
      });
    } catch (e) {
      emitContentError(e);
      return false;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment$1(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr2.insertText(newContent, from2, to);
    } else {
      newContent = content;
      const $from = tr2.doc.resolve(from2);
      const $fromNode = $from.node();
      const fromSelectionAtStart = $from.parentOffset === 0;
      const isTextSelection2 = $fromNode.isText || $fromNode.isTextblock;
      const hasContent = $fromNode.content.size > 0;
      if (fromSelectionAtStart && isTextSelection2 && hasContent) {
        from2 = Math.max(0, from2 - 1);
      }
      tr2.replaceWith(from2, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd$1(tr2, tr2.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr2.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options.applyPasteRules) {
      tr2.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
var joinUp$1 = () => ({ state, dispatch: dispatch2 }) => {
  return joinUp$3(state, dispatch2);
};
var joinDown$1 = () => ({ state, dispatch: dispatch2 }) => {
  return joinDown$3(state, dispatch2);
};
var joinBackward$1 = () => ({ state, dispatch: dispatch2 }) => {
  return joinBackward$3(state, dispatch2);
};
var joinForward$1 = () => ({ state, dispatch: dispatch2 }) => {
  return joinForward$3(state, dispatch2);
};
var joinItemBackward$1 = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward$1 = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinTextblockBackward$1 = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockBackward$3(state, dispatch2);
};
var joinTextblockForward$1 = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockForward$3(state, dispatch2);
};
function isMacOS$1() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName$1(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS$1() || isMacOS$1()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut$1 = (name) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  const keys2 = normalizeKeyName$1(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch2) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
var lift$1 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  const isActive2 = isNodeActive$1(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift$3(state, dispatch2);
};
var liftEmptyBlock$1 = () => ({ state, dispatch: dispatch2 }) => {
  return liftEmptyBlock$3(state, dispatch2);
};
var liftListItem$1 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  return liftListItem$3(type)(state, dispatch2);
};
var newlineInCode$1 = () => ({ state, dispatch: dispatch2 }) => {
  return newlineInCode$3(state, dispatch2);
};
function deleteProps$1(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes$1 = (typeOrName, attributes) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName$1(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType$1(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType$1(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr2.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, deleteProps$1(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps$1(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView$1 = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    tr2.scrollIntoView();
  }
  return true;
};
var selectAll$1 = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const selection = new AllSelection(tr2.doc);
    tr2.setSelection(selection);
  }
  return true;
};
var selectNodeBackward$1 = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeBackward$3(state, dispatch2);
};
var selectNodeForward$1 = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeForward$3(state, dispatch2);
};
var selectParentNode$1 = () => ({ state, dispatch: dispatch2 }) => {
  return selectParentNode$3(state, dispatch2);
};
var selectTextblockEnd$1 = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockEnd$3(state, dispatch2);
};
var selectTextblockStart$1 = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockStart$3(state, dispatch2);
};
var setContent$1 = (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) => ({ editor, tr: tr2, dispatch: dispatch2, commands }) => {
  const { doc: doc2 } = tr2;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument$1(content, editor.schema, parseOptions, {
      errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
    });
    if (dispatch2) {
      tr2.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch2) {
    tr2.setMeta("preventUpdate", !emitUpdate);
  }
  return commands.insertContentAt({ from: 0, to: doc2.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
  });
};
function canSetMark$1(state, tr2, newMarkType) {
  var _a2;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection$1(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a2 = state.storedMarks) != null ? _a2 : cursor.marks();
    const parentAllowsMarkType = cursor.parent.type.allowsMarkType(newMarkType);
    return parentAllowsMarkType && (!!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType)));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark$1 = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType$1(typeOrName, state.schema);
  if (dispatch2) {
    if (empty2) {
      const oldAttributes = getMarkAttributes$1(state, type);
      tr2.addStoredMark(
        type.create({
          ...oldAttributes,
          ...attributes
        })
      );
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(
                  trimmedFrom,
                  trimmedTo,
                  type.create({
                    ...mark.attrs,
                    ...attributes
                  })
                );
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark$1(state, tr2, type);
};
var setMeta$1 = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
var setNode$1 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2, chain: chain2 }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain2().command(({ commands }) => {
    const canSetBlock = setBlockType(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch2);
  }).run();
};
var setNodeSelection$1 = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr2;
    const from2 = minMax$1(position, 0, doc2.content.size);
    const selection = NodeSelection.create(doc2, from2);
    tr2.setSelection(selection);
  }
  return true;
};
var setTextSelection$1 = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr2;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc2).from;
    const maxPos = TextSelection.atEnd(doc2).to;
    const resolvedFrom = minMax$1(from2, minPos, maxPos);
    const resolvedEnd = minMax$1(to, minPos, maxPos);
    const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
var sinkListItem$1 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  return sinkListItem$3(type)(state, dispatch2);
};
function ensureMarks$1(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks == null ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock$1 = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  const { selection, doc: doc2 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes$1(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      if (keepMarks) {
        ensureMarks$1(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch2) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr2.deleteSelection();
      }
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks$1(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return can;
};
var splitListItem$1 = (typeOrName, overrideAttrs = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  var _a2;
  const type = getNodeType$1(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch2) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = (
        // eslint-disable-next-line no-nested-ternary
        $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3
      );
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes$1(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a2 = type.contentMatch.defaultType) == null ? void 0 : _a2.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start, tr2.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes$1(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes$1(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch2) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch2) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards$1 = (tr2, listType) => {
  const list = findParentNode$1((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
var joinListForwards$1 = (tr2, listType) => {
  const list = findParentNode$1((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
var toggleList$1 = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch: dispatch2, chain: chain2, commands, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType$1(listTypeOrName, state.schema);
  const itemType = getNodeType$1(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode$1((node) => isList$1(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands.liftListItem(itemType);
    }
    if (isList$1(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch2) {
      return chain2().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards$1(tr2, listType)).command(() => joinListForwards$1(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch2) {
    return chain2().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards$1(tr2, listType)).command(() => joinListForwards$1(tr2, listType)).run();
  }
  return chain2().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards$1(tr2, listType)).command(() => joinListForwards$1(tr2, listType)).run();
};
var toggleMark$1 = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType$1(typeOrName, state.schema);
  const isActive2 = isMarkActive$1(state, type, attributes);
  if (isActive2) {
    return commands.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands.setMark(type, attributes);
};
var toggleNode$1 = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  const toggleType = getNodeType$1(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive$1(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands.setNode(toggleType, attributesToCopy);
  }
  return commands.setNode(type, { ...attributesToCopy, ...attributes });
};
var toggleWrap$1 = (typeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  const isActive2 = isNodeActive$1(state, type, attributes);
  if (isActive2) {
    return commands.lift(type);
  }
  return commands.wrapIn(type, attributes);
};
var undoInputRule$1 = () => ({ state, dispatch: dispatch2 }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch2) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks$1 = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch2) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark$1 = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  var _a2;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr2;
  const type = getMarkType$1(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a2 = $from.marks().find((mark) => mark.type === type)) == null ? void 0 : _a2.attrs;
    const range = getMarkRange$1($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
var updateAttributes$1 = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName$1(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType$1(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType$1(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr2.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr2.selection.empty) {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
        });
      } else {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (pos < from2 && nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
          if (pos >= from2 && pos <= to) {
            if (nodeType && nodeType === node.type) {
              tr2.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom2 = Math.max(pos, from2);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr2.addMark(
                    trimmedFrom2,
                    trimmedTo2,
                    markType.create({
                      ...mark.attrs,
                      ...attributes
                    })
                  );
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== void 0) {
          tr2.setNodeMarkup(lastPos, void 0, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(
                trimmedFrom,
                trimmedTo,
                markType.create({
                  ...mark.attrs,
                  ...attributes
                })
              );
            }
          });
        }
      }
    });
  }
  return true;
};
var wrapIn$1 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  return wrapIn$3(type, attributes)(state, dispatch2);
};
var wrapInList$1 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  return wrapInList$3(type, attributes)(state, dispatch2);
};
var Commands$1 = Extension$1.create({
  name: "commands",
  addCommands() {
    return {
      ...commands_exports$1
    };
  }
});
var Delete$1 = Extension$1.create({
  name: "delete",
  onUpdate({ transaction: transaction2, appendedTransactions }) {
    var _a2, _b, _c;
    const callback = () => {
      var _a22, _b2, _c2, _d;
      if ((_d = (_c2 = (_b2 = (_a22 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a22.delete) == null ? void 0 : _b2.filterTransaction) == null ? void 0 : _c2.call(_b2, transaction2)) != null ? _d : transaction2.getMeta("y-sync$")) {
        return;
      }
      const nextTransaction = combineTransactionSteps$1(transaction2.before, [transaction2, ...appendedTransactions]);
      const changes = getChangedRanges$1(nextTransaction);
      changes.forEach((change) => {
        if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {
          nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from2) => {
            const to = from2 + node.nodeSize - 2;
            const isFullyWithinRange = change.oldRange.from <= from2 && to <= change.oldRange.to;
            this.editor.emit("delete", {
              type: "node",
              node,
              from: from2,
              to,
              newFrom: nextTransaction.mapping.map(from2),
              newTo: nextTransaction.mapping.map(to),
              deletedRange: change.oldRange,
              newRange: change.newRange,
              partial: !isFullyWithinRange,
              editor: this.editor,
              transaction: transaction2,
              combinedTransform: nextTransaction
            });
          });
        }
      });
      const mapping = nextTransaction.mapping;
      nextTransaction.steps.forEach((step, index2) => {
        var _a3, _b3;
        if (step instanceof RemoveMarkStep) {
          const newStart = mapping.slice(index2).map(step.from, -1);
          const newEnd = mapping.slice(index2).map(step.to);
          const oldStart = mapping.invert().map(newStart, -1);
          const oldEnd = mapping.invert().map(newEnd);
          const foundBeforeMark = (_a3 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a3.marks.some((mark) => mark.eq(step.mark));
          const foundAfterMark = (_b3 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b3.marks.some((mark) => mark.eq(step.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: step.mark,
            from: step.from,
            to: step.to,
            deletedRange: {
              from: oldStart,
              to: oldEnd
            },
            newRange: {
              from: newStart,
              to: newEnd
            },
            partial: Boolean(foundAfterMark || foundBeforeMark),
            editor: this.editor,
            transaction: transaction2,
            combinedTransform: nextTransaction
          });
        }
      });
    };
    if ((_c = (_b = (_a2 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a2.delete) == null ? void 0 : _b.async) != null ? _c : true) {
      setTimeout(callback, 0);
    } else {
      callback();
    }
  }
});
var Drop$1 = Extension$1.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e, slice2, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: slice2,
              moved
            });
          }
        }
      })
    ];
  }
});
var Editable$1 = Extension$1.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var focusEventsPluginKey$1 = new PluginKey("focusEvents");
var FocusEvents$1 = Extension$1.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: focusEventsPluginKey$1,
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction2 = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction2 = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap$1 = Extension$1.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands.command(({ tr: tr2 }) => {
        const { selection, doc: doc2 } = tr2;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands.clearNodes();
      }),
      () => commands.deleteSelection(),
      () => commands.joinBackward(),
      () => commands.selectNodeBackward()
    ]);
    const handleDelete2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.deleteSelection(),
      () => commands.deleteCurrentNode(),
      () => commands.joinForward(),
      () => commands.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands }) => [
      () => commands.newlineInCode(),
      () => commands.createParagraphNear(),
      () => commands.liftEmptyBlock(),
      () => commands.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace2,
      "Mod-Backspace": handleBackspace2,
      "Shift-Backspace": handleBackspace2,
      Delete: handleDelete2,
      "Mod-Delete": handleDelete2,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace2,
      "Alt-Backspace": handleBackspace2,
      "Ctrl-d": handleDelete2,
      "Ctrl-Alt-Backspace": handleDelete2,
      "Alt-Delete": handleDelete2,
      "Alt-d": handleDelete2,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS$1() || isMacOS$1()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr22) => tr22.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction2) => transaction2.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction2) => transaction2.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty = isNodeEmpty$1(newState.doc);
          if (!isEmpty) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState$1({
            state: newState,
            transaction: tr2
          });
          const { commands } = new CommandManager$1({
            editor: this.editor,
            state
          });
          commands.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
var Paste$1 = Extension$1.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e, slice2) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: slice2
            });
          }
        }
      })
    ];
  }
});
var Tabindex$1 = Extension$1.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
function DefaultRichTextToolbarContent({
  textEditor,
  onEditLinkStart
}) {
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const source = "rich-text-menu";
  const [_, set] = reactExports.useState(0);
  reactExports.useEffect(
    function forceUpdateWhenContentChanges() {
      function forceUpdate() {
        set((t2) => t2 + 1);
      }
      textEditor.on("update", forceUpdate);
      textEditor.on("selectionUpdate", forceUpdate);
    },
    [textEditor]
  );
  reactExports.useEffect(() => {
    function handleKeyDown2(event) {
      if (onEditLinkStart && isAccelKey(event) && event.shiftKey && event.key === "k") {
        event.preventDefault();
        onEditLinkStart();
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [onEditLinkStart]);
  const actions = reactExports.useMemo(() => {
    function handleOp(name, op) {
      if (!textEditor.view) return;
      trackEvent("rich-text", { operation: name, source });
      textEditor.chain().focus()[op]().run();
    }
    return [
      // { name: 'heading', attrs: { level: 3 }, onSelect() { textEditor.chain().focus().toggleHeading({ level: 3}).run() }},
      {
        name: "bold",
        onSelect() {
          handleOp("bold", "toggleBold");
        }
      },
      {
        name: "italic",
        onSelect() {
          handleOp("bold", "toggleItalic");
        }
      },
      // { name: 'underline', onSelect() { handleOp('underline', 'toggleUnderline') }},
      // { name: 'strike', onSelect() { handleOp('strike', 'toggleStrike')  }},
      {
        name: "code",
        onSelect() {
          handleOp("bold", "toggleCode");
        }
      },
      onEditLinkStart ? {
        name: "link",
        onSelect() {
          onEditLinkStart();
        }
      } : void 0,
      // ? is this really optional?
      {
        name: "bulletList",
        onSelect() {
          handleOp("bulletList", "toggleBulletList");
        }
      },
      {
        name: "highlight",
        onSelect() {
          handleOp("bulletList", "toggleHighlight");
        }
      }
    ].filter(Boolean);
  }, [textEditor, trackEvent, onEditLinkStart]);
  return actions.map(({ name, attrs, onSelect }) => {
    const isActive2 = textEditor.view ? textEditor.isActive(name, attrs) : false;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiToolbarButton,
      {
        title: msg2(`tool.rich-text-${name}`),
        "data-testid": `rich-text.${name}`,
        type: "icon",
        isActive: isActive2,
        onPointerDown: preventDefault,
        onClick: onSelect,
        role: "option",
        "aria-pressed": isActive2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: name })
      },
      name
    );
  });
}
function LinkEditor({ textEditor, value: initialValue, onClose }) {
  const editor = useEditor();
  const [value, setValue] = reactExports.useState(initialValue);
  const msg2 = useTranslation();
  const ref = reactExports.useRef(null);
  const trackEvent = useUiEvents();
  const source = "rich-text-menu";
  const linkifiedValue = value.startsWith("http") ? value : `https://${value}`;
  const handleValueChange = (value2) => setValue(value2);
  const handleLinkComplete = (link) => {
    trackEvent("rich-text", { operation: "link-edit", source });
    if (!link.startsWith("http://") && !link.startsWith("https://")) {
      link = `https://${link}`;
    }
    textEditor.chain().setLink({ href: link }).run();
    if (editor.getInstanceState().isCoarsePointer) {
      textEditor.commands.blur();
    } else {
      textEditor.commands.focus();
    }
    onClose();
  };
  const handleVisitLink = () => {
    trackEvent("rich-text", { operation: "link-visit", source });
    openWindow(linkifiedValue, "_blank");
    onClose();
  };
  const handleRemoveLink = () => {
    trackEvent("rich-text", { operation: "link-remove", source });
    textEditor.chain().unsetLink().focus().run();
    onClose();
  };
  const handleLinkCancel = () => onClose();
  reactExports.useEffect(() => {
    ref.current?.focus();
  }, [value]);
  reactExports.useEffect(() => {
    setValue(initialValue);
  }, [initialValue]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiInput,
      {
        ref,
        "data-testid": "rich-text.link-input",
        className: "tlui-rich-text__toolbar-link-input",
        value,
        onValueChange: handleValueChange,
        onComplete: handleLinkComplete,
        onCancel: handleLinkCancel,
        placeholder: "example.com",
        "aria-label": "example.com"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        className: "tlui-rich-text__toolbar-link-visit",
        title: msg2("tool.rich-text-link-visit"),
        type: "icon",
        onPointerDown: preventDefault,
        onClick: handleVisitLink,
        disabled: !value,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "external-link" })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        className: "tlui-rich-text__toolbar-link-remove",
        title: msg2("tool.rich-text-link-remove"),
        "data-testid": "rich-text.link-remove",
        type: "icon",
        onPointerDown: preventDefault,
        onClick: handleRemoveLink,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "trash" })
      }
    )
  ] });
}
const DefaultRichTextToolbar = track(function DefaultRichTextToolbar2({
  children
}) {
  const editor = useEditor();
  const textEditor = useValue("textEditor", () => editor.getRichTextEditor(), [editor]);
  if (editor.getInstanceState().isCoarsePointer || !textEditor) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ContextualToolbarInner$1, { textEditor, children });
});
function ContextualToolbarInner$1({
  textEditor,
  children
}) {
  const { isEditingLink, onEditLinkStart, onEditLinkClose } = useEditingLinkBehavior(textEditor);
  const [currentSelection, setCurrentSelection] = reactExports.useState(null);
  const previousSelectionBounds = reactExports.useRef();
  const isMousingDown = useIsMousingDownOnTextEditor(textEditor);
  const msg2 = useTranslation();
  const getSelectionBounds = reactExports.useCallback(() => {
    if (isEditingLink) {
      return previousSelectionBounds.current;
    }
    const selection = window.getSelection();
    if (!currentSelection || !selection || selection.rangeCount === 0 || selection.isCollapsed)
      return;
    const rangeBoxes = [];
    for (let i = 0; i < selection.rangeCount; i++) {
      const range = selection.getRangeAt(i);
      rangeBoxes.push(rectToBox(range.getBoundingClientRect()));
    }
    const bounds = Box.Common(rangeBoxes);
    previousSelectionBounds.current = bounds;
    return bounds;
  }, [currentSelection, isEditingLink]);
  reactExports.useEffect(() => {
    const handleSelectionUpdate = ({ editor: textEditor2 }) => setCurrentSelection(textEditor2.state.selection);
    textEditor.on("selectionUpdate", handleSelectionUpdate);
    handleSelectionUpdate({ editor: textEditor });
    return () => {
      textEditor.off("selectionUpdate", handleSelectionUpdate);
    };
  }, [textEditor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiContextualToolbar,
    {
      className: "tlui-rich-text__toolbar",
      getSelectionBounds,
      isMousingDown,
      changeOnlyWhenYChanges: true,
      label: msg2("tool.rich-text-toolbar-title"),
      children: children ? children : isEditingLink ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinkEditor,
        {
          textEditor,
          value: textEditor.isActive("link") ? textEditor.getAttributes("link").href : "",
          onClose: onEditLinkClose
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultRichTextToolbarContent, { textEditor, onEditLinkStart })
    }
  );
}
function useEditingLinkBehavior(textEditor) {
  const [isEditingLink, setIsEditingLink] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!textEditor) {
      setIsEditingLink(false);
      return;
    }
    const handleClick2 = () => {
      const isLinkActive = textEditor.isActive("link");
      setIsEditingLink(isLinkActive);
    };
    textEditor.view.dom.addEventListener("click", handleClick2);
    return () => {
      if (textEditor.isInitialized) {
        textEditor.view.dom.removeEventListener("click", handleClick2);
      }
    };
  }, [textEditor, isEditingLink]);
  reactExports.useEffect(() => {
    if (!textEditor) {
      return;
    }
    if (textEditor.isActive("link")) {
      try {
        const { from: from2, to } = getMarkRange$1(
          textEditor.state.doc.resolve(textEditor.state.selection.from),
          textEditor.schema.marks.link
        );
        if (textEditor.state.selection.empty) {
          textEditor.commands.setTextSelection({ from: from2, to });
        }
      } catch {
      }
    }
  }, [textEditor, isEditingLink]);
  const onEditLinkStart = reactExports.useCallback(() => {
    setIsEditingLink(true);
  }, []);
  const onEditLinkCancel = reactExports.useCallback(() => {
    setIsEditingLink(false);
  }, []);
  const onEditLinkClose = reactExports.useCallback(() => {
    setIsEditingLink(false);
    if (!textEditor) return;
    const from2 = textEditor.state.selection.from;
    textEditor.commands.setTextSelection({ from: from2, to: from2 });
  }, [textEditor]);
  return { isEditingLink, onEditLinkStart, onEditLinkClose, onEditLinkCancel };
}
function useIsMousingDownOnTextEditor(textEditor) {
  const [isMousingDown, setIsMousingDown] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!textEditor) return;
    const handlePointingStateChange = debounce(({ isPointing }) => {
      setIsMousingDown(isPointing);
    }, 16);
    const handlePointingDown = () => handlePointingStateChange({ isPointing: true });
    const handlePointingUp = () => handlePointingStateChange({ isPointing: false });
    const touchDownEvents = ["touchstart", "pointerdown", "mousedown"];
    const touchUpEvents = ["touchend", "pointerup", "mouseup"];
    touchDownEvents.forEach((eventName) => {
      textEditor.view.dom.addEventListener(eventName, handlePointingDown);
    });
    touchUpEvents.forEach((eventName) => {
      document.body.addEventListener(eventName, handlePointingUp);
    });
    return () => {
      touchDownEvents.forEach((eventName) => {
        if (textEditor.isInitialized) {
          textEditor.view.dom.removeEventListener(eventName, handlePointingDown);
        }
      });
      touchUpEvents.forEach((eventName) => {
        document.body.removeEventListener(eventName, handlePointingUp);
      });
    };
  }, [textEditor]);
  return isMousingDown;
}
function MobileStylePanel() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const { orientation } = useTldrawUiOrientation();
  const relevantStyles = useRelevantStyles();
  const color = relevantStyles?.get(DefaultColorStyle);
  const theme = getDefaultColorTheme({ isDarkMode: editor.user.getIsDarkMode() });
  const currentColor = color?.type === "shared" ? getColorValue(theme, color.value, "solid") : getColorValue(theme, "black", "solid");
  const disableStylePanel = useValue(
    "disable style panel",
    () => editor.isInAny("hand", "zoom", "eraser", "laser"),
    [editor]
  );
  const handleStylesOpenChange = reactExports.useCallback(
    (isOpen) => {
      if (!isOpen) {
        editor.updateInstanceState({ isChangingStyle: false });
      }
    },
    [editor]
  );
  const { StylePanel } = useTldrawUiComponents();
  if (!StylePanel) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: "mobile style menu", onOpenChange: handleStylesOpenChange, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        type: "tool",
        "data-testid": "mobile-styles.button",
        style: {
          color: disableStylePanel ? "var(--tl-color-muted-1)" : currentColor
        },
        title: msg2("style-panel.title"),
        disabled: disableStylePanel,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButtonIcon,
          {
            icon: disableStylePanel ? "blob" : color?.type === "mixed" ? "mixed" : "blob"
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverContent, { side: orientation === "horizontal" ? "top" : "right", align: "end", children: StylePanel && /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanel, { isMobile: true }) })
  ] });
}
function DefaultToolbarContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HandToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DrawToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EraserToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TextToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(NoteToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AssetToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RectangleToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EllipseToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DiamondToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HexagonToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(OvalToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RhombusToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StarToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CloudToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HeartToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(XBoxToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeftToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUpToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDownToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRightToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LineToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HighlightToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LaserToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FrameToolbarItem, {})
  ] });
}
function useIsToolSelected(tool) {
  const editor = useEditor();
  const geo = tool?.meta?.geo;
  return useValue(
    "is tool selected",
    () => {
      if (!tool) return false;
      const activeToolId = editor.getCurrentToolId();
      if (activeToolId === "geo") {
        return geo === editor.getSharedStyles().getAsKnownValue(GeoShapeGeoStyle);
      } else {
        return activeToolId === tool.id;
      }
    },
    [editor, tool?.id, geo]
  );
}
function ToolbarItem({ tool }) {
  const tools = useTools();
  const isSelected = useIsToolSelected(tools[tool]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: tool, isSelected });
}
function SelectToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "select" });
}
function HandToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "hand" });
}
function DrawToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "draw" });
}
function EraserToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "eraser" });
}
function ArrowToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "arrow" });
}
function TextToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "text" });
}
function NoteToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "note" });
}
function AssetToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "asset" });
}
function RectangleToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "rectangle" });
}
function EllipseToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "ellipse" });
}
function DiamondToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "diamond" });
}
function TriangleToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "triangle" });
}
function RhombusToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "rhombus" });
}
function HeartToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "heart" });
}
function HexagonToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "hexagon" });
}
function CloudToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "cloud" });
}
function StarToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "star" });
}
function OvalToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "oval" });
}
function XBoxToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "x-box" });
}
function CheckBoxToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "check-box" });
}
function ArrowLeftToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "arrow-left" });
}
function ArrowUpToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "arrow-up" });
}
function ArrowDownToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "arrow-down" });
}
function ArrowRightToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "arrow-right" });
}
function LineToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "line" });
}
function HighlightToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "highlight" });
}
function FrameToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "frame" });
}
function LaserToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "laser" });
}
const isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object2, event, method, useCapture) {
  if (object2.addEventListener) {
    object2.addEventListener(event, method, useCapture);
  } else if (object2.attachEvent) {
    object2.attachEvent("on".concat(event), method);
  }
}
function removeEvent(object2, event, method, useCapture) {
  if (object2.removeEventListener) {
    object2.removeEventListener(event, method, useCapture);
  } else if (object2.detachEvent) {
    object2.detachEvent("on".concat(event), method);
  }
}
function getMods(modifier, key) {
  const mods = key.slice(0, key.length - 1);
  for (let i = 0; i < mods.length; i++) mods[i] = modifier[mods[i].toLowerCase()];
  return mods;
}
function getKeys$1(key) {
  if (typeof key !== "string") key = "";
  key = key.replace(/\s/g, "");
  const keys2 = key.split(",");
  let index2 = keys2.lastIndexOf("");
  for (; index2 >= 0; ) {
    keys2[index2 - 1] += ",";
    keys2.splice(index2, 1);
    index2 = keys2.lastIndexOf("");
  }
  return keys2;
}
function compareArray(a1, a2) {
  const arr1 = a1.length >= a2.length ? a1 : a2;
  const arr2 = a1.length >= a2.length ? a2 : a1;
  let isIndex = true;
  for (let i = 0; i < arr1.length; i++) {
    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;
  }
  return isIndex;
}
const _keyMap = {
  backspace: 8,
  "": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  /// https://w3c.github.io/uievents/#events-keyboard-key-location
  arrowup: 38,
  arrowdown: 40,
  arrowleft: 37,
  arrowright: 39,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "{": 219,
  "}": 221,
  "[": 219,
  "]": 221,
  "\\": 220
};
const _modifier = {
  // shiftKey
  "": 16,
  shift: 16,
  // altKey
  "": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "": 91,
  cmd: 91,
  meta: 91,
  command: 91
};
const modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
const _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
const _handlers = {};
for (let k = 1; k < 20; k++) {
  _keyMap["f".concat(k)] = 111 + k;
}
let _downKeys = [];
let winListendFocus = null;
let _scope = "all";
const elementEventMap = /* @__PURE__ */ new Map();
const code = (x) => _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
const getKey = (x) => Object.keys(_keyMap).find((k) => _keyMap[k] === x);
const getModifier = (x) => Object.keys(_modifier).find((k) => _modifier[k] === x);
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function getPressedKeyString() {
  return _downKeys.map((c) => getKey(c) || getModifier(c) || String.fromCharCode(c));
}
function getAllKeyCodes() {
  const result = [];
  Object.keys(_handlers).forEach((k) => {
    _handlers[k].forEach((_ref) => {
      let {
        key,
        scope,
        mods,
        shortcut
      } = _ref;
      result.push({
        scope,
        shortcut,
        mods,
        keys: key.split("+").map((v) => code(v))
      });
    });
  });
  return result;
}
function filter(event) {
  const target = event.target || event.srcElement;
  const {
    tagName
  } = target;
  let flag = true;
  const isInput = tagName === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(target.type);
  if (target.isContentEditable || (isInput || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  let handlers2;
  let i;
  if (!scope) scope = getScope();
  for (const key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers2 = _handlers[key];
      for (i = 0; i < handlers2.length; ) {
        if (handlers2[i].scope === scope) {
          const deleteItems = handlers2.splice(i, 1);
          deleteItems.forEach((_ref2) => {
            let {
              element
            } = _ref2;
            return removeKeyEvent(element);
          });
        } else {
          i++;
        }
      }
    }
  }
  if (getScope() === scope) setScope(newScope || "all");
}
function clearModifier(event) {
  let key = event.keyCode || event.which || event.charCode;
  if (event.key && event.key.toLowerCase() === "capslock") {
    key = code(event.key);
  }
  const i = _downKeys.indexOf(key);
  if (i >= 0) {
    _downKeys.splice(i, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224) key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (const k in _modifier) if (_modifier[k] === key) hotkeys[k] = false;
  }
}
function unbind(keysInfo) {
  if (typeof keysInfo === "undefined") {
    Object.keys(_handlers).forEach((key) => {
      Array.isArray(_handlers[key]) && _handlers[key].forEach((info) => eachUnbind(info));
      delete _handlers[key];
    });
    removeKeyEvent(null);
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach((info) => {
      if (info.key) eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key) eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    let [scope, method] = args;
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
const eachUnbind = (_ref3) => {
  let {
    key,
    scope,
    method,
    splitKey = "+"
  } = _ref3;
  const multipleKeys = getKeys$1(key);
  multipleKeys.forEach((originKey) => {
    const unbindKeys = originKey.split(splitKey);
    const len = unbindKeys.length;
    const lastKey = unbindKeys[len - 1];
    const keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode]) return;
    if (!scope) scope = getScope();
    const mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
    const unbindElements = [];
    _handlers[keyCode] = _handlers[keyCode].filter((record) => {
      const isMatchingMethod = method ? record.method === method : true;
      const isUnbind = isMatchingMethod && record.scope === scope && compareArray(record.mods, mods);
      if (isUnbind) unbindElements.push(record.element);
      return !isUnbind;
    });
    unbindElements.forEach((element) => removeKeyEvent(element));
  });
};
function eventHandler(event, handler, scope, element) {
  if (handler.element !== element) {
    return;
  }
  let modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (const y in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y)) {
        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      handler.keys = [];
      handler.keys = handler.keys.concat(_downKeys);
      if (handler.method(event, handler) === false) {
        if (event.preventDefault) event.preventDefault();
        else event.returnValue = false;
        if (event.stopPropagation) event.stopPropagation();
        if (event.cancelBubble) event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event, element) {
  const asterisk = _handlers["*"];
  let key = event.keyCode || event.which || event.charCode;
  if (event.key && event.key.toLowerCase() === "capslock") {
    return;
  }
  if (!hotkeys.filter.call(this, event)) return;
  if (key === 93 || key === 224) key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);
  ["metaKey", "ctrlKey", "altKey", "shiftKey"].forEach((keyName2) => {
    const keyNum = modifierMap[keyName2];
    if (event[keyName2] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName2] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName2 === "metaKey" && event[keyName2]) {
      _downKeys = _downKeys.filter((k) => k in modifierMap || k === key);
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (const k in _modifier) {
      if (Object.prototype.hasOwnProperty.call(_modifier, k)) {
        const eventKey = modifierMap[_modifier[k]];
        hotkeys[k] = event[eventKey];
      }
    }
    if (!asterisk) return;
  }
  for (const e in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
      _mods[e] = event[modifierMap[e]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  const scope = getScope();
  if (asterisk) {
    for (let i = 0; i < asterisk.length; i++) {
      if (asterisk[i].scope === scope && (event.type === "keydown" && asterisk[i].keydown || event.type === "keyup" && asterisk[i].keyup)) {
        eventHandler(event, asterisk[i], scope, element);
      }
    }
  }
  if (!(key in _handlers)) return;
  const handlerKey = _handlers[key];
  const keyLen = handlerKey.length;
  for (let i = 0; i < keyLen; i++) {
    if (event.type === "keydown" && handlerKey[i].keydown || event.type === "keyup" && handlerKey[i].keyup) {
      if (handlerKey[i].key) {
        const record = handlerKey[i];
        const {
          splitKey
        } = record;
        const keyShortcut = record.key.split(splitKey);
        const _downKeysCurrent = [];
        for (let a = 0; a < keyShortcut.length; a++) {
          _downKeysCurrent.push(code(keyShortcut[a]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope, element);
        }
      }
    }
  }
}
function hotkeys(key, option, method) {
  _downKeys = [];
  const keys2 = getKeys$1(key);
  let mods = [];
  let scope = "all";
  let element = document;
  let i = 0;
  let keyup = false;
  let keydown = true;
  let splitKey = "+";
  let capture = false;
  let single = false;
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope) scope = option.scope;
    if (option.element) element = option.element;
    if (option.keyup) keyup = option.keyup;
    if (option.keydown !== void 0) keydown = option.keydown;
    if (option.capture !== void 0) capture = option.capture;
    if (typeof option.splitKey === "string") splitKey = option.splitKey;
    if (option.single === true) single = true;
  }
  if (typeof option === "string") scope = option;
  if (single) unbind(key, scope);
  for (; i < keys2.length; i++) {
    key = keys2[i].split(splitKey);
    mods = [];
    if (key.length > 1) mods = getMods(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers)) _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys2[i],
      method,
      key: keys2[i],
      splitKey,
      element
    });
  }
  if (typeof element !== "undefined" && window) {
    if (!elementEventMap.has(element)) {
      const keydownListener = function() {
        let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return dispatch(event, element);
      };
      const keyupListenr = function() {
        let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        dispatch(event, element);
        clearModifier(event);
      };
      elementEventMap.set(element, {
        keydownListener,
        keyupListenr,
        capture
      });
      addEvent(element, "keydown", keydownListener, capture);
      addEvent(element, "keyup", keyupListenr, capture);
    }
    if (!winListendFocus) {
      const listener = () => {
        _downKeys = [];
      };
      winListendFocus = {
        listener,
        capture
      };
      addEvent(window, "focus", listener, capture);
    }
  }
}
function trigger(shortcut) {
  let scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(_handlers).forEach((key) => {
    const dataList = _handlers[key].filter((item) => item.scope === scope && item.shortcut === shortcut);
    dataList.forEach((data) => {
      if (data && data.method) {
        data.method();
      }
    });
  });
}
function removeKeyEvent(element) {
  const values = Object.values(_handlers).flat();
  const findindex = values.findIndex((_ref4) => {
    let {
      element: el
    } = _ref4;
    return el === element;
  });
  if (findindex < 0) {
    const {
      keydownListener,
      keyupListenr,
      capture
    } = elementEventMap.get(element) || {};
    if (keydownListener && keyupListenr) {
      removeEvent(element, "keyup", keyupListenr, capture);
      removeEvent(element, "keydown", keydownListener, capture);
      elementEventMap.delete(element);
    }
  }
  if (values.length <= 0 || elementEventMap.size <= 0) {
    const eventKeys = Object.keys(elementEventMap);
    eventKeys.forEach((el) => {
      const {
        keydownListener,
        keyupListenr,
        capture
      } = elementEventMap.get(el) || {};
      if (keydownListener && keyupListenr) {
        removeEvent(el, "keyup", keyupListenr, capture);
        removeEvent(el, "keydown", keydownListener, capture);
        elementEventMap.delete(el);
      }
    });
    elementEventMap.clear();
    Object.keys(_handlers).forEach((key) => delete _handlers[key]);
    if (winListendFocus) {
      const {
        listener,
        capture
      } = winListendFocus;
      removeEvent(window, "focus", listener, capture);
      winListendFocus = null;
    }
  }
}
const _api = {
  getPressedKeyString,
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  getAllKeyCodes,
  isPressed,
  filter,
  trigger,
  unbind,
  keyMap: _keyMap,
  modifier: _modifier,
  modifierMap
};
for (const a in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a)) {
    hotkeys[a] = _api[a];
  }
}
if (typeof window !== "undefined") {
  const _hotkeys = window.hotkeys;
  hotkeys.noConflict = (deep) => {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}
const SKIP_KBDS = [
  // we set these in useNativeClipboardEvents instead
  "copy",
  "cut",
  "paste",
  // There's also an upload asset action, so we don't want to set the kbd twice
  "asset"
];
function useKeyboardShortcuts() {
  const editor = useEditor();
  const isReadonlyMode = useReadonly();
  const actions = useActions();
  const tools = useTools();
  const isFocused = useValue("is focused", () => editor.getInstanceState().isFocused, [editor]);
  reactExports.useEffect(() => {
    if (!isFocused) return;
    const disposables = new Array();
    const container = editor.getContainer();
    const hot = (keys2, callback) => {
      hotkeys(keys2, { element: container.ownerDocument.body }, callback);
      disposables.push(() => {
        hotkeys.unbind(keys2, callback);
      });
    };
    const hotUp = (keys2, callback) => {
      hotkeys(
        keys2,
        { element: container.ownerDocument.body, keyup: true, keydown: false },
        callback
      );
      disposables.push(() => {
        hotkeys.unbind(keys2, callback);
      });
    };
    for (const action of Object.values(actions)) {
      if (!action.kbd) continue;
      if (isReadonlyMode && !action.readonlyOk) continue;
      if (SKIP_KBDS.includes(action.id)) continue;
      hot(getHotkeysStringFromKbd(action.kbd), (event) => {
        if (areShortcutsDisabled(editor) && !action.isRequiredA11yAction) return;
        preventDefault(event);
        action.onSelect("kbd");
      });
    }
    for (const tool of Object.values(tools)) {
      if (!tool.kbd || !tool.readonlyOk && editor.getIsReadonly()) {
        continue;
      }
      if (SKIP_KBDS.includes(tool.id)) continue;
      hot(getHotkeysStringFromKbd(tool.kbd), (event) => {
        if (areShortcutsDisabled(editor)) return;
        preventDefault(event);
        tool.onSelect("kbd");
      });
    }
    hot(",", (e) => {
      if (areShortcutsDisabled(editor)) return;
      if (editor.inputs.keys.has("Comma")) return;
      preventDefault(e);
      editor.focus();
      editor.inputs.keys.add("Comma");
      const { x, y, z } = editor.inputs.currentPagePoint;
      const screenpoints = editor.pageToScreen({ x, y });
      const info = {
        type: "pointer",
        name: "pointer_down",
        point: { x: screenpoints.x, y: screenpoints.y, z },
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e),
        pointerId: 0,
        button: 0,
        isPen: editor.getInstanceState().isPenMode,
        target: "canvas"
      };
      editor.dispatch(info);
    });
    hotUp(",", (e) => {
      if (areShortcutsDisabled(editor)) return;
      if (!editor.inputs.keys.has("Comma")) return;
      editor.inputs.keys.delete("Comma");
      const { x, y, z } = editor.inputs.currentScreenPoint;
      const info = {
        type: "pointer",
        name: "pointer_up",
        point: { x, y, z },
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e),
        pointerId: 0,
        button: 0,
        isPen: editor.getInstanceState().isPenMode,
        target: "canvas"
      };
      editor.dispatch(info);
    });
    return () => {
      disposables.forEach((d) => d());
    };
  }, [actions, tools, isReadonlyMode, editor, isFocused]);
}
function areShortcutsDisabled(editor) {
  return editor.menus.hasAnyOpenMenus() || editor.getEditingShapeId() !== null || editor.getCrashingError() || !editor.user.getAreKeyboardShortcutsEnabled();
}
function getHotkeysStringFromKbd(kbd2) {
  return getKeys(kbd2).map((kbd22) => {
    let str = "";
    const shift2 = kbd22.includes("!");
    const alt = kbd22.includes("?");
    const cmd = kbd22.includes("$");
    const k = kbd22.replace(/[!?$]/g, "");
    if (shift2 && alt && cmd) {
      str = `cmd+shift+alt+${k},ctrl+shift+alt+${k}`;
    } else if (shift2 && cmd) {
      str = `cmd+shift+${k},ctrl+shift+${k}`;
    } else if (alt && cmd) {
      str = `cmd+alt+${k},ctrl+alt+${k}`;
    } else if (alt && shift2) {
      str = `shift+alt+${k}`;
    } else if (shift2) {
      str = `shift+${k}`;
    } else if (alt) {
      str = `alt+${k}`;
    } else if (cmd) {
      str = `cmd+${k},ctrl+${k}`;
    } else {
      str = k;
    }
    return str;
  }).join(",");
}
function getKeys(key) {
  if (typeof key !== "string") key = "";
  key = key.replace(/\s/g, "");
  const keys2 = key.split(",");
  let index2 = keys2.lastIndexOf("");
  for (; index2 >= 0; ) {
    keys2[index2 - 1] += ",";
    keys2.splice(index2, 1);
    index2 = keys2.lastIndexOf("");
  }
  return keys2;
}
const IsInOverflowContext = reactExports.createContext(false);
const NUMBERED_SHORTCUT_KEYS = {
  "1": 0,
  "2": 1,
  "3": 2,
  "4": 3,
  "5": 4,
  "6": 5,
  "7": 6,
  "8": 7,
  "9": 8,
  "0": 9
};
function OverflowingToolbar({
  children,
  orientation,
  sizingParentClassName,
  minItems,
  minSizePx,
  maxItems,
  maxSizePx
}) {
  const editor = useEditor();
  const id = useUniqueSafeId();
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const rButtons = reactExports.useRef([]);
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const mainToolsRef = reactExports.useRef(null);
  const [overflowTools, setOverflowTools] = reactExports.useState(null);
  const [lastActiveOverflowItem, setLastActiveOverflowItem] = reactExports.useState(null);
  const [shouldShowOverflow, setShouldShowOverflow] = reactExports.useState(false);
  const onDomUpdate = useEvent(() => {
    if (!mainToolsRef.current) return;
    const sizeProp = orientation === "horizontal" ? "offsetWidth" : "offsetHeight";
    const mainItems = collectItems(mainToolsRef.current.children);
    const overflowItems = overflowTools ? collectItems(overflowTools.children) : null;
    function collectItems(collection) {
      const items = [];
      for (const child of collection) {
        if (child.classList.contains("tlui-main-toolbar__group")) {
          items.push({
            type: "group",
            items: collectItems(child.children),
            element: child
          });
        } else if (!child.hasAttribute("data-radix-popper-content-wrapper")) {
          items.push({ type: "item", element: child });
        }
      }
      return items;
    }
    const sizingParent = findParentWithClassName(mainToolsRef.current, sizingParentClassName);
    const size2 = sizingParent[sizeProp];
    const itemsToShow = Math.floor(
      modulate(size2, [minSizePx, maxSizePx], [minItems, maxItems], true)
    );
    let mainItemCount = 0;
    let newActiveOverflowItem = null;
    let shouldInvalidateLastActiveOverflowItem = false;
    const numberedButtons = [];
    function visitItems(mainItems2, overflowItems2) {
      if (overflowItems2) assert(mainItems2.length === overflowItems2.length);
      let didShowAnyInMain = false;
      let didShowAnyInOverflow2 = false;
      for (let i = 0; i < mainItems2.length; i++) {
        const mainItem = mainItems2[i];
        const overflowItem = overflowItems2?.[i];
        if (mainItem.type === "item") {
          const isLastActiveOverflowItem = mainItem.element.getAttribute("data-value") === lastActiveOverflowItem;
          let shouldShowInMain;
          if (lastActiveOverflowItem) {
            shouldShowInMain = mainItemCount < itemsToShow || isLastActiveOverflowItem;
          } else {
            shouldShowInMain = mainItemCount <= itemsToShow;
          }
          const shouldShowInOverflow = mainItemCount >= itemsToShow;
          didShowAnyInMain ||= shouldShowInMain;
          didShowAnyInOverflow2 ||= shouldShowInOverflow;
          setAttribute(
            mainItem.element,
            "data-toolbar-visible",
            shouldShowInMain ? "true" : "false"
          );
          if (overflowItem) {
            assert(overflowItem.type === "item");
            setAttribute(
              overflowItem.element,
              "data-toolbar-visible",
              shouldShowInOverflow ? "true" : "false"
            );
          }
          if (shouldShowInOverflow && mainItem.element.getAttribute("aria-pressed") === "true") {
            newActiveOverflowItem = mainItem.element.getAttribute("data-value");
          }
          if (shouldShowInMain && mainItem.element.tagName === "BUTTON") {
            numberedButtons.push(mainItem.element);
          }
          if (!shouldShowInOverflow && isLastActiveOverflowItem) {
            shouldInvalidateLastActiveOverflowItem = true;
          }
          mainItemCount++;
        } else {
          let result, overflowGroup;
          if (overflowItem) {
            assert(overflowItem.type === "group");
            overflowGroup = overflowItem;
            result = visitItems(mainItem.items, overflowGroup.items);
          } else {
            result = visitItems(mainItem.items, null);
          }
          didShowAnyInMain ||= result.didShowAnyInMain;
          didShowAnyInOverflow2 ||= result.didShowAnyInOverflow;
          setAttribute(
            mainItem.element,
            "data-toolbar-visible",
            result.didShowAnyInMain ? "true" : "false"
          );
          if (overflowGroup) {
            setAttribute(
              overflowGroup.element,
              "data-toolbar-visible",
              result.didShowAnyInOverflow ? "true" : "false"
            );
          }
        }
      }
      return { didShowAnyInMain, didShowAnyInOverflow: didShowAnyInOverflow2 };
    }
    const { didShowAnyInOverflow } = visitItems(mainItems, overflowItems);
    setShouldShowOverflow(didShowAnyInOverflow);
    if (newActiveOverflowItem) {
      setLastActiveOverflowItem(newActiveOverflowItem);
    } else if (shouldInvalidateLastActiveOverflowItem) {
      setLastActiveOverflowItem(null);
    }
    rButtons.current = numberedButtons;
  });
  reactExports.useLayoutEffect(() => {
    onDomUpdate();
  });
  reactExports.useLayoutEffect(() => {
    if (!mainToolsRef.current) return;
    const mutationObserver = new MutationObserver(onDomUpdate);
    mutationObserver.observe(mainToolsRef.current, {
      childList: true,
      subtree: true,
      attributes: true,
      characterData: true
    });
    const sizingParent = findParentWithClassName(mainToolsRef.current, sizingParentClassName);
    const resizeObserver = new ResizeObserver(onDomUpdate);
    resizeObserver.observe(sizingParent);
    return () => {
      mutationObserver.disconnect();
      resizeObserver.disconnect();
    };
  }, [onDomUpdate, sizingParentClassName]);
  reactExports.useEffect(() => {
    if (!editor.options.enableToolbarKeyboardShortcuts) return;
    function handleKeyDown2(event) {
      if (areShortcutsDisabled(editor) || activeElementShouldCaptureKeys(
        true
        /* allow buttons */
      )) {
        return;
      }
      if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey) return;
      const index2 = NUMBERED_SHORTCUT_KEYS[event.key];
      if (typeof index2 === "number") {
        preventDefault(event);
        rButtons.current[index2]?.click();
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [editor]);
  const popoverId = "toolbar overflow";
  const Layout2 = orientation === "horizontal" ? TldrawUiRow : TldrawUiColumn;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TldrawUiToolbar,
    {
      orientation,
      className: classNames("tlui-main-toolbar__tools", {
        "tlui-main-toolbar__tools__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
      }),
      label: msg2("tool-panel.title"),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Layout2, { id: `${id}_main`, ref: mainToolsRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "toolbar", sourceId: "toolbar", children }) }),
        shouldShowOverflow && /* @__PURE__ */ jsxRuntimeExports.jsx(IsInOverflowContext.Provider, { value: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: popoverId, open: isOpen, onOpenChange: setIsOpen, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            TldrawUiToolbarButton,
            {
              title: msg2("tool-panel.more"),
              type: "tool",
              className: "tlui-main-toolbar__overflow",
              "data-testid": "tools.more-button",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TldrawUiButtonIcon,
                {
                  icon: orientation === "horizontal" ? "chevron-up" : "chevron-right"
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TldrawUiPopoverContent,
            {
              side: orientation === "horizontal" ? "top" : "right",
              align: orientation === "horizontal" ? "center" : "end",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TldrawUiToolbar,
                {
                  orientation: "grid",
                  className: "tlui-main-toolbar__overflow-content",
                  ref: setOverflowTools,
                  "data-testid": "tools.more-content",
                  label: msg2("tool-panel.more"),
                  id: `${id}_more`,
                  onClick: () => {
                    tlmenus.deleteOpenMenu(popoverId, editor.contextId);
                    setIsOpen(false);
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "toolbar-overflow", sourceId: "toolbar", children })
                }
              )
            }
          )
        ] }) })
      ]
    }
  ) });
}
function findParentWithClassName(startingElement, className) {
  let element = startingElement;
  while (element) {
    if (element.classList.contains(className)) {
      return element;
    }
    element = element.parentElement;
  }
  throw new Error("Could not find parent with class name " + className);
}
function setAttribute(element, name, value) {
  if (element.getAttribute(name) === value) return;
  element.setAttribute(name, value);
}
function ToggleToolLockedButton({ activeToolId }) {
  const editor = useEditor();
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const actions = useActions();
  const isToolLocked = useValue("is tool locked", () => editor.getInstanceState().isToolLocked, [
    editor
  ]);
  const tool = useValue("current tool", () => editor.getCurrentTool(), [editor]);
  if (!activeToolId || !tool.isLockable) return null;
  const toggleLockAction = actions["toggle-tool-lock"];
  const tooltipContent = toggleLockAction?.kbd ? `${msg2("action.toggle-tool-lock")} ${kbdStr(toggleLockAction.kbd)}` : msg2("action.toggle-tool-lock");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiTooltip, { content: tooltipContent, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiButton,
    {
      type: "normal",
      "data-testid": "tool-lock",
      className: classNames("tlui-main-toolbar__lock-button", {
        "tlui-main-toolbar__lock-button__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
      }),
      onClick: () => editor.updateInstanceState({ isToolLocked: !isToolLocked }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: isToolLocked ? "lock" : "unlock", small: true })
    }
  ) });
}
const DefaultToolbar = reactExports.memo(function DefaultToolbar2({
  children,
  orientation = "horizontal",
  minItems = 4,
  minSizePx = 310,
  maxItems = 8,
  maxSizePx = 470
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const activeToolId = useValue("current tool id", () => editor.getCurrentToolId(), [editor]);
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const { ActionsMenu, QuickActions } = useTldrawUiComponents();
  const showQuickActions = editor.options.actionShortcutsLocation === "menu" ? false : editor.options.actionShortcutsLocation === "toolbar" ? true : breakpoint < PORTRAIT_BREAKPOINT.TABLET;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiOrientationProvider,
    {
      orientation,
      tooltipSide: orientation === "horizontal" ? "top" : "right",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref,
          className: classNames("tlui-main-toolbar", `tlui-main-toolbar--${orientation}`),
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-main-toolbar__inner", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-main-toolbar__left", children: [
              !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-main-toolbar__extras", children: [
                showQuickActions && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  TldrawUiToolbar,
                  {
                    orientation,
                    className: "tlui-main-toolbar__extras__controls",
                    label: msg2("actions-menu.title"),
                    children: [
                      QuickActions && /* @__PURE__ */ jsxRuntimeExports.jsx(QuickActions, {}),
                      ActionsMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(ActionsMenu, {})
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleToolLockedButton, { activeToolId })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                OverflowingToolbar,
                {
                  orientation,
                  sizingParentClassName: "tlui-main-toolbar",
                  minItems,
                  maxItems,
                  minSizePx,
                  maxSizePx,
                  children: children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultToolbarContent, {})
                }
              )
            ] }),
            breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM && !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-main-toolbar__tools tlui-main-toolbar__mobile-style-panel", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MobileStylePanel, {}) })
          ] })
        }
      )
    }
  );
});
const DefaultVideoToolbarContent = track(function DefaultVideoToolbarContent2({
  videoShapeId,
  onEditAltTextStart
}) {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const source = "video-toolbar";
  const isReadonly = editor.getIsReadonly();
  const actions = useActions();
  const handleVideoReplace = reactExports.useCallback(
    () => actions["video-replace"].onSelect("video-toolbar"),
    [actions]
  );
  const handleVideoDownload = reactExports.useCallback(
    () => actions["download-original"].onSelect("video-toolbar"),
    [actions]
  );
  const altText = useValue(
    "altText",
    () => editor.getShape(videoShapeId).props.altText,
    [editor, videoShapeId]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !isReadonly && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        type: "icon",
        title: msg2("tool.replace-media"),
        onClick: handleVideoReplace,
        "data-testid": "tool.video-replace",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "tool-media" })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        type: "icon",
        title: msg2("action.download-original"),
        onClick: handleVideoDownload,
        "data-testid": "tool.video-download",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "download" })
      }
    ),
    (altText || !isReadonly) && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiToolbarButton,
      {
        type: "icon",
        isActive: !!altText,
        title: msg2("tool.media-alt-text"),
        "data-testid": "tool.video-alt-text",
        onClick: () => {
          trackEvent("alt-text-start", { source });
          onEditAltTextStart();
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "alt" })
      }
    )
  ] });
});
const DefaultVideoToolbar = track(function DefaultVideoToolbar2({
  children
}) {
  const editor = useEditor();
  const videoShapeId = useValue(
    "videoShape",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape || onlySelectedShape.type !== "video") return null;
      return onlySelectedShape.id;
    },
    [editor]
  );
  const showToolbar = editor.isInAny("select.idle", "select.pointing_shape");
  const isLocked = useValue(
    "locked",
    () => videoShapeId ? editor.getShape(videoShapeId)?.isLocked : false,
    [editor, videoShapeId]
  );
  if (!videoShapeId || !showToolbar || isLocked) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ContextualToolbarInner, { videoShapeId, children }, videoShapeId);
});
function ContextualToolbarInner({
  children,
  videoShapeId
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const [isEditingAltText, setIsEditingAltText] = reactExports.useState(false);
  const handleEditAltTextStart = reactExports.useCallback(() => setIsEditingAltText(true), []);
  const onEditAltTextClose = reactExports.useCallback(() => setIsEditingAltText(false), []);
  const getSelectionBounds = reactExports.useCallback(() => {
    const fullBounds = editor.getSelectionScreenBounds();
    if (!fullBounds) return void 0;
    return new Box(fullBounds.x, fullBounds.y, fullBounds.width, 0);
  }, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiContextualToolbar,
    {
      className: "tlui-video__toolbar",
      getSelectionBounds,
      label: msg2("tool.video-toolbar-title"),
      children: children ? children : isEditingAltText ? /* @__PURE__ */ jsxRuntimeExports.jsx(AltTextEditor, { shapeId: videoShapeId, onClose: onEditAltTextClose, source: "video-toolbar" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        DefaultVideoToolbarContent,
        {
          videoShapeId,
          onEditAltTextStart: handleEditAltTextStart
        }
      )
    }
  );
}
function OfflineIndicator() {
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames("tlui-offline-indicator"), children: [
    msg2("status.offline"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiIcon, { label: msg2("status.offline"), icon: "status-offline", small: true })
  ] });
}
function CenteredTopPanelContainer({
  maxWidth = 420,
  ignoreRightWidth = 0,
  stylePanelWidth = 148,
  marginBetweenZones = 12,
  squeezeAmount = 52,
  children
}) {
  const ref = reactExports.useRef(null);
  const breakpoint = useBreakpoint();
  const updateLayout = reactExports.useCallback(() => {
    const element = ref.current;
    if (!element) return;
    const layoutTop = element.parentElement.parentElement;
    const leftPanel = layoutTop.querySelector(".tlui-layout__top__left");
    const rightPanel = layoutTop.querySelector(".tlui-layout__top__right");
    const totalWidth = layoutTop.offsetWidth;
    const leftWidth = leftPanel.offsetWidth;
    const rightWidth = rightPanel.offsetWidth;
    const selfWidth = element.offsetWidth - ignoreRightWidth;
    let xCoordIfCentered = (totalWidth - selfWidth) / 2;
    if (totalWidth % 2 !== 0) {
      xCoordIfCentered -= 0.5;
    }
    const xCoordIfLeftAligned = leftWidth + marginBetweenZones;
    const left = element.offsetLeft;
    const maxWidthProperty = Math.min(
      totalWidth - rightWidth - leftWidth - 2 * marginBetweenZones,
      maxWidth
    );
    const xCoord = Math.max(xCoordIfCentered, xCoordIfLeftAligned) - left;
    if (rightPanel.offsetWidth > stylePanelWidth && breakpoint <= 6) {
      element.style.setProperty("max-width", maxWidthProperty - squeezeAmount + "px");
    } else {
      element.style.setProperty("max-width", maxWidthProperty + "px");
    }
    element.style.setProperty("transform", `translate(${xCoord}px, 0px)`);
  }, [breakpoint, ignoreRightWidth, marginBetweenZones, maxWidth, squeezeAmount, stylePanelWidth]);
  reactExports.useLayoutEffect(() => {
    const element = ref.current;
    if (!element) return;
    const layoutTop = element.parentElement.parentElement;
    const leftPanel = layoutTop.querySelector(".tlui-layout__top__left");
    const rightPanel = layoutTop.querySelector(".tlui-layout__top__right");
    const observer = new ResizeObserver(updateLayout);
    observer.observe(leftPanel);
    observer.observe(rightPanel);
    observer.observe(layoutTop);
    observer.observe(element);
    updateLayout();
    return () => {
      observer.disconnect();
    };
  }, [updateLayout]);
  reactExports.useLayoutEffect(() => {
    updateLayout();
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: "tlui-top-panel__container", children });
}
function DefaultTopPanel() {
  const isOffline = useCollaborationStatus() === "offline";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CenteredTopPanelContainer, { children: isOffline && /* @__PURE__ */ jsxRuntimeExports.jsx(OfflineIndicator, {}) });
}
function DefaultZoomMenuContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-in", noClose: true }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-out", noClose: true }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomTo100MenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomToFitMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomToSelectionMenuItem, {})
  ] });
}
const DefaultZoomMenu = reactExports.memo(function DefaultZoomMenu2({ children }) {
  const container = useContainer();
  const [isOpen, onOpenChange] = useMenuIsOpen("zoom menu");
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultZoomMenuContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$3, { dir: "ltr", open: isOpen, onOpenChange, modal: false, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomTriggerButton, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$2,
      {
        className: "tlui-menu",
        side: "top",
        align: "start",
        alignOffset: 0,
        sideOffset: 8,
        collisionPadding: 4,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "menu", sourceId: "zoom-menu", children: content })
      }
    ) })
  ] });
});
const ZoomTriggerButton = () => {
  const editor = useEditor();
  const breakpoint = useBreakpoint();
  const zoom = useValue("zoom", () => editor.getZoomLevel(), [editor]);
  const msg2 = useTranslation();
  const handleDoubleClick2 = reactExports.useCallback(() => {
    editor.resetZoom(editor.getViewportScreenCenter(), {
      animation: { duration: editor.options.animationMediumMs }
    });
  }, [editor]);
  const value = `${Math.floor(zoom * 100)}%`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiToolbarButton,
    {
      asChild: true,
      type: "icon",
      "aria-label": `${msg2("navigation-zone.zoom")}  ${value}`,
      title: `${msg2("navigation-zone.zoom")}  ${value}`,
      "data-testid": "minimap.zoom-menu-button",
      className: "tlui-zoom-menu__button",
      onDoubleClick: handleDoubleClick2,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$2, { dir: "ltr", children: breakpoint < PORTRAIT_BREAKPOINT.MOBILE ? null : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { flexGrow: 0, textAlign: "center" }, children: value }) })
    }
  );
};
const TldrawUiComponentsContext = reactExports.createContext(null);
function TldrawUiComponentsProvider({
  overrides = {},
  children
}) {
  const _overrides = useShallowObjectIdentity(overrides);
  const showCollaborationUi = useShowCollaborationUi();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiComponentsContext.Provider,
    {
      value: reactExports.useMemo(
        () => ({
          ContextMenu: DefaultContextMenu,
          ActionsMenu: DefaultActionsMenu,
          HelpMenu: null,
          ZoomMenu: DefaultZoomMenu,
          MainMenu: DefaultMainMenu,
          Minimap: DefaultMinimap,
          StylePanel: DefaultStylePanel,
          PageMenu: DefaultPageMenu,
          NavigationPanel: DefaultNavigationPanel,
          Toolbar: DefaultToolbar,
          RichTextToolbar: DefaultRichTextToolbar,
          ImageToolbar: DefaultImageToolbar,
          VideoToolbar: DefaultVideoToolbar,
          KeyboardShortcutsDialog: DefaultKeyboardShortcutsDialog,
          QuickActions: DefaultQuickActions,
          HelperButtons: DefaultHelperButtons,
          DebugPanel: DefaultDebugPanel,
          DebugMenu: DefaultDebugMenu,
          MenuPanel: DefaultMenuPanel,
          SharePanel: showCollaborationUi ? DefaultSharePanel : null,
          CursorChatBubble: showCollaborationUi ? CursorChatBubble : null,
          TopPanel: showCollaborationUi ? DefaultTopPanel : null,
          Dialogs: DefaultDialogs,
          Toasts: DefaultToasts,
          A11y: DefaultA11yAnnouncer,
          FollowingIndicator: DefaultFollowingIndicator,
          ..._overrides
        }),
        [_overrides, showCollaborationUi]
      ),
      children
    }
  );
}
function useTldrawUiComponents() {
  const components = reactExports.useContext(TldrawUiComponentsContext);
  if (!components) {
    throw new Error("useTldrawUiComponents must be used within a TldrawUiComponentsProvider");
  }
  return components;
}
const ActionsContext = reactExports.createContext(null);
function supportsDownloadingOriginal(shape, editor) {
  return (editor.isShapeOfType(shape, "image") || editor.isShapeOfType(shape, "video")) && !!shape.props.assetId;
}
function makeActions(actions) {
  return Object.fromEntries(actions.map((action) => [action.id, action]));
}
function getExportName(editor, defaultName) {
  const selectedShapes = editor.getSelectedShapes();
  if (selectedShapes.length === 0) {
    return editor.getDocumentSettings().name || defaultName;
  }
  return void 0;
}
function ActionsProvider({ overrides, children }) {
  const _editor = useMaybeEditor();
  const showCollaborationUi = useShowCollaborationUi();
  const helpers = useDefaultHelpers();
  const components = useTldrawUiComponents();
  const trackEvent = useUiEvents();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const defaultDocumentName = helpers.msg("document.default-name");
  const actions = reactExports.useMemo(() => {
    const editor = _editor;
    if (!editor) return {};
    function mustGoBackToSelectToolFirst() {
      if (!editor.isIn("select")) {
        editor.complete();
        editor.setCurrentTool("select");
        return false;
      }
      return false;
    }
    function canApplySelectionAction() {
      return editor.isIn("select") && editor.getSelectedShapeIds().length > 0;
    }
    function scaleShapes(scaleFactor) {
      if (!canApplySelectionAction()) return;
      if (mustGoBackToSelectToolFirst()) return;
      editor.markHistoryStoppingPoint("resize shapes");
      const selectedShapeIds = editor.getSelectedShapeIds();
      if (selectedShapeIds.length === 0) return;
      editor.run(() => {
        const shapes = selectedShapeIds.map((id) => editor.getShape(id)).filter(Boolean);
        shapes.forEach((shape) => {
          editor.resizeShape(shape.id, new Vec(scaleFactor, scaleFactor), {
            scaleOrigin: editor.getSelectionPageBounds()?.center
          });
        });
      });
    }
    const actionItems = [
      {
        id: "edit-link",
        label: "action.edit-link",
        icon: "link",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("edit-link", { source });
          editor.markHistoryStoppingPoint("edit-link");
          helpers.addDialog({ component: EditLinkDialog });
        }
      },
      {
        id: "insert-embed",
        label: "action.insert-embed",
        kbd: "cmd+i,ctrl+i",
        onSelect(source) {
          trackEvent("insert-embed", { source });
          helpers.addDialog({ component: EmbedDialog });
        }
      },
      {
        id: "open-kbd-shortcuts",
        label: "action.open-kbd-shortcuts",
        kbd: "cmd+alt+/,ctrl+alt+/",
        onSelect(source) {
          trackEvent("open-kbd-shortcuts", { source });
          helpers.addDialog({
            component: components.KeyboardShortcutsDialog ?? DefaultKeyboardShortcutsDialog
          });
        }
      },
      {
        id: "insert-media",
        label: "action.insert-media",
        kbd: "cmd+u,ctrl+u",
        onSelect(source) {
          trackEvent("insert-media", { source });
          helpers.insertMedia();
        }
      },
      {
        id: "undo",
        label: "action.undo",
        icon: "undo",
        kbd: "cmd+z,ctrl+z",
        onSelect(source) {
          trackEvent("undo", { source });
          editor.undo();
        }
      },
      {
        id: "redo",
        label: "action.redo",
        icon: "redo",
        kbd: "cmd+shift+z,ctrl+shift+z",
        onSelect(source) {
          trackEvent("redo", { source });
          editor.redo();
        }
      },
      {
        id: "export-as-svg",
        label: {
          default: "action.export-as-svg",
          menu: "action.export-as-svg.short",
          ["context-menu"]: "action.export-as-svg.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-as", { format: "svg", source });
          helpers.exportAs(ids, { format: "svg", name: getExportName(editor, defaultDocumentName) });
        }
      },
      {
        id: "export-as-png",
        label: {
          default: "action.export-as-png",
          menu: "action.export-as-png.short",
          ["context-menu"]: "action.export-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-as", { format: "png", source });
          helpers.exportAs(ids, { format: "png", name: getExportName(editor, defaultDocumentName) });
        }
      },
      {
        id: "export-all-as-svg",
        label: {
          default: "action.export-all-as-svg",
          menu: "action.export-all-as-svg.short",
          ["context-menu"]: "action.export-all-as-svg.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-all-as", { format: "svg", source });
          helpers.exportAs(Array.from(editor.getCurrentPageShapeIds()), {
            format: "svg",
            name: getExportName(editor, defaultDocumentName)
          });
        }
      },
      {
        id: "export-all-as-png",
        label: {
          default: "action.export-all-as-png",
          menu: "action.export-all-as-png.short",
          ["context-menu"]: "action.export-all-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          const ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-all-as", { format: "png", source });
          helpers.exportAs(ids, { format: "png", name: getExportName(editor, defaultDocumentName) });
        }
      },
      {
        id: "copy-as-svg",
        label: {
          default: "action.copy-as-svg",
          menu: "action.copy-as-svg.short",
          ["context-menu"]: "action.copy-as-svg.short"
        },
        kbd: "cmd+shift+c,ctrl+shift+c",
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("copy-as", { format: "svg", source });
          helpers.copyAs(ids, "svg");
        }
      },
      {
        id: "copy-as-png",
        label: {
          default: "action.copy-as-png",
          menu: "action.copy-as-png.short",
          ["context-menu"]: "action.copy-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("copy-as", { format: "png", source });
          helpers.copyAs(ids, "png");
        }
      },
      {
        id: "toggle-auto-size",
        label: "action.toggle-auto-size",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("toggle-auto-size", { source });
          editor.markHistoryStoppingPoint("toggling auto size");
          editor.run(() => {
            const shapes = editor.getSelectedShapes().filter(
              (shape) => editor.isShapeOfType(shape, "text") && shape.props.autoSize === false
            );
            editor.updateShapes(
              shapes.map((shape) => {
                return {
                  id: shape.id,
                  type: shape.type,
                  props: {
                    ...shape.props,
                    w: 8,
                    autoSize: true
                  }
                };
              })
            );
            kickoutOccludedShapes(
              editor,
              shapes.map((shape) => shape.id)
            );
          });
        }
      },
      {
        id: "open-embed-link",
        label: "action.open-embed-link",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("open-embed-link", { source });
          const ids = editor.getSelectedShapeIds();
          const warnMsg = "No embed shapes selected";
          if (ids.length !== 1) {
            console.error(warnMsg);
            return;
          }
          const shape = editor.getShape(ids[0]);
          if (!shape || !editor.isShapeOfType(shape, "embed")) {
            console.error(warnMsg);
            return;
          }
          openWindow(shape.props.url, "_blank");
        }
      },
      {
        id: "select-zoom-tool",
        readonlyOk: true,
        kbd: "z",
        onSelect(source) {
          if (editor.root.getCurrent()?.id === "zoom") return;
          trackEvent("zoom-tool", { source });
          if (!(editor.inputs.shiftKey || editor.inputs.ctrlKey)) {
            const currentTool = editor.root.getCurrent();
            if (currentTool && currentTool.getCurrent()?.id === "idle") {
              editor.setCurrentTool("zoom", { onInteractionEnd: currentTool.id, maskAs: "zoom" });
            }
          }
        }
      },
      {
        id: "convert-to-bookmark",
        label: "action.convert-to-bookmark",
        async onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("convert-to-bookmark", { source });
          const shapes = editor.getSelectedShapes();
          const markId = editor.markHistoryStoppingPoint("convert shapes to bookmark");
          const creationPromises = [];
          for (const shape of shapes) {
            if (!shape || !editor.isShapeOfType(shape, "embed") || !shape.props.url)
              continue;
            const center = editor.getShapePageBounds(shape)?.center;
            if (!center) continue;
            editor.deleteShapes([shape.id]);
            creationPromises.push(
              createBookmarkFromUrl(editor, { url: shape.props.url, center }).then((res) => {
                if (!res.ok) {
                  throw new Error(res.error);
                }
                return res;
              })
            );
          }
          await Promise.all(creationPromises).catch((error) => {
            editor.bailToMark(markId);
            console.error(error);
          });
        }
      },
      {
        id: "convert-to-embed",
        label: "action.convert-to-embed",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("convert-to-embed", { source });
          editor.run(() => {
            const ids = editor.getSelectedShapeIds();
            const shapes = compact(ids.map((id) => editor.getShape(id)));
            const createList = [];
            const deleteList = [];
            for (const shape of shapes) {
              if (!editor.isShapeOfType(shape, "bookmark")) continue;
              const { url } = shape.props;
              const embedInfo = helpers.getEmbedDefinition(url);
              if (!embedInfo) continue;
              if (!embedInfo.definition) continue;
              const { width, height } = embedInfo.definition;
              const newPos = new Vec(shape.x, shape.y);
              newPos.rot(-shape.rotation);
              newPos.add(new Vec(shape.props.w / 2 - width / 2, shape.props.h / 2 - height / 2));
              newPos.rot(shape.rotation);
              const shapeToCreate = {
                id: createShapeId(),
                type: "embed",
                x: newPos.x,
                y: newPos.y,
                rotation: shape.rotation,
                props: {
                  url,
                  w: width,
                  h: height
                }
              };
              createList.push(shapeToCreate);
              deleteList.push(shape.id);
            }
            editor.markHistoryStoppingPoint("convert shapes to embed");
            editor.deleteShapes(deleteList);
            editor.createShapes(createList);
          });
        }
      },
      {
        id: "duplicate",
        kbd: "cmd+d,ctrl+d",
        label: "action.duplicate",
        icon: "duplicate",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("duplicate-shapes", { source });
          const instanceState = editor.getInstanceState();
          let ids;
          let offset2;
          if (instanceState.duplicateProps) {
            ids = instanceState.duplicateProps.shapeIds;
            offset2 = instanceState.duplicateProps.offset;
          } else {
            ids = editor.getSelectedShapeIds();
            const commonBounds = Box.Common(compact(ids.map((id) => editor.getShapePageBounds(id))));
            offset2 = editor.getCameraOptions().isLocked ? {
              // same as the adjacent note margin
              x: editor.options.adjacentShapeMargin,
              y: editor.options.adjacentShapeMargin
            } : {
              x: commonBounds.width + editor.options.adjacentShapeMargin,
              y: 0
            };
          }
          editor.markHistoryStoppingPoint("duplicate shapes");
          editor.duplicateShapes(ids, offset2);
          if (instanceState.duplicateProps) {
            editor.updateInstanceState({
              duplicateProps: {
                ...instanceState.duplicateProps,
                shapeIds: editor.getSelectedShapeIds()
              }
            });
          }
        }
      },
      {
        id: "ungroup",
        label: "action.ungroup",
        kbd: "cmd+shift+g,ctrl+shift+g",
        icon: "ungroup",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("ungroup-shapes", { source });
          editor.markHistoryStoppingPoint("ungroup");
          editor.ungroupShapes(editor.getSelectedShapeIds());
        }
      },
      {
        id: "group",
        label: "action.group",
        kbd: "cmd+g,ctrl+g",
        icon: "group",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("group-shapes", { source });
          const onlySelectedShape = editor.getOnlySelectedShape();
          if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "group")) {
            editor.markHistoryStoppingPoint("ungroup");
            editor.ungroupShapes(editor.getSelectedShapeIds());
          } else {
            editor.markHistoryStoppingPoint("group");
            editor.groupShapes(editor.getSelectedShapeIds());
          }
        }
      },
      {
        id: "remove-frame",
        label: "action.remove-frame",
        kbd: "cmd+shift+f,ctrl+shift+f",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          trackEvent("remove-frame", { source });
          const selectedShapes = editor.getSelectedShapes();
          if (selectedShapes.length > 0 && selectedShapes.every((shape) => editor.isShapeOfType(shape, "frame"))) {
            editor.markHistoryStoppingPoint("remove-frame");
            removeFrame(
              editor,
              selectedShapes.map((shape) => shape.id)
            );
          }
        }
      },
      {
        id: "fit-frame-to-content",
        label: "action.fit-frame-to-content",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          trackEvent("fit-frame-to-content", { source });
          const onlySelectedShape = editor.getOnlySelectedShape();
          if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "frame")) {
            editor.markHistoryStoppingPoint("fit-frame-to-content");
            fitFrameToContent(editor, onlySelectedShape.id);
          }
        }
      },
      {
        id: "align-left",
        label: "action.align-left",
        kbd: "alt+A",
        icon: "align-left",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "left", source });
          editor.markHistoryStoppingPoint("align left");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "left");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-center-horizontal",
        label: {
          default: "action.align-center-horizontal",
          ["context-menu"]: "action.align-center-horizontal.short"
        },
        kbd: "alt+H",
        icon: "align-center-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "center-horizontal", source });
          editor.markHistoryStoppingPoint("align center horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "center-horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-right",
        label: "action.align-right",
        kbd: "alt+D",
        icon: "align-right",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "right", source });
          editor.markHistoryStoppingPoint("align right");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "right");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-center-vertical",
        label: {
          default: "action.align-center-vertical",
          ["context-menu"]: "action.align-center-vertical.short"
        },
        kbd: "alt+V",
        icon: "align-center-vertical",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "center-vertical", source });
          editor.markHistoryStoppingPoint("align center vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "center-vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-top",
        label: "action.align-top",
        icon: "align-top",
        kbd: "alt+W",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "top", source });
          editor.markHistoryStoppingPoint("align top");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "top");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-bottom",
        label: "action.align-bottom",
        icon: "align-bottom",
        kbd: "alt+S",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "bottom", source });
          editor.markHistoryStoppingPoint("align bottom");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "bottom");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "distribute-horizontal",
        label: {
          default: "action.distribute-horizontal",
          ["context-menu"]: "action.distribute-horizontal.short"
        },
        icon: "distribute-horizontal",
        kbd: "alt+shift+h",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("distribute-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("distribute horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.distributeShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "distribute-vertical",
        label: {
          default: "action.distribute-vertical",
          ["context-menu"]: "action.distribute-vertical.short"
        },
        icon: "distribute-vertical",
        kbd: "alt+shift+V",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("distribute-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("distribute vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.distributeShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stretch-horizontal",
        label: {
          default: "action.stretch-horizontal",
          ["context-menu"]: "action.stretch-horizontal.short"
        },
        icon: "stretch-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stretch-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("stretch horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stretchShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stretch-vertical",
        label: {
          default: "action.stretch-vertical",
          ["context-menu"]: "action.stretch-vertical.short"
        },
        icon: "stretch-vertical",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stretch-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("stretch vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stretchShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "flip-horizontal",
        label: {
          default: "action.flip-horizontal",
          ["context-menu"]: "action.flip-horizontal.short"
        },
        kbd: "shift+h",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("flip-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("flip horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.flipShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "flip-vertical",
        label: { default: "action.flip-vertical", ["context-menu"]: "action.flip-vertical.short" },
        kbd: "shift+v",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("flip-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("flip vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.flipShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "pack",
        label: "action.pack",
        icon: "pack",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("pack-shapes", { source });
          editor.markHistoryStoppingPoint("pack");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.packShapes(selectedShapeIds, editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stack-vertical",
        label: {
          default: "action.stack-vertical",
          ["context-menu"]: "action.stack-vertical.short"
        },
        icon: "stack-vertical",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stack-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("stack-vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stackShapes(selectedShapeIds, "vertical", editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stack-horizontal",
        label: {
          default: "action.stack-horizontal",
          ["context-menu"]: "action.stack-horizontal.short"
        },
        icon: "stack-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stack-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("stack-horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stackShapes(selectedShapeIds, "horizontal", editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "bring-to-front",
        label: "action.bring-to-front",
        kbd: "]",
        icon: "bring-to-front",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "toFront", source });
          editor.markHistoryStoppingPoint("bring to front");
          editor.bringToFront(editor.getSelectedShapeIds());
        }
      },
      {
        id: "bring-forward",
        label: "action.bring-forward",
        icon: "bring-forward",
        kbd: "alt+]",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "forward", source });
          editor.markHistoryStoppingPoint("bring forward");
          editor.bringForward(editor.getSelectedShapeIds());
        }
      },
      {
        id: "send-backward",
        label: "action.send-backward",
        icon: "send-backward",
        kbd: "alt+[",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "backward", source });
          editor.markHistoryStoppingPoint("send backward");
          editor.sendBackward(editor.getSelectedShapeIds());
        }
      },
      {
        id: "send-to-back",
        label: "action.send-to-back",
        icon: "send-to-back",
        kbd: "[",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "toBack", source });
          editor.markHistoryStoppingPoint("send to back");
          editor.sendToBack(editor.getSelectedShapeIds());
        }
      },
      {
        id: "cut",
        label: "action.cut",
        kbd: "cmd+x,ctrl+x",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          editor.markHistoryStoppingPoint("cut");
          helpers.cut(source);
        }
      },
      {
        id: "copy",
        label: "action.copy",
        kbd: "cmd+c,ctrl+c",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          helpers.copy(source);
        }
      },
      {
        id: "paste",
        label: "action.paste",
        kbd: "cmd+v,ctrl+v",
        onSelect(source) {
          navigator.clipboard?.read().then((clipboardItems) => {
            helpers.paste(
              clipboardItems,
              source,
              source === "context-menu" ? editor.inputs.currentPagePoint : void 0
            );
          }).catch(() => {
            helpers.addToast({
              title: helpers.msg("action.paste-error-title"),
              description: helpers.msg("action.paste-error-description"),
              severity: "error"
            });
          });
        }
      },
      {
        id: "select-all",
        label: "action.select-all",
        kbd: "cmd+a,ctrl+a",
        readonlyOk: true,
        onSelect(source) {
          editor.run(() => {
            if (mustGoBackToSelectToolFirst()) return;
            trackEvent("select-all-shapes", { source });
            editor.markHistoryStoppingPoint("select all kbd");
            editor.selectAll();
          });
        }
      },
      {
        id: "select-none",
        label: "action.select-none",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("select-none-shapes", { source });
          editor.markHistoryStoppingPoint("select none");
          editor.selectNone();
        }
      },
      {
        id: "delete",
        label: "action.delete",
        kbd: ",del",
        icon: "trash",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("delete-shapes", { source });
          editor.markHistoryStoppingPoint("delete");
          editor.deleteShapes(editor.getSelectedShapeIds());
        }
      },
      {
        id: "rotate-cw",
        label: "action.rotate-cw",
        icon: "rotate-cw",
        kbd: "shift+.,shift+alt+.",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          const isFine = editor.inputs.altKey;
          trackEvent("rotate-cw", { source, fine: isFine });
          editor.markHistoryStoppingPoint("rotate-cw");
          editor.run(() => {
            const rotation = HALF_PI / (isFine ? 96 : 6);
            const offset2 = editor.getSelectionRotation() % rotation;
            const dontUseOffset = approximately(offset2, 0) || approximately(offset2, rotation);
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.rotateShapesBy(selectedShapeIds, rotation - (dontUseOffset ? 0 : offset2));
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "rotate-ccw",
        label: "action.rotate-ccw",
        icon: "rotate-ccw",
        // omg double comma
        kbd: "shift+,,shift+alt+,",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          const isFine = editor.inputs.altKey;
          trackEvent("rotate-ccw", { source, fine: isFine });
          editor.markHistoryStoppingPoint("rotate-ccw");
          editor.run(() => {
            const rotation = HALF_PI / (isFine ? 96 : 6);
            const offset2 = editor.getSelectionRotation() % rotation;
            const offsetCloseToZero = approximately(offset2, 0);
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.rotateShapesBy(selectedShapeIds, offsetCloseToZero ? -rotation : -offset2);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "zoom-in",
        label: "action.zoom-in",
        kbd: "cmd+=,ctrl+=,=",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-in", { source, towardsCursor: false });
          editor.zoomIn(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-in-on-cursor",
        label: "action.zoom-in",
        kbd: "shift+cmd+=,shift+ctrl+=,shift+=",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-in", { source, towardsCursor: true });
          editor.zoomIn(editor.inputs.currentScreenPoint, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out",
        label: "action.zoom-out",
        kbd: "cmd+-,ctrl+-,-",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-out", { source, towardsCursor: false });
          editor.zoomOut(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out-on-cursor",
        label: "action.zoom-out",
        kbd: "shift+cmd+-,shift+ctrl+-,shift+-",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-out", { source, towardsCursor: true });
          editor.zoomOut(editor.inputs.currentScreenPoint, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-100",
        label: "action.zoom-to-100",
        icon: "reset-zoom",
        kbd: "shift+0",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("reset-zoom", { source });
          editor.resetZoom(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-fit",
        label: "action.zoom-to-fit",
        kbd: "shift+1",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-to-fit", { source });
          editor.zoomToFit({ animation: { duration: editor.options.animationMediumMs } });
        }
      },
      {
        id: "zoom-to-selection",
        label: "action.zoom-to-selection",
        kbd: "shift+2",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("zoom-to-selection", { source });
          editor.zoomToSelection({ animation: { duration: editor.options.animationMediumMs } });
        }
      },
      {
        id: "toggle-snap-mode",
        label: {
          default: "action.toggle-snap-mode",
          menu: "action.toggle-snap-mode.menu"
        },
        onSelect(source) {
          trackEvent("toggle-snap-mode", { source });
          editor.user.updateUserPreferences({ isSnapMode: !editor.user.getIsSnapMode() });
        },
        checkbox: true
      },
      {
        id: "toggle-dark-mode",
        label: {
          default: "action.toggle-dark-mode",
          menu: "action.toggle-dark-mode.menu"
        },
        kbd: "cmd+/,ctrl+/",
        readonlyOk: true,
        onSelect(source) {
          const value = editor.user.getIsDarkMode() ? "light" : "dark";
          trackEvent("color-scheme", { source, value });
          editor.user.updateUserPreferences({
            colorScheme: value
          });
        },
        checkbox: true
      },
      {
        id: "toggle-wrap-mode",
        label: {
          default: "action.toggle-wrap-mode",
          menu: "action.toggle-wrap-mode.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-wrap-mode", { source });
          editor.user.updateUserPreferences({
            isWrapMode: !editor.user.getIsWrapMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-dynamic-size-mode",
        label: {
          default: "action.toggle-dynamic-size-mode",
          menu: "action.toggle-dynamic-size-mode.menu"
        },
        readonlyOk: false,
        onSelect(source) {
          trackEvent("toggle-dynamic-size-mode", { source });
          editor.user.updateUserPreferences({
            isDynamicSizeMode: !editor.user.getIsDynamicResizeMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-paste-at-cursor",
        label: {
          default: "action.toggle-paste-at-cursor",
          menu: "action.toggle-paste-at-cursor.menu"
        },
        readonlyOk: false,
        onSelect(source) {
          trackEvent("toggle-paste-at-cursor", { source });
          editor.user.updateUserPreferences({
            isPasteAtCursorMode: !editor.user.getIsPasteAtCursorMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-reduce-motion",
        label: {
          default: "action.toggle-reduce-motion",
          menu: "action.toggle-reduce-motion.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-reduce-motion", { source });
          editor.user.updateUserPreferences({
            animationSpeed: editor.user.getAnimationSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: true
      },
      {
        id: "toggle-keyboard-shortcuts",
        label: {
          default: "action.toggle-keyboard-shortcuts",
          menu: "action.toggle-keyboard-shortcuts.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-keyboard-shortcuts", { source });
          editor.user.updateUserPreferences({
            areKeyboardShortcutsEnabled: !editor.user.getAreKeyboardShortcutsEnabled()
          });
        },
        checkbox: true
      },
      {
        id: "enhanced-a11y-mode",
        label: {
          default: "action.enhanced-a11y-mode",
          menu: "action.enhanced-a11y-mode.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("enhanced-a11y-mode", { source });
          editor.user.updateUserPreferences({
            enhancedA11yMode: !editor.user.getEnhancedA11yMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-edge-scrolling",
        label: {
          default: "action.toggle-edge-scrolling",
          menu: "action.toggle-edge-scrolling.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-edge-scrolling", { source });
          editor.user.updateUserPreferences({
            edgeScrollSpeed: editor.user.getEdgeScrollSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: true
      },
      {
        id: "toggle-transparent",
        label: {
          default: "action.toggle-transparent",
          menu: "action.toggle-transparent.menu",
          ["context-menu"]: "action.toggle-transparent.context-menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-transparent", { source });
          editor.updateInstanceState({
            exportBackground: !editor.getInstanceState().exportBackground
          });
        },
        checkbox: true
      },
      {
        id: "toggle-tool-lock",
        label: {
          default: "action.toggle-tool-lock",
          menu: "action.toggle-tool-lock.menu"
        },
        kbd: "q",
        onSelect(source) {
          trackEvent("toggle-tool-lock", { source });
          editor.updateInstanceState({ isToolLocked: !editor.getInstanceState().isToolLocked });
        },
        checkbox: true
      },
      {
        id: "unlock-all",
        label: "action.unlock-all",
        onSelect(source) {
          trackEvent("unlock-all", { source });
          const updates = [];
          for (const shape of editor.getCurrentPageShapes()) {
            if (shape.isLocked) {
              updates.push({ id: shape.id, type: shape.type, isLocked: false });
            }
          }
          if (updates.length > 0) {
            editor.updateShapes(updates);
          }
        }
      },
      {
        id: "toggle-focus-mode",
        label: {
          default: "action.toggle-focus-mode",
          menu: "action.toggle-focus-mode.menu"
        },
        readonlyOk: true,
        kbd: "cmd+.,ctrl+.",
        checkbox: true,
        onSelect(source) {
          editor.timers.requestAnimationFrame(() => {
            editor.run(() => {
              trackEvent("toggle-focus-mode", { source });
              helpers.clearDialogs();
              helpers.clearToasts();
              editor.updateInstanceState({ isFocusMode: !editor.getInstanceState().isFocusMode });
            });
          });
        }
      },
      {
        id: "toggle-grid",
        label: {
          default: "action.toggle-grid",
          menu: "action.toggle-grid.menu"
        },
        readonlyOk: true,
        kbd: "cmd+',ctrl+'",
        onSelect(source) {
          trackEvent("toggle-grid-mode", { source });
          editor.updateInstanceState({ isGridMode: !editor.getInstanceState().isGridMode });
        },
        checkbox: true
      },
      {
        id: "toggle-debug-mode",
        label: {
          default: "action.toggle-debug-mode",
          menu: "action.toggle-debug-mode.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-debug-mode", { source });
          editor.updateInstanceState({
            isDebugMode: !editor.getInstanceState().isDebugMode
          });
        },
        checkbox: true
      },
      {
        id: "print",
        label: "action.print",
        kbd: "cmd+p,ctrl+p",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("print", { source });
          helpers.printSelectionOrPages();
        }
      },
      {
        id: "exit-pen-mode",
        label: "action.exit-pen-mode",
        icon: "cross-2",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("exit-pen-mode", { source });
          editor.updateInstanceState({ isPenMode: false });
        }
      },
      {
        id: "stop-following",
        label: "action.stop-following",
        icon: "cross-2",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("stop-following", { source });
          editor.stopFollowingUser();
        }
      },
      {
        id: "back-to-content",
        label: "action.back-to-content",
        icon: "arrow-left",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-to-content", { source });
          const bounds = editor.getSelectionPageBounds() ?? editor.getCurrentPageBounds();
          if (!bounds) return;
          editor.zoomToBounds(bounds, {
            targetZoom: Math.min(1, editor.getZoomLevel()),
            animation: { duration: 220 }
          });
        }
      },
      {
        id: "toggle-lock",
        label: "action.toggle-lock",
        kbd: "shift+l",
        onSelect(source) {
          editor.markHistoryStoppingPoint("locking");
          trackEvent("toggle-lock", { source });
          editor.toggleLock(editor.getSelectedShapeIds());
        }
      },
      {
        id: "move-to-new-page",
        label: "context.pages.new-page",
        onSelect(source) {
          const newPageId = PageRecordType.createId();
          const ids = editor.getSelectedShapeIds();
          editor.run(() => {
            editor.markHistoryStoppingPoint("move_shapes_to_page");
            editor.createPage({
              name: helpers.msg("page-menu.new-page-initial-name"),
              id: newPageId
            });
            editor.moveShapesToPage(ids, newPageId);
          });
          trackEvent("move-to-new-page", { source });
        }
      },
      {
        id: "select-white-color",
        label: "color-style.white",
        kbd: "alt+t",
        onSelect(source) {
          const style2 = DefaultColorStyle;
          editor.run(() => {
            editor.markHistoryStoppingPoint("change-color");
            if (editor.isIn("select")) {
              editor.setStyleForSelectedShapes(style2, "white");
            }
            editor.setStyleForNextShapes(style2, "white");
          });
          trackEvent("set-style", { source, id: style2.id, value: "white" });
        }
      },
      {
        id: "select-fill-fill",
        label: "fill-style.fill",
        kbd: "alt+f",
        onSelect(source) {
          const style2 = DefaultFillStyle;
          editor.run(() => {
            editor.markHistoryStoppingPoint("change-fill");
            if (editor.isIn("select")) {
              editor.setStyleForSelectedShapes(style2, "fill");
            }
            editor.setStyleForNextShapes(style2, "fill");
          });
          trackEvent("set-style", { source, id: style2.id, value: "fill" });
        }
      },
      {
        id: "select-fill-lined-fill",
        label: "fill-style.lined-fill",
        kbd: "alt+shift+f",
        onSelect(source) {
          const style2 = DefaultFillStyle;
          editor.run(() => {
            editor.markHistoryStoppingPoint("change-fill");
            if (editor.isIn("select")) {
              editor.setStyleForSelectedShapes(style2, "lined-fill");
            }
            editor.setStyleForNextShapes(style2, "lined-fill");
          });
          trackEvent("set-style", { source, id: style2.id, value: "lined-fill" });
        }
      },
      {
        id: "flatten-to-image",
        label: "action.flatten-to-image",
        kbd: "shift+f",
        onSelect: async (source) => {
          const ids = editor.getSelectedShapeIds();
          if (ids.length === 0) return;
          editor.markHistoryStoppingPoint("flattening to image");
          trackEvent("flatten-to-image", { source });
          const newShapeIds = await flattenShapesToImages(
            editor,
            ids,
            editor.options.flattenImageBoundsExpand
          );
          if (newShapeIds?.length) {
            editor.setSelectedShapes(newShapeIds);
          }
        }
      },
      {
        id: "select-geo-tool",
        kbd: "g",
        onSelect: async (source) => {
          trackEvent("select-tool", { source, id: `geo-previous` });
          editor.setCurrentTool("geo");
        }
      },
      {
        id: "change-page-prev",
        kbd: "alt+left,alt+up",
        readonlyOk: true,
        onSelect: async (source) => {
          const pages = editor.getPages();
          const currentPageIndex = pages.findIndex((page) => page.id === editor.getCurrentPageId());
          if (currentPageIndex < 1) return;
          trackEvent("change-page", { source, direction: "prev" });
          editor.setCurrentPage(pages[currentPageIndex - 1].id);
        }
      },
      {
        id: "change-page-next",
        kbd: "alt+right,alt+down",
        readonlyOk: true,
        onSelect: async (source) => {
          const pages = editor.getPages();
          const currentPageIndex = pages.findIndex((page) => page.id === editor.getCurrentPageId());
          if (currentPageIndex === -1 || currentPageIndex >= pages.length - 1) {
            if (editor.getCurrentPageShapes().length <= 0 || editor.getIsReadonly()) {
              return;
            }
            trackEvent("new-page", { source });
            editor.run(() => {
              editor.markHistoryStoppingPoint("creating page");
              const newPageId = PageRecordType.createId();
              editor.createPage({
                name: helpers.msg("page-menu.new-page-initial-name"),
                id: newPageId
              });
              editor.setCurrentPage(newPageId);
            });
            return;
          }
          editor.setCurrentPage(pages[currentPageIndex + 1].id);
          trackEvent("change-page", { source, direction: "next" });
        }
      },
      {
        id: "adjust-shape-styles",
        label: "a11y.adjust-shape-styles",
        kbd: "cmd+Enter,ctrl+Enter",
        isRequiredA11yAction: true,
        onSelect: async (source) => {
          if (!canApplySelectionAction()) return;
          const onlySelectedShape = editor.getOnlySelectedShape();
          if (onlySelectedShape && (editor.isShapeOfType(onlySelectedShape, "image") || editor.isShapeOfType(onlySelectedShape, "video"))) {
            const firstToolbarButton = editor.getContainer().querySelector(".tlui-contextual-toolbar button:first-child");
            firstToolbarButton?.focus();
            return;
          }
          const firstButton = editor.getContainer().querySelector(".tlui-style-panel button");
          firstButton?.focus();
          trackEvent("adjust-shape-styles", { source });
        }
      },
      {
        id: "a11y-open-context-menu",
        kbd: "cmd+shift+Enter,ctrl+shift+Enter",
        isRequiredA11yAction: true,
        readonlyOk: true,
        onSelect: async (source) => {
          if (!canApplySelectionAction()) return;
          const selectionBounds = editor.getSelectionPageBounds();
          if (!selectionBounds) return;
          const centerX = selectionBounds.x + selectionBounds.width / 2;
          const centerY = selectionBounds.y + selectionBounds.height / 2;
          const screenPoint = editor.pageToScreen(new Vec(centerX, centerY));
          editor.getContainer().querySelector(".tl-canvas")?.dispatchEvent(
            new PointerEvent("contextmenu", {
              clientX: screenPoint.x,
              clientY: screenPoint.y,
              bubbles: true
            })
          );
          trackEvent("open-context-menu", { source });
        }
      },
      {
        id: "enlarge-shapes",
        label: "a11y.enlarge-shape",
        kbd: "cmd+alt+shift+=,ctrl+alt+shift+=",
        onSelect: async (source) => {
          scaleShapes(1.1);
          trackEvent("enlarge-shapes", { source });
        }
      },
      {
        id: "shrink-shapes",
        label: "a11y.shrink-shape",
        kbd: "cmd+alt+shift+-,ctrl+alt+shift+-",
        onSelect: async (source) => {
          scaleShapes(1 / 1.1);
          trackEvent("shrink-shapes", { source });
        }
      },
      {
        id: "a11y-repeat-shape-announce",
        kbd: "alt+r",
        label: "a11y.repeat-shape",
        isRequiredA11yAction: true,
        readonlyOk: true,
        onSelect: async (source) => {
          const selectedShapeIds = editor.getSelectedShapeIds();
          if (!selectedShapeIds.length) return;
          const a11yLive = generateShapeAnnouncementMessage({
            editor,
            selectedShapeIds,
            msg: msg2
          });
          if (a11yLive) {
            a11y.announce({ msg: "" });
            editor.timers.requestAnimationFrame(() => {
              a11y.announce({ msg: a11yLive });
            });
            trackEvent("a11y-repeat-shape-announce", { source });
          }
        }
      },
      {
        id: "image-replace",
        label: "tool.replace-media",
        icon: "arrow-cycle",
        readonlyOk: false,
        onSelect: async (source) => {
          trackEvent("image-replace", { source });
          helpers.replaceImage();
        }
      },
      {
        id: "video-replace",
        label: "tool.replace-media",
        icon: "arrow-cycle",
        readonlyOk: false,
        onSelect: async (source) => {
          trackEvent("video-replace", { source });
          helpers.replaceVideo();
        }
      },
      {
        id: "download-original",
        label: "action.download-original",
        readonlyOk: true,
        onSelect: async (source) => {
          const selectedShapes = editor.getSelectedShapes();
          if (selectedShapes.length === 0) return;
          const mediaShapes = selectedShapes.filter(
            (s) => supportsDownloadingOriginal(s, editor)
          );
          if (mediaShapes.length === 0) return;
          for (const mediaShape of mediaShapes) {
            const asset = editor.getAsset(mediaShape.props.assetId);
            if (!asset || !asset.props.src) continue;
            const url = await editor.resolveAssetUrl(asset.id, { shouldResolveToOriginal: true });
            if (!url) return;
            const link = document.createElement("a");
            link.href = url;
            if ((asset.type === "video" || asset.type === "image") && !asset.props.src.startsWith("asset:")) {
              link.download = asset.props.name;
            } else {
              link.download = "download";
            }
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          }
          trackEvent("download-original", { source });
        }
      }
    ];
    if (showCollaborationUi) {
      actionItems.push({
        id: "open-cursor-chat",
        label: "action.open-cursor-chat",
        readonlyOk: true,
        kbd: "/",
        onSelect(source) {
          trackEvent("open-cursor-chat", { source });
          if (editor.getInstanceState().isCoarsePointer) {
            return;
          }
          editor.timers.requestAnimationFrame(() => {
            editor.updateInstanceState({ isChatting: true });
          });
        }
      });
    }
    const actions2 = makeActions(actionItems);
    if (overrides) {
      return overrides(editor, actions2, helpers);
    }
    return actions2;
  }, [
    helpers,
    _editor,
    trackEvent,
    overrides,
    defaultDocumentName,
    showCollaborationUi,
    msg2,
    a11y,
    components
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ActionsContext.Provider, { value: asActions(actions), children });
}
function useActions() {
  const ctx = reactExports.useContext(ActionsContext);
  if (!ctx) {
    throw new Error("useTools must be used within a ToolProvider");
  }
  return ctx;
}
function asActions(actions) {
  return actions;
}
function unwrapLabel(label, menuType) {
  return label ? typeof label === "string" ? label : menuType ? label[menuType] ?? label["default"] : void 0 : void 0;
}
function TldrawUiMenuActionCheckboxItem({
  actionId = "",
  ...rest
}) {
  const actions = useActions();
  const action = actions[actionId];
  if (!action) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuCheckboxItem, { ...action, ...rest });
}
function ToggleAutoSizeMenuItem() {
  const shouldDisplay = useShowAutoSizeToggle();
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-auto-size" });
}
function EditLinkMenuItem() {
  const shouldDisplay = useHasLinkShapeSelected();
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "edit-link" });
}
function DuplicateMenuItem() {
  const shouldDisplay = useUnlockedSelectedShapesCount(1);
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "duplicate" });
}
function FlattenMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "should display flatten option",
    () => {
      const selectedShapeIds = editor.getSelectedShapeIds();
      if (selectedShapeIds.length === 0) return false;
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "image")) {
        return false;
      }
      return true;
    },
    [editor]
  );
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "flatten-to-image" });
}
function DownloadOriginalMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "should display download original option",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      if (selectedShapes.length === 0) return false;
      return selectedShapes.some((shape) => supportsDownloadingOriginal(shape, editor));
    },
    [editor]
  );
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "download-original" });
}
function GroupMenuItem() {
  const shouldDisplay = useAllowGroup();
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "group" });
}
function UngroupMenuItem() {
  const shouldDisplay = useAllowUngroup();
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "ungroup" });
}
function RemoveFrameMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "allow unframe",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      if (selectedShapes.length === 0) return false;
      return selectedShapes.every((shape) => editor.isShapeOfType(shape, "frame"));
    },
    [editor]
  );
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "remove-frame" });
}
function FitFrameToContentMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "allow fit frame to content",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      return editor.isShapeOfType(onlySelectedShape, "frame") && editor.getSortedChildIdsForParent(onlySelectedShape).length > 0;
    },
    [editor]
  );
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "fit-frame-to-content" });
}
function ToggleLockMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue("selected shapes", () => editor.getSelectedShapes().length > 0, [
    editor
  ]);
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-lock" });
}
function ToggleTransparentBgMenuItem() {
  const editor = useEditor();
  const isTransparentBg = useValue(
    "isTransparentBg",
    () => !editor.getInstanceState().exportBackground,
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-transparent",
      checked: isTransparentBg,
      toggle: true
    }
  );
}
function UnlockAllMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue("any shapes", () => editor.getCurrentPageShapeIds().size > 0, [
    editor
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "unlock-all", disabled: !shouldDisplay });
}
function ZoomTo100MenuItem() {
  const editor = useEditor();
  const isZoomedTo100 = useValue("zoomed to 100", () => editor.getZoomLevel() === 1, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-to-100", noClose: true, disabled: isZoomedTo100 });
}
function ZoomToFitMenuItem() {
  const editor = useEditor();
  const hasShapes = useValue("has shapes", () => editor.getCurrentPageShapeIds().size > 0, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionItem,
    {
      actionId: "zoom-to-fit",
      disabled: !hasShapes,
      "data-testid": "minimap.zoom-menu.zoom-to-fit",
      noClose: true
    }
  );
}
function ZoomToSelectionMenuItem() {
  const editor = useEditor();
  const hasSelected = useValue("has shapes", () => editor.getSelectedShapeIds().length > 0, [
    editor
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionItem,
    {
      actionId: "zoom-to-selection",
      disabled: !hasSelected,
      "data-testid": "minimap.zoom-menu.zoom-to-selection",
      noClose: true
    }
  );
}
function ClipboardMenuGroup() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "clipboard", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CutMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CopyMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PasteMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DuplicateMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteMenuItem, {})
  ] });
}
function CopyAsMenuGroup() {
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TldrawUiMenuSubmenu,
    {
      id: "copy-as",
      label: "context-menu.copy-as",
      size: "small",
      disabled: !atLeastOneShapeOnPage,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "copy-as-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "copy-as-svg" }),
          Boolean(window.navigator.clipboard?.write) && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "copy-as-png" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "copy-as-bg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleTransparentBgMenuItem, {}) })
      ]
    }
  );
}
function CutMenuItem() {
  const shouldDisplay = useUnlockedSelectedShapesCount(1);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "cut", disabled: !shouldDisplay });
}
function CopyMenuItem() {
  const shouldDisplay = useAnySelectedShapesCount(1);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "copy", disabled: !shouldDisplay });
}
function PasteMenuItem() {
  const shouldDisplay = showMenuPaste;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "paste", disabled: !shouldDisplay });
}
function ConversionsMenuGroup() {
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  if (!atLeastOneShapeOnPage) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "conversions", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CopyAsMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "export-as", label: "context-menu.export-as", size: "small", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "export-as-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "export-as-svg" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "export-as-png" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "export-as-bg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleTransparentBgMenuItem, {}) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOriginalMenuItem, {})
  ] });
}
function SelectAllMenuItem() {
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "select-all", disabled: !atLeastOneShapeOnPage });
}
function DeleteMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "delete", disabled: !oneSelected });
}
function EditMenuSubmenu() {
  const isReadonlyMode = useReadonly();
  if (!useAnySelectedShapesCount(1)) return null;
  if (isReadonlyMode) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "edit", label: "context-menu.edit", size: "small", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GroupMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(UngroupMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FlattenMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EditLinkMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FitFrameToContentMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RemoveFrameMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConvertToEmbedMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConvertToBookmarkMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleAutoSizeMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleLockMenuItem, {})
  ] });
}
function ArrangeMenuSubmenu() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const onlyFlippableShapeSelected = useOnlyFlippableShape();
  const isReadonlyMode = useReadonly();
  if (isReadonlyMode) return null;
  if (!(twoSelected || onlyFlippableShapeSelected)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "arrange", label: "context-menu.arrange", size: "small", children: [
    twoSelected && /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "align", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-left" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-horizontal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-right" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-top" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-vertical" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-bottom" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DistributeMenuGroup, {}),
    twoSelected && /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "stretch", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stretch-horizontal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stretch-vertical" })
    ] }),
    (twoSelected || onlyFlippableShapeSelected) && /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "flip", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "flip-horizontal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "flip-vertical" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(OrderMenuGroup, {})
  ] });
}
function DistributeMenuGroup() {
  const threeSelected = useUnlockedSelectedShapesCount(3);
  if (!threeSelected) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "distribute", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "distribute-horizontal" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "distribute-vertical" })
  ] });
}
function OrderMenuGroup() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const threeStackableItems = useThreeStackableItems();
  if (!twoSelected) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "order", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "pack" }),
    threeStackableItems && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stack-horizontal" }),
    threeStackableItems && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stack-vertical" })
  ] });
}
function ReorderMenuSubmenu() {
  const isReadonlyMode = useReadonly();
  const oneSelected = useUnlockedSelectedShapesCount(1);
  if (isReadonlyMode) return null;
  if (!oneSelected) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "reorder", label: "context-menu.reorder", size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "reorder", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-to-front" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-forward" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-backward" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-to-back" })
  ] }) });
}
function MoveToPageMenu() {
  const editor = useEditor();
  const pages = useValue("pages", () => editor.getPages(), [editor]);
  const currentPageId = useValue("current page id", () => editor.getCurrentPageId(), [editor]);
  const { addToast } = useToasts();
  const trackEvent = useUiEvents();
  const isReadonlyMode = useReadonly();
  const oneSelected = useUnlockedSelectedShapesCount(1);
  if (!oneSelected) return null;
  if (isReadonlyMode) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "move-to-page", label: "context-menu.move-to-page", size: "small", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "pages", children: pages.map((page) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiMenuItem,
      {
        id: page.id,
        disabled: currentPageId === page.id,
        label: page.name.length > 30 ? `${page.name.slice(0, 30)}` : page.name,
        onSelect: () => {
          editor.markHistoryStoppingPoint("move_shapes_to_page");
          editor.moveShapesToPage(editor.getSelectedShapeIds(), page.id);
          const toPage = editor.getPage(page.id);
          if (toPage) {
            addToast({
              title: "Changed page",
              description: `Moved to ${toPage.name}.`,
              actions: [
                {
                  label: "Go back",
                  type: "primary",
                  onClick: () => {
                    editor.markHistoryStoppingPoint("change-page");
                    editor.setCurrentPage(currentPageId);
                  }
                }
              ]
            });
          }
          trackEvent("move-to-page", { source: "context-menu" });
        }
      },
      page.id
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "new-page", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "move-to-new-page" }) })
  ] });
}
function ConvertToBookmarkMenuItem() {
  const editor = useEditor();
  const oneEmbedSelected = useValue(
    "oneEmbedSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      return !!(editor.isShapeOfType(onlySelectedShape, "embed") && onlySelectedShape.props.url && !editor.isShapeOrAncestorLocked(onlySelectedShape));
    },
    [editor]
  );
  if (!oneEmbedSelected) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "convert-to-bookmark" });
}
function ConvertToEmbedMenuItem() {
  const editor = useEditor();
  const getEmbedDefinition = useGetEmbedDefinition();
  const oneEmbeddableBookmarkSelected = useValue(
    "oneEmbeddableBookmarkSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      return !!(editor.isShapeOfType(onlySelectedShape, "bookmark") && onlySelectedShape.props.url && getEmbedDefinition(onlySelectedShape.props.url) && !editor.isShapeOrAncestorLocked(onlySelectedShape));
    },
    [editor]
  );
  if (!oneEmbeddableBookmarkSelected) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "convert-to-embed" });
}
function ToggleSnapModeItem() {
  const editor = useEditor();
  const isSnapMode = useValue("isSnapMode", () => editor.user.getIsSnapMode(), [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-snap-mode", checked: isSnapMode });
}
function ToggleToolLockItem() {
  const editor = useEditor();
  const isToolLock = useValue("isToolLock", () => editor.getInstanceState().isToolLocked, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-tool-lock", checked: isToolLock });
}
function ToggleGridItem() {
  const editor = useEditor();
  const isGridMode = useValue("isGridMode", () => editor.getInstanceState().isGridMode, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-grid", checked: isGridMode });
}
function ToggleWrapModeItem() {
  const editor = useEditor();
  const isWrapMode = useValue("isWrapMode", () => editor.user.getIsWrapMode(), [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-wrap-mode", checked: isWrapMode });
}
function ToggleFocusModeItem() {
  const editor = useEditor();
  const isFocusMode = useValue("isFocusMode", () => editor.getInstanceState().isFocusMode, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-focus-mode", checked: isFocusMode });
}
function ToggleEdgeScrollingItem() {
  const editor = useEditor();
  const edgeScrollSpeed = useValue("edgeScrollSpeed", () => editor.user.getEdgeScrollSpeed(), [
    editor
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-edge-scrolling",
      checked: edgeScrollSpeed === 1
    }
  );
}
function ToggleReduceMotionItem() {
  const editor = useEditor();
  const animationSpeed = useValue("animationSpeed", () => editor.user.getAnimationSpeed(), [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-reduce-motion",
      checked: animationSpeed === 0
    }
  );
}
function ToggleKeyboardShortcutsItem() {
  const editor = useEditor();
  const keyboardShortcuts = useValue(
    "keyboardShortcuts",
    () => editor.user.getAreKeyboardShortcutsEnabled(),
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-keyboard-shortcuts",
      checked: keyboardShortcuts
    }
  );
}
function ToggleEnhancedA11yModeItem() {
  const editor = useEditor();
  const enhancedA11yMode = useValue("enhancedA11yMode", () => editor.user.getEnhancedA11yMode(), [
    editor
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "enhanced-a11y-mode", checked: enhancedA11yMode });
}
function ToggleDebugModeItem() {
  const editor = useEditor();
  const isDebugMode = useValue("isDebugMode", () => editor.getInstanceState().isDebugMode, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-debug-mode", checked: isDebugMode });
}
function ToggleDynamicSizeModeItem() {
  const editor = useEditor();
  const isDynamicResizeMode = useValue(
    "dynamic resize",
    () => editor.user.getIsDynamicResizeMode(),
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-dynamic-size-mode",
      checked: isDynamicResizeMode
    }
  );
}
function TogglePasteAtCursorItem() {
  const editor = useEditor();
  const pasteAtCursor = useValue("paste at cursor", () => editor.user.getIsPasteAtCursorMode(), [
    editor
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-paste-at-cursor", checked: pasteAtCursor });
}
function CursorChatItem() {
  const editor = useEditor();
  const shouldShow = useValue(
    "show cursor chat",
    () => editor.getCurrentToolId() === "select" && !editor.getInstanceState().isCoarsePointer,
    [editor]
  );
  if (!shouldShow) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "open-cursor-chat" });
}
function AccessibilityMenu() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "help menu accessibility", label: "menu.accessibility", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "accessibility", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleReduceMotionItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleKeyboardShortcutsItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleEnhancedA11yModeItem, {})
  ] }) });
}
class ArrowBindingUtil extends BindingUtil {
  static type = "arrow";
  static props = arrowBindingProps;
  static migrations = arrowBindingMigrations;
  getDefaultProps() {
    return {
      isPrecise: false,
      isExact: false,
      normalizedAnchor: { x: 0.5, y: 0.5 },
      snap: "none"
    };
  }
  // when the binding itself changes
  onAfterCreate({ binding }) {
    const arrow2 = this.editor.getShape(binding.fromId);
    if (!arrow2) return;
    arrowDidUpdate(this.editor, arrow2);
  }
  // when the binding itself changes
  onAfterChange({ bindingAfter }) {
    const arrow2 = this.editor.getShape(bindingAfter.fromId);
    if (!arrow2) return;
    arrowDidUpdate(this.editor, arrow2);
  }
  // when the arrow itself changes
  onAfterChangeFromShape({
    shapeAfter
  }) {
    arrowDidUpdate(this.editor, shapeAfter);
  }
  // when the shape an arrow is bound to changes
  onAfterChangeToShape({
    binding,
    shapeBefore,
    shapeAfter,
    reason
  }) {
    if (reason !== "ancestry" && shapeBefore.parentId === shapeAfter.parentId && shapeBefore.index === shapeAfter.index) {
      return;
    }
    reparentArrow(this.editor, binding.fromId);
  }
  // when the arrow is isolated we need to update it's x,y positions
  onBeforeIsolateFromShape({
    binding
  }) {
    const arrow2 = this.editor.getShape(binding.fromId);
    if (!arrow2) return;
    updateArrowTerminal({
      editor: this.editor,
      arrow: arrow2,
      terminal: binding.props.terminal
    });
  }
}
function reparentArrow(editor, arrowId) {
  const arrow2 = editor.getShape(arrowId);
  if (!arrow2) return;
  const bindings = getArrowBindings(editor, arrow2);
  const { start, end } = bindings;
  const startShape = start ? editor.getShape(start.toId) : void 0;
  const endShape = end ? editor.getShape(end.toId) : void 0;
  const parentPageId = editor.getAncestorPageId(arrow2);
  if (!parentPageId) return;
  let nextParentId;
  if (startShape && endShape) {
    nextParentId = editor.findCommonAncestor([startShape, endShape]) ?? parentPageId;
  } else if (startShape || endShape) {
    const bindingParentId = (startShape || endShape)?.parentId;
    if (bindingParentId && bindingParentId === arrow2.parentId) {
      nextParentId = arrow2.parentId;
    } else {
      nextParentId = parentPageId;
    }
  } else {
    return;
  }
  if (nextParentId && nextParentId !== arrow2.parentId) {
    editor.reparentShapes([arrowId], nextParentId);
  }
  const reparentedArrow = editor.getShape(arrowId);
  if (!reparentedArrow) throw Error("no reparented arrow");
  const startSibling = editor.getShapeNearestSibling(reparentedArrow, startShape);
  const endSibling = editor.getShapeNearestSibling(reparentedArrow, endShape);
  let highestSibling;
  if (startSibling && endSibling) {
    highestSibling = startSibling.index > endSibling.index ? startSibling : endSibling;
  } else if (startSibling && !endSibling) {
    highestSibling = startSibling;
  } else if (endSibling && !startSibling) {
    highestSibling = endSibling;
  } else {
    return;
  }
  let finalIndex;
  const higherSiblings = editor.getSortedChildIdsForParent(highestSibling.parentId).map((id) => editor.getShape(id)).filter((sibling) => sibling.index > highestSibling.index);
  if (higherSiblings.length) {
    const nextHighestNonArrowSibling = higherSiblings.find((sibling) => sibling.type !== "arrow");
    if (
      // ...then, if we're above the last shape we want to be above...
      reparentedArrow.index > highestSibling.index && // ...but below the next non-arrow sibling...
      (!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)
    ) {
      return;
    }
    finalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index);
  } else {
    finalIndex = getIndexAbove(highestSibling.index);
  }
  if (finalIndex !== reparentedArrow.index) {
    editor.updateShapes([{ id: arrowId, type: "arrow", index: finalIndex }]);
  }
}
function arrowDidUpdate(editor, arrow2) {
  const bindings = getArrowBindings(editor, arrow2);
  for (const handle of ["start", "end"]) {
    const binding = bindings[handle];
    if (!binding) continue;
    const boundShape = editor.getShape(binding.toId);
    const isShapeInSamePageAsArrow = editor.getAncestorPageId(arrow2) === editor.getAncestorPageId(boundShape);
    if (!boundShape || !isShapeInSamePageAsArrow) {
      updateArrowTerminal({ editor, arrow: arrow2, terminal: handle, unbind: true });
    }
  }
  reparentArrow(editor, arrow2.id);
}
function updateArrowTerminal({
  editor,
  arrow: arrow2,
  terminal,
  unbind: unbind2 = false,
  useHandle = false
}) {
  const info = getArrowInfo(editor, arrow2);
  if (!info) {
    throw new Error("expected arrow info");
  }
  const startPoint = useHandle ? info.start.handle : info.start.point;
  const endPoint = useHandle ? info.end.handle : info.end.point;
  const point = terminal === "start" ? startPoint : endPoint;
  const update = {
    id: arrow2.id,
    type: "arrow",
    props: {
      [terminal]: { x: point.x, y: point.y },
      bend: arrow2.props.bend
    }
  };
  if (info.type === "arc") {
    const newStart = terminal === "start" ? startPoint : info.start.handle;
    const newEnd = terminal === "end" ? endPoint : info.end.handle;
    const newMidPoint = Vec.Med(newStart, newEnd);
    const lineSegment = Vec.Sub(newStart, newEnd).per().uni().mul(info.handleArc.radius * 2 * Math.sign(arrow2.props.bend));
    const intersections = intersectLineSegmentCircle(
      info.handleArc.center,
      Vec.Add(newMidPoint, lineSegment),
      info.handleArc.center,
      info.handleArc.radius
    );
    assert(intersections?.length === 1);
    const bend = Vec.Dist(newMidPoint, intersections[0]) * Math.sign(arrow2.props.bend);
    if (!approximately(bend, update.props.bend)) {
      update.props.bend = bend;
    }
  }
  editor.updateShape(update);
  if (unbind2) {
    removeArrowBinding(editor, arrow2, terminal);
  }
}
function TldrawCropHandles({
  size: size2,
  width,
  height,
  hideAlternateHandles
}) {
  const cropStrokeWidth = toDomPrecision(size2 / 3);
  const offset2 = cropStrokeWidth / 2;
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "tl-overlays__item", "aria-hidden": "true", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${toDomPrecision(0 - offset2)},${toDomPrecision(size2)} 
						${toDomPrecision(0 - offset2)},${toDomPrecision(0 - offset2)} 
						${toDomPrecision(size2)},${toDomPrecision(0 - offset2)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top_left",
        role: "button",
        "aria-label": msg2("handle.crop.top-left")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        className: classNames("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width / 2 - size2),
        y1: toDomPrecision(0 - offset2),
        x2: toDomPrecision(width / 2 + size2),
        y2: toDomPrecision(0 - offset2),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top",
        role: "button",
        "aria-label": msg2("handle.crop.top")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "polyline",
      {
        className: classNames("tl-corner-crop-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        points: `
						${toDomPrecision(width - size2)},${toDomPrecision(0 - offset2)} 
						${toDomPrecision(width + offset2)},${toDomPrecision(0 - offset2)} 
						${toDomPrecision(width + offset2)},${toDomPrecision(size2)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top_right",
        role: "button",
        "aria-label": msg2("handle.crop.top-right")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        className: classNames("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width + offset2),
        y1: toDomPrecision(height / 2 - size2),
        x2: toDomPrecision(width + offset2),
        y2: toDomPrecision(height / 2 + size2),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.right",
        role: "button",
        "aria-label": msg2("handle.crop.right")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${toDomPrecision(width + offset2)},${toDomPrecision(height - size2)} 
						${toDomPrecision(width + offset2)},${toDomPrecision(height + offset2)}
						${toDomPrecision(width - size2)},${toDomPrecision(height + offset2)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom_right",
        role: "button",
        "aria-label": msg2("handle.crop.bottom-right")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        className: classNames("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width / 2 - size2),
        y1: toDomPrecision(height + offset2),
        x2: toDomPrecision(width / 2 + size2),
        y2: toDomPrecision(height + offset2),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom",
        role: "button",
        "aria-label": msg2("handle.crop.bottom")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "polyline",
      {
        className: classNames("tl-corner-crop-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        points: `
						${toDomPrecision(0 + size2)},${toDomPrecision(height + offset2)} 
						${toDomPrecision(0 - offset2)},${toDomPrecision(height + offset2)}
						${toDomPrecision(0 - offset2)},${toDomPrecision(height - size2)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom_left",
        role: "button",
        "aria-label": msg2("handle.crop.bottom-left")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        className: classNames("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(0 - offset2),
        y1: toDomPrecision(height / 2 - size2),
        x2: toDomPrecision(0 - offset2),
        y2: toDomPrecision(height / 2 + size2),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.left",
        role: "button",
        "aria-label": msg2("handle.crop.left")
      }
    )
  ] });
}
function TldrawHandles({ children }) {
  const editor = useEditor();
  const shouldDisplayHandles = useValue(
    "shouldDisplayHandles",
    () => {
      if (editor.isInAny("select.idle", "select.pointing_handle", "select.pointing_shape")) {
        return true;
      }
      if (editor.isInAny("select.editing_shape")) {
        const onlySelectedShape = editor.getOnlySelectedShape();
        return onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "note");
      }
      return false;
    },
    [editor]
  );
  if (!shouldDisplayHandles) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "tl-user-handles tl-overlays__item", "aria-hidden": "true", children });
}
const arrowTargetStore = new WeakCache();
function getArrowTargetAtom(editor) {
  return arrowTargetStore.get(editor, () => atom("arrowTarget", null));
}
function getArrowTargetState(editor) {
  return getArrowTargetAtom(editor).get();
}
function clearArrowTargetState(editor) {
  getArrowTargetAtom(editor).set(null);
}
function updateArrowTargetState({
  editor,
  pointInPageSpace,
  arrow: arrow2,
  isPrecise,
  currentBinding,
  oppositeBinding
}) {
  const util = editor.getShapeUtil("arrow");
  if (util.options.shouldIgnoreTargets(editor)) {
    getArrowTargetAtom(editor).set(null);
    return null;
  }
  const arrowKind = arrow2 ? arrow2.props.kind : editor.getStyleForNextShape(ArrowShapeKindStyle);
  const target = editor.getShapeAtPoint(pointInPageSpace, {
    hitInside: true,
    hitFrameInside: true,
    margin: arrowKind === "elbow" ? 8 : [8, 0],
    filter: (targetShape) => {
      return !targetShape.isLocked && editor.canBindShapes({
        fromShape: arrow2 ?? targetFilterFallback,
        toShape: targetShape,
        binding: "arrow"
      });
    }
  });
  if (!target) {
    getArrowTargetAtom(editor).set(null);
    return null;
  }
  const targetGeometryInTargetSpace = editor.getShapeGeometry(target);
  const targetBoundsInTargetSpace = Box.ZeroFix(targetGeometryInTargetSpace.bounds);
  const targetCenterInTargetSpace = targetGeometryInTargetSpace.center;
  const targetTransform = editor.getShapePageTransform(target);
  const pointInTargetSpace = editor.getPointInShapeSpace(target, pointInPageSpace);
  const castDistance = Math.max(
    targetGeometryInTargetSpace.bounds.width,
    targetGeometryInTargetSpace.bounds.height
  );
  const handlesInPageSpace = mapObjectMapValues(ElbowArrowSideDeltas, (side, delta) => {
    const axis = ElbowArrowAxes[ElbowArrowSideAxes[side]];
    const farPoint = Vec.Mul(delta, castDistance).add(targetCenterInTargetSpace);
    let isEnabled = false;
    let handlePointInTargetSpace = axis.v(
      targetBoundsInTargetSpace[side],
      targetBoundsInTargetSpace[axis.crossMid]
    );
    let furthestDistance = 0;
    const intersections = targetGeometryInTargetSpace.intersectLineSegment(
      targetCenterInTargetSpace,
      farPoint,
      Geometry2dFilters.EXCLUDE_NON_STANDARD
    );
    for (const intersection of intersections) {
      const distance = Vec.Dist2(intersection, targetCenterInTargetSpace);
      if (distance > furthestDistance) {
        furthestDistance = distance;
        handlePointInTargetSpace = intersection;
        isEnabled = targetGeometryInTargetSpace.isClosed;
      }
    }
    const handlePointInPageSpace = targetTransform.applyToPoint(handlePointInTargetSpace);
    return { point: handlePointInPageSpace, isEnabled, far: targetTransform.applyToPoint(farPoint) };
  });
  const zoomLevel = editor.getZoomLevel();
  const minDistScaled = util.options.minElbowHandleDistance / zoomLevel;
  const targetCenterInPageSpace = targetTransform.applyToPoint(targetCenterInTargetSpace);
  for (const side of objectMapKeys(handlesInPageSpace)) {
    const handle = handlesInPageSpace[side];
    if (Vec.DistMin(handle.point, targetCenterInPageSpace, minDistScaled)) {
      handle.isEnabled = false;
    }
  }
  let precise2 = isPrecise;
  if (!precise2) {
    if (!currentBinding || currentBinding && target.id !== currentBinding.toId) {
      precise2 = editor.inputs.pointerVelocity.len() < 0.5;
    }
  }
  if (!isPrecise) {
    if (!targetGeometryInTargetSpace.isClosed) {
      precise2 = true;
    }
    if (oppositeBinding && target.id === oppositeBinding.toId && oppositeBinding.props.isPrecise) {
      precise2 = true;
    }
  }
  const isExact = util.options.shouldBeExact(editor, precise2);
  if (isExact) precise2 = true;
  const shouldSnapCenter = !isExact && precise2 && targetGeometryInTargetSpace.isClosed;
  const shouldSnapEdges = !isExact && (precise2 && arrowKind === "elbow" || !targetGeometryInTargetSpace.isClosed);
  const shouldSnapEdgePoints = !isExact && precise2 && arrowKind === "elbow" && targetGeometryInTargetSpace.isClosed;
  const shouldSnapNone = precise2 && (targetGeometryInTargetSpace.isClosed || isExact);
  const shouldSnapCenterAxis = !isExact && precise2 && arrowKind === "elbow" && targetGeometryInTargetSpace.isClosed;
  let snap = "none";
  let anchorInPageSpace = pointInPageSpace;
  if (!shouldSnapNone) {
    snap = "center";
    anchorInPageSpace = targetCenterInPageSpace;
  }
  if (shouldSnapEdges) {
    const snapDistance = shouldSnapNone ? calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util.options.elbowArrowEdgeSnapDistance
    ) : Infinity;
    const nearestPointOnEdgeInTargetSpace = targetGeometryInTargetSpace.nearestPoint(
      pointInTargetSpace,
      {
        includeLabels: false,
        includeInternal: false
      }
    );
    const nearestPointOnEdgeInPageSpace = targetTransform.applyToPoint(
      nearestPointOnEdgeInTargetSpace
    );
    const distance = Vec.Dist(nearestPointOnEdgeInPageSpace, pointInPageSpace);
    if (distance < snapDistance) {
      snap = "edge";
      anchorInPageSpace = nearestPointOnEdgeInPageSpace;
    }
  }
  if (shouldSnapCenterAxis) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util.options.elbowArrowAxisSnapDistance
    );
    const distanceFromXAxis = Vec.DistanceToLineSegment(
      handlesInPageSpace.left.far,
      handlesInPageSpace.right.far,
      pointInPageSpace
    );
    const distanceFromYAxis = Vec.DistanceToLineSegment(
      handlesInPageSpace.top.far,
      handlesInPageSpace.bottom.far,
      pointInPageSpace
    );
    const snapAxis = distanceFromXAxis < distanceFromYAxis && distanceFromXAxis < snapDistance ? "x" : distanceFromYAxis < snapDistance ? "y" : null;
    if (snapAxis) {
      const axis = ElbowArrowAxes[snapAxis];
      const loDist2 = Vec.Dist2(handlesInPageSpace[axis.loEdge].far, pointInPageSpace);
      const hiDist2 = Vec.Dist2(handlesInPageSpace[axis.hiEdge].far, pointInPageSpace);
      const side = loDist2 < hiDist2 ? axis.loEdge : axis.hiEdge;
      if (handlesInPageSpace[side].isEnabled) {
        snap = "edge-point";
        anchorInPageSpace = handlesInPageSpace[side].point;
      }
    }
  }
  if (shouldSnapEdgePoints) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util.options.elbowArrowPointSnapDistance
    );
    let closestSide = null;
    let closestDistance = Infinity;
    for (const [side, handle] of objectMapEntries(handlesInPageSpace)) {
      if (!handle.isEnabled) continue;
      const distance = Vec.Dist(handle.point, pointInPageSpace);
      if (distance < snapDistance && distance < closestDistance) {
        closestDistance = distance;
        closestSide = side;
      }
    }
    if (closestSide) {
      snap = "edge-point";
      anchorInPageSpace = handlesInPageSpace[closestSide].point;
    }
  }
  if (shouldSnapCenter) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      arrowKind === "elbow" ? util.options.elbowArrowCenterSnapDistance : util.options.arcArrowCenterSnapDistance
    );
    if (Vec.Dist(pointInTargetSpace, targetBoundsInTargetSpace.center) < snapDistance) {
      snap = "center";
      anchorInPageSpace = targetCenterInPageSpace;
    }
  }
  const snapPointInTargetSpace = editor.getPointInShapeSpace(target, anchorInPageSpace);
  const normalizedAnchor = {
    x: invLerp(
      targetBoundsInTargetSpace.minX,
      targetBoundsInTargetSpace.maxX,
      snapPointInTargetSpace.x
    ),
    y: invLerp(
      targetBoundsInTargetSpace.minY,
      targetBoundsInTargetSpace.maxY,
      snapPointInTargetSpace.y
    )
  };
  const result = {
    target,
    arrowKind,
    handlesInPageSpace,
    centerInPageSpace: targetCenterInPageSpace,
    anchorInPageSpace,
    isExact,
    isPrecise: precise2,
    snap,
    normalizedAnchor
  };
  getArrowTargetAtom(editor).set(result);
  return result;
}
const targetFilterFallback = { type: "arrow" };
function calculateSnapDistance(editor, targetBoundsInTargetSpace, idealSnapDistance) {
  return clamp$3(
    Math.min(targetBoundsInTargetSpace.width, targetBoundsInTargetSpace.height) * 0.15,
    4,
    idealSnapDistance
  ) / editor.getZoomLevel();
}
function TldrawOverlays() {
  const editor = useEditor();
  const shouldShowArrowHints = useValue(
    "should show arrow hints",
    () => {
      if (editor.isInAny("arrow.idle", "arrow.pointing")) return true;
      if (editor.isIn("select.pointing_handle")) {
        const node = editor.getStateDescendant("select.pointing_handle");
        if (node.info.shape.type === "arrow" && (node.info.handle.id === "start" || node.info.handle.id === "end")) {
          return true;
        }
      }
      if (editor.isIn("select.dragging_handle")) {
        const node = editor.getStateDescendant("select.dragging_handle");
        if (node.info.shape.type === "arrow" && (node.info.handle.id === "start" || node.info.handle.id === "end")) {
          return true;
        }
      }
      return false;
    },
    [editor]
  );
  if (!shouldShowArrowHints) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawArrowHints, {});
}
function TldrawArrowHints() {
  const editor = useEditor();
  const { ShapeIndicator } = useEditorComponents();
  const targetInfo = useValue("arrow target info", () => getArrowTargetState(editor), [editor]);
  if (!targetInfo) return null;
  const { handlesInPageSpace, snap, anchorInPageSpace, arrowKind, isExact, isPrecise } = targetInfo;
  const showEdgeHints = !isExact && arrowKind === "elbow";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    ShapeIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeIndicator, { shapeId: targetInfo.target.id }),
    showEdgeHints && /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "tl-overlays__item", "aria-hidden": "true", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "circle",
        {
          cx: anchorInPageSpace.x,
          cy: anchorInPageSpace.y,
          className: `tl-arrow-hint-snap tl-arrow-hint-snap__${isPrecise ? snap ?? "none" : "none"}`
        }
      ),
      Object.entries(handlesInPageSpace).map(([side, handle]) => {
        if (!handle.isEnabled) return null;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            cx: handle.point.x,
            cy: handle.point.y,
            className: "tl-arrow-hint-handle"
          },
          side
        );
      })
    ] })
  ] });
}
const { PI } = Math;
const FIXED_PI = PI + 1e-4;
function getStrokeOutlineTracks(strokePoints, options = {}) {
  const { size: size2 = 16, smoothing = 0.5 } = options;
  if (strokePoints.length === 0 || size2 <= 0) {
    return { left: [], right: [] };
  }
  const firstStrokePoint = strokePoints[0];
  const lastStrokePoint = strokePoints[strokePoints.length - 1];
  const totalLength = lastStrokePoint.runningLength;
  const minDistance = Math.pow(size2 * smoothing, 2);
  const leftPts = [];
  const rightPts = [];
  let prevVector = strokePoints[0].vector;
  let pl = strokePoints[0].point;
  let pr = pl;
  let tl = pl;
  let tr2 = pr;
  let isPrevPointSharpCorner = false;
  let strokePoint;
  for (let i = 0; i < strokePoints.length; i++) {
    strokePoint = strokePoints[i];
    const { point, vector } = strokePoints[i];
    const prevDpr = strokePoint.vector.dpr(prevVector);
    const nextVector = (i < strokePoints.length - 1 ? strokePoints[i + 1] : strokePoints[i]).vector;
    const nextDpr = i < strokePoints.length - 1 ? nextVector.dpr(strokePoint.vector) : 1;
    const isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner;
    const isNextPointSharpCorner = nextDpr !== null && nextDpr < 0.2;
    if (isPointSharpCorner || isNextPointSharpCorner) {
      if (nextDpr > -0.62 && totalLength - strokePoint.runningLength > strokePoint.radius) {
        const offset22 = prevVector.clone().mul(strokePoint.radius);
        const cpr = prevVector.clone().cpr(nextVector);
        if (cpr < 0) {
          tl = Vec.Add(point, offset22);
          tr2 = Vec.Sub(point, offset22);
        } else {
          tl = Vec.Sub(point, offset22);
          tr2 = Vec.Add(point, offset22);
        }
        leftPts.push(tl);
        rightPts.push(tr2);
      } else {
        const offset22 = prevVector.clone().mul(strokePoint.radius).per();
        const start = Vec.Sub(strokePoint.input, offset22);
        for (let step = 1 / 13, t2 = 0; t2 < 1; t2 += step) {
          tl = Vec.RotWith(start, strokePoint.input, FIXED_PI * t2);
          leftPts.push(tl);
          tr2 = Vec.RotWith(start, strokePoint.input, FIXED_PI + FIXED_PI * -t2);
          rightPts.push(tr2);
        }
      }
      pl = tl;
      pr = tr2;
      if (isNextPointSharpCorner) {
        isPrevPointSharpCorner = true;
      }
      continue;
    }
    isPrevPointSharpCorner = false;
    if (strokePoint === firstStrokePoint || strokePoint === lastStrokePoint) {
      const offset22 = Vec.Per(vector).mul(strokePoint.radius);
      leftPts.push(Vec.Sub(point, offset22));
      rightPts.push(Vec.Add(point, offset22));
      continue;
    }
    const offset2 = Vec.Lrp(nextVector, vector, nextDpr).per().mul(strokePoint.radius);
    tl = Vec.Sub(point, offset2);
    if (i <= 1 || Vec.Dist2(pl, tl) > minDistance) {
      leftPts.push(tl);
      pl = tl;
    }
    tr2 = Vec.Add(point, offset2);
    if (i <= 1 || Vec.Dist2(pr, tr2) > minDistance) {
      rightPts.push(tr2);
      pr = tr2;
    }
    prevVector = vector;
    continue;
  }
  return {
    left: leftPts,
    right: rightPts
  };
}
function getStrokeOutlinePoints(strokePoints, options = {}) {
  const { size: size2 = 16, start = {}, end = {}, last: isComplete = false } = options;
  const { cap: capStart = true } = start;
  const { cap: capEnd = true } = end;
  if (strokePoints.length === 0 || size2 <= 0) {
    return [];
  }
  const firstStrokePoint = strokePoints[0];
  const lastStrokePoint = strokePoints[strokePoints.length - 1];
  const totalLength = lastStrokePoint.runningLength;
  const taperStart = start.taper === false ? 0 : start.taper === true ? Math.max(size2, totalLength) : start.taper;
  const taperEnd = end.taper === false ? 0 : end.taper === true ? Math.max(size2, totalLength) : end.taper;
  const { left: leftPts, right: rightPts } = getStrokeOutlineTracks(strokePoints, options);
  const firstPoint = firstStrokePoint.point;
  const lastPoint = strokePoints.length > 1 ? strokePoints[strokePoints.length - 1].point : Vec.AddXY(firstStrokePoint.point, 1, 1);
  if (strokePoints.length === 1) {
    if (!(taperStart || taperEnd) || isComplete) {
      const start2 = Vec.Add(
        firstPoint,
        Vec.Sub(firstPoint, lastPoint).uni().per().mul(-firstStrokePoint.radius)
      );
      const dotPts = [];
      for (let step = 1 / 13, t2 = step; t2 <= 1; t2 += step) {
        dotPts.push(Vec.RotWith(start2, firstPoint, FIXED_PI * 2 * t2));
      }
      return dotPts;
    }
  }
  const startCap = [];
  if (taperStart || taperEnd && strokePoints.length === 1) ;
  else if (capStart) {
    for (let step = 1 / 8, t2 = step; t2 <= 1; t2 += step) {
      const pt = Vec.RotWith(rightPts[0], firstPoint, FIXED_PI * t2);
      startCap.push(pt);
    }
  } else {
    const cornersVector = Vec.Sub(leftPts[0], rightPts[0]);
    const offsetA = Vec.Mul(cornersVector, 0.5);
    const offsetB = Vec.Mul(cornersVector, 0.51);
    startCap.push(
      Vec.Sub(firstPoint, offsetA),
      Vec.Sub(firstPoint, offsetB),
      Vec.Add(firstPoint, offsetB),
      Vec.Add(firstPoint, offsetA)
    );
  }
  const endCap = [];
  const direction = lastStrokePoint.vector.clone().per().neg();
  if (taperEnd || taperStart && strokePoints.length === 1) {
    endCap.push(lastPoint);
  } else if (capEnd) {
    const start2 = Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius));
    for (let step = 1 / 29, t2 = step; t2 < 1; t2 += step) {
      endCap.push(Vec.RotWith(start2, lastPoint, FIXED_PI * 3 * t2));
    }
  } else {
    endCap.push(
      Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius)),
      Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),
      Vec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),
      Vec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius))
    );
  }
  return leftPts.concat(endCap, rightPts.reverse(), startCap);
}
const MIN_START_PRESSURE = 0.025;
const MIN_END_PRESSURE = 0.01;
function getStrokePoints(rawInputPoints, options = {}) {
  const { streamline = 0.5, size: size2 = 16, simulatePressure = false } = options;
  if (rawInputPoints.length === 0) return [];
  const t2 = 0.15 + (1 - streamline) * 0.85;
  let pts = rawInputPoints.map(Vec.From);
  let pointsRemovedFromNearEnd = 0;
  if (!simulatePressure) {
    let pt2 = pts[0];
    while (pt2) {
      if (pt2.z >= MIN_START_PRESSURE) break;
      pts.shift();
      pt2 = pts[0];
    }
  }
  if (!simulatePressure) {
    let pt2 = pts[pts.length - 1];
    while (pt2) {
      if (pt2.z >= MIN_END_PRESSURE) break;
      pts.pop();
      pt2 = pts[pts.length - 1];
    }
  }
  if (pts.length === 0)
    return [
      {
        point: Vec.From(rawInputPoints[0]),
        input: Vec.From(rawInputPoints[0]),
        pressure: simulatePressure ? 0.5 : 0.15,
        vector: new Vec(1, 1),
        distance: 0,
        runningLength: 0,
        radius: 1
      }
    ];
  let pt = pts[1];
  while (pt) {
    if (Vec.Dist2(pt, pts[0]) > (size2 / 3) ** 2) break;
    pts[0].z = Math.max(pts[0].z, pt.z);
    pts.splice(1, 1);
    pt = pts[1];
  }
  const last2 = pts.pop();
  pt = pts[pts.length - 1];
  while (pt) {
    if (Vec.Dist2(pt, last2) > (size2 / 3) ** 2) break;
    pts.pop();
    pt = pts[pts.length - 1];
    pointsRemovedFromNearEnd++;
  }
  pts.push(last2);
  const isComplete = options.last || !options.simulatePressure || pts.length > 1 && Vec.Dist2(pts[pts.length - 1], pts[pts.length - 2]) < size2 ** 2 || pointsRemovedFromNearEnd > 0;
  if (pts.length === 2 && options.simulatePressure) {
    const last22 = pts[1];
    pts = pts.slice(0, -1);
    for (let i = 1; i < 5; i++) {
      const next = Vec.Lrp(pts[0], last22, i / 4);
      next.z = (pts[0].z + (last22.z - pts[0].z)) * i / 4;
      pts.push(next);
    }
  }
  const strokePoints = [
    {
      point: pts[0],
      input: pts[0],
      pressure: simulatePressure ? 0.5 : pts[0].z,
      vector: new Vec(1, 1),
      distance: 0,
      runningLength: 0,
      radius: 1
    }
  ];
  let totalLength = 0;
  let prev = strokePoints[0];
  let point, distance;
  if (isComplete && streamline > 0) {
    pts.push(pts[pts.length - 1].clone());
  }
  for (let i = 1, n = pts.length; i < n; i++) {
    point = !t2 || options.last && i === n - 1 ? pts[i].clone() : pts[i].clone().lrp(prev.point, 1 - t2);
    if (prev.point.equals(point)) continue;
    distance = Vec.Dist(point, prev.point);
    totalLength += distance;
    if (i < 4 && totalLength < size2) {
      continue;
    }
    prev = {
      input: pts[i],
      // The adjusted point
      point,
      // The input pressure (or .5 if not specified)
      pressure: simulatePressure ? 0.5 : pts[i].z,
      // The vector from the current point to the previous point
      vector: Vec.Sub(prev.point, point).uni(),
      // The distance between the current point and the previous point
      distance,
      // The total distance so far
      runningLength: totalLength,
      // The stroke point's radius
      radius: 1
    };
    strokePoints.push(prev);
  }
  if (strokePoints[1]?.vector) {
    strokePoints[0].vector = strokePoints[1].vector.clone();
  }
  if (totalLength < 1) {
    const maxPressureAmongPoints = Math.max(0.5, ...strokePoints.map((s) => s.pressure));
    strokePoints.forEach((s) => s.pressure = maxPressureAmongPoints);
  }
  return strokePoints;
}
const { min } = Math;
const RATE_OF_PRESSURE_CHANGE = 0.275;
function setStrokePointRadii(strokePoints, options) {
  const {
    size: size2 = 16,
    thinning = 0.5,
    simulatePressure = true,
    easing = (t2) => t2,
    start = {},
    end = {}
  } = options;
  const { easing: taperStartEase = EASINGS.easeOutQuad } = start;
  const { easing: taperEndEase = EASINGS.easeOutCubic } = end;
  const totalLength = strokePoints[strokePoints.length - 1].runningLength;
  let firstRadius;
  let prevPressure = strokePoints[0].pressure;
  let strokePoint;
  if (!simulatePressure && totalLength < size2) {
    const max2 = strokePoints.reduce((max22, curr) => Math.max(max22, curr.pressure), 0.5);
    strokePoints.forEach((sp) => {
      sp.pressure = max2;
      sp.radius = size2 * easing(0.5 - thinning * (0.5 - sp.pressure));
    });
    return strokePoints;
  } else {
    let p;
    for (let i = 0, n = strokePoints.length; i < n; i++) {
      strokePoint = strokePoints[i];
      if (strokePoint.runningLength > size2 * 5) break;
      const sp = min(1, strokePoint.distance / size2);
      if (simulatePressure) {
        const rp = min(1, 1 - sp);
        p = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
      } else {
        p = min(1, prevPressure + (strokePoint.pressure - prevPressure) * 0.5);
      }
      prevPressure = prevPressure + (p - prevPressure) * 0.5;
    }
    for (let i = 0; i < strokePoints.length; i++) {
      strokePoint = strokePoints[i];
      if (thinning) {
        let { pressure } = strokePoint;
        const sp = min(1, strokePoint.distance / size2);
        if (simulatePressure) {
          const rp = min(1, 1 - sp);
          pressure = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
        } else {
          pressure = min(
            1,
            prevPressure + (pressure - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE)
          );
        }
        strokePoint.radius = size2 * easing(0.5 - thinning * (0.5 - pressure));
        prevPressure = pressure;
      } else {
        strokePoint.radius = size2 / 2;
      }
      if (firstRadius === void 0) {
        firstRadius = strokePoint.radius;
      }
    }
  }
  const taperStart = start.taper === false ? 0 : start.taper === true ? Math.max(size2, totalLength) : start.taper;
  const taperEnd = end.taper === false ? 0 : end.taper === true ? Math.max(size2, totalLength) : end.taper;
  if (taperStart || taperEnd) {
    for (let i = 0; i < strokePoints.length; i++) {
      strokePoint = strokePoints[i];
      const { runningLength } = strokePoint;
      const ts2 = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1;
      const te = totalLength - runningLength < taperEnd ? taperEndEase((totalLength - runningLength) / taperEnd) : 1;
      strokePoint.radius = Math.max(0.01, strokePoint.radius * Math.min(ts2, te));
    }
  }
  return strokePoints;
}
function getStroke(points, options = {}) {
  return getStrokeOutlinePoints(
    setStrokePointRadii(getStrokePoints(points, options), options),
    options
  );
}
function TldrawScribble({ scribble, zoom, color, opacity, className }) {
  if (!scribble.points.length) return null;
  const stroke = getStroke(scribble.points, {
    size: scribble.size / zoom,
    start: { taper: scribble.taper, easing: EASINGS.linear },
    last: scribble.state === "stopping",
    simulatePressure: false,
    streamline: 0.32
  });
  let d;
  if (stroke.length < 4) {
    const r = scribble.size / zoom / 2;
    const { x, y } = scribble.points[scribble.points.length - 1];
    d = `M ${x - r},${y} a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 ${-r * 2},0`;
  } else {
    d = getSvgPathFromPoints(stroke);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: className ? classNames("tl-overlays__item", className) : className, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      className: "tl-scribble",
      d,
      fill: color ?? `var(--tl-color-${scribble.color})`,
      opacity: opacity ?? scribble.opacity
    }
  ) });
}
const TldrawSelectionForeground = track(function TldrawSelectionForeground2({
  bounds,
  rotation
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const rSvg = reactExports.useRef(null);
  const isReadonlyMode = useReadonly();
  const topEvents = useSelectionEvents("top");
  const rightEvents = useSelectionEvents("right");
  const bottomEvents = useSelectionEvents("bottom");
  const leftEvents = useSelectionEvents("left");
  const topLeftEvents = useSelectionEvents("top_left");
  const topRightEvents = useSelectionEvents("top_right");
  const bottomRightEvents = useSelectionEvents("bottom_right");
  const bottomLeftEvents = useSelectionEvents("bottom_left");
  const isDefaultCursor = editor.getInstanceState().cursor.type === "default";
  const isCoarsePointer = editor.getInstanceState().isCoarsePointer;
  const onlyShape = editor.getOnlySelectedShape();
  const isLockedShape = onlyShape && editor.isShapeOrAncestorLocked(onlyShape);
  const expandOutlineBy = onlyShape ? editor.getShapeUtil(onlyShape).expandSelectionOutlinePx(onlyShape) : 0;
  const expandedBounds = expandOutlineBy instanceof Box ? bounds.clone().expand(expandOutlineBy).zeroFix() : bounds.clone().expandBy(expandOutlineBy).zeroFix();
  useTransform(rSvg, bounds?.x, bounds?.y, 1, editor.getSelectionRotation(), {
    x: expandedBounds.x - bounds.x,
    y: expandedBounds.y - bounds.y
  });
  if (onlyShape && editor.isShapeHidden(onlyShape)) return null;
  const zoom = editor.getZoomLevel();
  const isChangingStyle = editor.getInstanceState().isChangingStyle;
  const width = expandedBounds.width;
  const height = expandedBounds.height;
  const size2 = 8 / zoom;
  const isTinyX = width < size2 * 2;
  const isTinyY = height < size2 * 2;
  const isSmallX = width < size2 * 4;
  const isSmallY = height < size2 * 4;
  const isSmallCropX = width < size2 * 5;
  const isSmallCropY = height < size2 * 5;
  const mobileHandleMultiplier = isCoarsePointer ? 1.75 : 1;
  const targetSize = 6 / zoom * mobileHandleMultiplier;
  const targetSizeX = (isSmallX ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75);
  const targetSizeY = (isSmallY ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75);
  const showSelectionBounds = (onlyShape ? !editor.getShapeUtil(onlyShape).hideSelectionBoundsFg(onlyShape) : true) && !isChangingStyle;
  let shouldDisplayBox = showSelectionBounds && editor.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_canvas",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle",
    "select.pointing_resize_handle"
  ) || showSelectionBounds && editor.isIn("select.resizing") && onlyShape && editor.isShapeOfType(onlyShape, "text");
  if (onlyShape && shouldDisplayBox) {
    if (tlenv.isFirefox && editor.isShapeOfType(onlyShape, "embed")) {
      shouldDisplayBox = false;
    }
  }
  const showCropHandles = editor.isInAny(
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle"
  ) && !isChangingStyle && !isReadonlyMode;
  const shouldDisplayControls = editor.isInAny(
    "select.idle",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle"
  ) && !isChangingStyle && !isReadonlyMode;
  const showCornerRotateHandles = !isCoarsePointer && !(isTinyX || isTinyY) && (shouldDisplayControls || showCropHandles) && (onlyShape ? !editor.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true) && !isLockedShape;
  const showMobileRotateHandle = isCoarsePointer && (!isSmallX || !isSmallY) && (shouldDisplayControls || showCropHandles) && (onlyShape ? !editor.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true) && !isLockedShape;
  const showResizeHandles = shouldDisplayControls && (onlyShape ? editor.getShapeUtil(onlyShape).canResize(onlyShape) && !editor.getShapeUtil(onlyShape).hideResizeHandles(onlyShape) : true) && !showCropHandles && !isLockedShape;
  const hideAlternateCornerHandles = isTinyX || isTinyY;
  const showOnlyOneHandle = isTinyX && isTinyY;
  const hideAlternateCropHandles = isSmallCropX || isSmallCropY;
  const showHandles = showResizeHandles || showCropHandles;
  const hideRotateCornerHandles = !showCornerRotateHandles;
  const hideMobileRotateHandle = !shouldDisplayControls || !showMobileRotateHandle;
  const hideTopLeftCorner = !shouldDisplayControls || !showHandles;
  const hideTopRightCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles;
  const hideBottomLeftCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles;
  const hideBottomRightCorner = !shouldDisplayControls || !showHandles || showOnlyOneHandle && !showCropHandles;
  let hideVerticalEdgeTargets = true;
  let hideHorizontalEdgeTargets = true;
  if (showCropHandles) {
    hideVerticalEdgeTargets = hideAlternateCropHandles;
    hideHorizontalEdgeTargets = hideAlternateCropHandles;
  } else if (showResizeHandles) {
    hideVerticalEdgeTargets = hideAlternateCornerHandles || showOnlyOneHandle || isCoarsePointer;
    const isMobileAndTextShape = isCoarsePointer && onlyShape && onlyShape.type === "text";
    hideHorizontalEdgeTargets = hideVerticalEdgeTargets && !isMobileAndTextShape;
  }
  const textHandleHeight = Math.min(24 / zoom, height - targetSizeY * 3);
  const showTextResizeHandles = shouldDisplayControls && isCoarsePointer && onlyShape && editor.isShapeOfType(onlyShape, "text") && textHandleHeight * zoom >= 4;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      className: "tl-overlays__item tl-selection__fg",
      "data-testid": "selection-foreground",
      "aria-hidden": "true",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { ref: rSvg, children: [
        shouldDisplayBox && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            className: "tl-selection__fg__outline",
            width: toDomPrecision(width),
            height: toDomPrecision(height)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          RotateCornerHandle,
          {
            "data-testid": "selection.rotate.top-left",
            cx: 0,
            cy: 0,
            targetSize,
            corner: "top_left_rotate",
            cursor: isDefaultCursor ? getCursor("nwse-rotate", rotation) : void 0,
            isHidden: hideRotateCornerHandles
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          RotateCornerHandle,
          {
            "data-testid": "selection.rotate.top-right",
            cx: width + targetSize * 3,
            cy: 0,
            targetSize,
            corner: "top_right_rotate",
            cursor: isDefaultCursor ? getCursor("nesw-rotate", rotation) : void 0,
            isHidden: hideRotateCornerHandles
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          RotateCornerHandle,
          {
            "data-testid": "selection.rotate.bottom-left",
            cx: 0,
            cy: height + targetSize * 3,
            targetSize,
            corner: "bottom_left_rotate",
            cursor: isDefaultCursor ? getCursor("swne-rotate", rotation) : void 0,
            isHidden: hideRotateCornerHandles
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          RotateCornerHandle,
          {
            "data-testid": "selection.rotate.bottom-right",
            cx: width + targetSize * 3,
            cy: height + targetSize * 3,
            targetSize,
            corner: "bottom_right_rotate",
            cursor: isDefaultCursor ? getCursor("senw-rotate", rotation) : void 0,
            isHidden: hideRotateCornerHandles
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          MobileRotateHandle,
          {
            "data-testid": "selection.rotate.mobile",
            cx: isSmallX ? -targetSize * 1.5 : width / 2,
            cy: isSmallX ? height / 2 : -targetSize * 1.5,
            size: size2,
            isHidden: hideMobileRotateHandle
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ResizeHandle,
          {
            hide: hideVerticalEdgeTargets,
            dataTestId: "selection.resize.top",
            ariaLabel: msg2("handle.resize-top"),
            x: 0,
            y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY)),
            width: toDomPrecision(width),
            height: toDomPrecision(Math.max(1, targetSizeY * 2)),
            cursor: isDefaultCursor ? getCursor("ns-resize", rotation) : void 0,
            events: topEvents
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ResizeHandle,
          {
            hide: hideHorizontalEdgeTargets,
            dataTestId: "selection.resize.right",
            ariaLabel: msg2("handle.resize-right"),
            x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX)),
            y: 0,
            height: toDomPrecision(height),
            width: toDomPrecision(Math.max(1, targetSizeX * 2)),
            cursor: isDefaultCursor ? getCursor("ew-resize", rotation) : void 0,
            events: rightEvents
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ResizeHandle,
          {
            hide: hideVerticalEdgeTargets,
            dataTestId: "selection.resize.bottom",
            ariaLabel: msg2("handle.resize-bottom"),
            x: 0,
            y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY)),
            width: toDomPrecision(width),
            height: toDomPrecision(Math.max(1, targetSizeY * 2)),
            cursor: isDefaultCursor ? getCursor("ns-resize", rotation) : void 0,
            events: bottomEvents
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ResizeHandle,
          {
            hide: hideHorizontalEdgeTargets,
            dataTestId: "selection.resize.left",
            ariaLabel: msg2("handle.resize-left"),
            x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX)),
            y: 0,
            height: toDomPrecision(height),
            width: toDomPrecision(Math.max(1, targetSizeX * 2)),
            cursor: isDefaultCursor ? getCursor("ew-resize", rotation) : void 0,
            events: leftEvents
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ResizeHandle,
          {
            hide: hideTopLeftCorner,
            dataTestId: "selection.target.top-left",
            ariaLabel: msg2("handle.resize-top-left"),
            x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX * 1.5)),
            y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
            width: toDomPrecision(targetSizeX * 3),
            height: toDomPrecision(targetSizeY * 3),
            cursor: isDefaultCursor ? getCursor("nwse-resize", rotation) : void 0,
            events: topLeftEvents
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ResizeHandle,
          {
            hide: hideTopRightCorner,
            dataTestId: "selection.target.top-right",
            ariaLabel: msg2("handle.resize-top-right"),
            x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX * 1.5)),
            y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
            width: toDomPrecision(targetSizeX * 3),
            height: toDomPrecision(targetSizeY * 3),
            cursor: isDefaultCursor ? getCursor("nesw-resize", rotation) : void 0,
            events: topRightEvents
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ResizeHandle,
          {
            hide: hideBottomRightCorner,
            dataTestId: "selection.target.bottom-right",
            ariaLabel: msg2("handle.resize-bottom-right"),
            x: toDomPrecision(width - (isSmallX ? targetSizeX : targetSizeX * 1.5)),
            y: toDomPrecision(height - (isSmallY ? targetSizeY : targetSizeY * 1.5)),
            width: toDomPrecision(targetSizeX * 3),
            height: toDomPrecision(targetSizeY * 3),
            cursor: isDefaultCursor ? getCursor("nwse-resize", rotation) : void 0,
            events: bottomRightEvents
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ResizeHandle,
          {
            hide: hideBottomLeftCorner,
            dataTestId: "selection.target.bottom-left",
            ariaLabel: msg2("handle.resize-bottom-left"),
            x: toDomPrecision(0 - (isSmallX ? targetSizeX * 3 : targetSizeX * 1.5)),
            y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY * 1.5)),
            width: toDomPrecision(targetSizeX * 3),
            height: toDomPrecision(targetSizeY * 3),
            cursor: isDefaultCursor ? getCursor("nesw-resize", rotation) : void 0,
            events: bottomLeftEvents
          }
        ),
        showResizeHandles && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              "data-testid": "selection.resize.top-left",
              className: classNames("tl-corner-handle", {
                "tl-hidden": hideTopLeftCorner
              }),
              x: toDomPrecision(0 - size2 / 2),
              y: toDomPrecision(0 - size2 / 2),
              width: toDomPrecision(size2),
              height: toDomPrecision(size2)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              "data-testid": "selection.resize.top-right",
              className: classNames("tl-corner-handle", {
                "tl-hidden": hideTopRightCorner
              }),
              x: toDomPrecision(width - size2 / 2),
              y: toDomPrecision(0 - size2 / 2),
              width: toDomPrecision(size2),
              height: toDomPrecision(size2)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              "data-testid": "selection.resize.bottom-right",
              className: classNames("tl-corner-handle", {
                "tl-hidden": hideBottomRightCorner
              }),
              x: toDomPrecision(width - size2 / 2),
              y: toDomPrecision(height - size2 / 2),
              width: toDomPrecision(size2),
              height: toDomPrecision(size2)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              "data-testid": "selection.resize.bottom-left",
              className: classNames("tl-corner-handle", {
                "tl-hidden": hideBottomLeftCorner
              }),
              x: toDomPrecision(0 - size2 / 2),
              y: toDomPrecision(height - size2 / 2),
              width: toDomPrecision(size2),
              height: toDomPrecision(size2)
            }
          )
        ] }),
        showTextResizeHandles && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              "data-testid": "selection.text-resize.left.handle",
              className: "tl-text-handle",
              x: toDomPrecision(0 - size2 / 4),
              y: toDomPrecision(height / 2 - textHandleHeight / 2),
              rx: size2 / 4,
              width: toDomPrecision(size2 / 2),
              height: toDomPrecision(textHandleHeight)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              "data-testid": "selection.text-resize.right.handle",
              className: "tl-text-handle",
              rx: size2 / 4,
              x: toDomPrecision(width - size2 / 4),
              y: toDomPrecision(height / 2 - textHandleHeight / 2),
              width: toDomPrecision(size2 / 2),
              height: toDomPrecision(textHandleHeight)
            }
          )
        ] }),
        showCropHandles && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawCropHandles,
          {
            ...{
              size: size2,
              width,
              height,
              hideAlternateHandles: hideAlternateCropHandles
            }
          }
        )
      ] })
    }
  );
});
const ResizeHandle = function ResizeHandle2({
  hide: hide2,
  dataTestId,
  ariaLabel,
  x,
  y,
  width,
  height,
  cursor,
  events
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "rect",
    {
      className: classNames("tl-resize-handle", "tl-transparent", {
        "tl-hidden": hide2
      }),
      "data-testid": dataTestId,
      role: "button",
      "aria-label": ariaLabel,
      pointerEvents: "all",
      x,
      y,
      width,
      height,
      cursor,
      ...events
    }
  );
};
const RotateCornerHandle = function RotateCornerHandle2({
  cx,
  cy,
  targetSize,
  corner,
  cursor,
  isHidden: isHidden2,
  "data-testid": testId
}) {
  const events = useSelectionEvents(corner);
  const msg2 = useTranslation();
  const label = msg2(`handle.rotate.${corner}`);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "rect",
    {
      className: classNames("tl-transparent", "tl-rotate-corner", { "tl-hidden": isHidden2 }),
      "data-testid": testId,
      role: "button",
      "aria-label": label,
      pointerEvents: "all",
      x: toDomPrecision(cx - targetSize * 3),
      y: toDomPrecision(cy - targetSize * 3),
      width: toDomPrecision(Math.max(1, targetSize * 3)),
      height: toDomPrecision(Math.max(1, targetSize * 3)),
      cursor,
      ...events
    }
  );
};
const SQUARE_ROOT_PI = Math.sqrt(Math.PI);
const MobileRotateHandle = function RotateHandle({
  cx,
  cy,
  size: size2,
  isHidden: isHidden2,
  "data-testid": testId
}) {
  const events = useSelectionEvents("mobile_rotate");
  const editor = useEditor();
  const zoom = useValue("zoom level", () => editor.getZoomLevel(), [editor]);
  const bgRadius = Math.max(14 * (1 / zoom), 20 / Math.max(1, zoom));
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { role: "button", "aria-label": msg2("handle.rotate.mobile_rotate"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "circle",
      {
        "data-testid": testId,
        pointerEvents: "all",
        className: classNames("tl-transparent", "tl-mobile-rotate__bg", { "tl-hidden": isHidden2 }),
        cx,
        cy,
        r: bgRadius,
        ...events
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "circle",
      {
        className: classNames("tl-mobile-rotate__fg", { "tl-hidden": isHidden2 }),
        cx,
        cy,
        r: size2 / SQUARE_ROOT_PI
      }
    )
  ] });
};
function TldrawShapeIndicators() {
  const editor = useEditor();
  const isInSelectState = useValue(
    "is in a valid select state",
    () => {
      return editor.isInAny(
        "select.idle",
        "select.brushing",
        "select.scribble_brushing",
        "select.editing_shape",
        "select.pointing_shape",
        "select.pointing_selection",
        "select.pointing_handle"
      );
    },
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultShapeIndicators, { hideAll: !isInSelectState });
}
const defaultBindingUtils = [ArrowBindingUtil];
const TEXT_PROPS = {
  lineHeight: 1.35,
  fontWeight: "normal",
  fontVariant: "normal",
  fontStyle: "normal",
  padding: "0px"
};
const STROKE_SIZES = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
const FONT_SIZES = {
  s: 18,
  m: 24,
  l: 36,
  xl: 44
};
const LABEL_FONT_SIZES = {
  s: 18,
  m: 22,
  l: 26,
  xl: 32
};
const ARROW_LABEL_FONT_SIZES = {
  s: 18,
  m: 20,
  l: 24,
  xl: 28
};
const FONT_FAMILIES = {
  draw: "var(--tl-font-draw)",
  sans: "var(--tl-font-sans)",
  serif: "var(--tl-font-serif)",
  mono: "var(--tl-font-mono)"
};
const LABEL_TO_ARROW_PADDING = 20;
const ARROW_LABEL_PADDING = 4.25;
const LABEL_PADDING = 16;
function containBoxSize(originalSize, containBoxSize2) {
  const overByXScale = originalSize.w / containBoxSize2.w;
  const overByYScale = originalSize.h / containBoxSize2.h;
  if (overByXScale <= 1 && overByYScale <= 1) {
    return originalSize;
  } else if (overByXScale > overByYScale) {
    return {
      w: originalSize.w / overByXScale,
      h: originalSize.h / overByXScale
    };
  } else {
    return {
      w: originalSize.w / overByYScale,
      h: originalSize.h / overByYScale
    };
  }
}
async function putExcalidrawContent(editor, excalidrawClipboardContent, point) {
  const { elements, files } = excalidrawClipboardContent;
  const tldrawContent = {
    shapes: [],
    bindings: [],
    rootShapeIds: [],
    assets: [],
    schema: editor.store.schema.serialize()
  };
  const groupShapeIdToChildren = /* @__PURE__ */ new Map();
  const rotatedElements = /* @__PURE__ */ new Map();
  const currentPageId = editor.getCurrentPageId();
  const excElementIdsToTldrawShapeIds = /* @__PURE__ */ new Map();
  const rootShapeIds = [];
  const skipIds = /* @__PURE__ */ new Set();
  elements.forEach((element) => {
    excElementIdsToTldrawShapeIds.set(element.id, createShapeId());
    if (element.boundElements !== null) {
      for (const boundElement of element.boundElements) {
        if (boundElement.type === "text") {
          skipIds.add(boundElement.id);
        }
      }
    }
  });
  let index2 = ZERO_INDEX_KEY;
  for (const element of elements) {
    if (skipIds.has(element.id)) {
      continue;
    }
    const id = excElementIdsToTldrawShapeIds.get(element.id);
    const base2 = {
      id,
      typeName: "shape",
      parentId: currentPageId,
      index: index2,
      x: element.x,
      y: element.y,
      rotation: 0,
      isLocked: element.locked,
      opacity: getOpacity(element.opacity),
      meta: {}
    };
    if (element.angle !== 0) {
      rotatedElements.set(id, element.angle);
    }
    if (element.groupIds && element.groupIds.length > 0) {
      if (groupShapeIdToChildren.has(element.groupIds[0])) {
        groupShapeIdToChildren.get(element.groupIds[0])?.push(id);
      } else {
        groupShapeIdToChildren.set(element.groupIds[0], [id]);
      }
    } else {
      rootShapeIds.push(id);
    }
    switch (element.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        let text = "";
        let align = "middle";
        if (element.boundElements !== null) {
          for (const boundElement of element.boundElements) {
            if (boundElement.type === "text") {
              const labelElement = elements.find((elm) => elm.id === boundElement.id);
              if (labelElement) {
                text = labelElement.text;
                align = textAlignToAlignTypes[labelElement.textAlign];
              }
            }
          }
        }
        const colorToUse = element.backgroundColor === "transparent" ? element.strokeColor : element.backgroundColor;
        tldrawContent.shapes.push({
          ...base2,
          type: "geo",
          props: {
            geo: element.type,
            url: element.link ?? "",
            w: element.width,
            h: element.height,
            size: strokeWidthsToSizes[element.strokeWidth] ?? "draw",
            color: colorsToColors[colorToUse] ?? "black",
            richText: toRichText(text),
            align,
            dash: getDash(element),
            fill: getFill(element)
          }
        });
        break;
      }
      case "freedraw": {
        tldrawContent.shapes.push({
          ...base2,
          type: "draw",
          props: {
            dash: getDash(element),
            size: strokeWidthsToSizes[element.strokeWidth],
            color: colorsToColors[element.strokeColor] ?? "black",
            segments: [
              {
                type: "free",
                points: element.points.map(([x, y, z = 0.5]) => ({
                  x,
                  y,
                  z
                }))
              }
            ]
          }
        });
        break;
      }
      case "line": {
        const points = element.points.slice();
        if (points.length < 2) {
          break;
        }
        const indices = getIndices(element.points.length);
        tldrawContent.shapes.push({
          ...base2,
          type: "line",
          props: {
            dash: getDash(element),
            size: strokeWidthsToSizes[element.strokeWidth],
            color: colorsToColors[element.strokeColor] ?? "black",
            spline: element.roundness ? "cubic" : "line",
            points: {
              ...Object.fromEntries(
                element.points.map(([x, y], i) => {
                  const index22 = indices[i];
                  return [index22, { id: index22, index: index22, x, y }];
                })
              )
            }
          }
        });
        break;
      }
      case "arrow": {
        let text = "";
        if (element.boundElements !== null) {
          for (const boundElement of element.boundElements) {
            if (boundElement.type === "text") {
              const labelElement = elements.find((elm) => elm.id === boundElement.id);
              if (labelElement) {
                text = labelElement.text;
              }
            }
          }
        }
        const start = element.points[0];
        const end = element.points[element.points.length - 1];
        const startTargetId = excElementIdsToTldrawShapeIds.get(element.startBinding?.elementId);
        const endTargetId = excElementIdsToTldrawShapeIds.get(element.endBinding?.elementId);
        tldrawContent.shapes.push({
          ...base2,
          type: "arrow",
          props: {
            richText: toRichText(text),
            kind: element.elbowed ? "elbow" : "arc",
            bend: getBend(element, start, end),
            dash: getDash(element),
            size: strokeWidthsToSizes[element.strokeWidth] ?? "m",
            color: colorsToColors[element.strokeColor] ?? "black",
            start: { x: start[0], y: start[1] },
            end: { x: end[0], y: end[1] },
            arrowheadEnd: arrowheadsToArrowheadTypes[element.endArrowhead] ?? "none",
            arrowheadStart: arrowheadsToArrowheadTypes[element.startArrowhead] ?? "none"
          }
        });
        if (startTargetId) {
          tldrawContent.bindings.push({
            id: createBindingId(),
            typeName: "binding",
            type: "arrow",
            fromId: id,
            toId: startTargetId,
            props: {
              terminal: "start",
              normalizedAnchor: { x: 0.5, y: 0.5 },
              isPrecise: false,
              isExact: false
            },
            meta: {}
          });
        }
        if (endTargetId) {
          tldrawContent.bindings.push({
            id: createBindingId(),
            typeName: "binding",
            type: "arrow",
            fromId: id,
            toId: endTargetId,
            props: {
              terminal: "end",
              normalizedAnchor: { x: 0.5, y: 0.5 },
              isPrecise: false,
              isExact: false
            },
            meta: {}
          });
        }
        break;
      }
      case "text": {
        const { size: size2, scale } = getFontSizeAndScale(element.fontSize);
        tldrawContent.shapes.push({
          ...base2,
          type: "text",
          props: {
            size: size2,
            scale,
            font: fontFamilyToFontType[element.fontFamily] ?? "draw",
            color: colorsToColors[element.strokeColor] ?? "black",
            richText: toRichText(element.text),
            textAlign: textAlignToTextAlignTypes[element.textAlign]
          }
        });
        break;
      }
      case "image": {
        const file = files[element.fileId];
        if (!file) break;
        const assetId = AssetRecordType.createId();
        tldrawContent.assets.push({
          id: assetId,
          typeName: "asset",
          type: "image",
          props: {
            w: element.width,
            h: element.height,
            fileSize: file.size,
            name: element.id ?? "Untitled",
            isAnimated: false,
            mimeType: file.mimeType,
            src: file.dataURL
          },
          meta: {}
        });
        tldrawContent.shapes.push({
          ...base2,
          type: "image",
          props: {
            w: element.width,
            h: element.height,
            assetId
          }
        });
      }
    }
    index2 = getIndexAbove(index2);
  }
  const p = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : void 0);
  editor.putContentOntoCurrentPage(tldrawContent, {
    point: p,
    select: false,
    preserveIds: true
  });
  for (const groupedShapeIds of groupShapeIdToChildren.values()) {
    if (groupedShapeIds.length > 1) {
      editor.groupShapes(groupedShapeIds);
      const groupShape = editor.getShape(groupedShapeIds[0]);
      if (groupShape?.parentId && isShapeId(groupShape.parentId)) {
        rootShapeIds.push(groupShape.parentId);
      }
    }
  }
  for (const [id, angle] of rotatedElements) {
    editor.select(id);
    editor.rotateShapesBy([id], angle);
  }
  const rootShapes = compact(rootShapeIds.map((id) => editor.getShape(id)));
  const bounds = Box.Common(rootShapes.map((s) => editor.getShapePageBounds(s)));
  const viewPortCenter = editor.getViewportPageBounds().center;
  editor.updateShapes(
    rootShapes.map((s) => {
      const delta = {
        x: (s.x ?? 0) - (bounds.x + bounds.w / 2),
        y: (s.y ?? 0) - (bounds.y + bounds.h / 2)
      };
      return {
        id: s.id,
        type: s.type,
        x: viewPortCenter.x + delta.x,
        y: viewPortCenter.y + delta.y
      };
    })
  );
  editor.setSelectedShapes(rootShapeIds);
}
const getOpacity = (opacity) => {
  const t2 = opacity / 100;
  if (t2 < 0.2) {
    return 0.1;
  } else if (t2 < 0.4) {
    return 0.25;
  } else if (t2 < 0.6) {
    return 0.5;
  } else if (t2 < 0.8) {
    return 0.75;
  }
  return 1;
};
const strokeWidthsToSizes = {
  1: "s",
  2: "m",
  3: "l",
  4: "xl"
};
const fontSizesToSizes = {
  16: "s",
  20: "m",
  28: "l",
  36: "xl"
};
function getFontSizeAndScale(fontSize) {
  const size2 = fontSizesToSizes[fontSize];
  if (size2) {
    return { size: size2, scale: 1 };
  }
  if (fontSize < 16) {
    return { size: "s", scale: fontSize / 16 };
  }
  if (fontSize > 36) {
    return { size: "xl", scale: fontSize / 36 };
  }
  return { size: "m", scale: 1 };
}
const fontFamilyToFontType = {
  1: "draw",
  2: "sans",
  3: "mono"
};
const oc = {
  gray: ["#f8f9fa", "#e9ecef", "#ced4da", "#868e96", "#343a40"],
  red: ["#fff5f5", "#ffc9c9", "#ff8787", "#fa5252", "#e03131"],
  pink: ["#fff0f6", "#fcc2d7", "#f783ac", "#e64980", "#c2255c"],
  grape: ["#f8f0fc", "#eebefa", "#da77f2", "#be4bdb", "#9c36b5"],
  violet: ["#f3f0ff", "#d0bfff", "#9775fa", "#7950f2", "#6741d9"],
  indigo: ["#edf2ff", "#bac8ff", "#748ffc", "#4c6ef5", "#3b5bdb"],
  blue: ["#e7f5ff", "#a5d8ff", "#4dabf7", "#228be6", "#1971c2"],
  cyan: ["#e3fafc", "#99e9f2", "#3bc9db", "#15aabf", "#0c8599"],
  teal: ["#e6fcf5", "#96f2d7", "#38d9a9", "#12b886", "#099268"],
  green: ["#ebfbee", "#b2f2bb", "#69db7c", "#40c057", "#2f9e44"],
  lime: ["#f4fce3", "#d8f5a2", "#a9e34b", "#82c91e", "#66a80f"],
  yellow: ["#fff9db", "#ffec99", "#ffd43b", "#fab005", "#f08c00"],
  orange: ["#fff4e6", "#ffd8a8", "#ffa94d", "#fd7e14", "#e8590c"]
};
function mapExcalidrawColorToTldrawColors(excalidrawColor, light, dark) {
  const colors = [0, 1, 2, 3, 4].map((index2) => oc[excalidrawColor][index2]);
  return Object.fromEntries(colors.map((c, i) => [c, i < 3 ? light : dark]));
}
const colorsToColors = {
  ...mapExcalidrawColorToTldrawColors("gray", "grey", "black"),
  ...mapExcalidrawColorToTldrawColors("red", "light-red", "red"),
  ...mapExcalidrawColorToTldrawColors("pink", "light-red", "red"),
  ...mapExcalidrawColorToTldrawColors("grape", "light-violet", "violet"),
  ...mapExcalidrawColorToTldrawColors("blue", "light-blue", "blue"),
  ...mapExcalidrawColorToTldrawColors("cyan", "light-blue", "blue"),
  ...mapExcalidrawColorToTldrawColors("teal", "light-green", "green"),
  ...mapExcalidrawColorToTldrawColors("green", "light-green", "green"),
  ...mapExcalidrawColorToTldrawColors("yellow", "yellow", "orange"),
  ...mapExcalidrawColorToTldrawColors("orange", "yellow", "orange"),
  "#ffffff": "white",
  "#000000": "black"
};
const strokeStylesToStrokeTypes = {
  solid: "draw",
  dashed: "dashed",
  dotted: "dotted"
};
const fillStylesToFillType = {
  "cross-hatch": "pattern",
  hachure: "pattern",
  solid: "solid"
};
const textAlignToAlignTypes = {
  left: "start",
  center: "middle",
  right: "end"
};
const textAlignToTextAlignTypes = {
  left: "start",
  center: "middle",
  right: "end"
};
const arrowheadsToArrowheadTypes = {
  arrow: "arrow",
  dot: "dot",
  triangle: "triangle",
  bar: "pipe"
};
function getBend(element, startPoint, endPoint) {
  let bend = 0;
  if (element.points.length > 2) {
    const start = new Vec(startPoint[0], startPoint[1]);
    const end = new Vec(endPoint[0], endPoint[1]);
    const handle = new Vec(element.points[1][0], element.points[1][1]);
    const delta = Vec.Sub(end, start);
    const v = Vec.Per(delta);
    const med = Vec.Med(end, start);
    const A = Vec.Sub(med, v);
    const B = Vec.Add(med, v);
    const point = Vec.NearestPointOnLineSegment(A, B, handle, false);
    bend = Vec.Dist(point, med);
    if (Vec.Clockwise(point, end, med)) bend *= -1;
  }
  return bend;
}
const getDash = (element) => {
  let dash = strokeStylesToStrokeTypes[element.strokeStyle] ?? "draw";
  if (dash === "draw" && element.roughness === 0) {
    dash = "solid";
  }
  return dash;
};
const getFill = (element) => {
  if (element.backgroundColor === "transparent") {
    return "none";
  }
  return fillStylesToFillType[element.fillStyle] ?? "solid";
};
var __defProp$3 = Object.defineProperty;
var __export$1 = (target, all) => {
  for (var name in all)
    __defProp$3(target, name, { get: all[name], enumerable: true });
};
function createChainableState(config) {
  const { state, transaction: transaction2 } = config;
  let { selection } = transaction2;
  let { doc: doc2 } = transaction2;
  let { storedMarks } = transaction2;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction2.selection;
      doc2 = transaction2.doc;
      storedMarks = transaction2.storedMarks;
      return transaction2;
    }
  };
}
var CommandManager3 = class {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args) => {
          const callback = command2(...args)(props);
          if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr2);
          }
          return callback;
        };
        return [name, method];
      })
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run3 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain2 = {
      ...Object.fromEntries(
        Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args) => {
            const props = this.buildProps(tr2, shouldDispatch);
            const callback = command2(...args)(props);
            callbacks.push(callback);
            return chain2;
          };
          return [name, chainedCommand];
        })
      ),
      run: run3
    };
    return chain2;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch2 = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch2);
    const formattedCommands = Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
      })
    );
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch2)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          })
        );
      }
    };
    return props;
  }
};
var commands_exports = {};
__export$1(commands_exports, {
  blur: () => blur,
  clearContent: () => clearContent,
  clearNodes: () => clearNodes,
  command: () => command,
  createParagraphNear: () => createParagraphNear,
  cut: () => cut,
  deleteCurrentNode: () => deleteCurrentNode,
  deleteNode: () => deleteNode,
  deleteRange: () => deleteRange,
  deleteSelection: () => deleteSelection,
  enter: () => enter,
  exitCode: () => exitCode,
  extendMarkRange: () => extendMarkRange,
  first: () => first,
  focus: () => focus,
  forEach: () => forEach,
  insertContent: () => insertContent,
  insertContentAt: () => insertContentAt,
  joinBackward: () => joinBackward,
  joinDown: () => joinDown,
  joinForward: () => joinForward,
  joinItemBackward: () => joinItemBackward,
  joinItemForward: () => joinItemForward,
  joinTextblockBackward: () => joinTextblockBackward,
  joinTextblockForward: () => joinTextblockForward,
  joinUp: () => joinUp,
  keyboardShortcut: () => keyboardShortcut,
  lift: () => lift,
  liftEmptyBlock: () => liftEmptyBlock,
  liftListItem: () => liftListItem,
  newlineInCode: () => newlineInCode,
  resetAttributes: () => resetAttributes,
  scrollIntoView: () => scrollIntoView,
  selectAll: () => selectAll,
  selectNodeBackward: () => selectNodeBackward,
  selectNodeForward: () => selectNodeForward,
  selectParentNode: () => selectParentNode,
  selectTextblockEnd: () => selectTextblockEnd,
  selectTextblockStart: () => selectTextblockStart,
  setContent: () => setContent,
  setMark: () => setMark,
  setMeta: () => setMeta,
  setNode: () => setNode,
  setNodeSelection: () => setNodeSelection,
  setTextDirection: () => setTextDirection,
  setTextSelection: () => setTextSelection,
  sinkListItem: () => sinkListItem,
  splitBlock: () => splitBlock,
  splitListItem: () => splitListItem,
  toggleList: () => toggleList,
  toggleMark: () => toggleMark,
  toggleNode: () => toggleNode,
  toggleWrap: () => toggleWrap,
  undoInputRule: () => undoInputRule,
  unsetAllMarks: () => unsetAllMarks,
  unsetMark: () => unsetMark,
  unsetTextDirection: () => unsetTextDirection,
  updateAttributes: () => updateAttributes,
  wrapIn: () => wrapIn,
  wrapInList: () => wrapInList
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a2;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a2 = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = true) => ({ commands }) => {
  return commands.setContent("", { emitUpdate });
};
var clearNodes = () => ({ state, tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr2;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn) => (props) => {
  return fn(props);
};
var createParagraphNear = () => ({ state, dispatch: dispatch2 }) => {
  return createParagraphNear$3(state, dispatch2);
};
var cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(Math.max(newPos - 1, 0))));
  return true;
};
var deleteCurrentNode = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
var deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange = (range) => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { from: from2, to } = range;
  if (dispatch2) {
    tr2.delete(from2, to);
  }
  return true;
};
var deleteSelection = () => ({ state, dispatch: dispatch2 }) => {
  return deleteSelection$3(state, dispatch2);
};
var enter = () => ({ commands }) => {
  return commands.keyboardShortcut("Enter");
};
var exitCode = () => ({ state, dispatch: dispatch2 }) => {
  return exitCode$3(state, dispatch2);
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
      attributes
    );
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  var _a2;
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a2 = start.node.marks[0]) == null ? void 0 : _a2.attrs);
  const mark = findMarkInSet([...start.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc2, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch2) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc2, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands) => (props) => {
  const items = typeof commands === "function" ? commands(props) : commands;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition(doc2, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc2);
  const selectionAtEnd = Selection.atEnd(doc2);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus = (position = null, options = {}) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS() || isAndroid()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options == null ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch2 && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr2.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch2) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn) => (props) => {
  return items.every((item, index2) => fn(item, { ...props, index: index2 }));
};
var insertContent = (value, options) => ({ tr: tr2, commands }) => {
  return commands.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
};
var removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  if (typeof window === "undefined") {
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  }
  const wrappedValue = `<body>${value}</body>`;
  const html2 = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html2);
}
function createNodeFromContent(content, schema, options) {
  if (content instanceof Node$1 || content instanceof Fragment) {
    return content;
  }
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser$1.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
      } else {
        DOMParser$1.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${invalidContent}`)
        });
      }
    }
    const parser = DOMParser$1.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(elementFromString(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  const last2 = tr2.steps.length - 1;
  if (last2 < startLen) {
    return;
  }
  const step = tr2.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr2.mapping.maps[last2];
  let end = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
var isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
var insertContentAt = (position, value, options) => ({ tr: tr2, dispatch: dispatch2, editor }) => {
  var _a2;
  if (dispatch2) {
    options = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content;
    const emitContentError = (error) => {
      editor.emit("contentError", {
        editor,
        error,
        disableCollaboration: () => {
          if ("collaboration" in editor.storage && typeof editor.storage.collaboration === "object" && editor.storage.collaboration) {
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
    };
    const parseOptions = {
      preserveWhitespace: "full",
      ...options.parseOptions
    };
    if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {
      try {
        createNodeFromContent(value, editor.schema, {
          parseOptions,
          errorOnInvalidContent: true
        });
      } catch (e) {
        emitContentError(e);
      }
    }
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions,
        errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) != null ? _a2 : editor.options.enableContentCheck
      });
    } catch (e) {
      emitContentError(e);
      return false;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr2.insertText(newContent, from2, to);
    } else {
      newContent = content;
      const $from = tr2.doc.resolve(from2);
      const $fromNode = $from.node();
      const fromSelectionAtStart = $from.parentOffset === 0;
      const isTextSelection2 = $fromNode.isText || $fromNode.isTextblock;
      const hasContent = $fromNode.content.size > 0;
      if (fromSelectionAtStart && isTextSelection2 && hasContent) {
        from2 = Math.max(0, from2 - 1);
      }
      tr2.replaceWith(from2, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd(tr2, tr2.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr2.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options.applyPasteRules) {
      tr2.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
var joinUp = () => ({ state, dispatch: dispatch2 }) => {
  return joinUp$3(state, dispatch2);
};
var joinDown = () => ({ state, dispatch: dispatch2 }) => {
  return joinDown$3(state, dispatch2);
};
var joinBackward = () => ({ state, dispatch: dispatch2 }) => {
  return joinBackward$3(state, dispatch2);
};
var joinForward = () => ({ state, dispatch: dispatch2 }) => {
  return joinForward$3(state, dispatch2);
};
var joinItemBackward = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinTextblockBackward = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockBackward$3(state, dispatch2);
};
var joinTextblockForward = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockForward$3(state, dispatch2);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  const keys2 = normalizeKeyName(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch2) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
var lift = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift$3(state, dispatch2);
};
var liftEmptyBlock = () => ({ state, dispatch: dispatch2 }) => {
  return liftEmptyBlock$3(state, dispatch2);
};
var liftListItem = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem$3(type)(state, dispatch2);
};
var newlineInCode = () => ({ state, dispatch: dispatch2 }) => {
  return newlineInCode$3(state, dispatch2);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  let canReset = false;
  tr2.selection.ranges.forEach((range) => {
    state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
      if (nodeType && nodeType === node.type) {
        canReset = true;
        if (dispatch2) {
          tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
      }
      if (markType && node.marks.length) {
        node.marks.forEach((mark) => {
          if (markType === mark.type) {
            canReset = true;
            if (dispatch2) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          }
        });
      }
    });
  });
  return canReset;
};
var scrollIntoView = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    tr2.scrollIntoView();
  }
  return true;
};
var selectAll = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const selection = new AllSelection(tr2.doc);
    tr2.setSelection(selection);
  }
  return true;
};
var selectNodeBackward = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeBackward$3(state, dispatch2);
};
var selectNodeForward = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeForward$3(state, dispatch2);
};
var selectParentNode = () => ({ state, dispatch: dispatch2 }) => {
  return selectParentNode$3(state, dispatch2);
};
var selectTextblockEnd = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockEnd$3(state, dispatch2);
};
var selectTextblockStart = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockStart$3(state, dispatch2);
};
function createDocument(content, schema, parseOptions = {}, options = {}) {
  return createNodeFromContent(content, schema, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options.errorOnInvalidContent
  });
}
var setContent = (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) => ({ editor, tr: tr2, dispatch: dispatch2, commands }) => {
  const { doc: doc2 } = tr2;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument(content, editor.schema, parseOptions, {
      errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
    });
    if (dispatch2) {
      tr2.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch2) {
    tr2.setMeta("preventUpdate", !emitUpdate);
  }
  return commands.insertContentAt({ from: 0, to: doc2.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
  });
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction2) => {
    transaction2.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildrenInRange(node, range, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function flattenExtensions(extensions) {
  return extensions.map((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addExtensions = getExtensionField(extension, "addExtensions", context);
    if (addExtensions) {
      return [extension, ...flattenExtensions(addExtensions())];
    }
    return extension;
  }).flat(10);
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    validate: void 0,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField(
      extension,
      "addGlobalAttributes",
      context
    );
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(
      extension,
      "addAttributes",
      context
    );
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        newStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function buildAttributeSpec(extensionAttribute) {
  var _a2, _b;
  const spec = {};
  if (!((_a2 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a2.isRequired) && "default" in ((extensionAttribute == null ? void 0 : extensionAttribute.attribute) || {})) {
    spec.default = extensionAttribute.attribute.default;
  }
  if (((_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate) !== void 0) {
    spec.validate = extensionAttribute.attribute.validate;
  }
  return [extensionAttribute.name, spec];
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a2;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const topNode = (_a2 = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) == null ? void 0 : _a2.name;
  const nodes = Object.fromEntries(
    nodeExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraNodeFields = extensions.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraNodeFields,
        content: callOrReturn(getExtensionField(extension, "content", context)),
        marks: callOrReturn(getExtensionField(extension, "marks", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        inline: callOrReturn(getExtensionField(extension, "inline", context)),
        atom: callOrReturn(getExtensionField(extension, "atom", context)),
        selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
        draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
        linebreakReplacement: callOrReturn(
          getExtensionField(extension, "linebreakReplacement", context)
        ),
        defining: callOrReturn(getExtensionField(extension, "defining", context)),
        isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
        attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec))
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node) => renderHTML({
          node,
          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
        });
      }
      const renderText = getExtensionField(extension, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension.name, schema];
    })
  );
  const marks = Object.fromEntries(
    markExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraMarkFields = extensions.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraMarkFields,
        inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
        excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec))
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark) => renderHTML({
          mark,
          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
        });
      }
      return [extension.name, schema];
    })
  );
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function findDuplicates(items) {
  const filtered = items.filter((el, index2) => items.indexOf(el) !== index2);
  return Array.from(new Set(filtered));
}
function sortExtensions(extensions) {
  const defaultPriority = 100;
  return extensions.sort((a, b) => {
    const priorityA = getExtensionField(a, "priority") || defaultPriority;
    const priorityB = getExtensionField(b, "priority") || defaultPriority;
    if (priorityA > priorityB) {
      return -1;
    }
    if (priorityA < priorityB) {
      return 1;
    }
    return 0;
  });
}
function resolveExtensions(extensions) {
  const resolvedExtensions = sortExtensions(flattenExtensions(extensions));
  const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
  if (duplicatedNames.length) {
    console.warn(
      `[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`
    );
  }
  return resolvedExtensions;
}
function getTextBetween(startNode, range, options) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text = "";
  startNode.nodesBetween(from2, to, (node, pos, parent, index2) => {
    var _a2;
    if (node.isBlock && pos > from2) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers == null ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index: index2,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a2 = node == null ? void 0 : node.text) == null ? void 0 : _a2.slice(Math.max(from2, pos) - pos, to - pos);
    }
  });
  return text;
}
function getText(node, options) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options);
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(
    Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText])
  );
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array2, by = JSON.stringify) {
  const seen = {};
  return array2.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index2) => {
    const rest = uniqueChanges.filter((_, i) => i !== index2);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index2) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index2];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index2).map(from2, -1);
      const newEnd = mapping.slice(index2).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from2, to, doc2) {
  const marks = [];
  if (from2 === to) {
    doc2.resolve(from2).marks().forEach((mark) => {
      const $pos = doc2.resolve(from2);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc2.nodesBetween(from2, to, (node, pos) => {
      if (!node || (node == null ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(
        ...node.marks.map((mark) => ({
          from: pos,
          to: pos + node.nodeSize,
          mark
        }))
      );
    });
  }
  return marks;
}
var getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {
  const $pos = state.doc.resolve(pos);
  let currentDepth = maxDepth;
  let node = null;
  while (currentDepth > 0 && node === null) {
    const currentNode = $pos.node(currentDepth);
    if ((currentNode == null ? void 0 : currentNode.type.name) === typeOrName) {
      node = currentNode;
    } else {
      currentDepth -= 1;
    }
  }
  return [node, currentDepth];
};
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(
    Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    })
  );
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index2) => {
    var _a2, _b;
    const chunk = ((_b = (_a2 = node.type.spec).toText) == null ? void 0 : _b.call(_a2, {
      node,
      pos,
      parent,
      index: index2
    })) || node.textContent || "%leaf%";
    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(
        ...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        }))
      );
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
var isAtEndOfNode = (state, nodeType) => {
  const { $from, $to, $anchor } = state.selection;
  if (nodeType) {
    const parentNode2 = findParentNode((node) => node.type.name === nodeType)(state.selection);
    if (!parentNode2) {
      return false;
    }
    const $parentPos = state.doc.resolve(parentNode2.pos + 1);
    if ($anchor.pos + 1 === $parentPos.end()) {
      return true;
    }
    return false;
  }
  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {
    return false;
  }
  return true;
};
var isAtStartOfNode = (state) => {
  const { $from, $to } = state.selection;
  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {
    return false;
  }
  return true;
};
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node, {
  checkChildren = true,
  ignoreWhitespace = false
} = {}) {
  var _a2;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a2 = node.text) != null ? _a2 : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function canSetMark(state, tr2, newMarkType) {
  var _a2;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a2 = state.storedMarks) != null ? _a2 : cursor.marks();
    const parentAllowsMarkType = cursor.parent.type.allowsMarkType(newMarkType);
    return parentAllowsMarkType && (!!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType)));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch2) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr2.addStoredMark(
        type.create({
          ...oldAttributes,
          ...attributes
        })
      );
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(
                  trimmedFrom,
                  trimmedTo,
                  type.create({
                    ...mark.attrs,
                    ...attributes
                  })
                );
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr2, type);
};
var setMeta = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2, chain: chain2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain2().command(({ commands }) => {
    const canSetBlock = setBlockType(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch2);
  }).run();
};
var setNodeSelection = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr2;
    const from2 = minMax(position, 0, doc2.content.size);
    const selection = NodeSelection.create(doc2, from2);
    tr2.setSelection(selection);
  }
  return true;
};
var setTextDirection = (direction, position) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const { selection } = state;
  let from2;
  let to;
  if (typeof position === "number") {
    from2 = position;
    to = position;
  } else if (position && "from" in position && "to" in position) {
    from2 = position.from;
    to = position.to;
  } else {
    from2 = selection.from;
    to = selection.to;
  }
  if (dispatch2) {
    tr2.doc.nodesBetween(from2, to, (node, pos) => {
      if (node.isText) {
        return;
      }
      tr2.setNodeMarkup(pos, void 0, {
        ...node.attrs,
        dir: direction
      });
    });
  }
  return true;
};
var setTextSelection = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr2;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc2).from;
    const maxPos = TextSelection.atEnd(doc2).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
var sinkListItem = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem$3(type)(state, dispatch2);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks == null ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  const { selection, doc: doc2 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch2) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr2.deleteSelection();
      }
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return can;
};
var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  var _a2;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch2) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = (
        // eslint-disable-next-line no-nested-ternary
        $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3
      );
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a2 = type.contentMatch.defaultType) == null ? void 0 : _a2.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start, tr2.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch2) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch2) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
var joinListForwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch: dispatch2, chain: chain2, commands, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch2) {
      return chain2().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch2) {
    return chain2().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
  }
  return chain2().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands.setNode(toggleType, attributesToCopy);
  }
  return commands.setNode(type, { ...attributesToCopy, ...attributes });
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands.lift(type);
  }
  return commands.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch: dispatch2 }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch2) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch2) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  var _a2;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr2;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a2 = $from.marks().find((mark) => mark.type === type)) == null ? void 0 : _a2.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
var unsetTextDirection = (position) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const { selection } = state;
  let from2;
  let to;
  if (typeof position === "number") {
    from2 = position;
    to = position;
  } else if (position && "from" in position && "to" in position) {
    from2 = position.from;
    to = position.to;
  } else {
    from2 = selection.from;
    to = selection.to;
  }
  if (dispatch2) {
    tr2.doc.nodesBetween(from2, to, (node, pos) => {
      if (node.isText) {
        return;
      }
      const newAttrs = { ...node.attrs };
      delete newAttrs.dir;
      tr2.setNodeMarkup(pos, void 0, newAttrs);
    });
  }
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  let canUpdate = false;
  tr2.selection.ranges.forEach((range) => {
    const from2 = range.$from.pos;
    const to = range.$to.pos;
    let lastPos;
    let lastNode;
    let trimmedFrom;
    let trimmedTo;
    if (tr2.selection.empty) {
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          canUpdate = true;
          trimmedFrom = Math.max(pos, from2);
          trimmedTo = Math.min(pos + node.nodeSize, to);
          lastPos = pos;
          lastNode = node;
        }
      });
    } else {
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (pos < from2 && nodeType && nodeType === node.type) {
          canUpdate = true;
          trimmedFrom = Math.max(pos, from2);
          trimmedTo = Math.min(pos + node.nodeSize, to);
          lastPos = pos;
          lastNode = node;
        }
        if (pos >= from2 && pos <= to) {
          if (nodeType && nodeType === node.type) {
            canUpdate = true;
            if (dispatch2) {
              tr2.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
          }
          if (markType && node.marks.length) {
            node.marks.forEach((mark) => {
              if (markType === mark.type) {
                canUpdate = true;
                if (dispatch2) {
                  const trimmedFrom2 = Math.max(pos, from2);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr2.addMark(
                    trimmedFrom2,
                    trimmedTo2,
                    markType.create({
                      ...mark.attrs,
                      ...attributes
                    })
                  );
                }
              }
            });
          }
        }
      });
    }
    if (lastNode) {
      if (lastPos !== void 0 && dispatch2) {
        tr2.setNodeMarkup(lastPos, void 0, {
          ...lastNode.attrs,
          ...attributes
        });
      }
      if (markType && lastNode.marks.length) {
        lastNode.marks.forEach((mark) => {
          if (markType === mark.type && dispatch2) {
            tr2.addMark(
              trimmedFrom,
              trimmedTo,
              markType.create({
                ...mark.attrs,
                ...attributes
              })
            );
          }
        });
      }
    }
  });
  return canUpdate;
};
var wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn$3(type, attributes)(state, dispatch2);
};
var wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList$3(type, attributes)(state, dispatch2);
};
var EventEmitter = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  once(event, fn) {
    const onceFn = (...args) => {
      this.off(event, onceFn);
      fn.apply(this, args);
    };
    return this.on(event, onceFn);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
var InputRule = class {
  constructor(config) {
    var _a2;
    this.find = config.find;
    this.handler = config.handler;
    this.undoable = (_a2 = config.undoable) != null ? _a2 : true;
  }
};
var inputRuleMatcherHandler = (text, find2) => {
  if (isRegExp(find2)) {
    return find2.exec(text);
  }
  const inputRuleMatch = find2(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$2(config) {
  var _a2;
  const { editor, from: from2, to, text, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || // check for code mark
    !!((_a2 = $from.nodeBefore || $from.nodeAfter) == null ? void 0 : _a2.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr2 = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr2
    });
    const range = {
      from: from2 - (match[0].length - text.length),
      to
    };
    const { commands, chain: chain2, can } = new CommandManager3({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands,
      chain: chain2,
      can
    });
    if (handler === null || !tr2.steps.length) {
      return;
    }
    if (rule.undoable) {
      tr2.setMeta(plugin, {
        transform: tr2,
        from: from2,
        to,
        text
      });
    }
    view.dispatch(tr2);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr2, prev, state) {
        const stored = tr2.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr2.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text === "string") {
              text = text;
            } else {
              text = getHTMLFromFragment(Fragment.from(text), state.schema);
            }
            const { from: from2 } = simulatedInputMeta;
            const to = from2 + text.length;
            run$2({
              editor,
              from: from2,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr2.selectionSet || tr2.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text) {
        return run$2({
          editor,
          from: from2,
          to,
          text,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$2({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$2({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key]) && isPlainObject(target[key])) {
        output[key] = mergeDeep(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var Extendable3 = class {
  constructor(config = {}) {
    this.type = "extendable";
    this.parent = null;
    this.child = null;
    this.name = "";
    this.config = {
      name: this.name
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
  }
  get options() {
    return {
      ...callOrReturn(
        getExtensionField(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...callOrReturn(
        getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new this.constructor({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = "name" in extendedConfig ? extendedConfig.name : extension.parent.name;
    return extension;
  }
};
var Mark2 = class _Mark extends Extendable3 {
  constructor() {
    super(...arguments);
    this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Mark(resolvedConfig);
  }
  static handleExit({ editor, mark }) {
    const { tr: tr2 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr2.removeStoredMark(removeMark2);
      }
      tr2.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr2);
      return true;
    }
    return false;
  }
  configure(options) {
    return super.configure(options);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
function isNumber(value) {
  return typeof value === "number";
}
var PasteRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var pasteRuleMatcherHandler = (text, find2, event) => {
  if (isRegExp(find2)) {
    return [...text.matchAll(find2)];
  }
  const matches2 = find2(text, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run2(config) {
  const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
  const { commands, chain: chain2, can } = new CommandManager3({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    var _a2, _b, _c, _d, _e;
    if (((_b = (_a2 = node.type) == null ? void 0 : _a2.spec) == null ? void 0 : _b.code) || !(node.isText || node.isTextblock || node.isInline)) {
      return;
    }
    const contentSize = (_e = (_d = (_c = node.content) == null ? void 0 : _c.size) != null ? _d : node.nodeSize) != null ? _e : 0;
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + contentSize);
    if (resolvedFrom >= resolvedTo) {
      return;
    }
    const textToMatch = node.isText ? node.text || "" : node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start = resolvedFrom + match.index + 1;
      const end = start + match[0].length;
      const range = {
        from: state.tr.mapping.map(start),
        to: state.tr.mapping.map(end)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands,
        chain: chain2,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
var tiptapDragFromOtherEditor = null;
var createClipboardPasteEvent = (text) => {
  var _a2;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  (_a2 = event.clipboardData) == null ? void 0 : _a2.setData("text/html", text);
  return event;
};
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent;
  try {
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  } catch {
    dropEvent = null;
  }
  const processEvent = ({
    state,
    from: from2,
    to,
    rule,
    pasteEvt
  }) => {
    const tr2 = state.tr;
    const chainableState = createChainableState({
      state,
      transaction: tr2
    });
    const handler = run2({
      editor,
      state: chainableState,
      from: Math.max(from2 - 1, 0),
      to: to.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr2.steps.length) {
      return;
    }
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch {
      dropEvent = null;
    }
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr2;
  };
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a2;
          dragSourceElement = ((_a2 = view.dom.parentElement) == null ? void 0 : _a2.contains(event.target)) ? view.dom.parentElement : null;
          if (dragSourceElement) {
            tiptapDragFromOtherEditor = editor;
          }
        };
        const handleDragend = () => {
          if (tiptapDragFromOtherEditor) {
            tiptapDragFromOtherEditor = null;
          }
        };
        window.addEventListener("dragstart", handleDragstart);
        window.addEventListener("dragend", handleDragend);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
            window.removeEventListener("dragend", handleDragend);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            if (!isDroppedFromProseMirror) {
              const dragFromOtherEditor = tiptapDragFromOtherEditor;
              if (dragFromOtherEditor == null ? void 0 : dragFromOtherEditor.isEditable) {
                setTimeout(() => {
                  const selection = dragFromOtherEditor.state.selection;
                  if (selection) {
                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                  }
                }, 10);
              }
            }
            return false;
          },
          paste: (_view, event) => {
            var _a2;
            const html2 = (_a2 = event.clipboardData) == null ? void 0 : _a2.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html2 == null ? void 0 : html2.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction2 = transactions[0];
        const isPaste = transaction2.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction2.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction2.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          let { text } = simulatedPasteMeta;
          if (typeof text === "string") {
            text = text;
          } else {
            text = getHTMLFromFragment(Fragment.from(text), state.schema);
          }
          const { from: from22 } = simulatedPasteMeta;
          const to2 = from22 + text.length;
          const pasteEvt = createClipboardPasteEvent(text);
          return processEvent({
            rule,
            state,
            from: from22,
            to: { b: to2 },
            pasteEvt
          });
        }
        const from2 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from: from2,
          to,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
var ExtensionManager = class {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.baseExtensions = extensions;
    this.extensions = resolveExtensions(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((commands, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands;
      }
      return {
        ...commands,
        ...addCommands()
      };
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor } = this;
    const extensions = sortExtensions([...this.extensions].reverse());
    const allPlugins = extensions.flatMap((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(
        extension,
        "addKeyboardShortcuts",
        context
      );
      let defaultBindings = {};
      if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(
          Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
            return [shortcut, () => method({ editor })];
          })
        );
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        const rules = addInputRules();
        if (rules && rules.length) {
          const inputResult = inputRulesPlugin({
            editor,
            rules
          });
          const inputPlugins = Array.isArray(inputResult) ? inputResult : [inputResult];
          plugins.push(...inputPlugins);
        }
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        const rules = addPasteRules();
        if (rules && rules.length) {
          const pasteRules = pasteRulesPlugin({ editor, rules });
          plugins.push(...pasteRules);
        }
      }
      const addProseMirrorPlugins = getExtensionField(
        extension,
        "addProseMirrorPlugins",
        context
      );
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    });
    return allPlugins;
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(
      nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: this.editor.extensionStorage[extension.name],
          editor,
          type: getNodeType(extension.name, this.schema)
        };
        const addNodeView = getExtensionField(extension, "addNodeView", context);
        if (!addNodeView) {
          return [];
        }
        const nodeViewResult = addNodeView();
        if (!nodeViewResult) {
          return [];
        }
        const nodeview = (node, view, getPos, decorations, innerDecorations) => {
          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
          return nodeViewResult({
            // pass-through
            node,
            view,
            getPos,
            decorations,
            innerDecorations,
            // tiptap-specific
            editor,
            extension,
            HTMLAttributes
          });
        };
        return [extension.name, nodeview];
      })
    );
  }
  get markViews() {
    const { editor } = this;
    const { markExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(
      markExtensions.filter((extension) => !!getExtensionField(extension, "addMarkView")).map((extension) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: this.editor.extensionStorage[extension.name],
          editor,
          type: getMarkType(extension.name, this.schema)
        };
        const addMarkView = getExtensionField(extension, "addMarkView", context);
        if (!addMarkView) {
          return [];
        }
        const markView = (mark, view, inline) => {
          const HTMLAttributes = getRenderedAttributes(mark, extensionAttributes);
          return addMarkView()({
            // pass-through
            mark,
            view,
            inline,
            // tiptap-specific
            editor,
            extension,
            HTMLAttributes,
            updateAttributes: (attrs) => {
              updateMarkViewAttributes(mark, editor, attrs);
            }
          });
        };
        return [extension.name, markView];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const extensions = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      extensions.map((extension) => [extension.name, extension.storage])
    );
    extensions.forEach((extension) => {
      var _a2;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a2 = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) != null ? _a2 : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      const onCreate = getExtensionField(extension, "onCreate", context);
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      const onSelectionUpdate = getExtensionField(
        extension,
        "onSelectionUpdate",
        context
      );
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      const onFocus = getExtensionField(extension, "onFocus", context);
      const onBlur = getExtensionField(extension, "onBlur", context);
      const onDestroy = getExtensionField(extension, "onDestroy", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate) {
        this.editor.on("create", onCreate);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy) {
        this.editor.on("destroy", onDestroy);
      }
    });
  }
};
ExtensionManager.resolve = resolveExtensions;
ExtensionManager.sort = sortExtensions;
ExtensionManager.flatten = flattenExtensions;
var extensions_exports = {};
__export$1(extensions_exports, {
  ClipboardTextSerializer: () => ClipboardTextSerializer,
  Commands: () => Commands,
  Delete: () => Delete,
  Drop: () => Drop,
  Editable: () => Editable,
  FocusEvents: () => FocusEvents,
  Keymap: () => Keymap,
  Paste: () => Paste,
  Tabindex: () => Tabindex,
  TextDirection: () => TextDirection$1,
  focusEventsPluginKey: () => focusEventsPluginKey
});
var Extension = class _Extension3 extends Extendable3 {
  constructor() {
    super(...arguments);
    this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Extension3(resolvedConfig);
  }
  configure(options) {
    return super.configure(options);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc2, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from: from2, to };
            return getTextBetween(doc2, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands_exports
    };
  }
});
var Delete = Extension.create({
  name: "delete",
  onUpdate({ transaction: transaction2, appendedTransactions }) {
    var _a2, _b, _c;
    const callback = () => {
      var _a22, _b2, _c2, _d;
      if ((_d = (_c2 = (_b2 = (_a22 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a22.delete) == null ? void 0 : _b2.filterTransaction) == null ? void 0 : _c2.call(_b2, transaction2)) != null ? _d : transaction2.getMeta("y-sync$")) {
        return;
      }
      const nextTransaction = combineTransactionSteps(transaction2.before, [transaction2, ...appendedTransactions]);
      const changes = getChangedRanges(nextTransaction);
      changes.forEach((change) => {
        if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {
          nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from2) => {
            const to = from2 + node.nodeSize - 2;
            const isFullyWithinRange = change.oldRange.from <= from2 && to <= change.oldRange.to;
            this.editor.emit("delete", {
              type: "node",
              node,
              from: from2,
              to,
              newFrom: nextTransaction.mapping.map(from2),
              newTo: nextTransaction.mapping.map(to),
              deletedRange: change.oldRange,
              newRange: change.newRange,
              partial: !isFullyWithinRange,
              editor: this.editor,
              transaction: transaction2,
              combinedTransform: nextTransaction
            });
          });
        }
      });
      const mapping = nextTransaction.mapping;
      nextTransaction.steps.forEach((step, index2) => {
        var _a3, _b3;
        if (step instanceof RemoveMarkStep) {
          const newStart = mapping.slice(index2).map(step.from, -1);
          const newEnd = mapping.slice(index2).map(step.to);
          const oldStart = mapping.invert().map(newStart, -1);
          const oldEnd = mapping.invert().map(newEnd);
          const foundBeforeMark = (_a3 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a3.marks.some((mark) => mark.eq(step.mark));
          const foundAfterMark = (_b3 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b3.marks.some((mark) => mark.eq(step.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: step.mark,
            from: step.from,
            to: step.to,
            deletedRange: {
              from: oldStart,
              to: oldEnd
            },
            newRange: {
              from: newStart,
              to: newEnd
            },
            partial: Boolean(foundAfterMark || foundBeforeMark),
            editor: this.editor,
            transaction: transaction2,
            combinedTransform: nextTransaction
          });
        }
      });
    };
    if ((_c = (_b = (_a2 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a2.delete) == null ? void 0 : _b.async) != null ? _c : true) {
      setTimeout(callback, 0);
    } else {
      callback();
    }
  }
});
var Drop = Extension.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e, slice2, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: slice2,
              moved
            });
          }
        }
      })
    ];
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var focusEventsPluginKey = new PluginKey("focusEvents");
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: focusEventsPluginKey,
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction2 = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction2 = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands.command(({ tr: tr2 }) => {
        const { selection, doc: doc2 } = tr2;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands.clearNodes();
      }),
      () => commands.deleteSelection(),
      () => commands.joinBackward(),
      () => commands.selectNodeBackward()
    ]);
    const handleDelete2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.deleteSelection(),
      () => commands.deleteCurrentNode(),
      () => commands.joinForward(),
      () => commands.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands }) => [
      () => commands.newlineInCode(),
      () => commands.createParagraphNear(),
      () => commands.liftEmptyBlock(),
      () => commands.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace2,
      "Mod-Backspace": handleBackspace2,
      "Shift-Backspace": handleBackspace2,
      Delete: handleDelete2,
      "Mod-Delete": handleDelete2,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace2,
      "Alt-Backspace": handleBackspace2,
      "Ctrl-d": handleDelete2,
      "Ctrl-Alt-Backspace": handleDelete2,
      "Alt-Delete": handleDelete2,
      "Alt-d": handleDelete2,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr22) => tr22.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction2) => transaction2.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction2) => transaction2.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty = isNodeEmpty(newState.doc);
          if (!isEmpty) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr2
          });
          const { commands } = new CommandManager3({
            editor: this.editor,
            state
          });
          commands.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
var Paste = Extension.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e, slice2) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: slice2
            });
          }
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var TextDirection$1 = Extension.create({
  name: "textDirection",
  addOptions() {
    return {
      direction: void 0
    };
  },
  addGlobalAttributes() {
    if (!this.options.direction) {
      return [];
    }
    const { nodeExtensions } = splitExtensions(this.extensions);
    return [
      {
        types: nodeExtensions.filter((extension) => extension.name !== "text").map((extension) => extension.name),
        attributes: {
          dir: {
            default: this.options.direction,
            parseHTML: (element) => {
              const dir = element.getAttribute("dir");
              if (dir && (dir === "ltr" || dir === "rtl" || dir === "auto")) {
                return dir;
              }
              return this.options.direction;
            },
            renderHTML: (attributes) => {
              if (!attributes.dir) {
                return {};
              }
              return {
                dir: attributes.dir
              };
            }
          }
        }
      }
    ];
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("textDirection"),
        props: {
          attributes: () => {
            const direction = this.options.direction;
            if (!direction) {
              return {};
            }
            return {
              dir: direction
            };
          }
        }
      })
    ];
  }
});
var NodePos = class _NodePos {
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a2;
    return (_a2 = this.actualDepth) != null ? _a2 : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from2 = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from2 = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from2, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new _NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node, offset2) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const isNonTextAtom = node.isAtom && !node.isText;
      const targetPos = this.pos + offset2 + (isNonTextAtom ? 0 : 1);
      if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {
        return;
      }
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index2 = 0; index2 < attrKeys.length; index2 += 1) {
            const key = attrKeys[index2];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (!this.children || this.children.length === 0) {
      return nodes;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
        if (doesAllAttributesMatch) {
          nodes.push(childPos);
        }
      }
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const { tr: tr2 } = this.editor.state;
    tr2.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...attributes
    });
    this.editor.view.dispatch(tr2);
  }
};
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor2 = class extends EventEmitter {
  constructor(options = {}) {
    super();
    this.css = null;
    this.className = "tiptap";
    this.editorView = null;
    this.isFocused = false;
    this.isInitialized = false;
    this.extensionStorage = {};
    this.instanceId = Math.random().toString(36).slice(2, 9);
    this.options = {
      element: typeof document !== "undefined" ? document.createElement("div") : null,
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      textDirection: void 0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      emitContentError: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onMount: () => null,
      onUnmount: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("mount", this.options.onMount);
    this.on("unmount", this.options.onUnmount);
    this.on("contentError", this.options.onContentError);
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("drop", ({ event, slice: slice2, moved }) => this.options.onDrop(event, slice2, moved));
    this.on("paste", ({ event, slice: slice2 }) => this.options.onPaste(event, slice2));
    this.on("delete", this.options.onDelete);
    const initialDoc = this.createDoc();
    const selection = resolveFocusPosition(initialDoc, this.options.autofocus);
    this.editorState = EditorState.create({
      doc: initialDoc,
      schema: this.schema,
      selection: selection || void 0
    });
    if (this.options.element) {
      this.mount(this.options.element);
    }
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(el) {
    if (typeof document === "undefined") {
      throw new Error(
        `[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.`
      );
    }
    this.createView(el);
    this.emit("mount", { editor: this });
    if (this.css && !document.head.contains(this.css)) {
      document.head.appendChild(this.css);
    }
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      if (this.options.autofocus !== false && this.options.autofocus !== null) {
        this.commands.focus(this.options.autofocus);
      }
      this.emit("create", { editor: this });
      this.isInitialized = true;
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    if (this.editorView) {
      const dom = this.editorView.dom;
      if (dom == null ? void 0 : dom.editor) {
        delete dom.editor;
      }
      this.editorView.destroy();
    }
    this.editorView = null;
    this.isInitialized = false;
    if (this.css && !document.querySelectorAll(`.${this.className}`).length) {
      try {
        if (typeof this.css.remove === "function") {
          this.css.remove();
        } else if (this.css.parentNode) {
          this.css.parentNode.removeChild(this.css);
        }
      } catch (error) {
        console.warn("Failed to remove CSS element:", error);
      }
    }
    this.css = null;
    this.emit("unmount", { editor: this });
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && typeof document !== "undefined") {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.editorView || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    if (this.editorView) {
      return this.editorView;
    }
    return new Proxy(
      {
        state: this.editorState,
        updateState: (state) => {
          this.editorState = state;
        },
        dispatch: (tr2) => {
          this.dispatchTransaction(tr2);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: false,
        dragging: null,
        editable: true,
        isDestroyed: false
      },
      {
        get: (obj, key) => {
          if (this.editorView) {
            return this.editorView[key];
          }
          if (key === "state") {
            return this.editorState;
          }
          if (key in obj) {
            return Reflect.get(obj, key);
          }
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${key}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    if (this.editorView) {
      this.editorState = this.view.state;
    }
    return this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
    return state;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(nameOrPluginKeyToRemove) {
    if (this.isDestroyed) {
      return void 0;
    }
    const prevPlugins = this.state.plugins;
    let plugins = prevPlugins;
    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));
    });
    if (prevPlugins.length === plugins.length) {
      return void 0;
    }
    const state = this.state.reconfigure({
      plugins
    });
    this.view.updateState(state);
    return state;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var _a2, _b;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b = (_a2 = this.options.coreExtensionOptions) == null ? void 0 : _a2.clipboardTextSerializer) == null ? void 0 : _b.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex,
      Drop,
      Paste,
      Delete,
      TextDirection$1.configure({
        direction: this.options.textDirection
      })
    ].filter((ext) => {
      if (typeof this.options.enableCoreExtensions === "object") {
        return this.options.enableCoreExtensions[ext.name] !== false;
      }
      return true;
    }) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension == null ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager3({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let doc2;
    try {
      doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
        throw e;
      }
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          if ("collaboration" in this.storage && typeof this.storage.collaboration === "object" && this.storage.collaboration) {
            this.storage.collaboration.isDisabled = true;
          }
          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
          this.createExtensionManager();
        }
      });
      doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: false
      });
    }
    return doc2;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(element) {
    var _a2;
    this.editorView = new EditorView(element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(_a2 = this.options.editorProps) == null ? void 0 : _a2.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: this.editorState,
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.prependClass();
    this.injectCSS();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    if (this.view.isDestroyed) {
      return;
    }
    this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `${this.className} ${this.view.dom.className}`;
  }
  captureTransaction(fn) {
    this.isCapturingTransaction = true;
    fn();
    this.isCapturingTransaction = false;
    const tr2 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr2;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction2) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction2;
        return;
      }
      transaction2.steps.forEach((step) => {
        var _a2;
        return (_a2 = this.capturedTransaction) == null ? void 0 : _a2.step(step);
      });
      return;
    }
    const { state, transactions } = this.state.applyTransaction(transaction2);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    const rootTrWasApplied = transactions.includes(transaction2);
    const prevState = this.state;
    this.emit("beforeTransaction", {
      editor: this,
      transaction: transaction2,
      nextState: state
    });
    if (!rootTrWasApplied) {
      return;
    }
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction: transaction2,
      appendedTransactions: transactions.slice(1)
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction: transaction2
      });
    }
    const mostRecentFocusTr = transactions.findLast((tr2) => tr2.getMeta("focus") || tr2.getMeta("blur"));
    const focus2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("focus");
    const blur2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        transaction: mostRecentFocusTr
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        transaction: mostRecentFocusTr
      });
    }
    if (transaction2.getMeta("preventUpdate") || !transactions.some((tr2) => tr2.docChanged) || prevState.doc.eq(state.doc)) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction: transaction2,
      appendedTransactions: transactions.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    this.unmount();
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a2, _b;
    return (_b = (_a2 = this.editorView) == null ? void 0 : _a2.isDestroyed) != null ? _b : true;
  }
  $node(selector, attributes) {
    var _a2;
    return ((_a2 = this.$doc) == null ? void 0 : _a2.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a2;
    return ((_a2 = this.$doc) == null ? void 0 : _a2.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    },
    undoable: config.undoable
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr: tr2 } = state;
      const start = range.from;
      let end = range.to;
      const newNode = config.type.create(attributes);
      if (match[1]) {
        const offset2 = match[0].lastIndexOf(match[1]);
        let matchStart = start + offset2;
        if (matchStart > end) {
          matchStart = end;
        } else {
          end = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr2.insertText(lastChar, start + match[0].length - 1);
        tr2.replaceWith(matchStart, end, newNode);
      } else if (match[0]) {
        const insertionStart = config.type.isInline ? start : start - 1;
        tr2.insert(insertionStart, config.type.create(attributes)).delete(tr2.mapping.map(start), tr2.mapping.map(end));
      }
      tr2.scrollIntoView();
    },
    undoable: config.undoable
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    },
    undoable: config.undoable
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match, chain: chain2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const tr2 = state.tr.delete(range.from, range.to);
      const $start = tr2.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr2.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain2().updateAttributes(nodeType, attributes).run();
      }
      const before = tr2.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
        tr2.join(range.from - 1);
      }
    },
    undoable: config.undoable
  });
}
function canInsertNode(state, nodeType) {
  const { selection } = state;
  const { $from } = selection;
  if (selection instanceof NodeSelection) {
    const index2 = $from.index();
    const parent = $from.parent;
    return parent.canReplaceWith(index2, index2 + 1, nodeType);
  }
  let depth = $from.depth;
  while (depth >= 0) {
    const index2 = $from.index(depth);
    const parent = $from.node(depth);
    const match = parent.contentMatchAt(index2);
    if (match.matchType(nodeType)) {
      return true;
    }
    depth -= 1;
  }
  return false;
}
var markdown_exports = {};
__export$1(markdown_exports, {
  createAtomBlockMarkdownSpec: () => createAtomBlockMarkdownSpec,
  createBlockMarkdownSpec: () => createBlockMarkdownSpec,
  createInlineMarkdownSpec: () => createInlineMarkdownSpec,
  parseAttributes: () => parseAttributes,
  parseIndentedBlocks: () => parseIndentedBlocks,
  renderNestedMarkdownContent: () => renderNestedMarkdownContent,
  serializeAttributes: () => serializeAttributes
});
function parseAttributes(attrString) {
  if (!(attrString == null ? void 0 : attrString.trim())) {
    return {};
  }
  const attributes = {};
  const quotedStrings = [];
  const tempString = attrString.replace(/["']([^"']*)["']/g, (match) => {
    quotedStrings.push(match);
    return `__QUOTED_${quotedStrings.length - 1}__`;
  });
  const classMatches = tempString.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
  if (classMatches) {
    const classes = classMatches.map((match) => match.trim().slice(1));
    attributes.class = classes.join(" ");
  }
  const idMatch = tempString.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
  if (idMatch) {
    attributes.id = idMatch[1];
  }
  const kvRegex = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
  const kvMatches = Array.from(tempString.matchAll(kvRegex));
  kvMatches.forEach(([, key, quotedRef]) => {
    var _a2;
    const quotedIndex = parseInt(((_a2 = quotedRef.match(/__QUOTED_(\d+)__/)) == null ? void 0 : _a2[1]) || "0", 10);
    const quotedValue = quotedStrings[quotedIndex];
    if (quotedValue) {
      attributes[key] = quotedValue.slice(1, -1);
    }
  });
  const cleanString = tempString.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
  if (cleanString) {
    const booleanAttrs = cleanString.split(/\s+/).filter(Boolean);
    booleanAttrs.forEach((attr) => {
      if (attr.match(/^[a-zA-Z][\w-]*$/)) {
        attributes[attr] = true;
      }
    });
  }
  return attributes;
}
function serializeAttributes(attributes) {
  if (!attributes || Object.keys(attributes).length === 0) {
    return "";
  }
  const parts = [];
  if (attributes.class) {
    const classes = String(attributes.class).split(/\s+/).filter(Boolean);
    classes.forEach((cls) => parts.push(`.${cls}`));
  }
  if (attributes.id) {
    parts.push(`#${attributes.id}`);
  }
  Object.entries(attributes).forEach(([key, value]) => {
    if (key === "class" || key === "id") {
      return;
    }
    if (value === true) {
      parts.push(key);
    } else if (value !== false && value != null) {
      parts.push(`${key}="${String(value)}"`);
    }
  });
  return parts.join(" ");
}
function createAtomBlockMarkdownSpec(options) {
  const {
    nodeName,
    name: markdownName,
    parseAttributes: parseAttributes2 = parseAttributes,
    serializeAttributes: serializeAttributes2 = serializeAttributes,
    defaultAttributes = {},
    requiredAttributes = [],
    allowedAttributes
  } = options;
  const blockName = markdownName || nodeName;
  const filterAttributes = (attrs) => {
    if (!allowedAttributes) {
      return attrs;
    }
    const filtered = {};
    allowedAttributes.forEach((key) => {
      if (key in attrs) {
        filtered[key] = attrs[key];
      }
    });
    return filtered;
  };
  return {
    parseMarkdown: (token, h2) => {
      const attrs = { ...defaultAttributes, ...token.attributes };
      return h2.createNode(nodeName, attrs, []);
    },
    markdownTokenizer: {
      name: nodeName,
      level: "block",
      start(src) {
        var _a2;
        const regex = new RegExp(`^:::${blockName}(?:\\s|$)`, "m");
        const index2 = (_a2 = src.match(regex)) == null ? void 0 : _a2.index;
        return index2 !== void 0 ? index2 : -1;
      },
      tokenize(src, _tokens, _lexer) {
        const regex = new RegExp(`^:::${blockName}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`);
        const match = src.match(regex);
        if (!match) {
          return void 0;
        }
        const attrString = match[1] || "";
        const attributes = parseAttributes2(attrString);
        const missingRequired = requiredAttributes.find((required) => !(required in attributes));
        if (missingRequired) {
          return void 0;
        }
        return {
          type: nodeName,
          raw: match[0],
          attributes
        };
      }
    },
    renderMarkdown: (node) => {
      const filteredAttrs = filterAttributes(node.attrs || {});
      const attrs = serializeAttributes2(filteredAttrs);
      const attrString = attrs ? ` {${attrs}}` : "";
      return `:::${blockName}${attrString} :::`;
    }
  };
}
function createBlockMarkdownSpec(options) {
  const {
    nodeName,
    name: markdownName,
    getContent,
    parseAttributes: parseAttributes2 = parseAttributes,
    serializeAttributes: serializeAttributes2 = serializeAttributes,
    defaultAttributes = {},
    content = "block",
    allowedAttributes
  } = options;
  const blockName = markdownName || nodeName;
  const filterAttributes = (attrs) => {
    if (!allowedAttributes) {
      return attrs;
    }
    const filtered = {};
    allowedAttributes.forEach((key) => {
      if (key in attrs) {
        filtered[key] = attrs[key];
      }
    });
    return filtered;
  };
  return {
    parseMarkdown: (token, h2) => {
      let nodeContent;
      if (getContent) {
        const contentResult = getContent(token);
        nodeContent = typeof contentResult === "string" ? [{ type: "text", text: contentResult }] : contentResult;
      } else if (content === "block") {
        nodeContent = h2.parseChildren(token.tokens || []);
      } else {
        nodeContent = h2.parseInline(token.tokens || []);
      }
      const attrs = { ...defaultAttributes, ...token.attributes };
      return h2.createNode(nodeName, attrs, nodeContent);
    },
    markdownTokenizer: {
      name: nodeName,
      level: "block",
      start(src) {
        var _a2;
        const regex = new RegExp(`^:::${blockName}`, "m");
        const index2 = (_a2 = src.match(regex)) == null ? void 0 : _a2.index;
        return index2 !== void 0 ? index2 : -1;
      },
      tokenize(src, _tokens, lexer) {
        var _a2;
        const openingRegex = new RegExp(`^:::${blockName}(?:\\s+\\{([^}]*)\\})?\\s*\\n`);
        const openingMatch = src.match(openingRegex);
        if (!openingMatch) {
          return void 0;
        }
        const [openingTag, attrString = ""] = openingMatch;
        const attributes = parseAttributes2(attrString);
        let level = 1;
        const position = openingTag.length;
        let matchedContent = "";
        const blockPattern = /^:::([\w-]*)(\s.*)?/gm;
        const remaining = src.slice(position);
        blockPattern.lastIndex = 0;
        for (; ; ) {
          const match = blockPattern.exec(remaining);
          if (match === null) {
            break;
          }
          const matchPos = match.index;
          const blockType = match[1];
          if ((_a2 = match[2]) == null ? void 0 : _a2.endsWith(":::")) {
            continue;
          }
          if (blockType) {
            level += 1;
          } else {
            level -= 1;
            if (level === 0) {
              const rawContent = remaining.slice(0, matchPos);
              matchedContent = rawContent.trim();
              const fullMatch = src.slice(0, position + matchPos + match[0].length);
              let contentTokens = [];
              if (matchedContent) {
                if (content === "block") {
                  contentTokens = lexer.blockTokens(rawContent);
                  contentTokens.forEach((token) => {
                    if (token.text && (!token.tokens || token.tokens.length === 0)) {
                      token.tokens = lexer.inlineTokens(token.text);
                    }
                  });
                  while (contentTokens.length > 0) {
                    const lastToken = contentTokens[contentTokens.length - 1];
                    if (lastToken.type === "paragraph" && (!lastToken.text || lastToken.text.trim() === "")) {
                      contentTokens.pop();
                    } else {
                      break;
                    }
                  }
                } else {
                  contentTokens = lexer.inlineTokens(matchedContent);
                }
              }
              return {
                type: nodeName,
                raw: fullMatch,
                attributes,
                content: matchedContent,
                tokens: contentTokens
              };
            }
          }
        }
        return void 0;
      }
    },
    renderMarkdown: (node, h2) => {
      const filteredAttrs = filterAttributes(node.attrs || {});
      const attrs = serializeAttributes2(filteredAttrs);
      const attrString = attrs ? ` {${attrs}}` : "";
      const renderedContent = h2.renderChildren(node.content || [], "\n\n");
      return `:::${blockName}${attrString}

${renderedContent}

:::`;
    }
  };
}
function parseShortcodeAttributes(attrString) {
  if (!attrString.trim()) {
    return {};
  }
  const attributes = {};
  const regex = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
  let match = regex.exec(attrString);
  while (match !== null) {
    const [, key, doubleQuoted, singleQuoted] = match;
    attributes[key] = doubleQuoted || singleQuoted;
    match = regex.exec(attrString);
  }
  return attributes;
}
function serializeShortcodeAttributes(attrs) {
  return Object.entries(attrs).filter(([, value]) => value !== void 0 && value !== null).map(([key, value]) => `${key}="${value}"`).join(" ");
}
function createInlineMarkdownSpec(options) {
  const {
    nodeName,
    name: shortcodeName,
    getContent,
    parseAttributes: parseAttributes2 = parseShortcodeAttributes,
    serializeAttributes: serializeAttributes2 = serializeShortcodeAttributes,
    defaultAttributes = {},
    selfClosing = false,
    allowedAttributes
  } = options;
  const shortcode = shortcodeName || nodeName;
  const filterAttributes = (attrs) => {
    if (!allowedAttributes) {
      return attrs;
    }
    const filtered = {};
    allowedAttributes.forEach((key) => {
      if (key in attrs) {
        filtered[key] = attrs[key];
      }
    });
    return filtered;
  };
  const escapedShortcode = shortcode.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return {
    parseMarkdown: (token, h2) => {
      const attrs = { ...defaultAttributes, ...token.attributes };
      if (selfClosing) {
        return h2.createNode(nodeName, attrs);
      }
      const content = getContent ? getContent(token) : token.content || "";
      if (content) {
        return h2.createNode(nodeName, attrs, [h2.createTextNode(content)]);
      }
      return h2.createNode(nodeName, attrs, []);
    },
    markdownTokenizer: {
      name: nodeName,
      level: "inline",
      start(src) {
        const startPattern = selfClosing ? new RegExp(`\\[${escapedShortcode}\\s*[^\\]]*\\]`) : new RegExp(`\\[${escapedShortcode}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${escapedShortcode}\\]`);
        const match = src.match(startPattern);
        const index2 = match == null ? void 0 : match.index;
        return index2 !== void 0 ? index2 : -1;
      },
      tokenize(src, _tokens, _lexer) {
        const tokenPattern = selfClosing ? new RegExp(`^\\[${escapedShortcode}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${escapedShortcode}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${escapedShortcode}\\]`);
        const match = src.match(tokenPattern);
        if (!match) {
          return void 0;
        }
        let content = "";
        let attrString = "";
        if (selfClosing) {
          const [, attrs] = match;
          attrString = attrs;
        } else {
          const [, attrs, contentMatch] = match;
          attrString = attrs;
          content = contentMatch || "";
        }
        const attributes = parseAttributes2(attrString.trim());
        return {
          type: nodeName,
          raw: match[0],
          content: content.trim(),
          attributes
        };
      }
    },
    renderMarkdown: (node) => {
      let content = "";
      if (getContent) {
        content = getContent(node);
      } else if (node.content && node.content.length > 0) {
        content = node.content.filter((child) => child.type === "text").map((child) => child.text).join("");
      }
      const filteredAttrs = filterAttributes(node.attrs || {});
      const attrs = serializeAttributes2(filteredAttrs);
      const attrString = attrs ? ` ${attrs}` : "";
      if (selfClosing) {
        return `[${shortcode}${attrString}]`;
      }
      return `[${shortcode}${attrString}]${content}[/${shortcode}]`;
    }
  };
}
function parseIndentedBlocks(src, config, lexer) {
  var _a2, _b, _c, _d;
  const lines = src.split("\n");
  const items = [];
  let totalRaw = "";
  let i = 0;
  const baseIndentSize = config.baseIndentSize || 2;
  while (i < lines.length) {
    const currentLine = lines[i];
    const itemMatch = currentLine.match(config.itemPattern);
    if (!itemMatch) {
      if (items.length > 0) {
        break;
      } else if (currentLine.trim() === "") {
        i += 1;
        totalRaw = `${totalRaw}${currentLine}
`;
        continue;
      } else {
        return void 0;
      }
    }
    const itemData = config.extractItemData(itemMatch);
    const { indentLevel, mainContent } = itemData;
    totalRaw = `${totalRaw}${currentLine}
`;
    const itemContent = [mainContent];
    i += 1;
    while (i < lines.length) {
      const nextLine = lines[i];
      if (nextLine.trim() === "") {
        const nextNonEmptyIndex = lines.slice(i + 1).findIndex((l) => l.trim() !== "");
        if (nextNonEmptyIndex === -1) {
          break;
        }
        const nextNonEmpty = lines[i + 1 + nextNonEmptyIndex];
        const nextIndent2 = ((_b = (_a2 = nextNonEmpty.match(/^(\s*)/)) == null ? void 0 : _a2[1]) == null ? void 0 : _b.length) || 0;
        if (nextIndent2 > indentLevel) {
          itemContent.push(nextLine);
          totalRaw = `${totalRaw}${nextLine}
`;
          i += 1;
          continue;
        } else {
          break;
        }
      }
      const nextIndent = ((_d = (_c = nextLine.match(/^(\s*)/)) == null ? void 0 : _c[1]) == null ? void 0 : _d.length) || 0;
      if (nextIndent > indentLevel) {
        itemContent.push(nextLine);
        totalRaw = `${totalRaw}${nextLine}
`;
        i += 1;
      } else {
        break;
      }
    }
    let nestedTokens;
    const nestedContent = itemContent.slice(1);
    if (nestedContent.length > 0) {
      const dedentedNested = nestedContent.map((nestedLine) => nestedLine.slice(indentLevel + baseIndentSize)).join("\n");
      if (dedentedNested.trim()) {
        if (config.customNestedParser) {
          nestedTokens = config.customNestedParser(dedentedNested);
        } else {
          nestedTokens = lexer.blockTokens(dedentedNested);
        }
      }
    }
    const token = config.createToken(itemData, nestedTokens);
    items.push(token);
  }
  if (items.length === 0) {
    return void 0;
  }
  return {
    items,
    raw: totalRaw
  };
}
function renderNestedMarkdownContent(node, h2, prefixOrGenerator, ctx) {
  if (!node || !Array.isArray(node.content)) {
    return "";
  }
  const prefix = typeof prefixOrGenerator === "function" ? prefixOrGenerator(ctx) : prefixOrGenerator;
  const [content, ...children] = node.content;
  const mainContent = h2.renderChildren([content]);
  const output = [`${prefix}${mainContent}`];
  if (children && children.length > 0) {
    children.forEach((child) => {
      const childContent = h2.renderChildren([child]);
      if (childContent) {
        const indentedChild = childContent.split("\n").map((line) => line ? h2.indent(line) : "").join("\n");
        output.push(indentedChild);
      }
    });
  }
  return output.join("\n");
}
function updateMarkViewAttributes(checkMark, editor, attrs = {}) {
  const { state } = editor;
  const { doc: doc2, tr: tr2 } = state;
  const thisMark = checkMark;
  doc2.descendants((node, pos) => {
    const from2 = tr2.mapping.map(pos);
    const to = tr2.mapping.map(pos) + node.nodeSize;
    let foundMark = null;
    node.marks.forEach((mark) => {
      if (mark !== thisMark) {
        return false;
      }
      foundMark = mark;
    });
    if (!foundMark) {
      return;
    }
    let needsUpdate = false;
    Object.keys(attrs).forEach((k) => {
      if (attrs[k] !== foundMark.attrs[k]) {
        needsUpdate = true;
      }
    });
    if (needsUpdate) {
      const updatedMark = checkMark.type.create({
        ...checkMark.attrs,
        ...attrs
      });
      tr2.removeMark(from2, to, checkMark.type);
      tr2.addMark(from2, to, updatedMark);
    }
  });
  if (tr2.docChanged) {
    editor.view.dispatch(tr2);
  }
}
var Node3 = class _Node extends Extendable3 {
  constructor() {
    super(...arguments);
    this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Node(resolvedConfig);
  }
  configure(options) {
    return super.configure(options);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
var inputRegex$4 = /(^|[^`])`([^`]+)`(?!`)$/;
var pasteRegex$2 = /(^|[^`])`([^`]+)`(?!`)/g;
var Code = Mark2.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleCode: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetCode: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$4,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$2,
        type: this.type
      })
    ];
  }
});
var index_default$2 = Code;
var inputRegex$3 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/;
var pasteRegex$1 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g;
var Highlight = Mark2.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands }) => {
        return commands.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands }) => {
        return commands.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$3,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$1,
        type: this.type
      })
    ];
  }
});
var index_default$1 = Highlight;
var h = (tag, attributes) => {
  if (tag === "slot") {
    return 0;
  }
  if (tag instanceof Function) {
    return tag(attributes);
  }
  const { children, ...rest } = attributes != null ? attributes : {};
  if (tag === "svg") {
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  }
  return [tag, rest, children];
};
var inputRegex$2 = /^\s*>\s$/;
var Blockquote = Node3.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [{ tag: "blockquote" }];
  },
  renderHTML({ HTMLAttributes }) {
    return /* @__PURE__ */ h("blockquote", { ...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ h("slot", {}) });
  },
  parseMarkdown: (token, helpers) => {
    return helpers.createNode("blockquote", void 0, helpers.parseChildren(token.tokens || []));
  },
  renderMarkdown: (node, h2) => {
    if (!node.content) {
      return "";
    }
    const prefix = ">";
    const result = [];
    node.content.forEach((child) => {
      const childContent = h2.renderChildren([child]);
      const lines = childContent.split("\n");
      const linesWithPrefix = lines.map((line) => {
        if (line.trim() === "") {
          return prefix;
        }
        return `${prefix} ${line}`;
      });
      result.push(linesWithPrefix.join("\n"));
    });
    return result.join(`
${prefix}
`);
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands }) => {
        return commands.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands }) => {
        return commands.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands }) => {
        return commands.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$2,
        type: this.type
      })
    ];
  }
});
var starInputRegex$1 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
var starPasteRegex$1 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
var underscoreInputRegex$1 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
var underscorePasteRegex$1 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
var Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return /* @__PURE__ */ h("strong", { ...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ h("slot", {}) });
  },
  markdownTokenName: "strong",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("bold", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown: (node, h2) => {
    return `**${h2.renderChildren(node)}**`;
  },
  addCommands() {
    return {
      setBold: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleBold: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetBold: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex$1,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex$1,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex$1,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex$1,
        type: this.type
      })
    ];
  }
});
var DEFAULT_TAB_SIZE = 4;
var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock = Node3.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      defaultLanguage: null,
      enableTabIndentation: false,
      tabSize: DEFAULT_TAB_SIZE,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (element) => {
          var _a2;
          const { languageClassPrefix } = this.options;
          if (!languageClassPrefix) {
            return null;
          }
          const classNames2 = [...((_a2 = element.firstElementChild) == null ? void 0 : _a2.classList) || []];
          const languages = classNames2.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  markdownTokenName: "code",
  parseMarkdown: (token, helpers) => {
    var _a2;
    if (((_a2 = token.raw) == null ? void 0 : _a2.startsWith("```")) === false && token.codeBlockStyle !== "indented") {
      return [];
    }
    return helpers.createNode(
      "codeBlock",
      { language: token.lang || null },
      token.text ? [helpers.createTextNode(token.text)] : []
    );
  },
  renderMarkdown: (node, h2) => {
    var _a2;
    let output = "";
    const language = ((_a2 = node.attrs) == null ? void 0 : _a2.language) || "";
    if (!node.content) {
      output = `\`\`\`${language}

\`\`\``;
    } else {
      const lines = [`\`\`\`${language}`, h2.renderChildren(node.content), "```"];
      output = lines.join("\n");
    }
    return output;
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands }) => {
        return commands.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands }) => {
        return commands.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty2, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty2 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // handle tab indentation
      Tab: ({ editor }) => {
        var _a2;
        if (!this.options.enableTabIndentation) {
          return false;
        }
        const tabSize = (_a2 = this.options.tabSize) != null ? _a2 : DEFAULT_TAB_SIZE;
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if ($from.parent.type !== this.type) {
          return false;
        }
        const indent = " ".repeat(tabSize);
        if (empty2) {
          return editor.commands.insertContent(indent);
        }
        return editor.commands.command(({ tr: tr2 }) => {
          const { from: from2, to } = selection;
          const text = state.doc.textBetween(from2, to, "\n", "\n");
          const lines = text.split("\n");
          const indentedText = lines.map((line) => indent + line).join("\n");
          tr2.replaceWith(from2, to, state.schema.text(indentedText));
          return true;
        });
      },
      // handle shift+tab reverse indentation
      "Shift-Tab": ({ editor }) => {
        var _a2;
        if (!this.options.enableTabIndentation) {
          return false;
        }
        const tabSize = (_a2 = this.options.tabSize) != null ? _a2 : DEFAULT_TAB_SIZE;
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if ($from.parent.type !== this.type) {
          return false;
        }
        if (empty2) {
          return editor.commands.command(({ tr: tr2 }) => {
            var _a22;
            const { pos } = $from;
            const codeBlockStart = $from.start();
            const codeBlockEnd = $from.end();
            const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, "\n", "\n");
            const lines = allText.split("\n");
            let currentLineIndex = 0;
            let charCount = 0;
            const relativeCursorPos = pos - codeBlockStart;
            for (let i = 0; i < lines.length; i += 1) {
              if (charCount + lines[i].length >= relativeCursorPos) {
                currentLineIndex = i;
                break;
              }
              charCount += lines[i].length + 1;
            }
            const currentLine = lines[currentLineIndex];
            const leadingSpaces = ((_a22 = currentLine.match(/^ */)) == null ? void 0 : _a22[0]) || "";
            const spacesToRemove = Math.min(leadingSpaces.length, tabSize);
            if (spacesToRemove === 0) {
              return true;
            }
            let lineStartPos = codeBlockStart;
            for (let i = 0; i < currentLineIndex; i += 1) {
              lineStartPos += lines[i].length + 1;
            }
            tr2.delete(lineStartPos, lineStartPos + spacesToRemove);
            const cursorPosInLine = pos - lineStartPos;
            if (cursorPosInLine <= spacesToRemove) {
              tr2.setSelection(TextSelection.create(tr2.doc, lineStartPos));
            }
            return true;
          });
        }
        return editor.commands.command(({ tr: tr2 }) => {
          const { from: from2, to } = selection;
          const text = state.doc.textBetween(from2, to, "\n", "\n");
          const lines = text.split("\n");
          const reverseIndentText = lines.map((line) => {
            var _a22;
            const leadingSpaces = ((_a22 = line.match(/^ */)) == null ? void 0 : _a22[0]) || "";
            const spacesToRemove = Math.min(leadingSpaces.length, tabSize);
            return line.slice(spacesToRemove);
          }).join("\n");
          tr2.replaceWith(from2, to, state.schema.text(reverseIndentText));
          return true;
        });
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr: tr2 }) => {
          tr2.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc2 } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc2.nodeAt(after);
        if (nodeAfter) {
          return editor.commands.command(({ tr: tr2 }) => {
            tr2.setSelection(Selection.near(doc2.resolve(after)));
            return true;
          });
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData == null ? void 0 : vscodeData.mode;
            if (!text || !language) {
              return false;
            }
            const { tr: tr2, schema } = view.state;
            const textNode = schema.text(text.replace(/\r\n?/g, "\n"));
            tr2.replaceSelectionWith(this.type.create({ language }, textNode));
            if (tr2.selection.$from.parent.type !== this.type) {
              tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
            }
            tr2.setMeta("paste", true);
            view.dispatch(tr2);
            return true;
          }
        }
      })
    ];
  }
});
var Document = Node3.create({
  name: "doc",
  topNode: true,
  content: "block+",
  renderMarkdown: (node, h2) => {
    if (!node.content) {
      return "";
    }
    return h2.renderChildren(node.content, "\n\n");
  }
});
var HardBreak = Node3.create({
  name: "hardBreak",
  markdownTokenName: "br",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  linebreakReplacement: true,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  renderMarkdown: () => `  
`,
  parseMarkdown: () => {
    return {
      type: "hardBreak"
    };
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands, chain: chain2, state, editor }) => {
        return commands.first([
          () => commands.exitCode(),
          () => commands.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain2().insertContent({ type: this.name }).command(({ tr: tr2, dispatch: dispatch2 }) => {
              if (dispatch2 && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr2.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});
var Heading = Node3.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  parseMarkdown: (token, helpers) => {
    return helpers.createNode("heading", { level: token.depth || 1 }, helpers.parseInline(token.tokens || []));
  },
  renderMarkdown: (node, h2) => {
    var _a2;
    const level = ((_a2 = node.attrs) == null ? void 0 : _a2.level) ? parseInt(node.attrs.level, 10) : 1;
    const headingChars = "#".repeat(level);
    if (!node.content) {
      return "";
    }
    return `${headingChars} ${h2.renderChildren(node.content)}`;
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce(
      (items, level) => ({
        ...items,
        ...{
          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
        }
      }),
      {}
    );
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});
var HorizontalRule = Node3.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {},
      nextNodeType: "paragraph"
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  markdownTokenName: "hr",
  parseMarkdown: (token, helpers) => {
    return helpers.createNode("horizontalRule");
  },
  renderMarkdown: () => {
    return "---";
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: chain2, state }) => {
        if (!canInsertNode(state, state.schema.nodes[this.name])) {
          return false;
        }
        const { selection } = state;
        const { $to: $originTo } = selection;
        const currentChain = chain2();
        if (isNodeSelection(selection)) {
          currentChain.insertContentAt($originTo.pos, {
            type: this.name
          });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ state: chainState, tr: tr2, dispatch: dispatch2 }) => {
          if (dispatch2) {
            const { $to } = tr2.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr2.setSelection(NodeSelection.create(tr2.doc, $to.pos));
              } else {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos));
              }
            } else {
              const nodeType = chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType;
              const node = nodeType == null ? void 0 : nodeType.create();
              if (node) {
                tr2.insert(posAfter, node);
                tr2.setSelection(TextSelection.create(tr2.doc, posAfter + 1));
              }
            }
            tr2.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});
var starInputRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
var starPasteRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
var underscoreInputRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
var underscorePasteRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
var Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleItalic: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  markdownTokenName: "em",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("italic", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown: (node, h2) => {
    return `*${h2.renderChildren(node)}*`;
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});
const encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
const encodedUtlds = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222";
const numeric = "numeric";
const ascii = "ascii";
const alpha = "alpha";
const asciinumeric = "asciinumeric";
const alphanumeric = "alphanumeric";
const domain = "domain";
const emoji = "emoji";
const scheme = "scheme";
const slashscheme = "slashscheme";
const whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t2, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t2) < 0) {
      group.push(t2);
    }
  }
}
function flagsForToken(t2, groups) {
  const result = {};
  for (const c in groups) {
    if (groups[c].indexOf(t2) >= 0) {
      result[c] = true;
    }
  }
  return result;
}
function State(token = null) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i = 0; i < state.jr.length; i++) {
      const regex = state.jr[i][0];
      const nextState2 = state.jr[i][1];
      if (nextState2 && regex.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly = false) {
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t2 = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      Object.assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t2) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = Object.assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t2, allFlags, groups);
        } else if (flags) {
          addToGroups(t2, flags, groups);
        }
      }
      nextState.t = t2;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
const ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
const tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
const ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
const tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
const WORD = "WORD";
const UWORD = "UWORD";
const ASCIINUMERICAL = "ASCIINUMERICAL";
const ALPHANUMERICAL = "ALPHANUMERICAL";
const LOCALHOST = "LOCALHOST";
const TLD = "TLD";
const UTLD = "UTLD";
const SCHEME = "SCHEME";
const SLASH_SCHEME = "SLASH_SCHEME";
const NUM = "NUM";
const WS = "WS";
const NL = "NL";
const OPENBRACE = "OPENBRACE";
const CLOSEBRACE = "CLOSEBRACE";
const OPENBRACKET = "OPENBRACKET";
const CLOSEBRACKET = "CLOSEBRACKET";
const OPENPAREN = "OPENPAREN";
const CLOSEPAREN = "CLOSEPAREN";
const OPENANGLEBRACKET = "OPENANGLEBRACKET";
const CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
const FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
const FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
const LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
const RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
const LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
const RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
const FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
const FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
const AMPERSAND = "AMPERSAND";
const APOSTROPHE = "APOSTROPHE";
const ASTERISK = "ASTERISK";
const AT = "AT";
const BACKSLASH = "BACKSLASH";
const BACKTICK = "BACKTICK";
const CARET = "CARET";
const COLON = "COLON";
const COMMA = "COMMA";
const DOLLAR = "DOLLAR";
const DOT = "DOT";
const EQUALS = "EQUALS";
const EXCLAMATION = "EXCLAMATION";
const HYPHEN = "HYPHEN";
const PERCENT = "PERCENT";
const PIPE = "PIPE";
const PLUS = "PLUS";
const POUND = "POUND";
const QUERY = "QUERY";
const QUOTE = "QUOTE";
const FULLWIDTHMIDDLEDOT = "FULLWIDTHMIDDLEDOT";
const SEMI = "SEMI";
const SLASH = "SLASH";
const TILDE = "TILDE";
const UNDERSCORE = "UNDERSCORE";
const EMOJI$1 = "EMOJI";
const SYM = "SYM";
var tk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL,
  AMPERSAND,
  APOSTROPHE,
  ASCIINUMERICAL,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  CLOSEANGLEBRACKET,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEPAREN,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EMOJI: EMOJI$1,
  EQUALS,
  EXCLAMATION,
  FULLWIDTHGREATERTHAN,
  FULLWIDTHLEFTPAREN,
  FULLWIDTHLESSTHAN,
  FULLWIDTHMIDDLEDOT,
  FULLWIDTHRIGHTPAREN,
  HYPHEN,
  LEFTCORNERBRACKET,
  LEFTWHITECORNERBRACKET,
  LOCALHOST,
  NL,
  NUM,
  OPENANGLEBRACKET,
  OPENBRACE,
  OPENBRACKET,
  OPENPAREN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  RIGHTCORNERBRACKET,
  RIGHTWHITECORNERBRACKET,
  SCHEME,
  SEMI,
  SLASH,
  SLASH_SCHEME,
  SYM,
  TILDE,
  TLD,
  UNDERSCORE,
  UTLD,
  UWORD,
  WORD,
  WS
});
const ASCII_LETTER = /[a-z]/;
const LETTER = new RegExp("\\p{L}", "u");
const EMOJI = new RegExp("\\p{Emoji}", "u");
const DIGIT = /\d/;
const SPACE = /\s/;
const CR = "\r";
const LF = "\n";
const EMOJI_VARIATION = "";
const EMOJI_JOINER = "";
const OBJECT_REPLACEMENT = "";
let tlds = null, utlds = null;
function init$2(customSchemes = []) {
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, "", FULLWIDTHLEFTPAREN);
  tt(Start, "", FULLWIDTHRIGHTPAREN);
  tt(Start, "", LEFTCORNERBRACKET);
  tt(Start, "", RIGHTCORNERBRACKET);
  tt(Start, "", LEFTWHITECORNERBRACKET);
  tt(Start, "", RIGHTWHITECORNERBRACKET);
  tt(Start, "", FULLWIDTHLESSTHAN);
  tt(Start, "", FULLWIDTHGREATERTHAN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  tt(Start, "", FULLWIDTHMIDDLEDOT);
  const Num = tr(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr(Num, DIGIT, Num);
  const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {
    [asciinumeric]: true
  });
  const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {
    [alphanumeric]: true
  });
  const Word = tr(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr(Word, DIGIT, Asciinumeric);
  tr(Word, ASCII_LETTER, Word);
  tr(Asciinumeric, DIGIT, Asciinumeric);
  tr(Asciinumeric, ASCII_LETTER, Asciinumeric);
  const UWord = tr(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr(UWord, ASCII_LETTER);
  tr(UWord, DIGIT, Alphanumeric);
  tr(UWord, LETTER, UWord);
  tr(Alphanumeric, DIGIT, Alphanumeric);
  tr(Alphanumeric, ASCII_LETTER);
  tr(Alphanumeric, LETTER, Alphanumeric);
  const Nl2 = tt(Start, LF, NL, {
    [whitespace]: true
  });
  const Cr = tt(Start, CR, WS, {
    [whitespace]: true
  });
  const Ws = tr(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt(Start, OBJECT_REPLACEMENT, Ws);
  tt(Cr, LF, Nl2);
  tt(Cr, OBJECT_REPLACEMENT, Ws);
  tr(Cr, SPACE, Ws);
  tt(Ws, CR);
  tt(Ws, LF);
  tr(Ws, SPACE, Ws);
  tt(Ws, OBJECT_REPLACEMENT, Ws);
  const Emoji = tr(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tt(Emoji, "#");
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tt(EmojiJoiner, "#");
  tr(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];
  for (let i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (let i = 0; i < utlds.length; i++) {
    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
  for (let i = 0; i < customSchemes.length; i++) {
    const sch = customSchemes[i][0];
    const optionalSlashSlash = customSchemes[i][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: Object.assign({
      groups
    }, tk)
  };
}
function run$1(start, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index2 = 0;
  while (index2 < len) {
    let first2 = str.charCodeAt(index2);
    let second;
    let char = first2 < 55296 || first2 > 56319 || index2 + 1 === len || (second = str.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? str[index2] : str.slice(index2, index2 + 2);
    result.push(char);
    index2 += char.length;
  }
  return result;
}
function fastts(state, input, t2, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i = 0; i < len - 1; i++) {
    const char = input[i];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t2);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack2 = [];
  let i = 0;
  let digits = "0123456789";
  while (i < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack2.join(""));
      for (let popCount2 = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount2 > 0; popCount2--) {
        stack2.pop();
      }
      i += popDigitCount;
    } else {
      stack2.push(encoded[i]);
      i++;
    }
  }
  return words;
}
const defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop2,
  formatHref: noop2,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender = null) {
  let o = Object.assign({}, defaults);
  if (opts) {
    o = Object.assign(o, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  this.o = o;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable2 = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable2) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable2) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop2(val) {
  return val;
}
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options) {
    const val = this.toString();
    const truncate = options.get("truncate", val, this);
    const formatted = options.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options) {
    return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol = defaults.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options) {
    return {
      type: this.t,
      value: this.toFormattedString(options),
      isLink: this.isLink,
      href: this.toFormattedHref(options),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options) {
    return options.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options) {
    const token = this;
    const href = this.toHref(options.get("defaultProtocol"));
    const formattedHref = options.get("formatHref", href, this);
    const tagName = options.get("tagName", href, token);
    const content = this.toFormattedString(options);
    const attributes = {};
    const className = options.get("className", href, token);
    const target = options.get("target", href, token);
    const rel = options.get("rel", href, token);
    const attrs = options.getObj("attributes", href, token);
    const eventListeners = options.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      Object.assign(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}
const Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
const Text$1 = createTokenClass("text");
const Nl = createTokenClass("nl");
const Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2 = defaults.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
const makeState = (arg) => new State(arg);
function init$1({
  groups
}) {
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  tt(DomainHyphen, HYPHEN, DomainHyphen);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  tt(SchemeColon, QUERY, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // 
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // 
  ];
  for (let i = 0; i < bracketPairs.length; i++) {
    const [OPEN, CLOSE] = bracketPairs[i];
    const UrlOpen = tt(Url$1, OPEN);
    tt(UrlNonaccept, OPEN, UrlOpen);
    tt(UrlOpen, CLOSE, Url$1);
    const UrlOpenQ = makeState(Url);
    ta(UrlOpen, qsAccepting, UrlOpenQ);
    const UrlOpenSyms = makeState();
    ta(UrlOpen, qsNonAccepting);
    ta(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt(UrlOpenQ, CLOSE, Url$1);
    tt(UrlOpenSyms, CLOSE, Url$1);
  }
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run(start, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text$1, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text$1, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
const warn = typeof console !== "undefined" && console && console.warn || (() => {
});
const warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
const INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
  return INIT;
}
function registerCustomProtocol(scheme2, optionalSlashSlash = false) {
  if (INIT.initialized) {
    warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
  return INIT;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
tokenize.scan = run$1;
function find(str, type = null, opts = null) {
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options = new Options(opts);
  const tokens = tokenize(str);
  const filtered = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.isLink && (!type || token.t === type) && options.check(token)) {
      filtered.push(token.toFormattedObject(options));
    }
  }
  return filtered;
}
var UNICODE_WHITESPACE_PATTERN = "[\0- -\u2029]";
var UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN);
var UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`);
var UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, "g");
function isValidLinkStructure(tokens) {
  if (tokens.length === 1) {
    return tokens[0].isLink;
  }
  if (tokens.length === 3 && tokens[1].isLink) {
    return ["()", "[]"].includes(tokens[0].value + tokens[2].value);
  }
  return false;
}
function autolink(options) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction2) => transaction2.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction2) => transaction2.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr2 } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(
            textBlock.pos,
            textBlock.pos + textBlock.node.nodeSize,
            void 0,
            " "
          );
        } else if (nodesInChangedRanges.length) {
          const endText = newState.doc.textBetween(newRange.from, newRange.to, " ", " ");
          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {
            return;
          }
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean);
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map((t2) => t2.toObject(options.defaultProtocol));
          if (!isValidLinkStructure(linksBeforeSpace)) {
            return false;
          }
          linksBeforeSpace.filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => options.validate(link.value)).filter((link) => options.shouldAutoLink(link.value)).forEach((link) => {
            if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {
              return;
            }
            tr2.addMark(
              link.from,
              link.to,
              options.type.create({
                href: link.href
              })
            );
          });
        }
      });
      if (!tr2.steps.length) {
        return;
      }
      return tr2;
    }
  });
}
function clickHandler(options) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a2, _b;
        if (event.button !== 0) {
          return false;
        }
        if (!view.editable) {
          return false;
        }
        let link = null;
        if (event.target instanceof HTMLAnchorElement) {
          link = event.target;
        } else {
          let a = event.target;
          const els = [];
          while (a.nodeName !== "DIV") {
            els.push(a);
            a = a.parentNode;
          }
          link = els.find((value) => value.nodeName === "A");
        }
        if (!link) {
          return false;
        }
        const attrs = getAttributes(view.state, options.type.name);
        const href = (_a2 = link == null ? void 0 : link.href) != null ? _a2 : attrs.href;
        const target = (_b = link == null ? void 0 : link.target) != null ? _b : attrs.target;
        if (options.enableClickSelection) {
          options.editor.commands.extendMarkRange(options.type.name);
        }
        if (link && href) {
          window.open(href, target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, _event, slice2) => {
        const { shouldAutoLink } = options;
        const { state } = view;
        const { selection } = state;
        const { empty: empty2 } = selection;
        if (empty2) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find(
          (item) => item.isLink && item.value === textContent
        );
        if (!textContent || !link || shouldAutoLink !== void 0 && !shouldAutoLink(link.href)) {
          return false;
        }
        return options.editor.commands.setMark(options.type, {
          href: link.href
        });
      }
    }
  });
}
function isAllowedUri(uri, protocols) {
  const allowedProtocols = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return !uri || uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var Link = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  exitable: true,
  onCreate() {
    if (this.options.validate && !this.options.shouldAutoLink) {
      this.options.shouldAutoLink = this.options.validate;
      console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.");
    }
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      enableClickSelection: false,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),
      validate: (url) => !!url,
      shouldAutoLink: (url) => !!url
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(element) {
          return element.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (dom) => {
          const href = dom.getAttribute("href");
          if (!href || !this.options.isAllowedUri(href, {
            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          })) {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    if (!this.options.isAllowedUri(HTMLAttributes.href, {
      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    })) {
      return ["a", mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }), 0];
    }
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "link",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("link", helpers.parseInline(token.tokens || []), {
      href: token.href,
      title: token.title || null
    });
  },
  renderMarkdown: (node, h2) => {
    var _a2;
    const href = ((_a2 = node.attrs) == null ? void 0 : _a2.href) || "";
    const text = h2.renderChildren(node);
    return `[${text}](${href})`;
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain: chain2 }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain2().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain: chain2 }) => {
        const { href } = attributes || {};
        if (href && !this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain2().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain: chain2 }) => {
        return chain2().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text) => {
          const foundLinks = [];
          if (text) {
            const { protocols, defaultProtocol } = this.options;
            const links = find(text).filter(
              (item) => item.isLink && this.options.isAllowedUri(item.value, {
                defaultValidate: (href) => !!isAllowedUri(href, protocols),
                protocols,
                defaultProtocol
              })
            );
            if (links.length) {
              links.forEach((link) => {
                if (!this.options.shouldAutoLink(link.value)) {
                  return;
                }
                foundLinks.push({
                  text: link.value,
                  data: {
                    href: link.href
                  },
                  index: link.start
                });
              });
            }
          }
          return foundLinks;
        },
        type: this.type,
        getAttributes: (match) => {
          var _a2;
          return {
            href: (_a2 = match.data) == null ? void 0 : _a2.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    const { protocols, defaultProtocol } = this.options;
    if (this.options.autolink) {
      plugins.push(
        autolink({
          type: this.type,
          defaultProtocol: this.options.defaultProtocol,
          validate: (url) => this.options.isAllowedUri(url, {
            defaultValidate: (href) => !!isAllowedUri(href, protocols),
            protocols,
            defaultProtocol
          }),
          shouldAutoLink: this.options.shouldAutoLink
        })
      );
    }
    if (this.options.openOnClick === true) {
      plugins.push(
        clickHandler({
          type: this.type,
          editor: this.editor,
          enableClickSelection: this.options.enableClickSelection
        })
      );
    }
    if (this.options.linkOnPaste) {
      plugins.push(
        pasteHandler({
          editor: this.editor,
          defaultProtocol: this.options.defaultProtocol,
          type: this.type,
          shouldAutoLink: this.options.shouldAutoLink
        })
      );
    }
    return plugins;
  }
});
var __defProp$2 = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp$2(target, name, { get: all[name], enumerable: true });
};
var ListItemName = "listItem";
var TextStyleName = "textStyle";
var bulletListInputRegex = /^\s*([-+*])\s$/;
var BulletList = Node3.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [{ tag: "ul" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (token, helpers) => {
    if (token.type !== "list" || token.ordered) {
      return [];
    }
    return {
      type: "bulletList",
      content: token.items ? helpers.parseChildren(token.items) : []
    };
  },
  renderMarkdown: (node, h2) => {
    if (!node.content) {
      return "";
    }
    return h2.renderChildren(node.content, "\n");
  },
  markdownOptions: {
    indentsContent: true
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands, chain: chain2 }) => {
        if (this.options.keepAttributes) {
          return chain2().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
        }
        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: bulletListInputRegex,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: bulletListInputRegex,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyleName);
        },
        editor: this.editor
      });
    }
    return [inputRule];
  }
});
var ListItem = Node3.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "list_item",
  parseMarkdown: (token, helpers) => {
    if (token.type !== "list_item") {
      return [];
    }
    let content = [];
    if (token.tokens && token.tokens.length > 0) {
      const hasParagraphTokens = token.tokens.some((t2) => t2.type === "paragraph");
      if (hasParagraphTokens) {
        content = helpers.parseChildren(token.tokens);
      } else {
        const firstToken = token.tokens[0];
        if (firstToken && firstToken.type === "text" && firstToken.tokens && firstToken.tokens.length > 0) {
          const inlineContent = helpers.parseInline(firstToken.tokens);
          content = [
            {
              type: "paragraph",
              content: inlineContent
            }
          ];
          if (token.tokens.length > 1) {
            const remainingTokens = token.tokens.slice(1);
            const additionalContent = helpers.parseChildren(remainingTokens);
            content.push(...additionalContent);
          }
        } else {
          content = helpers.parseChildren(token.tokens);
        }
      }
    }
    if (content.length === 0) {
      content = [
        {
          type: "paragraph",
          content: []
        }
      ];
    }
    return {
      type: "listItem",
      content
    };
  },
  renderMarkdown: (node, h2, ctx) => {
    return renderNestedMarkdownContent(
      node,
      h2,
      (context) => {
        if (context.parentType === "bulletList") {
          return "- ";
        }
        if (context.parentType === "orderedList") {
          return `${context.index + 1}. `;
        }
        return "- ";
      },
      ctx
    );
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
var listHelpers_exports = {};
__export(listHelpers_exports, {
  findListItemPos: () => findListItemPos,
  getNextListDepth: () => getNextListDepth,
  handleBackspace: () => handleBackspace,
  handleDelete: () => handleDelete,
  hasListBefore: () => hasListBefore,
  hasListItemAfter: () => hasListItemAfter,
  hasListItemBefore: () => hasListItemBefore,
  listItemHasSubList: () => listItemHasSubList,
  nextListIsDeeper: () => nextListIsDeeper,
  nextListIsHigher: () => nextListIsHigher
});
var findListItemPos = (typeOrName, state) => {
  const { $from } = state.selection;
  const nodeType = getNodeType(typeOrName, state.schema);
  let currentNode = null;
  let currentDepth = $from.depth;
  let currentPos = $from.pos;
  let targetDepth = null;
  while (currentDepth > 0 && targetDepth === null) {
    currentNode = $from.node(currentDepth);
    if (currentNode.type === nodeType) {
      targetDepth = currentDepth;
    } else {
      currentDepth -= 1;
      currentPos -= 1;
    }
  }
  if (targetDepth === null) {
    return null;
  }
  return { $pos: state.doc.resolve(currentPos), depth: targetDepth };
};
var getNextListDepth = (typeOrName, state) => {
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos) {
    return false;
  }
  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4);
  return depth;
};
var hasListBefore = (editorState, name, parentListTypes) => {
  const { $anchor } = editorState.selection;
  const previousNodePos = Math.max(0, $anchor.pos - 2);
  const previousNode = editorState.doc.resolve(previousNodePos).node();
  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {
    return false;
  }
  return true;
};
var hasListItemBefore = (typeOrName, state) => {
  var _a2;
  const { $anchor } = state.selection;
  const $targetPos = state.doc.resolve($anchor.pos - 2);
  if ($targetPos.index() === 0) {
    return false;
  }
  if (((_a2 = $targetPos.nodeBefore) == null ? void 0 : _a2.type.name) !== typeOrName) {
    return false;
  }
  return true;
};
var listItemHasSubList = (typeOrName, state, node) => {
  if (!node) {
    return false;
  }
  const nodeType = getNodeType(typeOrName, state.schema);
  let hasSubList = false;
  node.descendants((child) => {
    if (child.type === nodeType) {
      hasSubList = true;
    }
  });
  return hasSubList;
};
var handleBackspace = (editor, name, parentListTypes) => {
  if (editor.commands.undoInputRule()) {
    return true;
  }
  if (editor.state.selection.from !== editor.state.selection.to) {
    return false;
  }
  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {
    const { $anchor } = editor.state.selection;
    const $listPos = editor.state.doc.resolve($anchor.before() - 1);
    const listDescendants = [];
    $listPos.node().descendants((node, pos) => {
      if (node.type.name === name) {
        listDescendants.push({ node, pos });
      }
    });
    const lastItem = listDescendants.at(-1);
    if (!lastItem) {
      return false;
    }
    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);
    return editor.chain().cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end()).joinForward().run();
  }
  if (!isNodeActive(editor.state, name)) {
    return false;
  }
  if (!isAtStartOfNode(editor.state)) {
    return false;
  }
  const listItemPos = findListItemPos(name, editor.state);
  if (!listItemPos) {
    return false;
  }
  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);
  const prevNode = $prev.node(listItemPos.depth);
  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);
  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {
    return editor.commands.joinItemBackward();
  }
  return editor.chain().liftListItem(name).run();
};
var nextListIsDeeper = (typeOrName, state) => {
  const listDepth = getNextListDepth(typeOrName, state);
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos || !listDepth) {
    return false;
  }
  if (listDepth > listItemPos.depth) {
    return true;
  }
  return false;
};
var nextListIsHigher = (typeOrName, state) => {
  const listDepth = getNextListDepth(typeOrName, state);
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos || !listDepth) {
    return false;
  }
  if (listDepth < listItemPos.depth) {
    return true;
  }
  return false;
};
var handleDelete = (editor, name) => {
  if (!isNodeActive(editor.state, name)) {
    return false;
  }
  if (!isAtEndOfNode(editor.state, name)) {
    return false;
  }
  const { selection } = editor.state;
  const { $from, $to } = selection;
  if (!selection.empty && $from.sameParent($to)) {
    return false;
  }
  if (nextListIsDeeper(name, editor.state)) {
    return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();
  }
  if (nextListIsHigher(name, editor.state)) {
    return editor.chain().joinForward().joinBackward().run();
  }
  return editor.commands.joinItemForward();
};
var hasListItemAfter = (typeOrName, state) => {
  var _a2;
  const { $anchor } = state.selection;
  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);
  if ($targetPos.index() === $targetPos.parent.childCount - 1) {
    return false;
  }
  if (((_a2 = $targetPos.nodeAfter) == null ? void 0 : _a2.type.name) !== typeOrName) {
    return false;
  }
  return true;
};
var ListKeymap = Extension.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleDelete(editor, itemName)) {
            handled = true;
          }
        });
        return handled;
      },
      "Mod-Delete": ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleDelete(editor, itemName)) {
            handled = true;
          }
        });
        return handled;
      },
      Backspace: ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleBackspace(editor, itemName, wrapperNames)) {
            handled = true;
          }
        });
        return handled;
      },
      "Mod-Backspace": ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleBackspace(editor, itemName, wrapperNames)) {
            handled = true;
          }
        });
        return handled;
      }
    };
  }
});
var ORDERED_LIST_ITEM_REGEX = /^(\s*)(\d+)\.\s+(.*)$/;
var INDENTED_LINE_REGEX = /^\s/;
function collectOrderedListItems(lines) {
  const listItems = [];
  let currentLineIndex = 0;
  let consumed = 0;
  while (currentLineIndex < lines.length) {
    const line = lines[currentLineIndex];
    const match = line.match(ORDERED_LIST_ITEM_REGEX);
    if (!match) {
      break;
    }
    const [, indent, number2, content] = match;
    const indentLevel = indent.length;
    let itemContent = content;
    let nextLineIndex = currentLineIndex + 1;
    const itemLines = [line];
    while (nextLineIndex < lines.length) {
      const nextLine = lines[nextLineIndex];
      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX);
      if (nextMatch) {
        break;
      }
      if (nextLine.trim() === "") {
        itemLines.push(nextLine);
        itemContent += "\n";
        nextLineIndex += 1;
      } else if (nextLine.match(INDENTED_LINE_REGEX)) {
        itemLines.push(nextLine);
        itemContent += `
${nextLine.slice(indentLevel + 2)}`;
        nextLineIndex += 1;
      } else {
        break;
      }
    }
    listItems.push({
      indent: indentLevel,
      number: parseInt(number2, 10),
      content: itemContent.trim(),
      raw: itemLines.join("\n")
    });
    consumed = nextLineIndex;
    currentLineIndex = nextLineIndex;
  }
  return [listItems, consumed];
}
function buildNestedStructure(items, baseIndent, lexer) {
  var _a2;
  const result = [];
  let currentIndex = 0;
  while (currentIndex < items.length) {
    const item = items[currentIndex];
    if (item.indent === baseIndent) {
      const contentLines = item.content.split("\n");
      const mainText = ((_a2 = contentLines[0]) == null ? void 0 : _a2.trim()) || "";
      const tokens = [];
      if (mainText) {
        tokens.push({
          type: "paragraph",
          raw: mainText,
          tokens: lexer.inlineTokens(mainText)
        });
      }
      const additionalContent = contentLines.slice(1).join("\n").trim();
      if (additionalContent) {
        const blockTokens = lexer.blockTokens(additionalContent);
        tokens.push(...blockTokens);
      }
      let lookAheadIndex = currentIndex + 1;
      const nestedItems = [];
      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {
        nestedItems.push(items[lookAheadIndex]);
        lookAheadIndex += 1;
      }
      if (nestedItems.length > 0) {
        const nextIndent = Math.min(...nestedItems.map((nestedItem) => nestedItem.indent));
        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer);
        tokens.push({
          type: "list",
          ordered: true,
          start: nestedItems[0].number,
          items: nestedListItems,
          raw: nestedItems.map((nestedItem) => nestedItem.raw).join("\n")
        });
      }
      result.push({
        type: "list_item",
        raw: item.raw,
        tokens
      });
      currentIndex = lookAheadIndex;
    } else {
      currentIndex += 1;
    }
  }
  return result;
}
function parseListItems(items, helpers) {
  return items.map((item) => {
    if (item.type !== "list_item") {
      return helpers.parseChildren([item])[0];
    }
    const content = [];
    if (item.tokens && item.tokens.length > 0) {
      item.tokens.forEach((itemToken) => {
        if (itemToken.type === "paragraph" || itemToken.type === "list" || itemToken.type === "blockquote" || itemToken.type === "code") {
          content.push(...helpers.parseChildren([itemToken]));
        } else if (itemToken.type === "text" && itemToken.tokens) {
          const inlineContent = helpers.parseChildren([itemToken]);
          content.push({
            type: "paragraph",
            content: inlineContent
          });
        } else {
          const parsed = helpers.parseChildren([itemToken]);
          if (parsed.length > 0) {
            content.push(...parsed);
          }
        }
      });
    }
    return {
      type: "listItem",
      content
    };
  });
}
var ListItemName2 = "listItem";
var TextStyleName2 = "textStyle";
var orderedListInputRegex = /^(\d+)\.\s$/;
var OrderedList = Node3.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      },
      type: {
        default: null,
        parseHTML: (element) => element.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start, ...attributesWithoutStart } = HTMLAttributes;
    return start === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (token, helpers) => {
    if (token.type !== "list" || !token.ordered) {
      return [];
    }
    const startValue = token.start || 1;
    const content = token.items ? parseListItems(token.items, helpers) : [];
    if (startValue !== 1) {
      return {
        type: "orderedList",
        attrs: { start: startValue },
        content
      };
    }
    return {
      type: "orderedList",
      content
    };
  },
  renderMarkdown: (node, h2) => {
    if (!node.content) {
      return "";
    }
    return h2.renderChildren(node.content, "\n");
  },
  markdownTokenizer: {
    name: "orderedList",
    level: "block",
    start: (src) => {
      const match = src.match(/^(\s*)(\d+)\.\s+/);
      const index2 = match == null ? void 0 : match.index;
      return index2 !== void 0 ? index2 : -1;
    },
    tokenize: (src, _tokens, lexer) => {
      var _a2;
      const lines = src.split("\n");
      const [listItems, consumed] = collectOrderedListItems(lines);
      if (listItems.length === 0) {
        return void 0;
      }
      const items = buildNestedStructure(listItems, 0, lexer);
      if (items.length === 0) {
        return void 0;
      }
      const startValue = ((_a2 = listItems[0]) == null ? void 0 : _a2.number) || 1;
      return {
        type: "list",
        ordered: true,
        start: startValue,
        items,
        raw: lines.slice(0, consumed).join("\n")
      };
    }
  },
  markdownOptions: {
    indentsContent: true
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands, chain: chain2 }) => {
        if (this.options.keepAttributes) {
          return chain2().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();
        }
        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: orderedListInputRegex,
      type: this.type,
      getAttributes: (match) => ({ start: +match[1] }),
      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: orderedListInputRegex,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName2) }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
        editor: this.editor
      });
    }
    return [inputRule];
  }
});
var inputRegex$1 = /^\s*(\[([( |x])?\])\s$/;
var TaskItem = Node3.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: false,
      HTMLAttributes: {},
      taskListTypeName: "taskList",
      a11y: void 0
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: true,
  addAttributes() {
    return {
      checked: {
        default: false,
        keepOnSplit: false,
        parseHTML: (element) => {
          const dataChecked = element.getAttribute("data-checked");
          return dataChecked === "" || dataChecked === "true";
        },
        renderHTML: (attributes) => ({
          "data-checked": attributes.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "li",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: node.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  parseMarkdown: (token, h2) => {
    const content = [];
    if (token.tokens && token.tokens.length > 0) {
      content.push(h2.createNode("paragraph", {}, h2.parseInline(token.tokens)));
    } else if (token.text) {
      content.push(h2.createNode("paragraph", {}, [h2.createNode("text", { text: token.text })]));
    } else {
      content.push(h2.createNode("paragraph", {}, []));
    }
    if (token.nestedTokens && token.nestedTokens.length > 0) {
      const nestedContent = h2.parseChildren(token.nestedTokens);
      content.push(...nestedContent);
    }
    return h2.createNode("taskItem", { checked: token.checked || false }, content);
  },
  renderMarkdown: (node, h2) => {
    var _a2;
    const checkedChar = ((_a2 = node.attrs) == null ? void 0 : _a2.checked) ? "x" : " ";
    const prefix = `- [${checkedChar}] `;
    return renderNestedMarkdownContent(node, h2, prefix);
  },
  addKeyboardShortcuts() {
    const shortcuts = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    if (!this.options.nested) {
      return shortcuts;
    }
    return {
      ...shortcuts,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    };
  },
  addNodeView() {
    return ({ node, HTMLAttributes, getPos, editor }) => {
      const listItem = document.createElement("li");
      const checkboxWrapper = document.createElement("label");
      const checkboxStyler = document.createElement("span");
      const checkbox = document.createElement("input");
      const content = document.createElement("div");
      const updateA11Y = (currentNode) => {
        var _a2, _b;
        checkbox.ariaLabel = ((_b = (_a2 = this.options.a11y) == null ? void 0 : _a2.checkboxLabel) == null ? void 0 : _b.call(_a2, currentNode, checkbox.checked)) || `Task item checkbox for ${currentNode.textContent || "empty task item"}`;
      };
      updateA11Y(node);
      checkboxWrapper.contentEditable = "false";
      checkbox.type = "checkbox";
      checkbox.addEventListener("mousedown", (event) => event.preventDefault());
      checkbox.addEventListener("change", (event) => {
        if (!editor.isEditable && !this.options.onReadOnlyChecked) {
          checkbox.checked = !checkbox.checked;
          return;
        }
        const { checked } = event.target;
        if (editor.isEditable && typeof getPos === "function") {
          editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr: tr2 }) => {
            const position = getPos();
            if (typeof position !== "number") {
              return false;
            }
            const currentNode = tr2.doc.nodeAt(position);
            tr2.setNodeMarkup(position, void 0, {
              ...currentNode == null ? void 0 : currentNode.attrs,
              checked
            });
            return true;
          }).run();
        }
        if (!editor.isEditable && this.options.onReadOnlyChecked) {
          if (!this.options.onReadOnlyChecked(node, checked)) {
            checkbox.checked = !checkbox.checked;
          }
        }
      });
      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {
        listItem.setAttribute(key, value);
      });
      listItem.dataset.checked = node.attrs.checked;
      checkbox.checked = node.attrs.checked;
      checkboxWrapper.append(checkbox, checkboxStyler);
      listItem.append(checkboxWrapper, content);
      Object.entries(HTMLAttributes).forEach(([key, value]) => {
        listItem.setAttribute(key, value);
      });
      return {
        dom: listItem,
        contentDOM: content,
        update: (updatedNode) => {
          if (updatedNode.type !== this.type) {
            return false;
          }
          listItem.dataset.checked = updatedNode.attrs.checked;
          checkbox.checked = updatedNode.attrs.checked;
          updateA11Y(updatedNode);
          return true;
        }
      };
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$1,
        type: this.type,
        getAttributes: (match) => ({
          checked: match[match.length - 1] === "x"
        })
      })
    ];
  }
});
var TaskList = Node3.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }), 0];
  },
  parseMarkdown: (token, h2) => {
    return h2.createNode("taskList", {}, h2.parseChildren(token.items || []));
  },
  renderMarkdown: (node, h2) => {
    if (!node.content) {
      return "";
    }
    return h2.renderChildren(node.content, "\n");
  },
  markdownTokenizer: {
    name: "taskList",
    level: "block",
    start(src) {
      var _a2;
      const index2 = (_a2 = src.match(/^\s*[-+*]\s+\[([ xX])\]\s+/)) == null ? void 0 : _a2.index;
      return index2 !== void 0 ? index2 : -1;
    },
    tokenize(src, tokens, lexer) {
      const parseTaskListContent = (content) => {
        const nestedResult = parseIndentedBlocks(
          content,
          {
            itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
            extractItemData: (match) => ({
              indentLevel: match[1].length,
              mainContent: match[4],
              checked: match[3].toLowerCase() === "x"
            }),
            createToken: (data, nestedTokens) => ({
              type: "taskItem",
              raw: "",
              mainContent: data.mainContent,
              indentLevel: data.indentLevel,
              checked: data.checked,
              text: data.mainContent,
              tokens: lexer.inlineTokens(data.mainContent),
              nestedTokens
            }),
            // Allow recursive nesting
            customNestedParser: parseTaskListContent
          },
          lexer
        );
        if (nestedResult) {
          return [
            {
              type: "taskList",
              raw: nestedResult.raw,
              items: nestedResult.items
            }
          ];
        }
        return lexer.blockTokens(content);
      };
      const result = parseIndentedBlocks(
        src,
        {
          itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
          extractItemData: (match) => ({
            indentLevel: match[1].length,
            mainContent: match[4],
            checked: match[3].toLowerCase() === "x"
          }),
          createToken: (data, nestedTokens) => ({
            type: "taskItem",
            raw: "",
            mainContent: data.mainContent,
            indentLevel: data.indentLevel,
            checked: data.checked,
            text: data.mainContent,
            tokens: lexer.inlineTokens(data.mainContent),
            nestedTokens
          }),
          // Use the recursive parser for nested content
          customNestedParser: parseTaskListContent
        },
        lexer
      );
      if (!result) {
        return void 0;
      }
      return {
        type: "taskList",
        raw: result.raw,
        items: result.items
      };
    }
  },
  markdownOptions: {
    indentsContent: true
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands }) => {
        return commands.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
Extension.create({
  name: "listKit",
  addExtensions() {
    const extensions = [];
    if (this.options.bulletList !== false) {
      extensions.push(BulletList.configure(this.options.bulletList));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem.configure(this.options.listItem));
    }
    if (this.options.listKeymap !== false) {
      extensions.push(ListKeymap.configure(this.options.listKeymap));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList.configure(this.options.orderedList));
    }
    if (this.options.taskItem !== false) {
      extensions.push(TaskItem.configure(this.options.taskItem));
    }
    if (this.options.taskList !== false) {
      extensions.push(TaskList.configure(this.options.taskList));
    }
    return extensions;
  }
});
var Paragraph = Node3.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  parseMarkdown: (token, helpers) => {
    const tokens = token.tokens || [];
    if (tokens.length === 1 && tokens[0].type === "image") {
      return helpers.parseChildren([tokens[0]]);
    }
    return helpers.createNode(
      "paragraph",
      void 0,
      // no attributes for paragraph
      helpers.parseInline(tokens)
    );
  },
  renderMarkdown: (node, h2) => {
    if (!node || !Array.isArray(node.content)) {
      return "";
    }
    return h2.renderChildren(node.content);
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands }) => {
        return commands.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});
var inputRegex = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
var pasteRegex = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
var Strike = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "del",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("strike", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown: (node, h2) => {
    return `~~${h2.renderChildren(node)}~~`;
  },
  addCommands() {
    return {
      setStrike: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleStrike: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});
var Text = Node3.create({
  name: "text",
  group: "inline",
  parseMarkdown: (token) => {
    return {
      type: "text",
      text: token.text || ""
    };
  },
  renderMarkdown: (node) => node.text || ""
});
var Underline = Mark2.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  parseMarkdown(token, helpers) {
    return helpers.applyMark(this.name || "underline", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown(node, helpers) {
    return `++${helpers.renderChildren(node)}++`;
  },
  markdownTokenizer: {
    name: "underline",
    level: "inline",
    start(src) {
      return src.indexOf("++");
    },
    tokenize(src, _tokens, lexer) {
      const rule = /^(\+\+)([\s\S]+?)(\+\+)/;
      const match = rule.exec(src);
      if (!match) {
        return void 0;
      }
      const innerContent = match[2].trim();
      return {
        type: "underline",
        raw: match[0],
        text: innerContent,
        tokens: lexer.inlineTokens(innerContent)
      };
    }
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleUnderline: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
class DropCursorView {
  constructor(editorView, options) {
    var _a2;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a2 = options.width) !== null && _a2 !== void 0 ? _a2 : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
    let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          let halfWidth = this.width / 2 * scaleY;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top - halfWidth, bottom: top + halfWidth };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      let halfWidth = this.width / 2 * scaleX;
      rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
      parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
      parentTop = rect2.top - parent.scrollTop * parentScaleY;
    }
    this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
    this.element.style.top = (rect.top - parentTop) / scaleY + "px";
    this.element.style.width = (rect.right - rect.left) / scaleX + "px";
    this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (!this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
}
class GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc2, mapping) {
    let $pos = doc2.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new GapCursor(doc2.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search: for (; ; ) {
      if (!mustMove && GapCursor.valid($pos))
        return $pos;
      let pos = $pos.pos, next = null;
      for (let d = $pos.depth; ; d--) {
        let parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break;
        } else if (d == 0) {
          return null;
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      for (; ; ) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search;
          }
          break;
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      return null;
    }
  }
}
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
class GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new GapBookmark(mapping.map(this.pos));
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
}
function needsGap(type) {
  return type.isAtom || type.spec.isolating || type.spec.createGapCursor;
}
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.index(d), parent = $pos.node(d);
    if (index2 == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index2 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || needsGap(before.type))
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.indexAfter(d), parent = $pos.node(d);
    if (index2 == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index2); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || needsGap(after.type))
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
const handleKeyDown = keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});
function arrow(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch2, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch2)
      dispatch2(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment.from(insert[i].createAndFill(null, frag));
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ (function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
})(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ (function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
})(RopeSequence);
const max_empty_items = 500;
class Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end = this.items.length;
    for (; ; end--) {
      let next = this.items.get(end - 1);
      if (next.selection) {
        --end;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array2) {
    if (this.eventCount == 0)
      return this;
    return new Branch(this.items.append(array2.map((map2) => new Item(map2))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map2, step, selection));
      } else {
        rebasedItems.push(new Item(map2));
      }
    }, start);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
    let branch = new Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count2 = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count2++;
    });
    return count2;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map2.invert(), step, selection), merged, last2 = items.length - 1;
          if (merged = items.length && items[last2].merge(newItem))
            items[last2] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch(RopeSequence.from(items.reverse()), events);
  }
}
Branch.empty = new Branch(RopeSequence.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
class Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new Item(step.getMap().invert(), step, this.selection);
    }
  }
}
class HistoryState {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr2, options) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr2, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr2.mapping.maps), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps);
    return new HistoryState(history2.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start, end) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start <= prevRanges[i + 1] && end >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)
    maps[i].forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new PluginKey("history");
const closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr2, hist, state) {
        return applyTransaction(hist, state, tr2, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2 || !view.editable)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll) {
  return (state, dispatch2) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch2) {
      let tr2 = histTransaction(hist, state, redo2);
      if (tr2)
        dispatch2(scroll ? tr2.scrollIntoView() : tr2);
    }
    return true;
  };
}
const undo = buildCommand(false, true);
const redo = buildCommand(true, true);
Extension.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (text) => text.length,
      wordCounter: (text) => text.split(" ").filter((word) => word !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (options) => {
      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;
      const mode = (options == null ? void 0 : options.mode) || this.options.mode;
      if (mode === "textSize") {
        const text = node.textBetween(0, node.content.size, void 0, " ");
        return this.options.textCounter(text);
      }
      return node.nodeSize;
    };
    this.storage.words = (options) => {
      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;
      const text = node.textBetween(0, node.content.size, " ", " ");
      return this.options.wordCounter(text);
    };
  },
  addProseMirrorPlugins() {
    let initialEvaluationDone = false;
    return [
      new Plugin({
        key: new PluginKey("characterCount"),
        appendTransaction: (transactions, oldState, newState) => {
          if (initialEvaluationDone) {
            return;
          }
          const limit = this.options.limit;
          if (limit === null || limit === void 0 || limit === 0) {
            initialEvaluationDone = true;
            return;
          }
          const initialContentSize = this.storage.characters({ node: newState.doc });
          if (initialContentSize > limit) {
            const over = initialContentSize - limit;
            const from2 = 0;
            const to = over;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`
            );
            const tr2 = newState.tr.deleteRange(from2, to);
            initialEvaluationDone = true;
            return tr2;
          }
          initialEvaluationDone = true;
        },
        filterTransaction: (transaction2, state) => {
          const limit = this.options.limit;
          if (!transaction2.docChanged || limit === 0 || limit === null || limit === void 0) {
            return true;
          }
          const oldSize = this.storage.characters({ node: state.doc });
          const newSize = this.storage.characters({ node: transaction2.doc });
          if (newSize <= limit) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize <= oldSize) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize > oldSize) {
            return false;
          }
          const isPaste = transaction2.getMeta("paste");
          if (!isPaste) {
            return false;
          }
          const pos = transaction2.selection.$head.pos;
          const over = newSize - limit;
          const from2 = pos - over;
          const to = pos;
          transaction2.deleteRange(from2, to);
          const updatedSize = this.storage.characters({ node: transaction2.doc });
          if (updatedSize > limit) {
            return false;
          }
          return true;
        }
      })
    ];
  }
});
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [dropCursor(this.options)];
  }
});
Extension.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("focus"),
        props: {
          decorations: ({ doc: doc2, selection }) => {
            const { isEditable, isFocused } = this.editor;
            const { anchor } = selection;
            const decorations = [];
            if (!isEditable || !isFocused) {
              return DecorationSet.create(doc2, []);
            }
            let maxLevels = 0;
            if (this.options.mode === "deepest") {
              doc2.descendants((node, pos) => {
                if (node.isText) {
                  return;
                }
                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
                if (!isCurrent) {
                  return false;
                }
                maxLevels += 1;
              });
            }
            let currentLevel = 0;
            doc2.descendants((node, pos) => {
              if (node.isText) {
                return false;
              }
              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
              if (!isCurrent) {
                return false;
              }
              currentLevel += 1;
              const outOfScope = this.options.mode === "deepest" && maxLevels - currentLevel > 0 || this.options.mode === "shallowest" && currentLevel > 1;
              if (outOfScope) {
                return this.options.mode === "deepest";
              }
              decorations.push(
                Decoration.node(pos, pos + node.nodeSize, {
                  class: this.options.className
                })
              );
            });
            return DecorationSet.create(doc2, decorations);
          }
        }
      })
    ];
  }
});
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [gapCursor()];
  },
  extendNodeSchema(extension) {
    var _a2;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a2 = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) != null ? _a2 : null
    };
  }
});
Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something ",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc2, selection }) => {
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const isEmptyDoc = this.editor.isEmpty;
            doc2.descendants((node, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
              const isEmpty = !node.isLeaf && isNodeEmpty(node);
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {
                const classes = [this.options.emptyNodeClass];
                if (isEmptyDoc) {
                  classes.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: classes.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc2, decorations);
          }
        }
      })
    ];
  }
});
Extension.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor, options } = this;
    return [
      new Plugin({
        key: new PluginKey("selection"),
        props: {
          decorations(state) {
            if (state.selection.empty || editor.isFocused || !editor.isEditable || isNodeSelection(state.selection) || editor.view.dragging) {
              return null;
            }
            return DecorationSet.create(state.doc, [
              Decoration.inline(state.selection.from, state.selection.to, {
                class: options.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function nodeEqualsType({ types, node }) {
  return node && Array.isArray(types) && types.includes(node.type) || (node == null ? void 0 : node.type) === types;
}
var TrailingNode = Extension.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: void 0,
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    var _a2;
    const plugin = new PluginKey(this.name);
    const defaultNode = this.options.node || ((_a2 = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : _a2.name) || "paragraph";
    const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value]) => value).filter((node) => (this.options.notAfter || []).concat(defaultNode).includes(node.name));
    return [
      new Plugin({
        key: plugin,
        appendTransaction: (_, __, state) => {
          const { doc: doc2, tr: tr2, schema } = state;
          const shouldInsertNodeAtEnd = plugin.getState(state);
          const endPosition = doc2.content.size;
          const type = schema.nodes[defaultNode];
          if (!shouldInsertNodeAtEnd) {
            return;
          }
          return tr2.insert(endPosition, type.create());
        },
        state: {
          init: (_, state) => {
            const lastNode = state.tr.doc.lastChild;
            return !nodeEqualsType({ node: lastNode, types: disabledNodes });
          },
          apply: (tr2, value) => {
            if (!tr2.docChanged) {
              return value;
            }
            if (tr2.getMeta("__uniqueIDTransaction")) {
              return value;
            }
            const lastNode = tr2.doc.lastChild;
            return !nodeEqualsType({ node: lastNode, types: disabledNodes });
          }
        }
      })
    ];
  }
});
var UndoRedo = Extension.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch: dispatch2 }) => {
        return undo(state, dispatch2);
      },
      redo: () => ({ state, dispatch: dispatch2 }) => {
        return redo(state, dispatch2);
      }
    };
  },
  addProseMirrorPlugins() {
    return [history(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
});
var StarterKit = Extension.create({
  name: "starterKit",
  addExtensions() {
    var _a2, _b, _c, _d;
    const extensions = [];
    if (this.options.bold !== false) {
      extensions.push(Bold.configure(this.options.bold));
    }
    if (this.options.blockquote !== false) {
      extensions.push(Blockquote.configure(this.options.blockquote));
    }
    if (this.options.bulletList !== false) {
      extensions.push(BulletList.configure(this.options.bulletList));
    }
    if (this.options.code !== false) {
      extensions.push(Code.configure(this.options.code));
    }
    if (this.options.codeBlock !== false) {
      extensions.push(CodeBlock.configure(this.options.codeBlock));
    }
    if (this.options.document !== false) {
      extensions.push(Document.configure(this.options.document));
    }
    if (this.options.dropcursor !== false) {
      extensions.push(Dropcursor.configure(this.options.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions.push(Gapcursor.configure(this.options.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions.push(HardBreak.configure(this.options.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions.push(Heading.configure(this.options.heading));
    }
    if (this.options.undoRedo !== false) {
      extensions.push(UndoRedo.configure(this.options.undoRedo));
    }
    if (this.options.horizontalRule !== false) {
      extensions.push(HorizontalRule.configure(this.options.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions.push(Italic.configure(this.options.italic));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem.configure(this.options.listItem));
    }
    if (this.options.listKeymap !== false) {
      extensions.push(ListKeymap.configure((_a2 = this.options) == null ? void 0 : _a2.listKeymap));
    }
    if (this.options.link !== false) {
      extensions.push(Link.configure((_b = this.options) == null ? void 0 : _b.link));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList.configure(this.options.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions.push(Paragraph.configure(this.options.paragraph));
    }
    if (this.options.strike !== false) {
      extensions.push(Strike.configure(this.options.strike));
    }
    if (this.options.text !== false) {
      extensions.push(Text.configure(this.options.text));
    }
    if (this.options.underline !== false) {
      extensions.push(Underline.configure((_c = this.options) == null ? void 0 : _c.underline));
    }
    if (this.options.trailingNode !== false) {
      extensions.push(TrailingNode.configure((_d = this.options) == null ? void 0 : _d.trailingNode));
    }
    return extensions;
  }
});
var index_default = StarterKit;
const DefaultFontFaces = {
  tldraw_draw: {
    normal: {
      normal: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw", format: "woff2" },
        weight: "normal"
      },
      bold: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_bold", format: "woff2" },
        weight: "bold"
      }
    },
    italic: {
      normal: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_sans: {
    normal: {
      normal: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_serif: {
    normal: {
      normal: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_mono: {
    normal: {
      normal: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  }
};
const allDefaultFontFaces = objectMapValues(DefaultFontFaces).flatMap(
  (font) => objectMapValues(font).flatMap((fontFace) => Object.values(fontFace))
);
const TextDirection = Extension$1.create({
  name: "textDirection",
  addGlobalAttributes() {
    return [
      {
        types: ["heading", "paragraph"],
        attributes: {
          dir: {
            default: "auto",
            parseHTML: (element) => {
              const dirAttribute = element.getAttribute("dir");
              if (dirAttribute && ["ltr", "rtl", "auto"].includes(dirAttribute)) {
                return dirAttribute;
              } else {
                return "auto";
              }
            },
            renderHTML: (attributes) => {
              return { dir: attributes.dir };
            }
          }
        }
      }
    ];
  }
});
const KeyboardShiftEnterTweakExtension = Extension$1.create({
  name: "keyboardShiftEnterHandler",
  addKeyboardShortcuts() {
    return {
      // We don't support soft breaks, so we just use the default enter command.
      "Shift-Enter": ({ editor }) => editor.commands.enter()
    };
  }
});
index_default$2.config.excludes = void 0;
index_default$1.config.priority = 1100;
const tipTapDefaultExtensions = [
  index_default.configure({
    blockquote: false,
    codeBlock: false,
    horizontalRule: false,
    link: {
      openOnClick: false,
      autolink: true
    }
  }),
  index_default$1,
  KeyboardShiftEnterTweakExtension,
  TextDirection
];
const htmlCache = new WeakCache();
function renderHtmlFromRichText(editor, richText) {
  return htmlCache.get(richText, () => {
    const tipTapExtensions = editor.getTextOptions().tipTapConfig?.extensions ?? tipTapDefaultExtensions;
    const html2 = generateHTML(richText, tipTapExtensions);
    return html2.replaceAll('<p dir="auto"></p>', "<p><br /></p>") ?? "";
  });
}
function renderHtmlFromRichTextForMeasurement(editor, richText) {
  const html2 = renderHtmlFromRichText(editor, richText);
  return `<div class="tl-rich-text">${html2}</div>`;
}
const plainTextFromRichTextCache = new WeakCache();
function isEmptyRichText(richText) {
  if (richText.content.length === 1) {
    if (!richText.content[0].content) return true;
  }
  return false;
}
function renderPlaintextFromRichText(editor, richText) {
  if (isEmptyRichText(richText)) return "";
  return plainTextFromRichTextCache.get(richText, () => {
    const tipTapExtensions = editor.getTextOptions().tipTapConfig?.extensions ?? tipTapDefaultExtensions;
    return generateText(richText, tipTapExtensions, {
      blockSeparator: "\n"
    });
  });
}
function renderRichTextFromHTML(editor, html2) {
  const tipTapExtensions = editor.getTextOptions().tipTapConfig?.extensions ?? tipTapDefaultExtensions;
  return generateJSON(html2, tipTapExtensions);
}
function defaultAddFontsFromNode(node, state, addFont) {
  for (const mark of node.marks) {
    if (mark.type.name === "bold" && state.weight !== "bold") {
      state = { ...state, weight: "bold" };
    }
    if (mark.type.name === "italic" && state.style !== "italic") {
      state = { ...state, style: "italic" };
    }
    if (mark.type.name === "code" && state.family !== "tldraw_mono") {
      state = { ...state, family: "tldraw_mono" };
    }
  }
  const fontsForFamily = getOwnProperty(DefaultFontFaces, state.family);
  if (!fontsForFamily) return state;
  const fontsForStyle = getOwnProperty(fontsForFamily, state.style);
  if (!fontsForStyle) return state;
  const fontsForWeight = getOwnProperty(fontsForStyle, state.weight);
  if (!fontsForWeight) return state;
  addFont(fontsForWeight);
  return state;
}
const INDENT = "  ";
class TextHelpers {
  static fixNewLines = /\r?\n|\r/g;
  static normalizeText(text) {
    return text.replace(TextHelpers.fixNewLines, "\n");
  }
  static normalizeTextForDom(text) {
    return text.replace(TextHelpers.fixNewLines, "\n").split("\n").map((x) => x || " ").join("\n");
  }
}
const rtlRegex = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
function isRightToLeftLanguage(text) {
  return rtlRegex.test(text);
}
function replaceTabsWithSpaces(text) {
  return text.replace(/\t/g, INDENT);
}
function stripCommonMinimumIndentation(text) {
  const lines = text.split("\n");
  while (lines[0] && lines[0].trim().length === 0) {
    lines.shift();
  }
  let minIndentation = Infinity;
  for (const line of lines) {
    if (line.trim().length > 0) {
      const indentation = line.length - line.trimStart().length;
      minIndentation = Math.min(minIndentation, indentation);
    }
  }
  return lines.map((line) => line.slice(minIndentation)).join("\n");
}
const COMMON_ENTITY_MAP = {
  "&amp;": "&",
  "&quot;": '"',
  "&apos;": "'",
  "&#27;": "'",
  "&#34;": '"',
  "&#38;": "&",
  "&#39;": "'",
  "&#8211;": "",
  "&#8212;": "",
  "&#8216;": "",
  "&#8217;": "",
  "&#8220;": "",
  "&#8221;": "",
  "&#8230;": ""
};
const entityRegex = new RegExp(Object.keys(COMMON_ENTITY_MAP).join("|"), "g");
function convertCommonTitleHTMLEntities(text) {
  return text.replace(entityRegex, (m) => COMMON_ENTITY_MAP[m]);
}
function stripTrailingWhitespace(text) {
  return text.replace(/[ \t]+$/gm, "").replace(/\n+$/, "");
}
function cleanupText(text) {
  return stripTrailingWhitespace(stripCommonMinimumIndentation(replaceTabsWithSpaces(text)));
}
const DEFAULT_MAX_IMAGE_DIMENSION = 5e3;
const DEFAULT_MAX_ASSET_SIZE = 10 * 1024 * 1024;
function registerDefaultExternalContentHandlers(editor, options) {
  editor.registerExternalAssetHandler("file", async (externalAsset) => {
    return defaultHandleExternalFileAsset(editor, externalAsset, options);
  });
  editor.registerExternalAssetHandler("url", async (externalAsset) => {
    return defaultHandleExternalUrlAsset(editor, externalAsset, options);
  });
  editor.registerExternalContentHandler("svg-text", async (externalContent) => {
    return defaultHandleExternalSvgTextContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("embed", (externalContent) => {
    return defaultHandleExternalEmbedContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("files", async (externalContent) => {
    return defaultHandleExternalFileContent(editor, externalContent, options);
  });
  editor.registerExternalContentHandler("file-replace", async (externalContent) => {
    return defaultHandleExternalFileReplaceContent(editor, externalContent, options);
  });
  editor.registerExternalContentHandler("text", async (externalContent) => {
    return defaultHandleExternalTextContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("url", async (externalContent) => {
    return defaultHandleExternalUrlContent(editor, externalContent, options);
  });
  editor.registerExternalContentHandler("tldraw", async (externalContent) => {
    return defaultHandleExternalTldrawContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("excalidraw", async (externalContent) => {
    return defaultHandleExternalExcalidrawContent(editor, externalContent);
  });
}
async function defaultHandleExternalFileAsset(editor, { file, assetId }, options) {
  const isSuccess = notifyIfFileNotAllowed(file, options);
  if (!isSuccess) assert(false, "File checks failed");
  const assetInfo = await getAssetInfo(file, options, assetId);
  const result = await editor.uploadAsset(assetInfo, file);
  assetInfo.props.src = result.src;
  if (result.meta) assetInfo.meta = { ...assetInfo.meta, ...result.meta };
  return AssetRecordType.create(assetInfo);
}
async function defaultHandleExternalFileReplaceContent(editor, { file, shapeId, isImage }, options) {
  const isSuccess = notifyIfFileNotAllowed(file, options);
  if (!isSuccess) assert(false, "File checks failed");
  const shape = editor.getShape(shapeId);
  if (!shape) assert(false, "Shape not found");
  const hash2 = getHashForBuffer(await file.arrayBuffer());
  const assetId = AssetRecordType.createId(hash2);
  editor.createTemporaryAssetPreview(assetId, file);
  const assetInfoPartial = await getMediaAssetInfoPartial(
    file,
    assetId,
    isImage,
    !isImage
    /* isVideo */
  );
  editor.createAssets([assetInfoPartial]);
  if (shape.type === "image") {
    const imageShape = shape;
    const currentCrop = imageShape.props.crop;
    let newWidth = assetInfoPartial.props.w;
    let newHeight = assetInfoPartial.props.h;
    let newX = imageShape.x;
    let newY = imageShape.y;
    let finalCrop = currentCrop;
    if (currentCrop) {
      const result = getCroppedImageDataForReplacedImage(
        imageShape,
        assetInfoPartial.props.w,
        assetInfoPartial.props.h
      );
      finalCrop = result.crop;
      newWidth = result.w;
      newHeight = result.h;
      newX = result.x;
      newY = result.y;
    }
    editor.updateShapes([
      {
        id: imageShape.id,
        type: imageShape.type,
        props: {
          assetId,
          crop: finalCrop,
          w: newWidth,
          h: newHeight
        },
        x: newX,
        y: newY
      }
    ]);
  } else if (shape.type === "video") {
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: {
          assetId,
          w: assetInfoPartial.props.w,
          h: assetInfoPartial.props.h
        }
      }
    ]);
  }
  const asset = await editor.getAssetForExternalContent({
    type: "file",
    file,
    assetId
  });
  editor.updateAssets([{ ...asset, id: assetId }]);
  return asset;
}
async function defaultHandleExternalUrlAsset(editor, { url }, { toasts, msg: msg2 }) {
  let meta;
  try {
    const resp = await fetch$1(url, {
      method: "GET",
      mode: "no-cors"
    });
    const html2 = await resp.text();
    const doc2 = new DOMParser().parseFromString(html2, "text/html");
    meta = {
      image: doc2.head.querySelector('meta[property="og:image"]')?.getAttribute("content") ?? "",
      favicon: doc2.head.querySelector('link[rel="apple-touch-icon"]')?.getAttribute("href") ?? doc2.head.querySelector('link[rel="icon"]')?.getAttribute("href") ?? "",
      title: doc2.head.querySelector('meta[property="og:title"]')?.getAttribute("content") ?? url,
      description: doc2.head.querySelector('meta[property="og:description"]')?.getAttribute("content") ?? ""
    };
    if (!meta.image.startsWith("http")) {
      meta.image = new URL(meta.image, url).href;
    }
    if (!meta.favicon.startsWith("http")) {
      meta.favicon = new URL(meta.favicon, url).href;
    }
  } catch (error) {
    console.error(error);
    toasts.addToast({
      title: msg2("assets.url.failed"),
      severity: "error"
    });
    meta = { image: "", favicon: "", title: "", description: "" };
  }
  return {
    id: AssetRecordType.createId(getHashForString(url)),
    typeName: "asset",
    type: "bookmark",
    props: {
      src: url,
      description: meta.description,
      image: meta.image,
      favicon: meta.favicon,
      title: meta.title
    },
    meta: {}
  };
}
async function defaultHandleExternalSvgTextContent(editor, { point, text }) {
  const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageBounds().center);
  const svg = new DOMParser().parseFromString(text, "image/svg+xml").querySelector("svg");
  if (!svg) {
    throw new Error("No <svg/> element present");
  }
  let width = parseFloat(svg.getAttribute("width") || "0");
  let height = parseFloat(svg.getAttribute("height") || "0");
  if (!(width && height)) {
    document.body.appendChild(svg);
    const box = svg.getBoundingClientRect();
    document.body.removeChild(svg);
    width = box.width;
    height = box.height;
  }
  const asset = await editor.getAssetForExternalContent({
    type: "file",
    file: new File([text], "asset.svg", { type: "image/svg+xml" })
  });
  if (!asset) throw Error("Could not create an asset");
  createShapesForAssets(editor, [asset], position);
}
function defaultHandleExternalEmbedContent(editor, { point, url, embed }) {
  const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageBounds().center);
  const { width, height } = embed;
  const id = createShapeId();
  const newPoint = maybeSnapToGrid(
    new Vec(position.x - (width || 450) / 2, position.y - (height || 450) / 2),
    editor
  );
  const shapePartial = {
    id,
    type: "embed",
    x: newPoint.x,
    y: newPoint.y,
    props: {
      w: width,
      h: height,
      url
    }
  };
  if (editor.canCreateShape(shapePartial)) {
    editor.createShape(shapePartial).select(id);
  }
}
async function defaultHandleExternalFileContent(editor, { point, files }, options) {
  const { acceptedImageMimeTypes = DEFAULT_SUPPORTED_IMAGE_TYPES, toasts, msg: msg2 } = options;
  if (files.length > editor.options.maxFilesAtOnce) {
    toasts.addToast({ title: msg2("assets.files.amount-too-many"), severity: "error" });
    return;
  }
  const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageBounds().center);
  const pagePoint = new Vec(position.x, position.y);
  const assetPartials = [];
  const assetsToUpdate = [];
  for (const file of files) {
    const isSuccess = notifyIfFileNotAllowed(file, options);
    if (!isSuccess) continue;
    const assetInfo = await getAssetInfo(file, options);
    if (acceptedImageMimeTypes.includes(file.type)) {
      editor.createTemporaryAssetPreview(assetInfo.id, file);
    }
    assetPartials.push(assetInfo);
    assetsToUpdate.push({ asset: assetInfo, file });
  }
  Promise.allSettled(
    assetsToUpdate.map(async (assetAndFile) => {
      try {
        const newAsset = await editor.getAssetForExternalContent({
          type: "file",
          file: assetAndFile.file
        });
        if (!newAsset) {
          throw Error("Could not create an asset");
        }
        editor.updateAssets([{ ...newAsset, id: assetAndFile.asset.id }]);
      } catch (error) {
        toasts.addToast({
          title: msg2("assets.files.upload-failed"),
          severity: "error"
        });
        console.error(error);
        editor.deleteAssets([assetAndFile.asset.id]);
        return;
      }
    })
  );
  createShapesForAssets(editor, assetPartials, pagePoint);
}
async function defaultHandleExternalTextContent(editor, { point, text, html: html2 }) {
  const p = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageBounds().center);
  const defaultProps = editor.getShapeUtil("text").getDefaultProps();
  const cleanedUpPlaintext = cleanupText(text);
  const richTextToPaste = html2 ? renderRichTextFromHTML(editor, html2) : toRichText(cleanedUpPlaintext);
  let w;
  let h2;
  let autoSize;
  let align = "middle";
  const htmlToMeasure = html2 ?? cleanedUpPlaintext.replace(/\n/g, "<br>");
  const isMultiLine = html2 ? richTextToPaste.content.length > 1 : cleanedUpPlaintext.split("\n").length > 1;
  const isRtl = isRightToLeftLanguage(cleanedUpPlaintext);
  if (isMultiLine) {
    align = isMultiLine ? isRtl ? "end" : "start" : "middle";
  }
  const rawSize = editor.textMeasure.measureHtml(htmlToMeasure, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[defaultProps.font],
    fontSize: FONT_SIZES[defaultProps.size],
    maxWidth: null
  });
  const minWidth = Math.min(
    isMultiLine ? editor.getViewportPageBounds().width * 0.9 : 920,
    Math.max(200, editor.getViewportPageBounds().width * 0.9)
  );
  if (rawSize.w > minWidth) {
    const shrunkSize = editor.textMeasure.measureHtml(htmlToMeasure, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[defaultProps.font],
      fontSize: FONT_SIZES[defaultProps.size],
      maxWidth: minWidth
    });
    w = shrunkSize.w;
    h2 = shrunkSize.h;
    autoSize = false;
    align = isRtl ? "end" : "start";
  } else {
    w = Math.max(rawSize.w, 10);
    h2 = Math.max(rawSize.h, 10);
    autoSize = true;
  }
  if (p.y - h2 / 2 < editor.getViewportPageBounds().minY + 40) {
    p.y = editor.getViewportPageBounds().minY + 40 + h2 / 2;
  }
  const newPoint = maybeSnapToGrid(new Vec(p.x - w / 2, p.y - h2 / 2), editor);
  const shapeId = createShapeId();
  editor.createShapes([
    {
      id: shapeId,
      type: "text",
      x: newPoint.x,
      y: newPoint.y,
      props: {
        richText: richTextToPaste,
        // if the text has more than one line, align it to the left
        textAlign: align,
        autoSize,
        w
      }
    }
  ]);
}
async function defaultHandleExternalUrlContent(editor, { point, url }, { toasts, msg: msg2 }) {
  const embedUtil = editor.getShapeUtil("embed");
  const embedInfo = embedUtil?.getEmbedDefinition(url);
  if (embedInfo && embedInfo.definition.embedOnPaste !== false) {
    return editor.putExternalContent({
      type: "embed",
      url: embedInfo.url,
      point,
      embed: embedInfo.definition
    });
  }
  const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageBounds().center);
  const result = await createBookmarkFromUrl(editor, { url, center: position });
  if (!result.ok) {
    toasts.addToast({
      title: msg2("assets.url.failed"),
      severity: "error"
    });
    return;
  }
}
async function defaultHandleExternalTldrawContent(editor, { point, content }) {
  editor.run(() => {
    const selectionBoundsBefore = editor.getSelectionPageBounds();
    editor.markHistoryStoppingPoint("paste");
    for (const shape of content.shapes) {
      if (content.rootShapeIds.includes(shape.id)) {
        shape.isLocked = false;
      }
    }
    editor.putContentOntoCurrentPage(content, {
      point,
      select: true
    });
    const selectedBoundsAfter = editor.getSelectionPageBounds();
    if (selectionBoundsBefore && selectedBoundsAfter && selectionBoundsBefore?.collides(selectedBoundsAfter)) {
      editor.updateInstanceState({ isChangingStyle: true });
      editor.timers.setTimeout(() => {
        editor.updateInstanceState({ isChangingStyle: false });
      }, 150);
    }
  });
}
async function defaultHandleExternalExcalidrawContent(editor, { point, content }) {
  editor.run(() => {
    putExcalidrawContent(editor, content, point);
  });
}
async function getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType, maxImageDimension) {
  let fileType = file.type;
  if (file.type === "video/quicktime") {
    fileType = "video/mp4";
  }
  const size2 = isImageType ? await MediaHelpers.getImageSize(file) : await MediaHelpers.getVideoSize(file);
  const isAnimated = await MediaHelpers.isAnimated(file) || isVideoType;
  const assetInfo = {
    id: assetId,
    type: isImageType ? "image" : "video",
    typeName: "asset",
    props: {
      name: file.name,
      src: "",
      w: size2.w,
      h: size2.h,
      fileSize: file.size,
      mimeType: fileType,
      isAnimated
    },
    meta: {}
  };
  if (maxImageDimension && isFinite(maxImageDimension)) {
    const size22 = { w: assetInfo.props.w, h: assetInfo.props.h };
    const resizedSize = containBoxSize(size22, { w: maxImageDimension, h: maxImageDimension });
    if (size22 !== resizedSize && MediaHelpers.isStaticImageType(file.type)) {
      assetInfo.props.w = resizedSize.w;
      assetInfo.props.h = resizedSize.h;
    }
  }
  return assetInfo;
}
async function createShapesForAssets(editor, assets, position) {
  if (!assets.length) return [];
  const currentPoint = Vec.From(position);
  const partials = [];
  for (let i = 0; i < assets.length; i++) {
    const asset = assets[i];
    switch (asset.type) {
      case "image": {
        partials.push({
          id: createShapeId(),
          type: "image",
          x: currentPoint.x,
          y: currentPoint.y,
          opacity: 1,
          props: {
            assetId: asset.id,
            w: asset.props.w,
            h: asset.props.h
          }
        });
        currentPoint.x += asset.props.w;
        break;
      }
      case "video": {
        partials.push({
          id: createShapeId(),
          type: "video",
          x: currentPoint.x,
          y: currentPoint.y,
          opacity: 1,
          props: {
            assetId: asset.id,
            w: asset.props.w,
            h: asset.props.h
          }
        });
        currentPoint.x += asset.props.w;
      }
    }
  }
  editor.run(() => {
    const assetsToCreate = assets.filter((asset) => !editor.getAsset(asset.id));
    editor.store.atomic(() => {
      if (editor.canCreateShapes(partials)) {
        if (assetsToCreate.length) {
          editor.createAssets(assetsToCreate);
        }
        editor.createShapes(partials).select(...partials.map((p) => p.id));
        centerSelectionAroundPoint(editor, position);
      }
    });
  });
  return partials.map((p) => p.id);
}
function centerSelectionAroundPoint(editor, position) {
  const viewportPageBounds = editor.getViewportPageBounds();
  let selectionPageBounds = editor.getSelectionPageBounds();
  if (selectionPageBounds) {
    const offset2 = selectionPageBounds.center.sub(position);
    editor.updateShapes(
      editor.getSelectedShapes().map((shape) => {
        const localRotation = editor.getShapeParentTransform(shape).decompose().rotation;
        const localDelta = Vec.Rot(offset2, -localRotation);
        return {
          id: shape.id,
          type: shape.type,
          x: shape.x - localDelta.x,
          y: shape.y - localDelta.y
        };
      })
    );
  }
  selectionPageBounds = editor.getSelectionPageBounds();
  if (selectionPageBounds && editor.getInstanceState().isGridMode) {
    const gridSize = editor.getDocumentSettings().gridSize;
    const topLeft = new Vec(selectionPageBounds.minX, selectionPageBounds.minY);
    const gridSnappedPoint = topLeft.clone().snapToGrid(gridSize);
    const delta = Vec.Sub(topLeft, gridSnappedPoint);
    editor.updateShapes(
      editor.getSelectedShapes().map((shape) => {
        const newPoint = { x: shape.x - delta.x, y: shape.y - delta.y };
        return {
          id: shape.id,
          type: shape.type,
          x: newPoint.x,
          y: newPoint.y
        };
      })
    );
  }
  selectionPageBounds = editor.getSelectionPageBounds();
  if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
    editor.zoomToSelection({ animation: { duration: editor.options.animationMediumMs } });
  }
}
function notifyIfFileNotAllowed(file, options) {
  const {
    acceptedImageMimeTypes = DEFAULT_SUPPORTED_IMAGE_TYPES,
    acceptedVideoMimeTypes = DEFAULT_SUPPORT_VIDEO_TYPES,
    maxAssetSize = DEFAULT_MAX_ASSET_SIZE,
    toasts,
    msg: msg2
  } = options;
  const isImageType = acceptedImageMimeTypes.includes(file.type);
  const isVideoType = acceptedVideoMimeTypes.includes(file.type);
  if (!isImageType && !isVideoType) {
    toasts.addToast({
      title: msg2("assets.files.type-not-allowed"),
      severity: "error"
    });
    return false;
  }
  if (file.size > maxAssetSize) {
    const formatBytes = (bytes) => {
      if (bytes === 0) return "0 bytes";
      const units = ["bytes", "KB", "MB", "GB", "TB", "PB"];
      const base2 = 1024;
      const unitIndex = Math.floor(Math.log(bytes) / Math.log(base2));
      const value = bytes / Math.pow(base2, unitIndex);
      const formatted = value % 1 === 0 ? value.toString() : value.toFixed(1);
      return `${formatted} ${units[unitIndex]}`;
    };
    toasts.addToast({
      title: msg2("assets.files.size-too-big"),
      description: msg2("assets.files.maximum-size").replace("{size}", formatBytes(maxAssetSize)),
      severity: "error"
    });
    return false;
  }
  if (!file.type) {
    toasts.addToast({
      title: msg2("assets.files.upload-failed"),
      severity: "error"
    });
    console.error("No mime type");
    return false;
  }
  return true;
}
async function getAssetInfo(file, options, assetId) {
  const {
    acceptedImageMimeTypes = DEFAULT_SUPPORTED_IMAGE_TYPES,
    acceptedVideoMimeTypes = DEFAULT_SUPPORT_VIDEO_TYPES,
    maxImageDimension = DEFAULT_MAX_IMAGE_DIMENSION
  } = options;
  const isImageType = acceptedImageMimeTypes.includes(file.type);
  const isVideoType = acceptedVideoMimeTypes.includes(file.type);
  const hash2 = getHashForBuffer(await file.arrayBuffer());
  assetId ??= AssetRecordType.createId(hash2);
  const assetInfo = await getMediaAssetInfoPartial(
    file,
    assetId,
    isImageType,
    isVideoType,
    maxImageDimension
  );
  return assetInfo;
}
let Idle$b = class Idle2 extends StateNode {
  static id = "idle";
  isPrecise = false;
  isPreciseTimerId = null;
  preciseTargetId = null;
  onPointerMove() {
    this.update();
  }
  onPointerDown(info) {
    this.parent.transition("pointing", { ...info, isPrecise: this.isPrecise });
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
    this.update();
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
  onExit() {
    clearArrowTargetState(this.editor);
    if (this.isPreciseTimerId !== null) {
      clearTimeout(this.isPreciseTimerId);
    }
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp(info) {
    this.update();
    if (info.key === "Enter") {
      if (this.editor.getIsReadonly()) return null;
      const onlySelectedShape = this.editor.getOnlySelectedShape();
      if (onlySelectedShape && this.editor.getShapeUtil(onlySelectedShape).canEdit(onlySelectedShape)) {
        this.editor.setCurrentTool("select");
        this.editor.setEditingShape(onlySelectedShape.id);
        this.editor.root.getCurrent()?.transition("editing_shape", {
          ...info,
          target: "shape",
          shape: onlySelectedShape
        });
      }
    }
  }
  update() {
    const arrowUtil = this.editor.getShapeUtil("arrow");
    const targetState = updateArrowTargetState({
      editor: this.editor,
      pointInPageSpace: this.editor.inputs.currentPagePoint,
      arrow: void 0,
      isPrecise: this.isPrecise,
      currentBinding: void 0,
      oppositeBinding: void 0
    });
    if (targetState && targetState.target.id !== this.preciseTargetId) {
      if (this.isPreciseTimerId !== null) {
        clearTimeout(this.isPreciseTimerId);
      }
      this.preciseTargetId = targetState.target.id;
      this.isPreciseTimerId = this.editor.timers.setTimeout(() => {
        this.isPrecise = true;
        this.update();
      }, arrowUtil.options.hoverPreciseTimeout);
    } else if (!targetState && this.preciseTargetId) {
      this.isPrecise = false;
      this.preciseTargetId = null;
      if (this.isPreciseTimerId !== null) {
        clearTimeout(this.isPreciseTimerId);
      }
    }
  }
};
let Pointing$7 = class Pointing2 extends StateNode {
  static id = "pointing";
  shape;
  isPrecise = false;
  isPreciseTimerId = null;
  markId = "";
  onEnter(info) {
    this.markId = "";
    this.isPrecise = !!info.isPrecise;
    const targetState = updateArrowTargetState({
      editor: this.editor,
      pointInPageSpace: this.editor.inputs.currentPagePoint,
      arrow: void 0,
      isPrecise: this.isPrecise,
      currentBinding: void 0,
      oppositeBinding: void 0
    });
    if (!targetState) {
      this.createArrowShape();
      if (!this.shape) {
        this.cancel();
        return;
      }
    }
    this.startPreciseTimeout();
  }
  onExit() {
    this.shape = void 0;
    clearArrowTargetState(this.editor);
    this.clearPreciseTimeout();
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      if (!this.shape) {
        this.createArrowShape();
      }
      if (!this.shape) {
        this.cancel();
        return;
      }
      this.updateArrowShapeEndHandle();
      this.editor.setCurrentTool("select.dragging_handle", {
        shape: this.shape,
        handle: { id: "end", type: "vertex", index: "a3", x: 0, y: 0 },
        isCreating: true,
        creatingMarkId: this.markId || void 0,
        onInteractionEnd: "arrow"
      });
    }
  }
  onPointerUp() {
    this.cancel();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    if (this.shape) {
      this.editor.bailToMark(this.markId);
    }
    this.parent.transition("idle");
  }
  createArrowShape() {
    const { originPagePoint } = this.editor.inputs;
    const id = createShapeId();
    this.markId = this.editor.markHistoryStoppingPoint(`creating_arrow:${id}`);
    const newPoint = maybeSnapToGrid(originPagePoint, this.editor);
    this.editor.createShape({
      id,
      type: "arrow",
      x: newPoint.x,
      y: newPoint.y,
      props: {
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const shape = this.editor.getShape(id);
    if (!shape) return;
    const handles = this.editor.getShapeHandles(shape);
    if (!handles) throw Error(`expected handles for arrow`);
    const util = this.editor.getShapeUtil("arrow");
    const initial = this.shape;
    const startHandle = handles.find((h2) => h2.id === "start");
    const change = util.onHandleDrag?.(shape, {
      handle: { ...startHandle, x: 0, y: 0 },
      isPrecise: true,
      isCreatingShape: true,
      initial
    });
    if (change) {
      this.editor.updateShapes([change]);
    }
    this.shape = this.editor.getShape(id);
    this.editor.select(id);
  }
  updateArrowShapeEndHandle() {
    const shape = this.shape;
    if (!shape) throw Error(`expected shape`);
    const handles = this.editor.getShapeHandles(shape);
    if (!handles) throw Error(`expected handles for arrow`);
    {
      const util = this.editor.getShapeUtil("arrow");
      const initial = this.shape;
      const startHandle = handles.find((h2) => h2.id === "start");
      const change = util.onHandleDrag?.(shape, {
        handle: { ...startHandle, x: 0, y: 0 },
        isPrecise: this.isPrecise,
        isCreatingShape: true,
        initial
      });
      if (change) {
        this.editor.updateShapes([change]);
      }
    }
    {
      const util = this.editor.getShapeUtil("arrow");
      const initial = this.shape;
      const point = this.editor.getPointInShapeSpace(shape, this.editor.inputs.currentPagePoint);
      const endHandle = handles.find((h2) => h2.id === "end");
      const change = util.onHandleDrag?.(this.editor.getShape(shape), {
        handle: { ...endHandle, x: point.x, y: point.y },
        isPrecise: this.isPrecise,
        isCreatingShape: true,
        initial
      });
      if (change) {
        this.editor.updateShapes([change]);
      }
    }
    this.shape = this.editor.getShape(shape.id);
  }
  startPreciseTimeout() {
    const arrowUtil = this.editor.getShapeUtil("arrow");
    this.isPreciseTimerId = this.editor.timers.setTimeout(() => {
      if (!this.getIsActive()) return;
      this.isPrecise = true;
    }, arrowUtil.options.pointingPreciseTimeout);
  }
  clearPreciseTimeout() {
    if (this.isPreciseTimerId !== null) {
      clearTimeout(this.isPreciseTimerId);
    }
  }
};
class ArrowShapeTool extends StateNode {
  static id = "arrow";
  static initial = "idle";
  static children() {
    return [Idle$b, Pointing$7];
  }
  shapeType = "arrow";
}
class Drawing extends StateNode {
  static id = "drawing";
  info = {};
  initialShape;
  shapeType = this.parent.id === "highlight" ? "highlight" : "draw";
  util = this.editor.getShapeUtil(this.shapeType);
  isPen = false;
  isPenOrStylus = false;
  segmentMode = "free";
  didJustShiftClickToExtendPreviousShapeLine = false;
  pagePointWhereCurrentSegmentChanged = {};
  pagePointWhereNextSegmentChanged = null;
  lastRecordedPoint = {};
  mergeNextPoint = false;
  currentLineLength = 0;
  markId = null;
  onEnter(info) {
    this.markId = null;
    this.info = info;
    this.lastRecordedPoint = this.editor.inputs.currentPagePoint.clone();
    this.startShape();
  }
  onPointerMove() {
    const { inputs } = this.editor;
    if (this.isPen && !inputs.isPen) {
      if (this.markId) {
        this.editor.bailToMark(this.markId);
        this.startShape();
        return;
      }
    }
    if (this.isPenOrStylus) {
      if (Vec.Dist(inputs.currentPagePoint, this.lastRecordedPoint) >= 1 / this.editor.getZoomLevel()) {
        this.lastRecordedPoint = inputs.currentPagePoint.clone();
        this.mergeNextPoint = false;
      } else {
        this.mergeNextPoint = true;
      }
    } else {
      this.mergeNextPoint = false;
    }
    this.updateDrawingShape();
  }
  onKeyDown(info) {
    if (info.key === "Shift") {
      switch (this.segmentMode) {
        case "free": {
          this.segmentMode = "starting_straight";
          this.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_free": {
          this.segmentMode = "starting_straight";
        }
      }
    }
    this.updateDrawingShape();
  }
  onKeyUp(info) {
    if (info.key === "Shift") {
      this.editor.snaps.clearIndicators();
      switch (this.segmentMode) {
        case "straight": {
          this.segmentMode = "starting_free";
          this.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_straight": {
          this.pagePointWhereNextSegmentChanged = null;
          this.segmentMode = "free";
          break;
        }
      }
    }
    this.updateDrawingShape();
  }
  onExit() {
    this.editor.snaps.clearIndicators();
    this.pagePointWhereCurrentSegmentChanged = this.editor.inputs.currentPagePoint.clone();
  }
  canClose() {
    return this.shapeType !== "highlight";
  }
  getIsClosed(segments, size2, scale) {
    if (!this.canClose()) return false;
    const strokeWidth = STROKE_SIZES[size2];
    const firstPoint = segments[0].points[0];
    const lastSegment = segments[segments.length - 1];
    const lastPoint = lastSegment.points[lastSegment.points.length - 1];
    return firstPoint !== lastPoint && this.currentLineLength > strokeWidth * 4 * scale && Vec.DistMin(firstPoint, lastPoint, strokeWidth * 2 * scale);
  }
  startShape() {
    const {
      inputs: { originPagePoint, isPen }
    } = this.editor;
    this.markId = this.editor.markHistoryStoppingPoint("draw start");
    const { z = 0.5 } = this.info.point;
    this.isPen = isPen;
    this.isPenOrStylus = isPen || z > 0 && z < 0.5 || z > 0.5 && z < 1;
    const pressure = this.isPenOrStylus ? z * 1.25 : 0.5;
    this.segmentMode = this.editor.inputs.shiftKey ? "straight" : "free";
    this.didJustShiftClickToExtendPreviousShapeLine = false;
    this.lastRecordedPoint = originPagePoint.clone();
    if (this.initialShape) {
      const shape2 = this.editor.getShape(this.initialShape.id);
      if (shape2 && this.segmentMode === "straight") {
        this.didJustShiftClickToExtendPreviousShapeLine = true;
        const prevSegment = last(shape2.props.segments);
        if (!prevSegment) throw Error("Expected a previous segment!");
        const prevPoint = last(prevSegment.points);
        if (!prevPoint) throw Error("Expected a previous point!");
        const { x, y } = this.editor.getPointInShapeSpace(shape2, originPagePoint).toFixed();
        const newSegment = {
          type: this.segmentMode,
          points: [
            {
              x: prevPoint.x,
              y: prevPoint.y,
              z: +pressure.toFixed(2)
            },
            {
              x,
              y,
              z: +pressure.toFixed(2)
            }
          ]
        };
        const prevPointPageSpace = Mat.applyToPoint(
          this.editor.getShapePageTransform(shape2.id),
          prevPoint
        );
        this.pagePointWhereCurrentSegmentChanged = prevPointPageSpace;
        this.pagePointWhereNextSegmentChanged = null;
        const segments = [...shape2.props.segments, newSegment];
        if (this.currentLineLength < STROKE_SIZES[shape2.props.size] * 4) {
          this.currentLineLength = this.getLineLength(segments);
        }
        const shapePartial = {
          id: shape2.id,
          type: this.shapeType,
          props: {
            segments
          }
        };
        if (this.canClose()) {
          shapePartial.props.isClosed = this.getIsClosed(
            segments,
            shape2.props.size,
            shape2.props.scale
          );
        }
        this.editor.updateShapes([shapePartial]);
        return;
      }
    }
    this.pagePointWhereCurrentSegmentChanged = originPagePoint.clone();
    const id = createShapeId();
    this.editor.createShape({
      id,
      type: this.shapeType,
      x: originPagePoint.x,
      y: originPagePoint.y,
      props: {
        isPen: this.isPenOrStylus,
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,
        segments: [
          {
            type: this.segmentMode,
            points: [
              {
                x: 0,
                y: 0,
                z: +pressure.toFixed(2)
              }
            ]
          }
        ]
      }
    });
    const shape = this.editor.getShape(id);
    if (!shape) {
      this.cancel();
      return;
    }
    this.currentLineLength = 0;
    this.initialShape = this.editor.getShape(id);
  }
  updateDrawingShape() {
    const { initialShape } = this;
    const { inputs } = this.editor;
    if (!initialShape) return;
    const {
      id,
      props: { size: size2, scale }
    } = initialShape;
    const shape = this.editor.getShape(id);
    if (!shape) return;
    const { segments } = shape.props;
    const { x, y, z } = this.editor.getPointInShapeSpace(shape, inputs.currentPagePoint).toFixed();
    const pressure = this.isPenOrStylus ? +(inputs.currentPagePoint.z * 1.25).toFixed(2) : 0.5;
    const newPoint = { x, y, z: pressure };
    switch (this.segmentMode) {
      case "starting_straight": {
        const { pagePointWhereNextSegmentChanged } = this;
        if (pagePointWhereNextSegmentChanged === null) {
          throw Error("We should have a point where the segment changed");
        }
        const hasMovedFarEnough = Vec.Dist2(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > this.editor.options.dragDistanceSquared;
        if (hasMovedFarEnough) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone();
          this.pagePointWhereNextSegmentChanged = null;
          this.segmentMode = "straight";
          const prevSegment = last(segments);
          if (!prevSegment) throw Error("Expected a previous segment!");
          const prevLastPoint = last(prevSegment.points);
          if (!prevLastPoint) throw Error("Expected a previous last point!");
          let newSegment;
          const newLastPoint = this.editor.getPointInShapeSpace(shape, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson();
          if (prevSegment.type === "straight") {
            this.currentLineLength += Vec.Dist(prevLastPoint, newLastPoint);
            newSegment = {
              type: "straight",
              points: [{ ...prevLastPoint }, newLastPoint]
            };
            const transform = this.editor.getShapePageTransform(shape);
            this.pagePointWhereCurrentSegmentChanged = Mat.applyToPoint(transform, prevLastPoint);
          } else {
            newSegment = {
              type: "straight",
              points: [newLastPoint, newPoint]
            };
          }
          const shapePartial = {
            id,
            type: this.shapeType,
            props: {
              segments: [...segments, newSegment]
            }
          };
          if (this.canClose()) {
            shapePartial.props.isClosed = this.getIsClosed(
              segments,
              size2,
              scale
            );
          }
          this.editor.updateShapes([shapePartial]);
        }
        break;
      }
      case "starting_free": {
        const { pagePointWhereNextSegmentChanged } = this;
        if (pagePointWhereNextSegmentChanged === null) {
          throw Error("We should have a point where the segment changed");
        }
        const hasMovedFarEnough = Vec.Dist2(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > this.editor.options.dragDistanceSquared;
        if (hasMovedFarEnough) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone();
          this.pagePointWhereNextSegmentChanged = null;
          this.segmentMode = "free";
          const newSegments = segments.slice();
          const prevStraightSegment = newSegments[newSegments.length - 1];
          const prevPoint = last(prevStraightSegment.points);
          if (!prevPoint) {
            throw Error("No previous point!");
          }
          const newFreeSegment = {
            type: "free",
            points: [
              ...Vec.PointsBetween(prevPoint, newPoint, 6).map((p) => ({
                x: toFixed(p.x),
                y: toFixed(p.y),
                z: toFixed(p.z)
              }))
            ]
          };
          const finalSegments = [...newSegments, newFreeSegment];
          if (this.currentLineLength < STROKE_SIZES[shape.props.size] * 4) {
            this.currentLineLength = this.getLineLength(finalSegments);
          }
          const shapePartial = {
            id,
            type: this.shapeType,
            props: {
              segments: finalSegments
            }
          };
          if (this.canClose()) {
            shapePartial.props.isClosed = this.getIsClosed(
              finalSegments,
              size2,
              scale
            );
          }
          this.editor.updateShapes([shapePartial]);
        }
        break;
      }
      case "straight": {
        const newSegments = segments.slice();
        const newSegment = newSegments[newSegments.length - 1];
        const { pagePointWhereCurrentSegmentChanged } = this;
        const { ctrlKey: ctrlKey2, currentPagePoint } = this.editor.inputs;
        if (!pagePointWhereCurrentSegmentChanged)
          throw Error("We should have a point where the segment changed");
        let pagePoint;
        let shouldSnapToAngle = false;
        if (this.didJustShiftClickToExtendPreviousShapeLine) {
          if (this.editor.inputs.isDragging) {
            shouldSnapToAngle = !ctrlKey2;
            this.didJustShiftClickToExtendPreviousShapeLine = false;
          }
        } else {
          shouldSnapToAngle = !ctrlKey2;
        }
        let newPoint2 = this.editor.getPointInShapeSpace(shape, currentPagePoint).toFixed().toJson();
        let didSnap = false;
        let snapSegment = void 0;
        const shouldSnap = this.editor.user.getIsSnapMode() ? !ctrlKey2 : ctrlKey2;
        if (shouldSnap) {
          if (newSegments.length > 2) {
            let nearestPoint = void 0;
            let minDistance = 8 / this.editor.getZoomLevel();
            for (let i = 0, n = segments.length - 2; i < n; i++) {
              const segment = segments[i];
              if (!segment) break;
              if (segment.type === "free") continue;
              const first2 = segment.points[0];
              const lastPoint = last(segment.points);
              if (!(first2 && lastPoint)) continue;
              const nearestPointOnSegment = Vec.NearestPointOnLineSegment(
                first2,
                lastPoint,
                newPoint2
              );
              if (Vec.DistMin(nearestPointOnSegment, newPoint2, minDistance)) {
                nearestPoint = nearestPointOnSegment.toFixed().toJson();
                minDistance = Vec.Dist(nearestPointOnSegment, newPoint2);
                snapSegment = segment;
                break;
              }
            }
            if (nearestPoint) {
              didSnap = true;
              newPoint2 = nearestPoint;
            }
          }
        }
        if (didSnap && snapSegment) {
          const transform = this.editor.getShapePageTransform(shape);
          const first2 = snapSegment.points[0];
          const lastPoint = last(snapSegment.points);
          if (!lastPoint) throw Error("Expected a last point!");
          const A = Mat.applyToPoint(transform, first2);
          const B = Mat.applyToPoint(transform, lastPoint);
          const snappedPoint = Mat.applyToPoint(transform, newPoint2);
          this.editor.snaps.setIndicators([
            {
              id: uniqueId(),
              type: "points",
              points: [A, snappedPoint, B]
            }
          ]);
        } else {
          this.editor.snaps.clearIndicators();
          if (shouldSnapToAngle) {
            const currentAngle = Vec.Angle(pagePointWhereCurrentSegmentChanged, currentPagePoint);
            const snappedAngle = snapAngle(currentAngle, 24);
            const angleDiff = snappedAngle - currentAngle;
            pagePoint = Vec.RotWith(
              currentPagePoint,
              pagePointWhereCurrentSegmentChanged,
              angleDiff
            );
          } else {
            pagePoint = currentPagePoint;
          }
          newPoint2 = this.editor.getPointInShapeSpace(shape, pagePoint).toFixed().toJson();
        }
        this.currentLineLength += Vec.Dist(newSegment.points[0], newPoint2);
        newSegments[newSegments.length - 1] = {
          ...newSegment,
          type: "straight",
          points: [newSegment.points[0], newPoint2]
        };
        const shapePartial = {
          id,
          type: this.shapeType,
          props: {
            segments: newSegments
          }
        };
        if (this.canClose()) {
          shapePartial.props.isClosed = this.getIsClosed(
            segments,
            size2,
            scale
          );
        }
        this.editor.updateShapes([shapePartial]);
        break;
      }
      case "free": {
        const newSegments = segments.slice();
        const newSegment = newSegments[newSegments.length - 1];
        const newPoints = [...newSegment.points];
        if (newPoints.length && this.mergeNextPoint) {
          const { z: z2 } = newPoints[newPoints.length - 1];
          newPoints[newPoints.length - 1] = {
            x: newPoint.x,
            y: newPoint.y,
            z: z2 ? Math.max(z2, newPoint.z) : newPoint.z
          };
        } else {
          this.currentLineLength += Vec.Dist(newPoints[newPoints.length - 1], newPoint);
          newPoints.push(newPoint);
        }
        newSegments[newSegments.length - 1] = {
          ...newSegment,
          points: newPoints
        };
        if (this.currentLineLength < STROKE_SIZES[shape.props.size] * 4) {
          this.currentLineLength = this.getLineLength(newSegments);
        }
        const shapePartial = {
          id,
          type: this.shapeType,
          props: {
            segments: newSegments
          }
        };
        if (this.canClose()) {
          shapePartial.props.isClosed = this.getIsClosed(
            newSegments,
            size2,
            scale
          );
        }
        this.editor.updateShapes([shapePartial]);
        if (newPoints.length > this.util.options.maxPointsPerShape) {
          this.editor.updateShapes([{ id, type: this.shapeType, props: { isComplete: true } }]);
          const newShapeId = createShapeId();
          const props = this.editor.getShape(id).props;
          if (!this.editor.canCreateShapes([newShapeId])) return this.cancel();
          this.editor.createShape({
            id: newShapeId,
            type: this.shapeType,
            x: toFixed(inputs.currentPagePoint.x),
            y: toFixed(inputs.currentPagePoint.y),
            props: {
              isPen: this.isPenOrStylus,
              scale: props.scale,
              segments: [
                {
                  type: "free",
                  points: [{ x: 0, y: 0, z: this.isPenOrStylus ? +(z * 1.25).toFixed() : 0.5 }]
                }
              ]
            }
          });
          const shape2 = this.editor.getShape(newShapeId);
          if (!shape2) {
            return this.cancel();
          }
          this.initialShape = structuredClone(shape2);
          this.mergeNextPoint = false;
          this.lastRecordedPoint = inputs.currentPagePoint.clone();
          this.currentLineLength = 0;
        }
        break;
      }
    }
  }
  getLineLength(segments) {
    let length = 0;
    for (const segment of segments) {
      for (let i = 0; i < segment.points.length - 1; i++) {
        const A = segment.points[i];
        const B = segment.points[i + 1];
        length += Vec.Dist2(B, A);
      }
    }
    return Math.sqrt(length);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    if (this.editor.inputs.isDragging) {
      return;
    }
    if (this.markId) {
      this.editor.bailToMark(this.markId);
    }
    this.cancel();
  }
  complete() {
    const { initialShape } = this;
    if (!initialShape) return;
    this.editor.updateShapes([
      { id: initialShape.id, type: initialShape.type, props: { isComplete: true } }
    ]);
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
}
let Idle$a = class Idle3 extends StateNode {
  static id = "idle";
  onPointerDown(info) {
    this.parent.transition("drawing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
class DrawShapeTool extends StateNode {
  static id = "draw";
  static initial = "idle";
  static isLockable = false;
  static useCoalescedEvents = true;
  static children() {
    return [Idle$a, Drawing];
  }
  shapeType = "draw";
  onExit() {
    const drawingState = this.children["drawing"];
    drawingState.initialShape = void 0;
  }
}
class FrameShapeTool extends BaseBoxShapeTool {
  static id = "frame";
  static initial = "idle";
  shapeType = "frame";
  onCreate(shape) {
    if (!shape) return;
    const bounds = this.editor.getShapePageBounds(shape);
    const shapesToAddToFrame = [];
    const ancestorIds = this.editor.getShapeAncestors(shape).map((shape2) => shape2.id);
    this.editor.getSortedChildIdsForParent(shape.parentId).map((siblingShapeId) => {
      const siblingShape = this.editor.getShape(siblingShapeId);
      if (!siblingShape) return;
      if (siblingShape.id === shape.id) return;
      if (siblingShape.isLocked) return;
      const pageShapeBounds = this.editor.getShapePageBounds(siblingShape);
      if (!pageShapeBounds) return;
      if (bounds.contains(pageShapeBounds)) {
        if (canEnclose(siblingShape, ancestorIds, shape)) {
          shapesToAddToFrame.push(siblingShape.id);
        }
      }
    });
    this.editor.reparentShapes(shapesToAddToFrame, shape.id);
    if (this.editor.getInstanceState().isToolLocked) {
      this.editor.setCurrentTool("frame");
    } else {
      this.editor.setCurrentTool("select.idle");
    }
  }
}
function canEnclose(shape, ancestorIds, frame) {
  if (ancestorIds.includes(shape.id)) {
    return false;
  }
  if (shape.parentId === frame.parentId) {
    return true;
  }
  return false;
}
let Idle$9 = class Idle4 extends StateNode {
  static id = "idle";
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onKeyUp(info) {
    if (info.key === "Enter") {
      if (this.editor.getIsReadonly()) return null;
      const onlySelectedShape = this.editor.getOnlySelectedShape();
      if (onlySelectedShape && this.editor.getShapeUtil(onlySelectedShape).canEdit(onlySelectedShape)) {
        this.editor.setCurrentTool("select");
        this.editor.setEditingShape(onlySelectedShape.id);
        this.editor.root.getCurrent()?.transition("editing_shape", {
          ...info,
          target: "shape",
          shape: onlySelectedShape
        });
      }
    }
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
let Pointing$6 = class Pointing3 extends StateNode {
  static id = "pointing";
  onPointerUp() {
    this.complete();
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      const { originPagePoint } = this.editor.inputs;
      const id = createShapeId();
      const creatingMarkId = this.editor.markHistoryStoppingPoint(`creating_geo:${id}`);
      const newPoint = maybeSnapToGrid(originPagePoint, this.editor);
      this.editor.createShapes([
        {
          id,
          type: "geo",
          x: newPoint.x,
          y: newPoint.y,
          props: {
            w: 1,
            h: 1,
            geo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),
            scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
          }
        }
      ]).select(id);
      const shape = this.editor.getShape(id);
      if (!shape) {
        this.cancel();
        return;
      }
      this.editor.setCurrentTool("select.resizing", {
        ...info,
        target: "selection",
        handle: "bottom_right",
        isCreating: true,
        creatingMarkId,
        creationCursorOffset: { x: 1, y: 1 },
        onInteractionEnd: "geo"
      });
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { originPagePoint } = this.editor.inputs;
    const id = createShapeId();
    this.editor.markHistoryStoppingPoint(`creating_geo:${id}`);
    const scale = this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1;
    const geo = this.editor.getStyleForNextShape(GeoShapeGeoStyle);
    const size2 = geo === "star" ? { w: 200, h: 190 } : geo === "cloud" ? { w: 300, h: 180 } : { w: 200, h: 200 };
    this.editor.createShapes([
      {
        id,
        type: "geo",
        x: originPagePoint.x,
        y: originPagePoint.y,
        props: {
          geo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),
          scale,
          ...size2
        }
      }
    ]);
    const shape = this.editor.getShape(id);
    if (!shape) {
      this.cancel();
      return;
    }
    const { w, h: h2 } = shape.props;
    const delta = new Vec(w / 2, h2 / 2).mul(scale);
    const parentTransform = this.editor.getShapeParentTransform(shape);
    if (parentTransform) delta.rot(-parentTransform.rotation());
    const newPoint = maybeSnapToGrid(new Vec(shape.x - delta.x, shape.y - delta.y), this.editor);
    this.editor.select(id);
    this.editor.updateShape({
      id: shape.id,
      type: "geo",
      x: newPoint.x,
      y: newPoint.y,
      props: {
        geo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),
        w: w * scale,
        h: h2 * scale
      }
    });
    if (this.editor.getInstanceState().isToolLocked) {
      this.parent.transition("idle");
    } else {
      this.editor.setCurrentTool("select", {});
    }
  }
  cancel() {
    this.parent.transition("idle");
  }
};
class GeoShapeTool extends StateNode {
  static id = "geo";
  static initial = "idle";
  static children() {
    return [Idle$9, Pointing$6];
  }
  shapeType = "geo";
}
class HighlightShapeTool extends StateNode {
  static id = "highlight";
  static initial = "idle";
  static useCoalescedEvents = true;
  static children() {
    return [Idle$a, Drawing];
  }
  static isLockable = false;
  shapeType = "highlight";
  onExit() {
    const drawingState = this.children["drawing"];
    drawingState.initialShape = void 0;
  }
}
let Idle$8 = class Idle5 extends StateNode {
  static id = "idle";
  shapeId = "";
  onEnter(info) {
    this.shapeId = info.shapeId;
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onPointerDown() {
    this.parent.transition("pointing", { shapeId: this.shapeId });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
const MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES = 2;
let Pointing$5 = class Pointing4 extends StateNode {
  static id = "pointing";
  shape = {};
  markId;
  onEnter(info) {
    const { inputs } = this.editor;
    const { currentPagePoint } = inputs;
    this.markId = void 0;
    const shape = info.shapeId && this.editor.getShape(info.shapeId);
    if (shape && inputs.shiftKey) {
      this.markId = this.editor.markHistoryStoppingPoint(`creating_line:${shape.id}`);
      this.shape = shape;
      const handles = this.editor.getShapeHandles(this.shape);
      if (!handles) return;
      const vertexHandles = handles.filter((h2) => h2.type === "vertex").sort(sortByIndex);
      const endHandle = vertexHandles[vertexHandles.length - 1];
      const prevEndHandle = vertexHandles[vertexHandles.length - 2];
      const shapePagePoint = Mat.applyToPoint(
        this.editor.getShapeParentTransform(this.shape),
        new Vec(this.shape.x, this.shape.y)
      );
      const nudgedPoint = Vec.Sub(currentPagePoint, shapePagePoint).addXY(0.1, 0.1);
      const nextPoint = maybeSnapToGrid(nudgedPoint, this.editor);
      const points = structuredClone(this.shape.props.points);
      if (Vec.DistMin(endHandle, prevEndHandle, MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES) || Vec.DistMin(nextPoint, endHandle, MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES)) {
        points[endHandle.id] = {
          id: endHandle.id,
          index: endHandle.index,
          x: nextPoint.x,
          y: nextPoint.y
        };
      } else {
        const nextIndex = getIndexAbove(endHandle.index);
        points[nextIndex] = {
          id: nextIndex,
          index: nextIndex,
          x: nextPoint.x,
          y: nextPoint.y
        };
      }
      this.editor.updateShapes([
        {
          id: this.shape.id,
          type: this.shape.type,
          props: {
            points
          }
        }
      ]);
    } else {
      const id = createShapeId();
      this.markId = this.editor.markHistoryStoppingPoint(`creating_line:${id}`);
      const newPoint = maybeSnapToGrid(currentPagePoint, this.editor);
      this.editor.createShapes([
        {
          id,
          type: "line",
          x: newPoint.x,
          y: newPoint.y,
          props: {
            scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
          }
        }
      ]);
      if (!this.editor.getShape(id)) {
        this.cancel();
        return;
      }
      this.editor.select(id);
      this.shape = this.editor.getShape(id);
    }
  }
  onPointerMove() {
    if (!this.shape) return;
    if (this.editor.inputs.isDragging) {
      const handles = this.editor.getShapeHandles(this.shape);
      if (!handles) {
        if (this.markId) this.editor.bailToMark(this.markId);
        throw Error("No handles found");
      }
      const lastHandle = last(handles);
      this.editor.setCurrentTool("select.dragging_handle", {
        shape: this.shape,
        isCreating: true,
        creatingMarkId: this.markId,
        // remove the offset that we added to the handle when we created it
        handle: { ...lastHandle, x: lastHandle.x - 0.1, y: lastHandle.y - 0.1 },
        onInteractionEnd: "line"
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.parent.transition("idle");
    if (this.markId) this.editor.bailToMark(this.markId);
    this.editor.snaps.clearIndicators();
  }
  complete() {
    this.parent.transition("idle", { shapeId: this.shape.id });
    this.editor.snaps.clearIndicators();
  }
  cancel() {
    if (this.markId) this.editor.bailToMark(this.markId);
    this.parent.transition("idle", { shapeId: this.shape.id });
    this.editor.snaps.clearIndicators();
  }
};
class LineShapeTool extends StateNode {
  static id = "line";
  static initial = "idle";
  static children() {
    return [Idle$8, Pointing$5];
  }
  shapeType = "line";
}
let Idle$7 = class Idle6 extends StateNode {
  static id = "idle";
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
const CLONE_HANDLE_MARGIN = 0;
const NOTE_SIZE = 200;
const NOTE_CENTER_OFFSET = new Vec(NOTE_SIZE / 2, NOTE_SIZE / 2);
const NOTE_ADJACENT_POSITION_SNAP_RADIUS = 10;
const BASE_NOTE_POSITIONS = (editor) => [
  [
    ["a1"],
    new Vec(NOTE_SIZE * 0.5, NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin)
  ],
  // t
  [
    ["a2"],
    new Vec(NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5)
  ],
  // r
  [
    ["a3"],
    new Vec(NOTE_SIZE * 0.5, NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin)
  ],
  // b
  [
    ["a4"],
    new Vec(NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5)
  ]
  // l
];
function getBaseAdjacentNotePositions(editor, scale) {
  if (scale === 1) return BASE_NOTE_POSITIONS(editor);
  const s = NOTE_SIZE * scale;
  const m = editor.options.adjacentShapeMargin * scale;
  return [
    [["a1"], new Vec(s * 0.5, s * -0.5 - m)],
    // t
    [["a2"], new Vec(s * 1.5 + m, s * 0.5)],
    // r
    [["a3"], new Vec(s * 0.5, s * 1.5 + m)],
    // b
    [["a4"], new Vec(s * -0.5 - m, s * 0.5)]
    // l
  ];
}
function getNoteAdjacentPositions(editor, pagePoint, pageRotation, growY, extraHeight, scale) {
  return Object.fromEntries(
    getBaseAdjacentNotePositions(editor, scale).map(([id, v], i) => {
      const point = v.clone();
      if (i === 0 && extraHeight) {
        point.y -= extraHeight;
      } else if (i === 2 && growY) {
        point.y += growY;
      }
      return [id, point.rot(pageRotation).add(pagePoint)];
    })
  );
}
function getAvailableNoteAdjacentPositions(editor, rotation, scale, extraHeight) {
  const selectedShapeIds = new Set(editor.getSelectedShapeIds());
  const minSize = (NOTE_SIZE + editor.options.adjacentShapeMargin + extraHeight) ** 2;
  const allCenters = /* @__PURE__ */ new Map();
  const positions = [];
  for (const shape of editor.getCurrentPageShapes()) {
    if (!editor.isShapeOfType(shape, "note") || scale !== shape.props.scale || selectedShapeIds.has(shape.id)) {
      continue;
    }
    const transform = editor.getShapePageTransform(shape.id);
    if (rotation !== transform.rotation()) continue;
    allCenters.set(shape, editor.getShapePageBounds(shape).center);
    positions.push(
      ...Object.values(
        getNoteAdjacentPositions(
          editor,
          transform.point(),
          rotation,
          shape.props.growY,
          extraHeight,
          scale
        )
      )
    );
  }
  const len = positions.length;
  let position;
  for (const [shape, center] of allCenters) {
    for (let i = 0; i < len; i++) {
      position = positions[i];
      if (!position) continue;
      if (Vec.Dist2(center, position) > minSize) continue;
      if (editor.isPointInShape(shape, position)) {
        positions[i] = void 0;
      }
    }
  }
  return compact(positions);
}
function getNoteShapeForAdjacentPosition(editor, shape, center, pageRotation, forceNew = false) {
  let nextNote;
  const allShapesOnPage = editor.getCurrentPageShapesSorted();
  const minDistance = (NOTE_SIZE + editor.options.adjacentShapeMargin ** 2) ** shape.props.scale;
  for (let i = allShapesOnPage.length - 1; i >= 0; i--) {
    const otherNote = allShapesOnPage[i];
    if (otherNote.type === "note" && otherNote.id !== shape.id) {
      const otherBounds = editor.getShapePageBounds(otherNote);
      if (otherBounds && Vec.Dist2(otherBounds.center, center) < minDistance && editor.isPointInShape(otherNote, center)) {
        nextNote = otherNote;
        break;
      }
    }
  }
  editor.complete();
  if (!nextNote || forceNew) {
    editor.markHistoryStoppingPoint("creating note shape");
    const id = createShapeId();
    editor.createShape({
      id,
      type: "note",
      x: center.x,
      y: center.y,
      rotation: pageRotation,
      opacity: shape.opacity,
      props: {
        // Use the props of the shape we're cloning
        ...shape.props,
        richText: toRichText(""),
        growY: 0,
        fontSizeAdjustment: 0,
        url: ""
      }
    });
    const createdShape = editor.getShape(id);
    if (!createdShape) return;
    const topLeft = editor.getPointInParentSpace(
      createdShape,
      Vec.Sub(
        center,
        Vec.Rot(NOTE_CENTER_OFFSET.clone().mul(createdShape.props.scale), pageRotation)
      )
    );
    editor.updateShape({
      id,
      type: "note",
      x: topLeft.x,
      y: topLeft.y
    });
    nextNote = editor.getShape(id);
  }
  editor.zoomToSelectionIfOffscreen(16, {
    animation: {
      duration: editor.options.animationMediumMs
    },
    inset: 0
  });
  return nextNote;
}
let Pointing$4 = class Pointing5 extends StateNode {
  static id = "pointing";
  dragged = false;
  info = {};
  markId = "";
  shape = {};
  onEnter() {
    const { editor } = this;
    const id = createShapeId();
    this.markId = editor.markHistoryStoppingPoint(`creating_note:${id}`);
    const center = this.editor.inputs.originPagePoint.clone();
    const offset2 = getNoteShapeAdjacentPositionOffset(
      this.editor,
      center,
      this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
    );
    if (offset2) {
      center.sub(offset2);
    }
    const shape = createNoteShape(this.editor, id, center);
    if (shape) {
      this.shape = shape;
    } else {
      this.cancel();
    }
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      this.editor.setCurrentTool("select.translating", {
        ...info,
        target: "shape",
        shape: this.shape,
        onInteractionEnd: "note",
        isCreating: true,
        creatingMarkId: this.markId,
        onCreate: () => {
          this.editor.setEditingShape(this.shape.id);
          this.editor.setCurrentTool("select.editing_shape");
        }
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  complete() {
    if (this.editor.getInstanceState().isToolLocked) {
      this.parent.transition("idle");
    } else {
      this.editor.setEditingShape(this.shape.id);
      this.editor.setCurrentTool("select.editing_shape", {
        ...this.info,
        target: "shape",
        shape: this.shape
      });
    }
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    this.parent.transition("idle", this.info);
  }
};
function getNoteShapeAdjacentPositionOffset(editor, center, scale) {
  let min2 = NOTE_ADJACENT_POSITION_SNAP_RADIUS / editor.getZoomLevel();
  let offset2;
  for (const pit of getAvailableNoteAdjacentPositions(editor, 0, scale, 0)) {
    const deltaToPit = Vec.Sub(center, pit);
    const dist = deltaToPit.len();
    if (dist < min2) {
      min2 = dist;
      offset2 = deltaToPit;
    }
  }
  return offset2;
}
function createNoteShape(editor, id, center) {
  editor.createShape({
    id,
    type: "note",
    x: center.x,
    y: center.y,
    props: {
      scale: editor.user.getIsDynamicResizeMode() ? 1 / editor.getZoomLevel() : 1
    }
  });
  const shape = editor.getShape(id);
  if (!shape) return;
  editor.select(id);
  const bounds = editor.getShapeGeometry(shape).bounds;
  const newPoint = maybeSnapToGrid(
    new Vec(shape.x - bounds.width / 2, shape.y - bounds.height / 2),
    editor
  );
  editor.updateShapes([
    {
      id,
      type: "note",
      x: newPoint.x,
      y: newPoint.y
    }
  ]);
  return editor.getShape(id);
}
class NoteShapeTool extends StateNode {
  static id = "note";
  static initial = "idle";
  static children() {
    return [Idle$7, Pointing$4];
  }
  shapeType = "note";
}
function _updateHoveredShapeId(editor) {
  const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint, {
    hitInside: false,
    hitLabels: false,
    margin: editor.options.hitTestMargin / editor.getZoomLevel(),
    renderingOnly: true
  });
  if (!hitShape) return editor.setHoveredShape(null);
  let shapeToHover = void 0;
  const outermostShape = editor.getOutermostSelectableShape(hitShape);
  if (outermostShape === hitShape) {
    shapeToHover = hitShape;
  } else {
    if (outermostShape.id === editor.getFocusedGroupId() || editor.getSelectedShapeIds().includes(outermostShape.id)) {
      shapeToHover = hitShape;
    } else {
      shapeToHover = outermostShape;
    }
  }
  return editor.setHoveredShape(shapeToHover.id);
}
const updateHoveredShapeId = throttle(
  _updateHoveredShapeId,
  32
);
let Idle$6 = class Idle7 extends StateNode {
  static id = "idle";
  onPointerMove(info) {
    switch (info.target) {
      case "shape":
      case "canvas": {
        updateHoveredShapeId(this.editor);
      }
    }
  }
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onExit() {
    updateHoveredShapeId.cancel();
  }
  onKeyDown(info) {
    if (info.key === "Enter") {
      if (this.editor.getIsReadonly()) return null;
      const onlySelectedShape = this.editor.getOnlySelectedShape();
      if (onlySelectedShape && this.editor.getShapeUtil(onlySelectedShape).canEdit(onlySelectedShape)) {
        this.editor.setCurrentTool("select");
        this.editor.setEditingShape(onlySelectedShape.id);
        this.editor.root.getCurrent()?.transition("editing_shape", {
          ...info,
          target: "shape",
          shape: onlySelectedShape
        });
      }
    }
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
let Pointing$3 = class Pointing6 extends StateNode {
  static id = "pointing";
  shape;
  markId = "";
  enterTime = 0;
  onEnter() {
    this.enterTime = Date.now();
  }
  onExit() {
    this.editor.setHintingShapes([]);
  }
  onPointerMove(info) {
    if (Date.now() - this.enterTime < 150) return;
    const { editor } = this;
    const { isPointing } = editor.inputs;
    if (!isPointing) return;
    const { originPagePoint, currentPagePoint } = editor.inputs;
    const currentDragDist = Math.abs(originPagePoint.x - currentPagePoint.x);
    const baseMinDragDistForFixedWidth = Math.sqrt(
      editor.getInstanceState().isCoarsePointer ? editor.options.coarseDragDistanceSquared : editor.options.dragDistanceSquared
    );
    const minSquaredDragDist = baseMinDragDistForFixedWidth * 6 / editor.getZoomLevel();
    if (currentDragDist > minSquaredDragDist) {
      const id = createShapeId();
      this.markId = editor.markHistoryStoppingPoint(`creating_text:${id}`);
      const shape = this.createTextShape(id, originPagePoint, false, currentDragDist);
      if (!shape) {
        this.cancel();
        return;
      }
      this.shape = editor.getShape(shape);
      editor.select(id);
      const scale = this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1;
      editor.setCurrentTool("select.resizing", {
        ...info,
        target: "selection",
        handle: "right",
        isCreating: true,
        creatingMarkId: this.markId,
        // Make sure the cursor offset takes into account how far we've already dragged
        creationCursorOffset: { x: currentDragDist * scale, y: 1 },
        onInteractionEnd: "text",
        onCreate: () => {
          editor.setEditingShape(shape.id);
        }
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.cancel();
  }
  onCancel() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    this.editor.markHistoryStoppingPoint("creating text shape");
    const id = createShapeId();
    const { originPagePoint } = this.editor.inputs;
    const shape = this.createTextShape(id, originPagePoint, true, 20);
    if (!shape) return;
    this.editor.select(id);
    this.editor.setEditingShape(id);
  }
  cancel() {
    this.parent.transition("idle");
    this.editor.bailToMark(this.markId);
  }
  createTextShape(id, point, autoSize, width) {
    this.editor.createShape({
      id,
      type: "text",
      x: point.x,
      y: point.y,
      props: {
        richText: toRichText(""),
        autoSize,
        w: width,
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const shape = this.editor.getShape(id);
    if (!shape) {
      this.cancel();
      return;
    }
    const bounds = this.editor.getShapePageBounds(shape);
    const delta = new Vec();
    if (autoSize) {
      switch (shape.props.textAlign) {
        case "start": {
          delta.x = 0;
          break;
        }
        case "middle": {
          delta.x = -bounds.width / 2;
          break;
        }
        case "end": {
          delta.x = -bounds.width;
          break;
        }
      }
    } else {
      delta.x = 0;
    }
    delta.y = -bounds.height / 2;
    if (isShapeId(shape.parentId)) {
      const transform = this.editor.getShapeParentTransform(shape);
      delta.rot(-transform.rotation());
    }
    const shapeX = shape.x + delta.x;
    const shapeY = shape.y + delta.y;
    if (this.editor.getInstanceState().isGridMode) {
      const topLeft = new Vec(shapeX, shapeY);
      const gridSnappedPoint = maybeSnapToGrid(topLeft, this.editor);
      const gridDelta = Vec.Sub(topLeft, gridSnappedPoint);
      this.editor.updateShape({
        ...shape,
        x: shapeX - gridDelta.x,
        y: shapeY - gridDelta.y
      });
    } else {
      this.editor.updateShape({
        ...shape,
        x: shapeX,
        y: shapeY
      });
    }
    return shape;
  }
};
class TextShapeTool extends StateNode {
  static id = "text";
  static initial = "idle";
  static children() {
    return [Idle$6, Pointing$3];
  }
  shapeType = "text";
}
const defaultShapeTools = [
  TextShapeTool,
  DrawShapeTool,
  GeoShapeTool,
  NoteShapeTool,
  LineShapeTool,
  FrameShapeTool,
  ArrowShapeTool,
  HighlightShapeTool
];
const RichTextArea = React.forwardRef(function RichTextArea2({
  shapeId,
  isEditing,
  richText,
  handleFocus,
  handleChange,
  handleBlur,
  handleKeyDown: handleKeyDown2,
  handleDoubleClick: handleDoubleClick2,
  hasCustomTabBehavior,
  handlePaste
}, ref) {
  const editor = useEditor();
  const tipTapId = useUniqueSafeId("tip-tap-editor");
  const tipTapConfig = editor.getTextOptions().tipTapConfig;
  const rInitialRichText = reactExports.useRef(richText);
  const rTextEditor = reactExports.useRef(null);
  const rTextEditorEl = reactExports.useRef(null);
  reactExports.useLayoutEffect(() => {
    if (!rTextEditor.current) {
      rInitialRichText.current = richText;
    } else if (rInitialRichText.current !== richText) {
      rTextEditor.current.commands.setContent(richText);
    }
  }, [richText]);
  const rCreateInfo = reactExports.useRef({
    selectAll: false,
    caretPosition: null
  });
  reactExports.useLayoutEffect(() => {
    function selectAllIfEditing(event) {
      if (event.shapeId === editor.getEditingShapeId()) {
        rCreateInfo.current.selectAll = true;
      }
    }
    function placeCaret(event) {
      if (event.shapeId === editor.getEditingShapeId()) {
        rCreateInfo.current.caretPosition = event.point;
      }
    }
    editor.on("select-all-text", selectAllIfEditing);
    editor.on("place-caret", placeCaret);
    return () => {
      editor.off("select-all-text", selectAllIfEditing);
      editor.off("place-caret", placeCaret);
    };
  }, [editor, isEditing]);
  const onChange = useEvent(handleChange);
  const onKeyDown = useEvent(handleKeyDown2);
  const onFocus = useEvent(handleFocus);
  const onBlur = useEvent(handleBlur);
  const onDoubleClick = useEvent(handleDoubleClick2);
  const onPaste = useEvent(handlePaste);
  reactExports.useLayoutEffect(() => {
    if (!isEditing || !tipTapConfig || !rTextEditorEl.current) return;
    const { editorProps, ...restOfTipTapConfig } = tipTapConfig;
    const textEditorInstance = new Editor2({
      element: rTextEditorEl.current,
      autofocus: true,
      editable: isEditing,
      onUpdate: (props) => {
        const content = props.editor.state.doc.toJSON();
        rInitialRichText.current = content;
        onChange({ richText: content });
      },
      onFocus,
      onBlur,
      // onCreate is called after a `setTimeout(0)`
      onCreate: (props) => {
        if (editor.getEditingShapeId() !== shapeId) return;
        const textEditor = props.editor;
        editor.setRichTextEditor(textEditor);
        const { selectAll: selectAll2, caretPosition } = rCreateInfo.current;
        if (selectAll2) {
          textEditor.chain().focus().selectAll().run();
        } else if (caretPosition) {
          const pos = textEditor.view.posAtCoords({
            left: caretPosition.x,
            top: caretPosition.y
          })?.pos;
          if (pos) {
            textEditor.chain().focus().setTextSelection(pos).run();
          } else {
            textEditor.chain().focus().selectAll().run();
          }
        }
      },
      editorProps: {
        handleKeyDown: (view, event) => {
          if (!hasCustomTabBehavior && event.key === "Tab") {
            handleTab(editor, view, event);
          }
          onKeyDown(event);
        },
        handlePaste: (view, event) => {
          onPaste(event);
          if (event.defaultPrevented) return true;
        },
        handleDoubleClick: (_view, _pos, event) => onDoubleClick(event),
        ...editorProps
      },
      coreExtensionOptions: {
        clipboardTextSerializer: {
          blockSeparator: "\n"
        }
      },
      ...restOfTipTapConfig,
      content: rInitialRichText.current
    });
    const timeout = editor.timers.setTimeout(() => {
      if (rCreateInfo.current.caretPosition || rCreateInfo.current.selectAll) {
        textEditorInstance.commands.focus();
      } else {
        textEditorInstance.commands.focus("end");
      }
      rCreateInfo.current.selectAll = false;
      rCreateInfo.current.caretPosition = null;
    }, 100);
    rTextEditor.current = textEditorInstance;
    return () => {
      rTextEditor.current = null;
      clearTimeout(timeout);
      textEditorInstance.destroy();
    };
  }, [
    isEditing,
    tipTapConfig,
    onFocus,
    onBlur,
    onDoubleClick,
    onChange,
    onPaste,
    onKeyDown,
    editor,
    shapeId,
    hasCustomTabBehavior
  ]);
  if (!isEditing || !tipTapConfig) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: tipTapId,
      ref,
      tabIndex: -1,
      "data-testid": "rich-text-area",
      className: "tl-rich-text tl-text tl-text-input",
      onContextMenu: isEditing ? (e) => e.stopPropagation() : void 0,
      onPointerDownCapture: (e) => e.stopPropagation(),
      onTouchEnd: (e) => e.stopPropagation(),
      onDragStart: preventDefault,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-rich-text", ref: rTextEditorEl })
    }
  );
});
function handleTab(editor, view, event) {
  event.preventDefault();
  const textEditor = editor.getRichTextEditor();
  if (textEditor?.isActive("bulletList") || textEditor?.isActive("orderedList")) return;
  const { state, dispatch: dispatch2 } = view;
  const { $from, $to } = state.selection;
  const isShift = event.shiftKey;
  let tr2 = state.tr;
  let pos = $to.end();
  while (pos >= $from.start()) {
    const line = state.doc.resolve(pos).blockRange();
    if (!line) break;
    const lineStart = line.start;
    const lineEnd = line.end;
    const lineText = state.doc.textBetween(lineStart, lineEnd, "\n");
    let isInList = false;
    state.doc.nodesBetween(lineStart, lineEnd, (node) => {
      if (node.type.name === "bulletList" || node.type.name === "orderedList") {
        isInList = true;
        return false;
      }
    });
    if (!isInList) {
      if (!isShift) {
        tr2 = tr2.insertText("	", lineStart + 1);
      } else {
        if (lineText.startsWith("	")) {
          tr2 = tr2.delete(lineStart + 1, lineStart + 2);
        }
      }
    }
    pos = lineStart - 1;
  }
  const mappedSelection = state.selection.map(tr2.doc, tr2.mapping);
  tr2.setSelection(mappedSelection);
  if (tr2.docChanged) {
    dispatch2(tr2);
  }
}
function isLegacyAlign(align) {
  return align === "start-legacy" || align === "middle-legacy" || align === "end-legacy";
}
function useEditablePlainText(shapeId, type, text) {
  const commonUseEditableTextHandlers = useEditableTextCommon(shapeId);
  const isEditing = commonUseEditableTextHandlers.isEditing;
  const editor = useEditor();
  const rInput = reactExports.useRef(null);
  const isEmpty = (text || "").trim().length === 0;
  reactExports.useEffect(() => {
    function selectAllIfEditing(event) {
      if (event.shapeId === shapeId) {
        rInput.current?.select?.();
      }
    }
    editor.on("select-all-text", selectAllIfEditing);
    return () => {
      editor.off("select-all-text", selectAllIfEditing);
    };
  }, [editor, shapeId, isEditing]);
  reactExports.useEffect(() => {
    if (!isEditing) return;
    if (document.activeElement !== rInput.current) {
      rInput.current?.focus();
    }
    if (editor.getInstanceState().isCoarsePointer) {
      rInput.current?.select();
    }
    if (tlenv.isSafari) {
      rInput.current?.blur();
      rInput.current?.focus();
    }
  }, [editor, isEditing]);
  const handleKeyDown2 = reactExports.useCallback(
    (e) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      switch (e.key) {
        case "Enter": {
          if (e.ctrlKey || e.metaKey) {
            editor.complete();
          }
          break;
        }
      }
    },
    [editor, shapeId]
  );
  const handleChange = reactExports.useCallback(
    ({ plaintext }) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      const normalizedPlaintext = TextHelpers.normalizeText(plaintext || "");
      editor.updateShape({
        id: shapeId,
        type,
        props: { text: normalizedPlaintext }
      });
    },
    [editor, shapeId, type]
  );
  return {
    rInput,
    handleKeyDown: handleKeyDown2,
    handleChange,
    isEmpty,
    ...commonUseEditableTextHandlers
  };
}
function useIsReadyForEditing(editor, shapeId) {
  return useValue(
    "isReadyForEditing",
    () => {
      const editingShapeId = editor.getEditingShapeId();
      return (
        // something's being editing... and either it's this shape OR this shape is hovered
        editingShapeId !== null && (editingShapeId === shapeId || editor.getHoveredShapeId() === shapeId)
      );
    },
    [editor, shapeId]
  );
}
function useEditableTextCommon(shapeId) {
  const editor = useEditor();
  const isEditing = useValue("isEditing", () => editor.getEditingShapeId() === shapeId, [editor]);
  const isReadyForEditing = useIsReadyForEditing(editor, shapeId);
  const handleInputPointerDown = reactExports.useCallback(
    (e) => {
      editor.dispatch({
        ...getPointerInfo(editor, e),
        type: "pointer",
        name: "pointer_down",
        target: "shape",
        shape: editor.getShape(shapeId)
      });
      e.stopPropagation();
    },
    [editor, shapeId]
  );
  const handlePaste = reactExports.useCallback(
    (e) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      if (e.clipboardData) {
        const html2 = e.clipboardData.getData("text/html");
        if (html2) {
          if (html2.includes("<div data-tldraw")) {
            preventDefault(e);
          }
        }
      }
    },
    [editor, shapeId]
  );
  return {
    handleFocus: noop$3,
    handleBlur: noop$3,
    handleInputPointerDown,
    handleDoubleClick: editor.markEventAsHandled,
    handlePaste,
    isEditing,
    isReadyForEditing
  };
}
function useEditableRichText(shapeId, type, richText) {
  const commonUseEditableTextHandlers = useEditableTextCommon(shapeId);
  const isEditing = commonUseEditableTextHandlers.isEditing;
  const editor = useEditor();
  const rInput = reactExports.useRef(null);
  const isEmpty = richText && isEmptyRichText(richText);
  reactExports.useEffect(() => {
    if (!isEditing) return;
    const contentEditable = rInput.current?.querySelector("[contenteditable]");
    if (contentEditable && document.activeElement !== rInput.current) {
      contentEditable.focus();
    }
  }, [editor, isEditing]);
  const handleKeyDown2 = reactExports.useCallback(
    (e) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      if (e.key === "Enter" && isAccelKey(e)) editor.complete();
    },
    [editor, shapeId]
  );
  const handleChange = reactExports.useCallback(
    ({ richText: richText2 }) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      editor.updateShape({
        id: shapeId,
        type,
        props: { richText: richText2 }
      });
    },
    [editor, shapeId, type]
  );
  return {
    rInput,
    handleKeyDown: handleKeyDown2,
    handleChange,
    isEmpty,
    ...commonUseEditableTextHandlers
  };
}
const RichTextLabel = React.memo(function RichTextLabel2({
  shapeId,
  type,
  richText,
  labelColor,
  font,
  fontSize,
  lineHeight,
  align,
  verticalAlign,
  wrap: wrap2,
  isSelected,
  padding = 0,
  onKeyDown: handleKeyDownCustom,
  classNamePrefix,
  style: style2,
  textWidth,
  textHeight,
  hasCustomTabBehavior
}) {
  const editor = useEditor();
  const isDragging = React.useRef(false);
  const { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } = useEditableRichText(shapeId, type, richText);
  const html2 = reactExports.useMemo(() => {
    if (richText) {
      return renderHtmlFromRichText(editor, richText);
    }
  }, [editor, richText]);
  const selectToolActive = useValue(
    "isSelectToolActive",
    () => editor.getCurrentToolId() === "select",
    [editor]
  );
  useReactor(
    "isDragging",
    () => {
      editor.getInstanceState();
      isDragging.current = editor.inputs.isDragging;
    },
    [editor]
  );
  const legacyAlign = isLegacyAlign(align);
  const handlePointerDown = (e) => {
    if (e.target instanceof HTMLElement && (e.target.tagName === "A" || e.target.closest("a"))) {
      preventDefault(e);
      if (!selectToolActive) return;
      const link = e.target.closest("a")?.getAttribute("href") ?? "";
      const handlePointerUp = (e2) => {
        if (e2.name !== "pointer_up" || !link) return;
        if (!isDragging.current) {
          openWindow(link, "_blank", false);
        }
        editor.off("event", handlePointerUp);
      };
      editor.on("event", handlePointerUp);
    }
  };
  if (!isEditing && isEmpty) return null;
  const cssPrefix = classNamePrefix || "tl-text";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `${cssPrefix}-label tl-text-wrapper tl-rich-text-wrapper`,
      "aria-hidden": !isEditing,
      "data-font": font,
      "data-align": align,
      "data-hastext": !isEmpty,
      "data-isediting": isEditing,
      "data-textwrap": !!wrap2,
      "data-isselected": isSelected,
      style: {
        justifyContent: align === "middle" || legacyAlign ? "center" : align,
        alignItems: verticalAlign === "middle" ? "center" : verticalAlign,
        padding,
        ...style2
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `${cssPrefix}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize,
            lineHeight: lineHeight.toString(),
            minHeight: Math.floor(fontSize * lineHeight) + "px",
            minWidth: Math.ceil(textWidth || 0),
            color: labelColor,
            width: textWidth ? Math.ceil(textWidth) : void 0,
            height: textHeight ? Math.ceil(textHeight) : void 0
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${cssPrefix} tl-text tl-text-content`, dir: "auto", children: richText && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "tl-rich-text",
                "data-is-select-tool-active": selectToolActive,
                dangerouslySetInnerHTML: { __html: html2 || "" },
                onPointerDown: handlePointerDown,
                "data-is-ready-for-editing": isReadyForEditing
              }
            ) }),
            (isReadyForEditing || isSelected) && /* @__PURE__ */ jsxRuntimeExports.jsx(
              RichTextArea,
              {
                ref: rInput,
                richText,
                isEditing,
                shapeId,
                ...editableTextRest,
                hasCustomTabBehavior,
                handleKeyDown: handleKeyDownCustom ?? editableTextRest.handleKeyDown
              }
            )
          ]
        }
      )
    }
  );
});
function RichTextSVG({
  bounds,
  richText,
  fontSize,
  font,
  align,
  verticalAlign,
  wrap: wrap2,
  labelColor,
  padding,
  showTextOutline = true
}) {
  const editor = useEditor();
  const html2 = renderHtmlFromRichText(editor, richText);
  const textAlign = align === "middle" ? "center" : align === "start" ? "start" : "end";
  const justifyContent = align === "middle" ? "center" : align === "start" ? "flex-start" : "flex-end";
  const alignItems = verticalAlign === "middle" ? "center" : verticalAlign === "start" ? "flex-start" : "flex-end";
  const wrapperStyle = {
    display: "flex",
    fontFamily: DefaultFontFamilies[font],
    height: `100%`,
    justifyContent,
    alignItems,
    padding: `${padding}px`
  };
  const style2 = {
    fontSize: `${fontSize}px`,
    wrap: wrap2 ? "wrap" : "nowrap",
    color: labelColor,
    lineHeight: TEXT_PROPS.lineHeight,
    textAlign,
    width: "100%",
    wordWrap: "break-word",
    overflowWrap: "break-word",
    whiteSpace: "pre-wrap",
    textShadow: showTextOutline ? "var(--tl-text-outline)" : "none"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "foreignObject",
    {
      x: bounds.minX,
      y: bounds.minY,
      width: bounds.w,
      height: bounds.h,
      className: "tl-export-embed-styles tl-rich-text tl-rich-text-svg",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: wrapperStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dangerouslySetInnerHTML: { __html: html2 }, style: style2 }) })
    }
  );
}
function getFillDefForExport(fill) {
  return {
    key: `${DefaultFontStyle.id}:${fill}`,
    async getElement() {
      if (fill !== "pattern") return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HashPatternForExport, {});
    }
  };
}
function HashPatternForExport() {
  const getHashPatternZoomName = useGetHashPatternZoomName();
  const maskId = useUniqueSafeId();
  const theme = useDefaultColorTheme();
  const t2 = 8 / 12;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("mask", { id: maskId, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0", y: "0", width: "8", height: "8", fill: "white" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { strokeLinecap: "round", stroke: "black", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: t2 * 1, y1: t2 * 3, x2: t2 * 3, y2: t2 * 1 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: t2 * 5, y1: t2 * 7, x2: t2 * 7, y2: t2 * 5 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: t2 * 9, y1: t2 * 11, x2: t2 * 11, y2: t2 * 9 })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "pattern",
      {
        id: getHashPatternZoomName(1, theme.id),
        width: "8",
        height: "8",
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0", y: "0", width: "8", height: "8", fill: theme.solid, mask: `url(#${maskId})` })
      }
    )
  ] });
}
function getFillDefForCanvas() {
  return {
    key: `${DefaultFontStyle.id}:pattern`,
    component: PatternFillDefForCanvas
  };
}
const TILE_PATTERN_SIZE = 8;
const generateImage = (dpr, currentZoom, darkMode) => {
  return new Promise((resolve, reject) => {
    const size2 = TILE_PATTERN_SIZE * currentZoom * dpr;
    const canvasEl = document.createElement("canvas");
    canvasEl.width = size2;
    canvasEl.height = size2;
    const ctx = canvasEl.getContext("2d");
    if (!ctx) return;
    ctx.fillStyle = darkMode ? DefaultColorThemePalette.darkMode.solid : DefaultColorThemePalette.lightMode.solid;
    ctx.fillRect(0, 0, size2, size2);
    ctx.globalCompositeOperation = "destination-out";
    ctx.lineCap = "round";
    ctx.lineWidth = 1.25 * currentZoom * dpr;
    const t2 = 8 / 12;
    const s = (v) => v * currentZoom * dpr;
    ctx.beginPath();
    ctx.moveTo(s(t2 * 1), s(t2 * 3));
    ctx.lineTo(s(t2 * 3), s(t2 * 1));
    ctx.moveTo(s(t2 * 5), s(t2 * 7));
    ctx.lineTo(s(t2 * 7), s(t2 * 5));
    ctx.moveTo(s(t2 * 9), s(t2 * 11));
    ctx.lineTo(s(t2 * 11), s(t2 * 9));
    ctx.stroke();
    canvasEl.toBlob((blob) => {
      if (!blob || debugFlags.throwToBlob.get()) {
        reject();
      } else {
        resolve(blob);
      }
    });
  });
};
const canvasBlob = (size2, fn) => {
  const canvas = document.createElement("canvas");
  canvas.width = size2[0];
  canvas.height = size2[1];
  const ctx = canvas.getContext("2d");
  if (!ctx) return "";
  fn(ctx);
  return canvas.toDataURL();
};
let defaultPixels = null;
function getDefaultPixels() {
  if (!defaultPixels) {
    defaultPixels = {
      white: canvasBlob([1, 1], (ctx) => {
        ctx.fillStyle = "#f8f9fa";
        ctx.fillRect(0, 0, 1, 1);
      }),
      black: canvasBlob([1, 1], (ctx) => {
        ctx.fillStyle = "#212529";
        ctx.fillRect(0, 0, 1, 1);
      })
    };
  }
  return defaultPixels;
}
function getPatternLodForZoomLevel(zoom) {
  return Math.ceil(Math.log2(Math.max(1, zoom)));
}
function useGetHashPatternZoomName() {
  const id = useSharedSafeId("hash_pattern");
  return reactExports.useCallback(
    (zoom, theme) => {
      const lod = getPatternLodForZoomLevel(zoom);
      return suffixSafeId(id, `${theme}_${lod}`);
    },
    [id]
  );
}
function getPatternLodsToGenerate(maxZoom) {
  const levels = [];
  const minLod = 0;
  const maxLod = getPatternLodForZoomLevel(maxZoom);
  for (let i = minLod; i <= maxLod; i++) {
    levels.push(Math.pow(2, i));
  }
  return levels;
}
function getDefaultPatterns(maxZoom) {
  const defaultPixels2 = getDefaultPixels();
  return getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [
    { zoom, url: defaultPixels2.white, theme: "light" },
    { zoom, url: defaultPixels2.black, theme: "dark" }
  ]);
}
function usePattern() {
  const editor = useEditor();
  const dpr = useValue("devicePixelRatio", () => editor.getInstanceState().devicePixelRatio, [
    editor
  ]);
  const maxZoom = useValue("maxZoom", () => Math.ceil(last(editor.getCameraOptions().zoomSteps)), [
    editor
  ]);
  const [isReady, setIsReady] = reactExports.useState(false);
  const [backgroundUrls, setBackgroundUrls] = reactExports.useState(
    () => getDefaultPatterns(maxZoom)
  );
  const getHashPatternZoomName = useGetHashPatternZoomName();
  reactExports.useEffect(() => {
    const promise = Promise.all(
      getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [
        generateImage(dpr, zoom, false).then((blob) => ({
          zoom,
          theme: "light",
          url: URL.createObjectURL(blob)
        })),
        generateImage(dpr, zoom, true).then((blob) => ({
          zoom,
          theme: "dark",
          url: URL.createObjectURL(blob)
        }))
      ])
    );
    let isCancelled = false;
    promise.then((urls) => {
      if (isCancelled) return;
      setBackgroundUrls(urls);
      setIsReady(true);
    });
    return () => {
      isCancelled = true;
      setIsReady(false);
      promise.then((patterns) => {
        for (const { url } of patterns) {
          URL.revokeObjectURL(url);
        }
      });
    };
  }, [dpr, maxZoom]);
  const defs = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: backgroundUrls.map((item) => {
    const id = getHashPatternZoomName(item.zoom, item.theme);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "pattern",
      {
        id,
        width: TILE_PATTERN_SIZE,
        height: TILE_PATTERN_SIZE,
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("image", { href: item.url, width: TILE_PATTERN_SIZE, height: TILE_PATTERN_SIZE })
      },
      id
    );
  }) });
  return { defs, isReady };
}
function PatternFillDefForCanvas() {
  const editor = useEditor();
  const containerRef = reactExports.useRef(null);
  const { defs, isReady } = usePattern();
  reactExports.useEffect(() => {
    if (isReady && tlenv.isSafari) {
      const htmlLayer = findHtmlLayerParent(containerRef.current);
      if (htmlLayer) {
        editor.timers.requestAnimationFrame(() => {
          htmlLayer.style.display = "none";
          editor.timers.requestAnimationFrame(() => {
            htmlLayer.style.display = "";
          });
        });
      }
    }
  }, [editor, isReady]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { ref: containerRef, "data-testid": isReady ? "ready-pattern-fill-defs" : void 0, children: defs });
}
function findHtmlLayerParent(element) {
  if (element.classList.contains("tl-html-layer")) return element;
  if (element.parentElement) return findHtmlLayerParent(element.parentElement);
  return null;
}
const ShapeFill = React.memo(function ShapeFill2({
  theme,
  d,
  color,
  fill,
  scale
}) {
  switch (fill) {
    case "none": {
      return null;
    }
    case "solid": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: getColorValue(theme, color, "semi"), d });
    }
    case "semi": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: theme.solid, d });
    }
    case "fill": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: getColorValue(theme, color, "fill"), d });
    }
    case "pattern": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PatternFill, { theme, color, fill, d, scale });
    }
    case "lined-fill": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: getColorValue(theme, color, "linedFill"), d });
    }
  }
});
function PatternFill({ d, color, theme }) {
  const editor = useEditor();
  const svgExport = useSvgExportContext();
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const getHashPatternZoomName = useGetHashPatternZoomName();
  const teenyTiny = editor.getZoomLevel() <= 0.18;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: getColorValue(theme, color, "pattern"), d }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: svgExport ? `url(#${getHashPatternZoomName(1, theme.id)})` : teenyTiny ? getColorValue(theme, color, "semi") : `url(#${getHashPatternZoomName(zoomLevel, theme.id)})`,
        d
      }
    )
  ] });
}
function getArrowBodyPath(shape, info, opts) {
  switch (info.type) {
    case "straight":
      return new PathBuilder().moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 }).lineTo(info.end.point.x, info.end.point.y, { offset: 0, roundness: 0 }).toSvg(opts);
    case "arc":
      return new PathBuilder().moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 }).circularArcTo(
        info.bodyArc.radius,
        !!info.bodyArc.largeArcFlag,
        !!info.bodyArc.sweepFlag,
        info.end.point.x,
        info.end.point.y,
        { offset: 0, roundness: 0 }
      ).toSvg(opts);
    case "elbow": {
      const path = new PathBuilder();
      path.moveTo(info.start.point.x, info.start.point.y, {
        offset: 0
      });
      for (let i = 1; i < info.route.points.length; i++) {
        const point = info.route.points[i];
        if (info.route.skipPointsWhenDrawing.has(point)) {
          continue;
        }
        path.lineTo(point.x, point.y, {
          offset: i === info.route.points.length - 1 ? 0 : void 0
        });
      }
      return path.toSvg(opts);
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
}
function getArrowHandlePath(info, opts) {
  switch (info.type) {
    case "straight":
      return new PathBuilder().moveTo(info.start.handle.x, info.start.handle.y).lineTo(info.end.handle.x, info.end.handle.y).toSvg(opts);
    case "arc":
      return new PathBuilder().moveTo(info.start.handle.x, info.start.handle.y).circularArcTo(
        info.handleArc.radius,
        !!info.handleArc.largeArcFlag,
        !!info.handleArc.sweepFlag,
        info.end.handle.x,
        info.end.handle.y
      ).toSvg(opts);
    case "elbow": {
      const handleRoute = getRouteHandlePath(info.elbow, info.route);
      return PathBuilder.lineThroughPoints(handleRoute.points).toSvg(opts);
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
}
function getArrowBodyGeometry(editor, shape) {
  const info = getArrowInfo(editor, shape);
  switch (info.type) {
    case "straight":
      return new Edge2d({
        start: Vec.From(info.start.point),
        end: Vec.From(info.end.point)
      });
    case "arc":
      return new Arc2d({
        center: Vec.Cast(info.handleArc.center),
        start: Vec.Cast(info.start.point),
        end: Vec.Cast(info.end.point),
        sweepFlag: info.bodyArc.sweepFlag,
        largeArcFlag: info.bodyArc.largeArcFlag
      });
    case "elbow":
      return new Polyline2d({ points: info.route.points });
    default:
      exhaustiveSwitchError(info, "type");
  }
}
const labelSizeCache = createComputedCache(
  "arrow label size",
  (editor, shape) => {
    editor.fonts.trackFontsForShape(shape);
    let width = 0;
    let height = 0;
    const bodyGeom = getArrowBodyGeometry(editor, shape);
    const isEmpty = isEmptyRichText(shape.props.richText);
    const html2 = renderHtmlFromRichTextForMeasurement(
      editor,
      isEmpty ? toRichText("i") : shape.props.richText
    );
    const bodyBounds = bodyGeom.bounds;
    const fontSize = getArrowLabelFontSize(shape);
    const { w, h: h2 } = editor.textMeasure.measureHtml(html2, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[shape.props.font],
      fontSize,
      maxWidth: null
    });
    width = w;
    height = h2;
    let shouldSquish = false;
    const info = getArrowInfo(editor, shape);
    const labelToArrowPadding = getLabelToArrowPadding(shape);
    const margin = info.type === "elbow" ? Math.max(info.elbow.A.arrowheadOffset + labelToArrowPadding, 32) + Math.max(info.elbow.B.arrowheadOffset + labelToArrowPadding, 32) : 64;
    if (bodyBounds.width > bodyBounds.height) {
      width = Math.max(Math.min(w, margin), Math.min(bodyBounds.width - margin, w));
      shouldSquish = true;
    } else if (width > 16 * fontSize) {
      width = 16 * fontSize;
      shouldSquish = true;
    }
    if (shouldSquish) {
      const { w: squishedWidth, h: squishedHeight } = editor.textMeasure.measureHtml(html2, {
        ...TEXT_PROPS,
        fontFamily: FONT_FAMILIES[shape.props.font],
        fontSize,
        maxWidth: width
      });
      width = squishedWidth;
      height = squishedHeight;
    }
    return new Vec(width, height).addScalar(ARROW_LABEL_PADDING * 2 * shape.props.scale);
  },
  {
    areRecordsEqual: (a, b) => {
      if (a.props === b.props) return true;
      const changedKeys = getChangedKeys(a.props, b.props);
      return changedKeys.length === 1 && changedKeys[0] === "labelPosition";
    }
  }
);
function getArrowLabelSize(editor, shape) {
  return labelSizeCache.get(editor, shape.id) ?? new Vec(0, 0);
}
function getLabelToArrowPadding(shape) {
  const strokeWidth = STROKE_SIZES[shape.props.size];
  const labelToArrowPadding = (LABEL_TO_ARROW_PADDING + (strokeWidth - STROKE_SIZES.s) * 2 + (strokeWidth === STROKE_SIZES.xl ? 20 : 0)) * shape.props.scale;
  return labelToArrowPadding;
}
function getArrowLabelRange(editor, shape, info) {
  const bodyGeom = getArrowBodyGeometry(editor, shape);
  const dbgPoints = [];
  const dbg = [new Group2d({ children: [bodyGeom], debugColor: "lime" })];
  const labelSize = getArrowLabelSize(editor, shape);
  const labelToArrowPadding = getLabelToArrowPadding(shape);
  const paddingRelative = labelToArrowPadding / bodyGeom.length;
  let startBox, endBox;
  if (info.type === "elbow") {
    dbgPoints.push(info.start.point, info.end.point);
    startBox = Box.FromCenter(info.start.point, labelSize).expandBy(labelToArrowPadding);
    endBox = Box.FromCenter(info.end.point, labelSize).expandBy(labelToArrowPadding);
  } else {
    const startPoint = bodyGeom.interpolateAlongEdge(paddingRelative);
    const endPoint = bodyGeom.interpolateAlongEdge(1 - paddingRelative);
    dbgPoints.push(startPoint, endPoint);
    startBox = Box.FromCenter(startPoint, labelSize);
    endBox = Box.FromCenter(endPoint, labelSize);
  }
  const startIntersections = bodyGeom.intersectPolygon(startBox.corners);
  const endIntersections = bodyGeom.intersectPolygon(endBox.corners);
  const startConstrained = furthest(info.start.point, startIntersections);
  const endConstrained = furthest(info.end.point, endIntersections);
  let startRelative = startConstrained ? bodyGeom.uninterpolateAlongEdge(startConstrained) : 0.5;
  let endRelative = endConstrained ? bodyGeom.uninterpolateAlongEdge(endConstrained) : 0.5;
  if (startRelative > endRelative) {
    startRelative = 0.5;
    endRelative = 0.5;
  }
  for (const pt of [...startIntersections, ...endIntersections, ...dbgPoints]) {
    dbg.push(
      new Circle2d({
        x: pt.x - 3,
        y: pt.y - 3,
        radius: 3,
        isFilled: false,
        debugColor: "magenta",
        ignore: true
      })
    );
  }
  dbg.push(
    new Polygon2d({
      points: startBox.corners,
      debugColor: "lime",
      isFilled: false,
      ignore: true
    }),
    new Polygon2d({
      points: endBox.corners,
      debugColor: "lime",
      isFilled: false,
      ignore: true
    })
  );
  return { start: startRelative, end: endRelative, dbg };
}
function getArrowLabelPosition(editor, shape) {
  const isEditing = editor.getEditingShapeId() === shape.id;
  if (!isEditing && isEmptyRichText(shape.props.richText)) {
    const bodyGeom2 = getArrowBodyGeometry(editor, shape);
    const labelCenter2 = bodyGeom2.interpolateAlongEdge(0.5);
    return { box: Box.FromCenter(labelCenter2, new Vec(0, 0)), debugGeom: [] };
  }
  const debugGeom = [];
  const info = getArrowInfo(editor, shape);
  const arrowheadInfo = {
    hasStartBinding: !!info.bindings.start,
    hasEndBinding: !!info.bindings.end,
    hasStartArrowhead: info.start.arrowhead !== "none",
    hasEndArrowhead: info.end.arrowhead !== "none"
  };
  const range = getArrowLabelRange(editor, shape, info);
  if (range.dbg) debugGeom.push(...range.dbg);
  const clampedPosition = getClampedPosition(shape, range, arrowheadInfo);
  const bodyGeom = getArrowBodyGeometry(editor, shape);
  const labelCenter = bodyGeom.interpolateAlongEdge(clampedPosition);
  const labelSize = getArrowLabelSize(editor, shape);
  return { box: Box.FromCenter(labelCenter, labelSize), debugGeom };
}
function getClampedPosition(shape, range, arrowheadInfo) {
  const { hasEndArrowhead, hasEndBinding, hasStartBinding, hasStartArrowhead } = arrowheadInfo;
  const clampedPosition = clamp$3(
    shape.props.labelPosition,
    hasStartArrowhead || hasStartBinding ? range.start : 0,
    hasEndArrowhead || hasEndBinding ? range.end : 1
  );
  return clampedPosition;
}
function furthest(from2, candidates) {
  let furthest2 = null;
  let furthestDist = -Infinity;
  for (const candidate of candidates) {
    const dist = Vec.Dist2(from2, candidate);
    if (dist > furthestDist) {
      furthest2 = candidate;
      furthestDist = dist;
    }
  }
  return furthest2;
}
function getArrowLabelFontSize(shape) {
  return ARROW_LABEL_FONT_SIZES[shape.props.size] * shape.props.scale;
}
function getArrowLabelDefaultPosition(editor, shape) {
  const info = getArrowInfo(editor, shape);
  switch (info.type) {
    case "straight":
    case "arc":
      return 0.5;
    case "elbow": {
      const midpointHandle = info.route.midpointHandle;
      const bodyGeom = getArrowBodyGeometry(editor, shape);
      if (midpointHandle && bodyGeom) {
        return bodyGeom.uninterpolateAlongEdge(midpointHandle.point);
      }
      return 0.5;
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
}
function isOverArrowLabel(editor, shape) {
  if (!editor.isShapeOfType(shape, "arrow")) return false;
  const pointInShapeSpace = editor.getPointInShapeSpace(shape, editor.inputs.currentPagePoint);
  const labelGeometry = editor.getShapeGeometry(shape).children[1];
  return labelGeometry && pointInPolygon(pointInShapeSpace, labelGeometry.vertices);
}
function getArrowPoints(info, side, strokeWidth) {
  const point = side === "end" ? info.end.point : info.start.point;
  let int;
  switch (info.type) {
    case "straight": {
      const opposite = side === "end" ? info.start.point : info.end.point;
      const compareLength = Vec.Dist(opposite, point);
      const length = clamp$3(compareLength / 5, strokeWidth, strokeWidth * 3);
      int = Vec.Nudge(point, opposite, length);
      break;
    }
    case "arc": {
      const compareLength = Math.abs(info.bodyArc.length);
      const length = clamp$3(compareLength / 5, strokeWidth, strokeWidth * 3);
      const intersections = intersectCircleCircle(
        point,
        length,
        info.handleArc.center,
        info.handleArc.radius
      );
      int = side === "end" ? info.handleArc.sweepFlag ? intersections[0] : intersections[1] : info.handleArc.sweepFlag ? intersections[1] : intersections[0];
      break;
    }
    case "elbow": {
      const previousPoint = side === "end" ? info.route.points[info.route.points.length - 2] : info.route.points[1];
      const previousSegmentLength = Vec.ManhattanDist(previousPoint, point);
      const length = clamp$3(previousSegmentLength / 2, strokeWidth, strokeWidth * 3);
      int = previousPoint ? Vec.Nudge(point, previousPoint, length) : point;
      break;
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
  if (Vec.IsNaN(int)) {
    int = point;
  }
  return { point, int };
}
function getArrowhead({ point, int }) {
  const PL = Vec.RotWith(int, point, PI$1 / 6);
  const PR = Vec.RotWith(int, point, -PI$1 / 6);
  return `M ${PL.x} ${PL.y} L ${point.x} ${point.y} L ${PR.x} ${PR.y}`;
}
function getTriangleHead({ point, int }) {
  const PL = Vec.RotWith(int, point, PI$1 / 6);
  const PR = Vec.RotWith(int, point, -PI$1 / 6);
  return `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y} L ${point.x} ${point.y} Z`;
}
function getInvertedTriangleHead({ point, int }) {
  const d = Vec.Sub(int, point).div(2);
  const PL = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  return `M ${PL.x} ${PL.y} L ${int.x} ${int.y} L ${PR.x} ${PR.y} Z`;
}
function getDotHead({ point, int }) {
  const A = Vec.Lrp(point, int, 0.45);
  const r = Vec.Dist(A, point);
  return `M ${A.x - r},${A.y}
  a ${r},${r} 0 1,0 ${r * 2},0
  a ${r},${r} 0 1,0 -${r * 2},0 `;
}
function getDiamondHead({ point, int }) {
  const PB = Vec.Lrp(point, int, 0.75);
  const PL = Vec.RotWith(PB, point, PI$1 / 4);
  const PR = Vec.RotWith(PB, point, -PI$1 / 4);
  const PQ = Vec.Lrp(PL, PR, 0.5);
  PQ.add(Vec.Sub(PQ, point));
  return `M ${PQ.x} ${PQ.y} L ${PR.x} ${PR.y} ${point.x} ${point.y} L ${PL.x} ${PL.y} Z`;
}
function getSquareHead({ int, point }) {
  const PB = Vec.Lrp(point, int, 0.85);
  const d = Vec.Sub(PB, point).div(2);
  const PL1 = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR1 = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  const PL2 = Vec.Add(PB, Vec.Rot(d, HALF_PI));
  const PR2 = Vec.Sub(PB, Vec.Rot(d, HALF_PI));
  return `M ${PL1.x} ${PL1.y} L ${PL2.x} ${PL2.y} L ${PR2.x} ${PR2.y} L ${PR1.x} ${PR1.y} Z`;
}
function getBarHead({ int, point }) {
  const d = Vec.Sub(int, point).div(2);
  const PL = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  return `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y}`;
}
function getArrowheadPathForType(info, side, strokeWidth) {
  const type = side === "end" ? info.end.arrowhead : info.start.arrowhead;
  if (type === "none") return;
  const points = getArrowPoints(info, side, strokeWidth);
  if (!points) return;
  switch (type) {
    case "bar":
      return getBarHead(points);
    case "square":
      return getSquareHead(points);
    case "diamond":
      return getDiamondHead(points);
    case "dot":
      return getDotHead(points);
    case "inverted":
      return getInvertedTriangleHead(points);
    case "arrow":
      return getArrowhead(points);
    case "triangle":
      return getTriangleHead(points);
  }
  return "";
}
function ElbowArrowDebug({ arrow: arrow2 }) {
  const editor = useEditor();
  const info = useValue(
    "elbow arrow grid",
    () => {
      try {
        const info2 = getElbowArrowInfo(
          editor,
          editor.getShape(arrow2.id),
          getArrowBindings(editor, arrow2)
        );
        return info2;
      } catch (err) {
        console.error(err);
        return void 0;
      }
    },
    [editor, arrow2.id]
  );
  if (!info) return null;
  const fullBox = Box.Common([info.A.original, info.B.original]).expandBy(50);
  const label = info.route?.name ?? "";
  const midPoint = info.route?.midpointHandle;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    info.midX !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: { x: info.midX, y: fullBox.minY },
        b: { x: info.midX, y: fullBox.maxY },
        stroke: "red"
      }
    ),
    info.midY !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: { x: fullBox.minX, y: info.midY },
        b: { x: fullBox.maxX, y: info.midY },
        stroke: "blue"
      }
    ),
    midPoint?.axis === "x" && info.midXRange && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: { x: info.midXRange.lo, y: midPoint.point.y },
        b: { x: info.midXRange.hi, y: midPoint.point.y },
        stroke: "red",
        strokeDasharray: "0 2"
      }
    ),
    midPoint?.axis === "y" && info.midYRange && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: { x: midPoint.point.x, y: info.midYRange.lo },
        b: { x: midPoint.point.x, y: info.midYRange.hi },
        stroke: "blue",
        strokeDasharray: "0 2"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugBox, { box: info.A.original, stroke: "orange" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugBox, { box: info.A.expanded, stroke: "orange", strokeWidth: 0.5 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugBox,
      {
        box: info.A.original.clone().expandBy(info.options.minElbowLegLength),
        stroke: "orange",
        strokeWidth: 0.5
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugBox, { box: info.B.original, stroke: "lightskyblue" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugBox, { box: info.B.expanded, stroke: "lightskyblue", strokeWidth: 0.5 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugBox,
      {
        box: info.B.original.clone().expandBy(info.options.minElbowLegLength),
        stroke: "lightskyblue",
        strokeWidth: 0.5
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.A.edges.top, axis: "x", stroke: "orange" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.B.edges.top, axis: "x", stroke: "lightskyblue" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.A.edges.right, axis: "y", stroke: "orange" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.B.edges.right, axis: "y", stroke: "lightskyblue" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.A.edges.bottom, axis: "x", stroke: "orange" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.B.edges.bottom, axis: "x", stroke: "lightskyblue" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.A.edges.left, axis: "y", stroke: "orange" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.B.edges.left, axis: "y", stroke: "lightskyblue" }),
    info.route && /* @__PURE__ */ jsxRuntimeExports.jsx(DebugRoute, { route: info.route.points, strokeWidth: 10 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "text",
      {
        x: fullBox.minX + 5,
        y: fullBox.minY - 3,
        fontSize: 10,
        fill: "black",
        stroke: "var(--tl-color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: label
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "text",
      {
        x: info.A.expanded.x,
        y: info.A.expanded.y,
        fontSize: 10,
        fill: "black",
        stroke: "var(--tl-color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: [
          "A",
          info.route && `, ${info.route.aEdgePicking}`,
          info.A.isPoint && `, point`
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "text",
      {
        x: info.B.expanded.x,
        y: info.B.expanded.y,
        fontSize: 10,
        fill: "black",
        stroke: "var(--tl-color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: [
          "B",
          info.route && `, ${info.route.bEdgePicking}`,
          info.B.isPoint && `, point`
        ]
      }
    )
  ] });
}
function DebugLine({ a, b, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "line",
    {
      fill: "none",
      strokeWidth: 1,
      strokeDasharray: "4,4",
      stroke: "green",
      x1: a.x,
      y1: a.y,
      x2: b.x,
      y2: b.y,
      ...props
    }
  );
}
function DebugRoute({ route, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "polyline",
    {
      fill: "none",
      stroke: "darkorchid",
      strokeWidth: 3,
      opacity: 0.5,
      points: route.map((r) => `${r.x},${r.y}`).join(" "),
      ...props
    }
  );
}
function DebugEdge({
  edge,
  axis,
  ...props
}) {
  if (!edge || edge.expanded === null) return null;
  const vec = (vec2) => axis === "x" ? { x: vec2.y, y: vec2.x } : vec2;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: vec({ x: edge.expanded, y: edge.cross.min }),
        b: vec({ x: edge.expanded, y: edge.cross.max }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: vec({ x: edge.expanded - 4, y: edge.cross.min }),
        b: vec({ x: edge.expanded + 4, y: edge.cross.min }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: vec({ x: edge.expanded - 4, y: edge.cross.max }),
        b: vec({ x: edge.expanded + 4, y: edge.cross.max }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    )
  ] });
}
function DebugBox({ box, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "rect",
    {
      x: box.minX,
      y: box.minY,
      width: box.width,
      height: box.height,
      strokeDasharray: "4,4",
      strokeWidth: 1,
      fill: "none",
      ...props
    }
  );
}
const snapLinesStore = new WeakCache();
function getElbowArrowSnapLines(editor) {
  return snapLinesStore.get(editor, (editor2) => {
    const currentSelectedArrowShape = computed("current selected arrow shape", () => {
      const shape = editor2.getOnlySelectedShape();
      if (!shape || !editor2.isShapeOfType(shape, "arrow")) return null;
      return shape.id;
    });
    const unselectedArrowShapeIds = editor2.store.query.ids("shape", () => {
      const activeArrowShapeId = currentSelectedArrowShape.get();
      if (!activeArrowShapeId) return { type: { eq: "arrow" } };
      return {
        type: { eq: "arrow" },
        id: { neq: activeArrowShapeId }
      };
    });
    return computed("elbow arrow snap lines", () => {
      const result = /* @__PURE__ */ new Map();
      const currentPageShapeIds = editor2.getCurrentPageShapeIds();
      const viewportBounds = editor2.getViewportPageBounds();
      for (const id of unselectedArrowShapeIds.get()) {
        if (!currentPageShapeIds.has(id)) continue;
        const shape = editor2.getShape(id);
        if (shape?.type !== "arrow") continue;
        const shapeBounds = editor2.getShapePageBounds(id);
        if (!shapeBounds || !viewportBounds.includes(shapeBounds)) continue;
        const bindings = getArrowBindings(editor2, shape);
        const pageTransform = editor2.getShapePageTransform(id);
        if (!pageTransform) continue;
        const geometry = editor2.getShapeGeometry(id);
        const pageVertices = pageTransform.applyToPoints(geometry.vertices);
        for (let i = 1; i < pageVertices.length; i++) {
          const prev = pageVertices[i - 1];
          const curr = pageVertices[i];
          let angle = Vec.Angle(prev, curr);
          if (angle < 0) angle += Math.PI;
          let set = result.get(angle);
          if (!set) {
            set = /* @__PURE__ */ new Set();
            result.set(angle, set);
          }
          const perpDistance = perpDistanceToLineAngle(prev, angle);
          set.add({
            perpDistance,
            startBoundShapeId: bindings.start?.toId,
            endBoundShapeId: bindings.end?.toId
          });
        }
      }
      return result;
    });
  }).get();
}
function perpDistanceToLineAngle(pointOnLine, lineAngle) {
  const perpDir = Vec.FromAngle(lineAngle).per();
  return Vec.Dpr(pointOnLine, perpDir);
}
class ArrowShapeUtil extends ShapeUtil {
  static type = "arrow";
  static props = arrowShapeProps;
  static migrations = arrowShapeMigrations;
  options = {
    expandElbowLegLength: {
      s: 28,
      m: 36,
      l: 44,
      xl: 66
    },
    minElbowLegLength: {
      s: STROKE_SIZES.s * 3,
      m: STROKE_SIZES.m * 3,
      l: STROKE_SIZES.l * 3,
      xl: STROKE_SIZES.xl * 3
    },
    minElbowHandleDistance: 16,
    arcArrowCenterSnapDistance: 16,
    elbowArrowCenterSnapDistance: 24,
    elbowArrowEdgeSnapDistance: 20,
    elbowArrowPointSnapDistance: 24,
    elbowArrowAxisSnapDistance: 16,
    labelCenterSnapDistance: 10,
    elbowMidpointSnapDistance: 10,
    elbowMinSegmentLengthToShowMidpointHandle: 20,
    hoverPreciseTimeout: 600,
    pointingPreciseTimeout: 320,
    shouldBeExact: (editor) => editor.inputs.altKey,
    shouldIgnoreTargets: (editor) => editor.inputs.ctrlKey
  };
  canEdit() {
    return true;
  }
  canBind({ toShapeType }) {
    return toShapeType !== "arrow";
  }
  canSnap() {
    return false;
  }
  hideResizeHandles() {
    return true;
  }
  hideRotateHandle() {
    return true;
  }
  hideSelectionBoundsBg() {
    return true;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  hideInMinimap() {
    return true;
  }
  canBeLaidOut(shape, info) {
    if (info.type === "flip") {
      const bindings = getArrowBindings(this.editor, shape);
      const { start, end } = bindings;
      const { shapes = [] } = info;
      if (start && !shapes.find((s) => s.id === start.toId)) return false;
      if (end && !shapes.find((s) => s.id === end.toId)) return false;
    }
    return true;
  }
  getFontFaces(shape) {
    if (isEmptyRichText(shape.props.richText)) return EMPTY_ARRAY;
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  getDefaultProps() {
    return {
      kind: "arc",
      elbowMidPoint: 0.5,
      dash: "draw",
      size: "m",
      fill: "none",
      color: "black",
      labelColor: "black",
      bend: 0,
      start: { x: 0, y: 0 },
      end: { x: 2, y: 0 },
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      richText: toRichText(""),
      labelPosition: 0.5,
      font: "draw",
      scale: 1
    };
  }
  getGeometry(shape) {
    const isEditing = this.editor.getEditingShapeId() === shape.id;
    const info = getArrowInfo(this.editor, shape);
    const debugGeom = [];
    const bodyGeom = info.type === "straight" ? new Edge2d({
      start: Vec.From(info.start.point),
      end: Vec.From(info.end.point)
    }) : info.type === "arc" ? new Arc2d({
      center: Vec.Cast(info.handleArc.center),
      start: Vec.Cast(info.start.point),
      end: Vec.Cast(info.end.point),
      sweepFlag: info.bodyArc.sweepFlag,
      largeArcFlag: info.bodyArc.largeArcFlag
    }) : new Polyline2d({ points: info.route.points });
    let labelGeom;
    if (isEditing || !isEmptyRichText(shape.props.richText)) {
      const labelPosition = getArrowLabelPosition(this.editor, shape);
      if (debugFlags.debugGeometry.get()) {
        debugGeom.push(...labelPosition.debugGeom);
      }
      labelGeom = new Rectangle2d({
        x: labelPosition.box.x,
        y: labelPosition.box.y,
        width: labelPosition.box.w,
        height: labelPosition.box.h,
        isFilled: true,
        isLabel: true
      });
    }
    return new Group2d({
      children: [...labelGeom ? [bodyGeom, labelGeom] : [bodyGeom], ...debugGeom]
    });
  }
  getHandles(shape) {
    const info = getArrowInfo(this.editor, shape);
    const handles = [
      {
        id: "start",
        type: "vertex",
        index: "a1",
        x: info.start.handle.x,
        y: info.start.handle.y
      },
      {
        id: "end",
        type: "vertex",
        index: "a3",
        x: info.end.handle.x,
        y: info.end.handle.y
      }
    ];
    if (shape.props.kind === "arc" && (info.type === "straight" || info.type === "arc")) {
      handles.push({
        id: "middle",
        type: "virtual",
        index: "a2",
        x: info.middle.x,
        y: info.middle.y
      });
    }
    if (shape.props.kind === "elbow" && info.type === "elbow" && info.route.midpointHandle) {
      const shapePageTransform = this.editor.getShapePageTransform(shape.id);
      const segmentStart = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentStart);
      const segmentEnd = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentEnd);
      const segmentLength = Vec.Dist(segmentStart, segmentEnd) * this.editor.getZoomLevel();
      if (segmentLength > this.options.elbowMinSegmentLengthToShowMidpointHandle) {
        handles.push({
          id: "middle",
          type: "vertex",
          index: "a2",
          x: info.route.midpointHandle.point.x,
          y: info.route.midpointHandle.point.y
        });
      }
    }
    return handles;
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  onHandleDrag(shape, info) {
    const handleId = info.handle.id;
    switch (handleId) {
      case "middle":
        switch (shape.props.kind) {
          case "arc":
            return this.onArcMidpointHandleDrag(shape, info);
          case "elbow":
            return this.onElbowMidpointHandleDrag(shape, info);
          default:
            exhaustiveSwitchError(shape.props.kind);
        }
      case "start":
      case "end":
        return this.onTerminalHandleDrag(shape, info, handleId);
      default:
        exhaustiveSwitchError(handleId);
    }
  }
  onArcMidpointHandleDrag(shape, { handle }) {
    const bindings = getArrowBindings(this.editor, shape);
    const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const delta = Vec.Sub(end, start);
    const v = Vec.Per(delta);
    const med = Vec.Med(end, start);
    const A = Vec.Sub(med, v);
    const B = Vec.Add(med, v);
    const point = Vec.NearestPointOnLineSegment(A, B, handle, false);
    let bend = Vec.Dist(point, med);
    if (Vec.Clockwise(point, end, med)) bend *= -1;
    return { id: shape.id, type: shape.type, props: { bend } };
  }
  onElbowMidpointHandleDrag(shape, { handle }) {
    const info = getArrowInfo(this.editor, shape);
    if (info?.type !== "elbow") return;
    const shapeToPageTransform = this.editor.getShapePageTransform(shape.id);
    const handlePagePoint = shapeToPageTransform.applyToPoint(handle);
    const axisName = info.route.midpointHandle?.axis;
    if (!axisName) return;
    const axis = ElbowArrowAxes[axisName];
    const midRange = info.elbow[axis.midRange];
    if (!midRange) return;
    let angle = Vec.Angle(
      shapeToPageTransform.applyToPoint(axis.v(0, 0)),
      shapeToPageTransform.applyToPoint(axis.v(0, 1))
    );
    if (angle < 0) angle += Math.PI;
    const handlePoint = perpDistanceToLineAngle(handlePagePoint, angle);
    const loPoint = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(midRange.lo, 0)),
      angle
    );
    const hiPoint = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(midRange.hi, 0)),
      angle
    );
    const maxSnapDistance = this.options.elbowMidpointSnapDistance / this.editor.getZoomLevel();
    const midPoint = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(lerp(midRange.lo, midRange.hi, 0.5), 0)),
      angle
    );
    let snapPoint = midPoint;
    let snapDistance = Math.abs(midPoint - handlePoint);
    for (const [snapAngle2, snapLines] of getElbowArrowSnapLines(this.editor)) {
      const { isParallel, isFlippedParallel } = anglesAreApproximatelyParallel(angle, snapAngle2);
      if (isParallel || isFlippedParallel) {
        for (const snapLine of snapLines) {
          const doesShareStartIntersection = snapLine.startBoundShapeId && (snapLine.startBoundShapeId === info.bindings.start?.toId || snapLine.startBoundShapeId === info.bindings.end?.toId);
          const doesShareEndIntersection = snapLine.endBoundShapeId && (snapLine.endBoundShapeId === info.bindings.start?.toId || snapLine.endBoundShapeId === info.bindings.end?.toId);
          if (!doesShareStartIntersection && !doesShareEndIntersection) continue;
          const point = isFlippedParallel ? -snapLine.perpDistance : snapLine.perpDistance;
          const distance = Math.abs(point - handlePoint);
          if (distance < snapDistance) {
            snapPoint = point;
            snapDistance = distance;
          }
        }
      }
    }
    if (snapDistance > maxSnapDistance) {
      snapPoint = handlePoint;
    }
    const newMid = clamp$3(invLerp(loPoint, hiPoint, snapPoint), 0, 1);
    return {
      id: shape.id,
      type: shape.type,
      props: {
        elbowMidPoint: newMid
      }
    };
  }
  onTerminalHandleDrag(shape, { handle, isPrecise }, handleId) {
    const bindings = getArrowBindings(this.editor, shape);
    const update = { id: shape.id, type: "arrow", props: {} };
    const currentBinding = bindings[handleId];
    const oppositeHandleId = handleId === "start" ? "end" : "start";
    const oppositeBinding = bindings[oppositeHandleId];
    const targetInfo = updateArrowTargetState({
      editor: this.editor,
      pointInPageSpace: this.editor.getShapePageTransform(shape.id).applyToPoint(handle),
      arrow: shape,
      isPrecise,
      currentBinding,
      oppositeBinding
    });
    if (!targetInfo) {
      removeArrowBinding(this.editor, shape, handleId);
      const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor);
      update.props[handleId] = {
        x: newPoint.x,
        y: newPoint.y
      };
      return update;
    }
    const bindingProps = {
      terminal: handleId,
      normalizedAnchor: targetInfo.normalizedAnchor,
      isPrecise: targetInfo.isPrecise,
      isExact: targetInfo.isExact,
      snap: targetInfo.snap
    };
    createOrUpdateArrowBinding(this.editor, shape, targetInfo.target.id, bindingProps);
    const newBindings = getArrowBindings(this.editor, shape);
    if (newBindings.start && newBindings.end && newBindings.start.toId === newBindings.end.toId) {
      if (Vec.Equals(newBindings.start.props.normalizedAnchor, newBindings.end.props.normalizedAnchor)) {
        createOrUpdateArrowBinding(this.editor, shape, newBindings.end.toId, {
          ...newBindings.end.props,
          normalizedAnchor: {
            x: newBindings.end.props.normalizedAnchor.x + 0.05,
            y: newBindings.end.props.normalizedAnchor.y
          }
        });
      }
    }
    return update;
  }
  onTranslateStart(shape) {
    const bindings = getArrowBindings(this.editor, shape);
    if (shape.props.kind === "elbow" && this.editor.getOnlySelectedShapeId() === shape.id) {
      const info = getArrowInfo(this.editor, shape);
      if (!info) return;
      const update = { id: shape.id, type: "arrow", props: {} };
      if (bindings.start) {
        update.props.start = { x: info.start.point.x, y: info.start.point.y };
        removeArrowBinding(this.editor, shape, "start");
      }
      if (bindings.end) {
        update.props.end = { x: info.end.point.x, y: info.end.point.y };
        removeArrowBinding(this.editor, shape, "end");
      }
      return update;
    }
    const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const shapePageTransform = this.editor.getShapePageTransform(shape.id);
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    if (bindings.start && (selectedShapeIds.includes(bindings.start.toId) || this.editor.isAncestorSelected(bindings.start.toId)) || bindings.end && (selectedShapeIds.includes(bindings.end.toId) || this.editor.isAncestorSelected(bindings.end.toId))) {
      return;
    }
    shapeAtTranslationStart.set(shape, {
      pagePosition: shapePageTransform.applyToPoint(shape),
      terminalBindings: mapObjectMapValues(terminalsInArrowSpace, (terminalName, point) => {
        const binding = bindings[terminalName];
        if (!binding) return null;
        return {
          binding,
          shapePosition: point,
          pagePosition: shapePageTransform.applyToPoint(point)
        };
      })
    });
    if (bindings.start) {
      updateArrowTerminal({
        editor: this.editor,
        arrow: shape,
        terminal: "start",
        useHandle: true
      });
      shape = this.editor.getShape(shape.id);
    }
    if (bindings.end) {
      updateArrowTerminal({
        editor: this.editor,
        arrow: shape,
        terminal: "end",
        useHandle: true
      });
    }
    for (const handleName of [
      "start",
      "end"
      /* End */
    ]) {
      const binding = bindings[handleName];
      if (!binding) continue;
      this.editor.updateBinding({
        ...binding,
        props: { ...binding.props, isPrecise: true }
      });
    }
    return;
  }
  onTranslate(initialShape, shape) {
    const atTranslationStart = shapeAtTranslationStart.get(initialShape);
    if (!atTranslationStart) return;
    const shapePageTransform = this.editor.getShapePageTransform(shape.id);
    const pageDelta = Vec.Sub(
      shapePageTransform.applyToPoint(shape),
      atTranslationStart.pagePosition
    );
    for (const terminalBinding of Object.values(atTranslationStart.terminalBindings)) {
      if (!terminalBinding) continue;
      const newPagePoint = Vec.Add(terminalBinding.pagePosition, Vec.Mul(pageDelta, 0.5));
      const newTarget = this.editor.getShapeAtPoint(newPagePoint, {
        hitInside: true,
        hitFrameInside: true,
        margin: 0,
        filter: (targetShape) => {
          return !targetShape.isLocked && this.editor.canBindShapes({ fromShape: shape, toShape: targetShape, binding: "arrow" });
        }
      });
      if (newTarget?.id === terminalBinding.binding.toId) {
        const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(newTarget).bounds);
        const pointInTargetSpace = this.editor.getPointInShapeSpace(newTarget, newPagePoint);
        const normalizedAnchor = {
          x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
          y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height
        };
        createOrUpdateArrowBinding(this.editor, shape, newTarget.id, {
          ...terminalBinding.binding.props,
          normalizedAnchor,
          isPrecise: true
        });
      } else {
        removeArrowBinding(this.editor, shape, terminalBinding.binding.props.terminal);
      }
    }
  }
  _resizeInitialBindings = new WeakCache();
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    const bindings = this._resizeInitialBindings.get(
      shape,
      () => getArrowBindings(this.editor, shape)
    );
    const terminals = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const { start, end } = structuredClone(shape.props);
    let { bend } = shape.props;
    if (!bindings.start) {
      start.x = terminals.start.x * scaleX;
      start.y = terminals.start.y * scaleY;
    }
    if (!bindings.end) {
      end.x = terminals.end.x * scaleX;
      end.y = terminals.end.y * scaleY;
    }
    const mx = Math.abs(scaleX);
    const my = Math.abs(scaleY);
    const startNormalizedAnchor = bindings?.start ? Vec.From(bindings.start.props.normalizedAnchor) : null;
    const endNormalizedAnchor = bindings?.end ? Vec.From(bindings.end.props.normalizedAnchor) : null;
    if (scaleX < 0 && scaleY >= 0) {
      if (bend !== 0) {
        bend *= -1;
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.x = 1 - startNormalizedAnchor.x;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.x = 1 - endNormalizedAnchor.x;
      }
    } else if (scaleX >= 0 && scaleY < 0) {
      if (bend !== 0) {
        bend *= -1;
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.y = 1 - startNormalizedAnchor.y;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.y = 1 - endNormalizedAnchor.y;
      }
    } else if (scaleX >= 0 && scaleY >= 0) {
      if (bend !== 0) {
        bend *= Math.max(mx, my);
      }
    } else if (scaleX < 0 && scaleY < 0) {
      if (bend !== 0) {
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.x = 1 - startNormalizedAnchor.x;
        startNormalizedAnchor.y = 1 - startNormalizedAnchor.y;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.x = 1 - endNormalizedAnchor.x;
        endNormalizedAnchor.y = 1 - endNormalizedAnchor.y;
      }
    }
    if (bindings.start && startNormalizedAnchor) {
      createOrUpdateArrowBinding(this.editor, shape, bindings.start.toId, {
        ...bindings.start.props,
        normalizedAnchor: startNormalizedAnchor.toJson()
      });
    }
    if (bindings.end && endNormalizedAnchor) {
      createOrUpdateArrowBinding(this.editor, shape, bindings.end.toId, {
        ...bindings.end.props,
        normalizedAnchor: endNormalizedAnchor.toJson()
      });
    }
    const next = {
      props: {
        start,
        end,
        bend
      }
    };
    return next;
  }
  onDoubleClickHandle(shape, handle) {
    switch (handle.id) {
      case "start": {
        return {
          id: shape.id,
          type: shape.type,
          props: {
            ...shape.props,
            arrowheadStart: shape.props.arrowheadStart === "none" ? "arrow" : "none"
          }
        };
      }
      case "end": {
        return {
          id: shape.id,
          type: shape.type,
          props: {
            ...shape.props,
            arrowheadEnd: shape.props.arrowheadEnd === "none" ? "arrow" : "none"
          }
        };
      }
    }
  }
  component(shape) {
    const theme = useDefaultColorTheme();
    const onlySelectedShape = this.editor.getOnlySelectedShape();
    const shouldDisplayHandles = this.editor.isInAny(
      "select.idle",
      "select.pointing_handle",
      "select.dragging_handle",
      "select.translating",
      "arrow.dragging"
    ) && !this.editor.getIsReadonly();
    const info = getArrowInfo(this.editor, shape);
    if (!info?.isValid) return null;
    const labelPosition = getArrowLabelPosition(this.editor, shape);
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const isEditing = this.editor.getEditingShapeId() === shape.id;
    const showArrowLabel = isEditing || !isEmptyRichText(shape.props.richText);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(SVGContainer, { style: { minWidth: 50, minHeight: 50 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ArrowSvg,
          {
            shape,
            shouldDisplayHandles: shouldDisplayHandles && onlySelectedShape?.id === shape.id
          }
        ),
        shape.props.kind === "elbow" && debugFlags.debugElbowArrows.get() && /* @__PURE__ */ jsxRuntimeExports.jsx(ElbowArrowDebug, { arrow: shape })
      ] }),
      showArrowLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(
        RichTextLabel,
        {
          shapeId: shape.id,
          type: "arrow",
          font: shape.props.font,
          fontSize: getArrowLabelFontSize(shape),
          lineHeight: TEXT_PROPS.lineHeight,
          align: "middle",
          verticalAlign: "middle",
          labelColor: getColorValue(theme, shape.props.labelColor, "solid"),
          richText: shape.props.richText,
          textWidth: labelPosition.box.w - ARROW_LABEL_PADDING * 2 * shape.props.scale,
          isSelected,
          padding: 0,
          style: {
            transform: `translate(${labelPosition.box.center.x}px, ${labelPosition.box.center.y}px)`
          }
        }
      )
    ] });
  }
  indicator(shape) {
    const isEditing = useIsEditing(shape.id);
    const clipPathId = useSharedSafeId(shape.id + "_clip");
    const info = getArrowInfo(this.editor, shape);
    if (!info) return null;
    const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, info?.bindings);
    const geometry = this.editor.getShapeGeometry(shape);
    const bounds = geometry.bounds;
    const isEmpty = isEmptyRichText(shape.props.richText);
    const labelGeometry = isEditing || !isEmpty ? geometry.children[1] : null;
    if (Vec.Equals(start, end)) return null;
    const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale;
    const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
    const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
    const includeClipPath = as && info.start.arrowhead !== "arrow" || ae && info.end.arrowhead !== "arrow" || !!labelGeometry;
    const labelBounds = labelGeometry ? labelGeometry.getBounds() : new Box(0, 0, 0, 0);
    if (isEditing && labelGeometry) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          x: toDomPrecision(labelBounds.x),
          y: toDomPrecision(labelBounds.y),
          width: labelBounds.w,
          height: labelBounds.h,
          rx: 3.5 * shape.props.scale,
          ry: 3.5 * shape.props.scale
        }
      );
    }
    const clipStartArrowhead = !(info.start.arrowhead === "none" || info.start.arrowhead === "arrow");
    const clipEndArrowhead = !(info.end.arrowhead === "none" || info.end.arrowhead === "arrow");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
      includeClipPath && /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ArrowClipPath,
        {
          radius: 3.5 * shape.props.scale,
          hasText: !isEmpty,
          bounds,
          labelBounds,
          as: clipStartArrowhead && as ? as : "",
          ae: clipEndArrowhead && ae ? ae : ""
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "g",
        {
          style: {
            clipPath: includeClipPath ? `url(#${clipPathId})` : void 0,
            WebkitClipPath: includeClipPath ? `url(#${clipPathId})` : void 0
          },
          children: [
            includeClipPath && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "rect",
              {
                x: bounds.minX - 100,
                y: bounds.minY - 100,
                width: bounds.width + 200,
                height: bounds.height + 200,
                opacity: 0
              }
            ),
            getArrowBodyPath(
              shape,
              info,
              shape.props.dash === "draw" ? {
                style: "draw",
                randomSeed: shape.id,
                strokeWidth: 1,
                passes: 1,
                offset: 0,
                roundness: strokeWidth * 2,
                props: { strokeWidth: void 0 }
              } : { style: "solid", strokeWidth: 1, props: { strokeWidth: void 0 } }
            )
          ]
        }
      ),
      as && /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: as }),
      ae && /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: ae }),
      labelGeometry && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          x: toDomPrecision(labelBounds.x),
          y: toDomPrecision(labelBounds.y),
          width: labelBounds.w,
          height: labelBounds.h,
          rx: 3.5,
          ry: 3.5
        }
      )
    ] });
  }
  onEditStart(shape) {
    if (isEmptyRichText(shape.props.richText)) {
      const labelPosition = getArrowLabelDefaultPosition(this.editor, shape);
      this.editor.updateShape({
        id: shape.id,
        type: shape.type,
        props: { labelPosition }
      });
    }
  }
  toSvg(shape, ctx) {
    ctx.addExportDef(getFillDefForExport(shape.props.fill));
    const theme = getDefaultColorTheme(ctx);
    const scaleFactor = 1 / shape.props.scale;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { transform: `scale(${scaleFactor})`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowSvg, { shape, shouldDisplayHandles: false }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        RichTextSVG,
        {
          fontSize: getArrowLabelFontSize(shape),
          font: shape.props.font,
          align: "middle",
          verticalAlign: "middle",
          labelColor: getColorValue(theme, shape.props.labelColor, "solid"),
          richText: shape.props.richText,
          bounds: getArrowLabelPosition(this.editor, shape).box.clone().expandBy(-ARROW_LABEL_PADDING * shape.props.scale),
          padding: 0,
          showTextOutline: true
        }
      )
    ] });
  }
  getCanvasSvgDefs() {
    return [
      getFillDefForCanvas(),
      {
        key: `arrow:dot`,
        component: ArrowheadDotDef
      },
      {
        key: `arrow:cross`,
        component: ArrowheadCrossDef
      }
    ];
  }
  getInterpolatedProps(startShape, endShape, progress) {
    return {
      ...progress > 0.5 ? endShape.props : startShape.props,
      scale: lerp(startShape.props.scale, endShape.props.scale, progress),
      start: {
        x: lerp(startShape.props.start.x, endShape.props.start.x, progress),
        y: lerp(startShape.props.start.y, endShape.props.start.y, progress)
      },
      end: {
        x: lerp(startShape.props.end.x, endShape.props.end.x, progress),
        y: lerp(startShape.props.end.y, endShape.props.end.y, progress)
      },
      bend: lerp(startShape.props.bend, endShape.props.bend, progress),
      labelPosition: lerp(startShape.props.labelPosition, endShape.props.labelPosition, progress)
    };
  }
}
const ArrowSvg = track(function ArrowSvg2({
  shape,
  shouldDisplayHandles
}) {
  const editor = useEditor();
  const theme = useDefaultColorTheme();
  const info = getArrowInfo(editor, shape);
  const isForceSolid = useValue(
    "force solid",
    () => {
      return editor.getZoomLevel() < 0.2;
    },
    [editor]
  );
  const clipPathId = useSharedSafeId(shape.id + "_clip");
  const arrowheadDotId = useSharedSafeId("arrowhead-dot");
  const arrowheadCrossId = useSharedSafeId("arrowhead-cross");
  const isEditing = useIsEditing(shape.id);
  const geometry = editor.getShapeGeometry(shape);
  if (!geometry) return null;
  const bounds = Box.ZeroFix(geometry.bounds);
  const bindings = getArrowBindings(editor, shape);
  const isEmpty = isEmptyRichText(shape.props.richText);
  if (!info?.isValid) return null;
  const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale;
  const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
  const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
  let handlePath = null;
  if (shouldDisplayHandles && (bindings.start || bindings.end)) {
    handlePath = getArrowHandlePath(info, {
      style: "dashed",
      start: "skip",
      end: "skip",
      lengthRatio: 2.5,
      strokeWidth: 2 / editor.getZoomLevel(),
      props: {
        className: "tl-arrow-hint",
        markerStart: bindings.start ? bindings.start.props.isExact ? "" : bindings.start.props.isPrecise ? `url(#${arrowheadCrossId})` : `url(#${arrowheadDotId})` : "",
        markerEnd: bindings.end ? bindings.end.props.isExact ? "" : bindings.end.props.isPrecise ? `url(#${arrowheadCrossId})` : `url(#${arrowheadDotId})` : "",
        opacity: 0.16
      }
    });
  }
  const labelPosition = getArrowLabelPosition(editor, shape);
  const clipStartArrowhead = !(info.start.arrowhead === "none" || info.start.arrowhead === "arrow");
  const clipEndArrowhead = !(info.end.arrowhead === "none" || info.end.arrowhead === "arrow");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: clipPathId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ArrowClipPath,
      {
        radius: 3.5 * shape.props.scale,
        hasText: isEditing || !isEmpty,
        bounds,
        labelBounds: labelPosition.box,
        as: clipStartArrowhead && as ? as : "",
        ae: clipEndArrowhead && ae ? ae : ""
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "g",
      {
        fill: "none",
        stroke: getColorValue(theme, shape.props.color, "solid"),
        strokeWidth,
        strokeLinejoin: "round",
        strokeLinecap: "round",
        pointerEvents: "none",
        children: [
          handlePath,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "g",
            {
              style: {
                clipPath: `url(#${clipPathId})`,
                WebkitClipPath: `url(#${clipPathId})`
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "rect",
                  {
                    x: toDomPrecision(bounds.minX - 100),
                    y: toDomPrecision(bounds.minY - 100),
                    width: toDomPrecision(bounds.width + 200),
                    height: toDomPrecision(bounds.height + 200),
                    opacity: 0
                  }
                ),
                getArrowBodyPath(shape, info, {
                  style: shape.props.dash,
                  strokeWidth,
                  forceSolid: isForceSolid,
                  randomSeed: shape.id
                })
              ]
            }
          ),
          as && clipStartArrowhead && shape.props.fill !== "none" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ShapeFill,
            {
              theme,
              d: as,
              color: shape.props.color,
              fill: shape.props.fill,
              scale: shape.props.scale
            }
          ),
          ae && clipEndArrowhead && shape.props.fill !== "none" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ShapeFill,
            {
              theme,
              d: ae,
              color: shape.props.color,
              fill: shape.props.fill,
              scale: shape.props.scale
            }
          ),
          as && /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: as }),
          ae && /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: ae })
        ]
      }
    )
  ] });
});
function ArrowClipPath({
  radius,
  hasText,
  bounds,
  labelBounds,
  as,
  ae
}) {
  const path = reactExports.useMemo(() => {
    const path2 = new PathBuilder();
    path2.moveTo(bounds.left - 100, bounds.top - 100).lineTo(bounds.right + 100, bounds.top - 100).lineTo(bounds.right + 100, bounds.bottom + 100).lineTo(bounds.left - 100, bounds.bottom + 100).close();
    if (hasText) {
      path2.moveTo(labelBounds.left, labelBounds.top + radius).lineTo(labelBounds.left, labelBounds.bottom - radius).circularArcTo(radius, false, false, labelBounds.left + radius, labelBounds.bottom).lineTo(labelBounds.right - radius, labelBounds.bottom).circularArcTo(radius, false, false, labelBounds.right, labelBounds.bottom - radius).lineTo(labelBounds.right, labelBounds.top + radius).circularArcTo(radius, false, false, labelBounds.right - radius, labelBounds.top).lineTo(labelBounds.left + radius, labelBounds.top).circularArcTo(radius, false, false, labelBounds.left, labelBounds.top + radius).close();
    }
    return path2.toD();
  }, [
    radius,
    hasText,
    bounds.bottom,
    bounds.left,
    bounds.right,
    bounds.top,
    labelBounds.bottom,
    labelBounds.left,
    labelBounds.right,
    labelBounds.top
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: `${path}${as}${ae}` });
}
const shapeAtTranslationStart = /* @__PURE__ */ new WeakMap();
function ArrowheadDotDef() {
  const id = useSharedSafeId("arrowhead-dot");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("marker", { id, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "3", cy: "3", r: "2", strokeDasharray: "100%" }) });
}
function ArrowheadCrossDef() {
  const id = useSharedSafeId("arrowhead-cross");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("marker", { id, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1.5", y1: "1.5", x2: "4.5", y2: "4.5", strokeDasharray: "100%" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1.5", y1: "4.5", x2: "4.5", y2: "1.5", strokeDasharray: "100%" })
  ] });
}
function anglesAreApproximatelyParallel(a, b, tolerance = 1e-4) {
  const diff = Math.abs(a - b);
  const isParallel = diff < tolerance;
  const isFlippedParallel = Math.abs(diff - Math.PI) < tolerance;
  const is360Parallel = Math.abs(diff - PI2) < tolerance;
  return { isParallel: isParallel || is360Parallel, isFlippedParallel };
}
const LINK_ICON$1 = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
function HyperlinkButton({ url }) {
  const editor = useEditor();
  const hideButton = useValue("zoomLevel", () => editor.getZoomLevel() < 0.32, [editor]);
  const markAsHandledOnShiftKey = reactExports.useCallback(
    (e) => {
      if (!editor.inputs.shiftKey) editor.markEventAsHandled(e);
    },
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "a",
    {
      className: classNames("tl-hyperlink-button", {
        "tl-hyperlink-button__hidden": hideButton
      }),
      href: url,
      target: "_blank",
      rel: "noopener noreferrer",
      onPointerDown: markAsHandledOnShiftKey,
      onPointerUp: markAsHandledOnShiftKey,
      title: url,
      draggable: false,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "tl-hyperlink__icon",
          style: {
            mask: `url("${LINK_ICON$1}") center 100% / 100% no-repeat`,
            WebkitMask: `url("${LINK_ICON$1}") center 100% / 100% no-repeat`
          }
        }
      )
    }
  );
}
const LINK_ICON = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
const ROTATING_BOX_SHADOWS = [
  {
    offsetX: 0,
    offsetY: 2,
    blur: 4,
    spread: 0,
    color: "#00000029"
  },
  {
    offsetX: 0,
    offsetY: 3,
    blur: 6,
    spread: 0,
    color: "#0000001f"
  }
];
function getRotatedBoxShadow(rotation) {
  const cssStrings = ROTATING_BOX_SHADOWS.map((shadow) => {
    const { offsetX, offsetY, blur: blur2, spread, color } = shadow;
    const vec = new Vec(offsetX, offsetY);
    const { x, y } = vec.rot(-rotation);
    return `${x}px ${y}px ${blur2}px ${spread}px ${color}`;
  });
  return cssStrings.join(", ");
}
class BookmarkShapeUtil extends BaseBoxShapeUtil {
  static type = "bookmark";
  static props = bookmarkShapeProps;
  static migrations = bookmarkShapeMigrations;
  canResize() {
    return false;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  getText(shape) {
    return shape.props.url;
  }
  getAriaDescriptor(shape) {
    const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : null;
    if (!asset?.props.title) return void 0;
    return convertCommonTitleHTMLEntities(asset.props.title) + (asset.props.description ? ", " + asset.props.description : "");
  }
  getDefaultProps() {
    return {
      url: "",
      w: BOOKMARK_WIDTH,
      h: BOOKMARK_HEIGHT,
      assetId: null
    };
  }
  component(shape) {
    const { assetId, url, h: h2 } = shape.props;
    const rotation = this.editor.getShapePageTransform(shape).rotation();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BookmarkShapeComponent, { assetId, url, h: h2, rotation });
  }
  indicator(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BookmarkIndicatorComponent, { w: shape.props.w, h: shape.props.h });
  }
  onBeforeCreate(next) {
    return setBookmarkHeight(this.editor, next);
  }
  onBeforeUpdate(prev, shape) {
    if (prev.props.url !== shape.props.url) {
      if (!linkUrl.isValid(shape.props.url)) {
        return { ...shape, props: { ...shape.props, url: prev.props.url } };
      } else {
        updateBookmarkAssetOnUrlChange(this.editor, shape);
      }
    }
    if (prev.props.assetId !== shape.props.assetId) {
      return setBookmarkHeight(this.editor, shape);
    }
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
}
function BookmarkIndicatorComponent({ w, h: h2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: toDomPrecision(w), height: toDomPrecision(h2), rx: "6", ry: "6" });
}
function BookmarkShapeComponent({
  assetId,
  rotation,
  url,
  h: h2,
  showImageContainer = true
}) {
  const editor = useEditor();
  const asset = assetId ? editor.getAsset(assetId) : null;
  const isSafariExport = !!useSvgExportContext() && tlenv.isSafari;
  const address = getHumanReadableAddress(url);
  const [isFaviconValid, setIsFaviconValid] = reactExports.useState(true);
  const onFaviconError = () => setIsFaviconValid(false);
  const markAsHandledOnShiftKey = reactExports.useCallback(
    (e) => {
      if (!editor.inputs.shiftKey) editor.markEventAsHandled(e);
    },
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(HTMLContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classNames(
        "tl-bookmark__container",
        isSafariExport && "tl-bookmark__container--safariExport"
      ),
      style: {
        boxShadow: isSafariExport ? void 0 : getRotatedBoxShadow(rotation),
        maxHeight: h2
      },
      children: [
        showImageContainer && (!asset || asset.props.image) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-bookmark__image_container", children: [
          asset ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              className: "tl-bookmark__image",
              draggable: false,
              referrerPolicy: "strict-origin-when-cross-origin",
              src: asset?.props.image,
              alt: asset?.props.title || ""
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-bookmark__placeholder" }),
          asset?.props.image && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-bookmark__copy_container", children: [
          asset?.props.title ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              className: "tl-bookmark__link",
              href: url || "",
              target: "_blank",
              rel: "noopener noreferrer",
              draggable: false,
              onPointerDown: markAsHandledOnShiftKey,
              onPointerUp: markAsHandledOnShiftKey,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "tl-bookmark__heading", children: convertCommonTitleHTMLEntities(asset.props.title) })
            }
          ) : null,
          asset?.props.description && asset?.props.image ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "tl-bookmark__description", children: asset.props.description }) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "a",
            {
              className: "tl-bookmark__link",
              href: url || "",
              target: "_blank",
              rel: "noopener noreferrer",
              draggable: false,
              onPointerDown: markAsHandledOnShiftKey,
              onPointerUp: markAsHandledOnShiftKey,
              children: [
                isFaviconValid && asset?.props.favicon ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    className: "tl-bookmark__favicon",
                    src: asset?.props.favicon,
                    referrerPolicy: "strict-origin-when-cross-origin",
                    onError: onFaviconError,
                    alt: `favicon of ${address}`
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "tl-hyperlink__icon",
                    style: {
                      mask: `url("${LINK_ICON}") center 100% / 100% no-repeat`,
                      WebkitMask: `url("${LINK_ICON}") center 100% / 100% no-repeat`
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: address })
              ]
            }
          )
        ] })
      ]
    }
  ) });
}
function getSvgPathFromStrokePoints(points, closed = false) {
  const len = points.length;
  if (len < 2) {
    return "";
  }
  let a = points[0].point;
  let b = points[1].point;
  if (len === 2) {
    return `M${precise(a)}L${precise(b)}`;
  }
  let result = "";
  for (let i = 2, max2 = len - 1; i < max2; i++) {
    a = points[i].point;
    b = points[i + 1].point;
    result += average(a, b);
  }
  if (closed) {
    return `M${average(points[0].point, points[1].point)}Q${precise(points[1].point)}${average(
      points[1].point,
      points[2].point
    )}T${result}${average(points[len - 1].point, points[0].point)}${average(
      points[0].point,
      points[1].point
    )}Z`;
  } else {
    return `M${precise(points[0].point)}Q${precise(points[1].point)}${average(
      points[1].point,
      points[2].point
    )}${points.length > 3 ? "T" : ""}${result}L${precise(points[len - 1].point)}`;
  }
}
function svgInk(rawInputPoints, options = {}) {
  const { start = {}, end = {} } = options;
  const { cap: capStart = true } = start;
  const { cap: capEnd = true } = end;
  assert(!start.taper && !end.taper, "cap taper not supported here");
  assert(!start.easing && !end.easing, "cap easing not supported here");
  assert(capStart && capEnd, "cap must be true");
  const points = getStrokePoints(rawInputPoints, options);
  setStrokePointRadii(points, options);
  const partitions = partitionAtElbows(points);
  let svg = "";
  for (const partition of partitions) {
    svg += renderPartition(partition, options);
  }
  return svg;
}
function partitionAtElbows(points) {
  if (points.length <= 2) return [points];
  const result = [];
  let currentPartition = [points[0]];
  let prevV = Vec.Sub(points[1].point, points[0].point).uni();
  let nextV;
  let dpr;
  let prevPoint, thisPoint, nextPoint;
  for (let i = 1, n = points.length; i < n - 1; i++) {
    prevPoint = points[i - 1];
    thisPoint = points[i];
    nextPoint = points[i + 1];
    nextV = Vec.Sub(nextPoint.point, thisPoint.point).uni();
    dpr = Vec.Dpr(prevV, nextV);
    prevV = nextV;
    if (dpr < -0.8) {
      const elbowPoint = {
        ...thisPoint,
        point: thisPoint.input
      };
      currentPartition.push(elbowPoint);
      result.push(cleanUpPartition(currentPartition));
      currentPartition = [elbowPoint];
      continue;
    }
    currentPartition.push(thisPoint);
    if (dpr > 0.7) {
      continue;
    }
    if ((Vec.Dist2(prevPoint.point, thisPoint.point) + Vec.Dist2(thisPoint.point, nextPoint.point)) / ((prevPoint.radius + thisPoint.radius + nextPoint.radius) / 3) ** 2 < 1.5) {
      currentPartition.push(thisPoint);
      result.push(cleanUpPartition(currentPartition));
      currentPartition = [thisPoint];
      continue;
    }
  }
  currentPartition.push(points[points.length - 1]);
  result.push(cleanUpPartition(currentPartition));
  return result;
}
function cleanUpPartition(partition) {
  const startPoint = partition[0];
  let nextPoint;
  while (partition.length > 2) {
    nextPoint = partition[1];
    if (Vec.Dist2(startPoint.point, nextPoint.point) < ((startPoint.radius + nextPoint.radius) / 2 * 0.5) ** 2) {
      partition.splice(1, 1);
    } else {
      break;
    }
  }
  const endPoint = partition[partition.length - 1];
  let prevPoint;
  while (partition.length > 2) {
    prevPoint = partition[partition.length - 2];
    if (Vec.Dist2(endPoint.point, prevPoint.point) < ((endPoint.radius + prevPoint.radius) / 2 * 0.5) ** 2) {
      partition.splice(partition.length - 2, 1);
    } else {
      break;
    }
  }
  if (partition.length > 1) {
    partition[0] = {
      ...partition[0],
      vector: Vec.Sub(partition[0].point, partition[1].point).uni()
    };
    partition[partition.length - 1] = {
      ...partition[partition.length - 1],
      vector: Vec.Sub(
        partition[partition.length - 2].point,
        partition[partition.length - 1].point
      ).uni()
    };
  }
  return partition;
}
function circlePath(cx, cy, r) {
  return "M " + cx + " " + cy + " m -" + r + ", 0 a " + r + "," + r + " 0 1,1 " + r * 2 + ",0 a " + r + "," + r + " 0 1,1 -" + r * 2 + ",0";
}
function renderPartition(strokePoints, options = {}) {
  if (strokePoints.length === 0) return "";
  if (strokePoints.length === 1) {
    return circlePath(strokePoints[0].point.x, strokePoints[0].point.y, strokePoints[0].radius);
  }
  const { left, right } = getStrokeOutlineTracks(strokePoints, options);
  right.reverse();
  let svg = `M${precise(left[0])}T`;
  for (let i = 1; i < left.length; i++) {
    svg += average(left[i - 1], left[i]);
  }
  {
    const point = strokePoints[strokePoints.length - 1];
    const radius = point.radius;
    const direction = point.vector.clone().per().neg();
    const arcStart = Vec.Add(point.point, Vec.Mul(direction, radius));
    const arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius));
    svg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(
      radius
    )} 0 0 1 ${precise(arcEnd)}T`;
  }
  for (let i = 1; i < right.length; i++) {
    svg += average(right[i - 1], right[i]);
  }
  {
    const point = strokePoints[0];
    const radius = point.radius;
    const direction = point.vector.clone().per();
    const arcStart = Vec.Add(point.point, Vec.Mul(direction, radius));
    const arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius));
    svg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(
      radius
    )} 0 0 1 ${precise(arcEnd)}Z`;
  }
  return svg;
}
const interpolateSegments = (startSegments, endSegments, progress) => {
  const startPoints = [];
  const endPoints = [];
  startSegments.forEach((segment) => startPoints.push(...segment.points));
  endSegments.forEach((segment) => endPoints.push(...segment.points));
  const maxLength = Math.max(startPoints.length, endPoints.length);
  const pointsToUseStart = [];
  const pointsToUseEnd = [];
  for (let i = 0; i < maxLength; i++) {
    pointsToUseStart.push(startPoints[i] || startPoints[startPoints.length - 1]);
    pointsToUseEnd.push(endPoints[i] || endPoints[endPoints.length - 1]);
  }
  const interpolatedPoints = pointsToUseStart.map((point, k) => {
    let z = 0.5;
    if (pointsToUseEnd[k].z !== void 0 && point.z !== void 0) {
      z = lerp(point.z, pointsToUseEnd[k].z, progress);
    }
    return {
      x: lerp(point.x, pointsToUseEnd[k].x, progress),
      y: lerp(point.y, pointsToUseEnd[k].y, progress),
      z
    };
  });
  return [
    {
      type: "free",
      points: interpolatedPoints
    }
  ];
};
const PEN_EASING = (t2) => t2 * 0.65 + SIN(t2 * PI$1 / 2) * 0.35;
const simulatePressureSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0.5,
    streamline: modulate(strokeWidth, [9, 16], [0.64, 0.74], true),
    // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
    smoothing: 0.62,
    easing: EASINGS.easeOutSine,
    simulatePressure: true
  };
};
const realPressureSettings = (strokeWidth) => {
  return {
    size: 1 + strokeWidth * 1.2,
    thinning: 0.62,
    streamline: 0.62,
    smoothing: 0.62,
    simulatePressure: false,
    easing: PEN_EASING
  };
};
const solidSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0,
    streamline: modulate(strokeWidth, [9, 16], [0.64, 0.74], true),
    // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
    smoothing: 0.62,
    simulatePressure: false,
    easing: EASINGS.linear
  };
};
const solidRealPressureSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0,
    streamline: 0.62,
    smoothing: 0.62,
    simulatePressure: false,
    easing: EASINGS.linear
  };
};
function getHighlightFreehandSettings({
  strokeWidth,
  showAsComplete
}) {
  return {
    size: 1 + strokeWidth,
    thinning: 0,
    streamline: 0.5,
    smoothing: 0.5,
    simulatePressure: false,
    easing: EASINGS.easeOutSine,
    last: showAsComplete
  };
}
function getFreehandOptions(shapeProps, strokeWidth, forceComplete, forceSolid) {
  const last2 = shapeProps.isComplete || forceComplete;
  if (forceSolid) {
    if (shapeProps.isPen) {
      return { ...solidRealPressureSettings(strokeWidth), last: last2 };
    } else {
      return { ...solidSettings(strokeWidth), last: last2 };
    }
  }
  if (shapeProps.dash === "draw") {
    if (shapeProps.isPen) {
      return { ...realPressureSettings(strokeWidth), last: last2 };
    } else {
      return { ...simulatePressureSettings(strokeWidth), last: last2 };
    }
  }
  return { ...solidSettings(strokeWidth), last: last2 };
}
function getPointsFromSegments(segments) {
  const points = [];
  for (const segment of segments) {
    if (segment.type === "free" || segment.points.length < 2) {
      points.push(...segment.points.map(Vec.Cast));
    } else {
      const pointsToInterpolate = Math.max(
        4,
        Math.floor(Vec.Dist(segment.points[0], segment.points[1]) / 16)
      );
      points.push(...Vec.PointsBetween(segment.points[0], segment.points[1], pointsToInterpolate));
    }
  }
  return points;
}
function getDrawShapeStrokeDashArray(shape, strokeWidth, dotAdjustment) {
  return {
    draw: "none",
    solid: `none`,
    dotted: `${dotAdjustment} ${strokeWidth * 2}`,
    dashed: `${strokeWidth * 2} ${strokeWidth * 2}`
  }[shape.props.dash];
}
class DrawShapeUtil extends ShapeUtil {
  static type = "draw";
  static props = drawShapeProps;
  static migrations = drawShapeMigrations;
  options = {
    maxPointsPerShape: 600
  };
  hideResizeHandles(shape) {
    return getIsDot$1(shape);
  }
  hideRotateHandle(shape) {
    return getIsDot$1(shape);
  }
  hideSelectionBoundsFg(shape) {
    return getIsDot$1(shape);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      isComplete: false,
      isClosed: false,
      isPen: false,
      scale: 1
    };
  }
  getGeometry(shape) {
    const points = getPointsFromSegments(shape.props.segments);
    const sw = (STROKE_SIZES[shape.props.size] + 1) * shape.props.scale;
    if (shape.props.segments.length === 1) {
      const box = Box.FromPoints(points);
      if (box.width < sw * 2 && box.height < sw * 2) {
        return new Circle2d({
          x: -sw,
          y: -sw,
          radius: sw,
          isFilled: true
        });
      }
    }
    const strokePoints = getStrokePoints(
      points,
      getFreehandOptions(shape.props, sw, shape.props.isPen, true)
    ).map((p) => p.point);
    if (shape.props.isClosed && strokePoints.length > 2) {
      return new Polygon2d({
        points: strokePoints,
        isFilled: shape.props.fill !== "none"
      });
    }
    if (strokePoints.length === 1) {
      return new Circle2d({
        x: -sw,
        y: -sw,
        radius: sw,
        isFilled: true
      });
    }
    return new Polyline2d({
      points: strokePoints
    });
  }
  component(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawShapeSvg, { shape }) });
  }
  indicator(shape) {
    const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
    let sw = (STROKE_SIZES[shape.props.size] + 1) * shape.props.scale;
    const forceSolid = useValue(
      "force solid",
      () => {
        const zoomLevel = this.editor.getZoomLevel();
        return zoomLevel < 0.5 && zoomLevel < 1.5 / sw;
      },
      [this.editor, sw]
    );
    if (!forceSolid && !shape.props.isPen && shape.props.dash === "draw" && allPointsFromSegments.length === 1) {
      sw += rng(shape.id)() * (sw / 6);
    }
    const showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === "straight";
    const options = getFreehandOptions(shape.props, sw, showAsComplete, true);
    const strokePoints = getStrokePoints(allPointsFromSegments, options);
    const solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed) : getDot(allPointsFromSegments[0], sw);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: solidStrokePath });
  }
  toSvg(shape, ctx) {
    ctx.addExportDef(getFillDefForExport(shape.props.fill));
    const scaleFactor = 1 / shape.props.scale;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `scale(${scaleFactor})`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawShapeSvg, { shape, zoomOverride: 1 }) });
  }
  getCanvasSvgDefs() {
    return [getFillDefForCanvas()];
  }
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    const newSegments = [];
    for (const segment of shape.props.segments) {
      newSegments.push({
        ...segment,
        points: segment.points.map(({ x, y, z }) => {
          return {
            x: toFixed(scaleX * x),
            y: toFixed(scaleY * y),
            z
          };
        })
      });
    }
    return {
      props: {
        segments: newSegments
      }
    };
  }
  expandSelectionOutlinePx(shape) {
    const multiplier = shape.props.dash === "draw" ? 1.6 : 1;
    return STROKE_SIZES[shape.props.size] * multiplier / 2 * shape.props.scale;
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      segments: interpolateSegments(startShape.props.segments, endShape.props.segments, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
}
function getDot(point, sw) {
  const r = (sw + 1) * 0.5;
  return `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0`;
}
function getIsDot$1(shape) {
  return shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2;
}
function DrawShapeSvg({ shape, zoomOverride }) {
  const theme = useDefaultColorTheme();
  const editor = useEditor();
  const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
  const showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === "straight";
  let sw = (STROKE_SIZES[shape.props.size] + 1) * shape.props.scale;
  const forceSolid = useValue(
    "force solid",
    () => {
      const zoomLevel = zoomOverride ?? editor.getZoomLevel();
      return zoomLevel < 0.5 && zoomLevel < 1.5 / sw;
    },
    [editor, sw, zoomOverride]
  );
  const dotAdjustment = useValue(
    "dot adjustment",
    () => {
      const zoomLevel = zoomOverride ?? editor.getZoomLevel();
      return zoomLevel < 0.2 ? 0 : 0.1;
    },
    [editor, zoomOverride]
  );
  if (!forceSolid && !shape.props.isPen && shape.props.dash === "draw" && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (sw / 6);
  }
  const options = getFreehandOptions(shape.props, sw, showAsComplete, forceSolid);
  if (!forceSolid && shape.props.dash === "draw") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      shape.props.isClosed && shape.props.fill && allPointsFromSegments.length > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        ShapeFill,
        {
          d: getSvgPathFromStrokePoints(
            getStrokePoints(allPointsFromSegments, options),
            shape.props.isClosed
          ),
          theme,
          color: shape.props.color,
          fill: shape.props.isClosed ? shape.props.fill : "none",
          scale: shape.props.scale
        }
      ) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: svgInk(allPointsFromSegments, options),
          strokeLinecap: "round",
          fill: getColorValue(theme, shape.props.color, "solid")
        }
      )
    ] });
  }
  const strokePoints = getStrokePoints(allPointsFromSegments, options);
  const isDot = strokePoints.length < 2;
  const solidStrokePath = isDot ? getDot(allPointsFromSegments[0], 0) : getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ShapeFill,
      {
        d: solidStrokePath,
        theme,
        color: shape.props.color,
        fill: isDot || shape.props.isClosed ? shape.props.fill : "none",
        scale: shape.props.scale
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: solidStrokePath,
        strokeLinecap: "round",
        fill: isDot ? getColorValue(theme, shape.props.color, "solid") : "none",
        stroke: getColorValue(theme, shape.props.color, "solid"),
        strokeWidth: sw,
        strokeDasharray: isDot ? "none" : getDrawShapeStrokeDashArray(shape, sw, dotAdjustment),
        strokeDashoffset: "0"
      }
    )
  ] });
}
function escapeStringRegexp(string2) {
  if (typeof string2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function matchEmbedUrl(definitions, url) {
  const parsed = safeParseUrl(url);
  if (!parsed) return;
  const host = parsed.host.replace("www.", "");
  for (const localEmbedDef of definitions) {
    if (checkHostnames(localEmbedDef.hostnames, host)) {
      const originalUrl = localEmbedDef.fromEmbedUrl(url);
      if (originalUrl) {
        return {
          definition: localEmbedDef,
          url: originalUrl,
          embedUrl: url
        };
      }
    }
  }
}
const globlikeRegExp = (input) => {
  return input.split("*").map((str) => escapeStringRegexp(str)).join(".+");
};
const checkHostnames = (hostnames, targetHostname) => {
  return !!hostnames.find((hostname) => {
    const re = new RegExp(globlikeRegExp(hostname));
    return targetHostname.match(re);
  });
};
function matchUrl(definitions, url) {
  const parsed = safeParseUrl(url);
  if (!parsed) return;
  const host = parsed.host.replace("www.", "");
  for (const localEmbedDef of definitions) {
    if (checkHostnames(localEmbedDef.hostnames, host)) {
      const embedUrl = localEmbedDef.toEmbedUrl(url);
      if (embedUrl) {
        return {
          definition: localEmbedDef,
          embedUrl,
          url
        };
      }
    }
  }
}
function getEmbedInfo(definitions, inputUrl) {
  try {
    return matchUrl(definitions, inputUrl) ?? matchEmbedUrl(definitions, inputUrl);
  } catch {
    return void 0;
  }
}
const getSandboxPermissions = (permissions) => {
  return Object.entries(permissions).filter(([_perm, isEnabled]) => isEnabled).map(([perm]) => perm).join(" ");
};
class EmbedShapeUtil extends BaseBoxShapeUtil {
  static type = "embed";
  static props = embedShapeProps;
  static migrations = embedShapeMigrations;
  static embedDefinitions = DEFAULT_EMBED_DEFINITIONS;
  static setEmbedDefinitions(embedDefinitions) {
    EmbedShapeUtil.embedDefinitions = embedDefinitions;
  }
  getEmbedDefinitions() {
    return EmbedShapeUtil.embedDefinitions;
  }
  getEmbedDefinition(url) {
    return getEmbedInfo(EmbedShapeUtil.embedDefinitions, url);
  }
  getText(shape) {
    return shape.props.url;
  }
  getAriaDescriptor(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return embedInfo?.definition.title;
  }
  hideSelectionBoundsFg(shape) {
    return !this.canResize(shape);
  }
  canEdit() {
    return true;
  }
  canResize(shape) {
    return !!this.getEmbedDefinition(shape.props.url)?.definition?.doesResize;
  }
  canEditInReadonly() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 300,
      h: 300,
      url: ""
    };
  }
  getGeometry(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    if (!embedInfo?.definition) {
      return new Rectangle2d({
        width: BOOKMARK_WIDTH,
        height: BOOKMARK_JUST_URL_HEIGHT,
        isFilled: true
      });
    }
    return super.getGeometry(shape);
  }
  isAspectRatioLocked(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return embedInfo?.definition.isAspectRatioLocked ?? false;
  }
  onResize(shape, info) {
    const isAspectRatioLocked = this.isAspectRatioLocked(shape);
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    let minWidth = embedInfo?.definition.minWidth ?? 200;
    let minHeight = embedInfo?.definition.minHeight ?? 200;
    if (isAspectRatioLocked) {
      const aspectRatio = shape.props.w / shape.props.h;
      if (aspectRatio > 1) {
        minWidth *= aspectRatio;
      } else {
        minHeight /= aspectRatio;
      }
    }
    return resizeBox(shape, info, { minWidth, minHeight });
  }
  component(shape) {
    const svgExport = useSvgExportContext();
    const { w, h: h2, url } = shape.props;
    const isEditing = useIsEditing(shape.id);
    const embedInfo = this.getEmbedDefinition(url);
    const isHoveringWhileEditingSameShape = useValue(
      "is hovering",
      () => {
        const { editingShapeId, hoveredShapeId } = this.editor.getCurrentPageState();
        if (editingShapeId && hoveredShapeId !== editingShapeId) {
          const editingShape = this.editor.getShape(editingShapeId);
          if (editingShape && this.editor.isShapeOfType(editingShape, "embed")) {
            return true;
          }
        }
        return false;
      },
      []
    );
    const pageRotation = this.editor.getShapePageTransform(shape).rotation();
    if (svgExport) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "tl-embed",
          style: {
            border: 0,
            boxShadow: getRotatedBoxShadow(pageRotation),
            borderRadius: embedInfo?.definition.overrideOutlineRadius ?? 8,
            background: embedInfo?.definition.backgroundColor ?? "var(--tl-color-background)",
            width: w,
            height: h2
          }
        }
      ) });
    }
    const isInteractive = isEditing || isHoveringWhileEditingSameShape;
    const isIframe = typeof window !== "undefined" && (window !== window.top || window.self !== window.parent);
    if (isIframe && embedInfo?.definition.type === "tldraw") return null;
    if (embedInfo?.definition.type === "github_gist") {
      const idFromGistUrl = embedInfo.url.split("/").pop();
      if (!idFromGistUrl) throw Error("No gist id!");
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Gist,
        {
          id: idFromGistUrl,
          width: toDomPrecision(w),
          height: toDomPrecision(h2),
          isInteractive,
          pageRotation
        }
      ) });
    }
    const sandbox = getSandboxPermissions({
      ...embedShapePermissionDefaults,
      ...embedInfo?.definition.overridePermissions ?? {}
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: embedInfo?.definition ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      "iframe",
      {
        className: "tl-embed",
        sandbox,
        src: embedInfo.embedUrl,
        width: toDomPrecision(w),
        height: toDomPrecision(h2),
        draggable: false,
        frameBorder: "0",
        referrerPolicy: "no-referrer-when-downgrade",
        tabIndex: isEditing ? 0 : -1,
        style: {
          border: 0,
          pointerEvents: isInteractive ? "auto" : "none",
          // Fix for safari <https://stackoverflow.com/a/49150908>
          zIndex: isInteractive ? "" : "-1",
          boxShadow: getRotatedBoxShadow(pageRotation),
          borderRadius: embedInfo?.definition.overrideOutlineRadius ?? 8,
          background: embedInfo?.definition.backgroundColor
        }
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      BookmarkShapeComponent,
      {
        url,
        h: h2,
        rotation: pageRotation,
        assetId: null,
        showImageContainer: false
      }
    ) });
  }
  indicator(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return embedInfo?.definition ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      "rect",
      {
        width: toDomPrecision(shape.props.w),
        height: toDomPrecision(shape.props.h),
        rx: embedInfo?.definition.overrideOutlineRadius ?? 8,
        ry: embedInfo?.definition.overrideOutlineRadius ?? 8
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(BookmarkIndicatorComponent, { w: BOOKMARK_WIDTH, h: BOOKMARK_JUST_URL_HEIGHT });
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
}
function Gist({
  id,
  isInteractive,
  width,
  height,
  style: style2,
  pageRotation
}) {
  if (!id.match(/^[0-9a-f]+$/)) throw Error("No gist id!");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "iframe",
    {
      className: "tl-embed",
      draggable: false,
      width: toDomPrecision(width),
      height: toDomPrecision(height),
      frameBorder: "0",
      scrolling: "no",
      referrerPolicy: "no-referrer-when-downgrade",
      tabIndex: isInteractive ? 0 : -1,
      style: {
        ...style2,
        pointerEvents: isInteractive ? "all" : "none",
        // Fix for safari <https://stackoverflow.com/a/49150908>
        zIndex: isInteractive ? "" : "-1",
        boxShadow: getRotatedBoxShadow(pageRotation)
      },
      srcDoc: `
			<html>
				<head>
					<base target="_blank">
				</head>
				<body>
					<script src=${`https://gist.github.com/${id}.js`}><\/script>
					<style type="text/css">
						* { margin: 0px; }
						table { height: 100%; background-color: red; }
						.gist { background-color: none; height: 100%;  }
						.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
					</style>
				</body>
			</html>`
    }
  );
}
function correctSpacesToNbsp(input) {
  return input.replace(/\s/g, "");
}
function createTextJsxFromSpans(editor, spans, opts) {
  const { padding = 0 } = opts;
  if (spans.length === 0) return null;
  const bounds = Box.From(spans[0].box);
  for (const { box } of spans) {
    bounds.union(box);
  }
  const offsetX = padding + (opts.offsetX ?? 0);
  const offsetY = (opts.offsetY ?? 0) + opts.fontSize / 2 + (opts.verticalTextAlign === "start" ? padding : opts.verticalTextAlign === "end" ? opts.height - padding - bounds.height : (Math.ceil(opts.height) - bounds.height) / 2);
  let currentLineTop = null;
  const children = [];
  for (const { text, box } of spans) {
    const didBreakLine = currentLineTop !== null && box.y > currentLineTop;
    if (didBreakLine) {
      children.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "tspan",
          {
            alignmentBaseline: "mathematical",
            x: offsetX,
            y: box.y + offsetY,
            children: "\n"
          },
          children.length
        )
      );
    }
    children.push(
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "tspan",
        {
          alignmentBaseline: "mathematical",
          x: box.x + offsetX,
          y: box.y + offsetY,
          unicodeBidi: "plaintext",
          children: correctSpacesToNbsp(text)
        },
        children.length
      )
    );
    currentLineTop = box.y;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "text",
    {
      fontSize: opts.fontSize,
      fontFamily: opts.fontFamily,
      fontStyle: opts.fontStyle,
      fontWeight: opts.fontWeight,
      dominantBaseline: "mathematical",
      alignmentBaseline: "mathematical",
      stroke: opts.stroke,
      strokeWidth: opts.strokeWidth,
      fill: opts.fill,
      children
    }
  );
}
function getFrameHeadingSide(editor, shape) {
  const pageRotation = canonicalizeRotation(editor.getShapePageTransform(shape.id).rotation());
  const offsetRotation = pageRotation + Math.PI / 4;
  const scaledRotation = (offsetRotation * (2 / Math.PI) + 4) % 4;
  return Math.floor(scaledRotation);
}
const measurementWeakmap = /* @__PURE__ */ new WeakMap();
function getFrameHeadingSize(editor, shape, opts) {
  let width = measurementWeakmap.get(shape.props);
  if (!width) {
    const frameTitle = defaultEmptyAs(shape.props.name, "Frame") + String.fromCharCode(8203);
    const spans = editor.textMeasure.measureTextSpans(frameTitle, opts);
    const firstSpan = spans[0];
    const lastSpan = last(spans);
    width = lastSpan.box.w + lastSpan.box.x - firstSpan.box.x;
    measurementWeakmap.set(shape.props, width);
  }
  return new Box(0, -opts.height, width, opts.height);
}
function getFrameHeadingOpts(width, isSvg) {
  return {
    fontSize: 12,
    fontFamily: isSvg ? "Arial" : "Inter, sans-serif",
    textAlign: "start",
    width,
    height: 24,
    // --frame-height
    padding: 0,
    lineHeight: 1,
    fontStyle: "normal",
    fontWeight: "normal",
    overflow: "truncate-ellipsis",
    verticalTextAlign: "middle",
    offsetY: -34,
    // --frame-minimum-height + (border width * 2)
    offsetX: 0
  };
}
function getFrameHeadingTranslation(shape, side, isSvg) {
  const u = isSvg ? "" : "px";
  const r = isSvg ? "" : "deg";
  let labelTranslate;
  switch (side) {
    case 0:
      labelTranslate = ``;
      break;
    case 3:
      labelTranslate = `translate(${toDomPrecision(shape.props.w)}${u}, 0${u}) rotate(90${r})`;
      break;
    case 2:
      labelTranslate = `translate(${toDomPrecision(shape.props.w)}${u}, ${toDomPrecision(
        shape.props.h
      )}${u}) rotate(180${r})`;
      break;
    case 1:
      labelTranslate = `translate(0${u}, ${toDomPrecision(shape.props.h)}${u}) rotate(270${r})`;
      break;
    default:
      throw Error("labelSide out of bounds");
  }
  return labelTranslate;
}
const FrameLabelInput = reactExports.forwardRef(({ id, name, isEditing }, ref) => {
  const editor = useEditor();
  const breakpoint = useBreakpoint();
  const isCoarsePointer = useValue(
    "isCoarsePointer",
    () => editor.getInstanceState().isCoarsePointer,
    [editor]
  );
  const shouldUseWindowPrompt = breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM && isCoarsePointer;
  const promptOpen = reactExports.useRef(false);
  const msg2 = useTranslation();
  const handlePointerDown = reactExports.useCallback(
    (e) => {
      if (isEditing) editor.markEventAsHandled(e);
    },
    [editor, isEditing]
  );
  const handleKeyDown2 = reactExports.useCallback(
    (e) => {
      if (e.key === "Enter" && !e.nativeEvent.isComposing) {
        editor.markEventAsHandled(e);
        e.currentTarget.blur();
        editor.setEditingShape(null);
      }
    },
    [editor]
  );
  const renameFrame = reactExports.useCallback(
    (value) => {
      const shape = editor.getShape(id);
      if (!shape) return;
      const name2 = shape.props.name;
      if (name2 === value) return;
      editor.updateShapes([
        {
          id,
          type: "frame",
          props: { name: value }
        }
      ]);
    },
    [id, editor]
  );
  const handleBlur = reactExports.useCallback(
    (e) => {
      renameFrame(e.currentTarget.value);
    },
    [renameFrame]
  );
  const handleChange = reactExports.useCallback(
    (e) => {
      renameFrame(e.currentTarget.value);
    },
    [renameFrame]
  );
  reactExports.useEffect(() => {
    if (!isEditing) {
      promptOpen.current = false;
      return;
    }
    if (isEditing && shouldUseWindowPrompt && !promptOpen.current) {
      promptOpen.current = true;
      const shape = editor.getShape(id);
      const currentName = shape?.props.name ?? "";
      const newName = window.prompt(msg2("action.rename"), currentName);
      promptOpen.current = false;
      if (newName !== null) renameFrame(newName);
      editor.setEditingShape(null);
    }
  }, [isEditing, shouldUseWindowPrompt, id, msg2, renameFrame, editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `tl-frame-label ${isEditing && !shouldUseWindowPrompt ? "tl-frame-label__editing" : ""}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            className: "tl-frame-name-input",
            ref,
            disabled: !isEditing || shouldUseWindowPrompt,
            readOnly: !isEditing || shouldUseWindowPrompt,
            style: { display: isEditing ? void 0 : "none" },
            value: name,
            autoFocus: !shouldUseWindowPrompt,
            onKeyDown: handleKeyDown2,
            onBlur: handleBlur,
            onChange: handleChange,
            onPointerDown: handlePointerDown,
            draggable: false
          }
        ),
        defaultEmptyAs(name, "Frame") + String.fromCharCode(8203)
      ]
    }
  );
});
const FrameHeading = reactExports.memo(function FrameHeading2({
  id,
  name,
  width,
  height,
  fill,
  stroke,
  color,
  offsetX,
  showColors
}) {
  const editor = useEditor();
  const { side, translation } = useValue(
    "shape rotation",
    () => {
      const shape = editor.getShape(id);
      if (!shape) {
        return {
          side: 0,
          translation: "translate(0, 0)"
        };
      }
      const labelSide = getFrameHeadingSide(editor, shape);
      return {
        side: labelSide,
        translation: getFrameHeadingTranslation(shape, labelSide, false)
      };
    },
    [editor, offsetX, id]
  );
  const rInput = reactExports.useRef(null);
  const isEditing = useIsEditing(id);
  reactExports.useEffect(() => {
    const el = rInput.current;
    if (el && isEditing) {
      el.focus();
      el.select();
    }
  }, [rInput, isEditing]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "tl-frame-heading",
      style: {
        overflow: isEditing ? "visible" : "hidden",
        maxWidth: `calc(var(--tl-zoom) * ${side === 0 || side === 2 ? Math.ceil(width) : Math.ceil(height)}px + ${showColors ? "0px" : "var(--tl-frame-offset-width)"})`,
        bottom: "100%",
        transform: `${translation} scale(var(--tl-scale)) translateX(${offsetX}px)`
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "tl-frame-heading-hit-area",
          style: { color, backgroundColor: fill, boxShadow: `inset 0px 0px 0px 1px ${stroke}` },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(FrameLabelInput, { ref: rInput, id, name, isEditing })
        }
      )
    }
  );
});
const FRAME_HEADING_EXTRA_WIDTH = 12;
const FRAME_HEADING_MIN_WIDTH = 32;
const FRAME_HEADING_NOCOLORS_OFFSET_X = -7;
const FRAME_HEADING_OFFSET_Y = 4;
function defaultEmptyAs(str, dflt) {
  if (str.match(/^\s*$/)) {
    return dflt;
  }
  return str;
}
class FrameShapeUtil extends BaseBoxShapeUtil {
  static type = "frame";
  static props = frameShapeProps;
  static migrations = frameShapeMigrations;
  options = {
    showColors: false
  };
  // evil crimes :)
  // By default, showColors is off. Because they use style props, which are picked up
  // automatically, we don't have DefaultColorStyle in the props in the schema by default.
  // Instead, when someone calls .configure to turn the option on, we manually add in the color
  // style here so it plays nicely with the other editor APIs.
  static configure(options) {
    const withOptions = super.configure.call(this, options);
    if (options.showColors) {
      withOptions.props = { ...withOptions.props, color: DefaultColorStyle };
    }
    return withOptions;
  }
  canEdit() {
    return true;
  }
  canResize() {
    return true;
  }
  canResizeChildren() {
    return false;
  }
  isExportBoundsContainer() {
    return true;
  }
  getDefaultProps() {
    return { w: 160 * 2, h: 90 * 2, name: "", color: "black" };
  }
  getAriaDescriptor(shape) {
    return shape.props.name;
  }
  getGeometry(shape) {
    const { editor } = this;
    const z = editor.getZoomLevel();
    const labelSide = getFrameHeadingSide(editor, shape);
    const isVertical = labelSide % 2 === 1;
    const rotatedTopEdgeWidth = isVertical ? shape.props.h : shape.props.w;
    const opts = getFrameHeadingOpts(rotatedTopEdgeWidth, false);
    const headingSize = getFrameHeadingSize(editor, shape, opts);
    const isShowingFrameColors = this.options.showColors;
    const extraWidth = FRAME_HEADING_EXTRA_WIDTH / z;
    const minWidth = FRAME_HEADING_MIN_WIDTH / z;
    const maxWidth = rotatedTopEdgeWidth + (isShowingFrameColors ? 1 : extraWidth);
    const labelWidth = headingSize.w / z;
    const labelHeight = headingSize.h / z;
    const clampedLabelWidth = clamp$3(labelWidth + extraWidth, minWidth, maxWidth);
    const offsetX = (isShowingFrameColors ? -1 : FRAME_HEADING_NOCOLORS_OFFSET_X) / z;
    const offsetY = FRAME_HEADING_OFFSET_Y / z;
    const width = isVertical ? labelHeight : clampedLabelWidth;
    const height = isVertical ? clampedLabelWidth : labelHeight;
    let x, y;
    switch (labelSide) {
      case 0: {
        x = offsetX;
        y = -(labelHeight + offsetY);
        break;
      }
      case 1: {
        x = -(labelHeight + offsetY);
        y = shape.props.h - (offsetX + clampedLabelWidth);
        break;
      }
      case 2: {
        x = shape.props.w - (offsetX + clampedLabelWidth);
        y = shape.props.h + offsetY;
        break;
      }
      case 3: {
        x = shape.props.w + offsetY;
        y = offsetX;
        break;
      }
    }
    return new Group2d({
      children: [
        new Rectangle2d({
          width: shape.props.w,
          height: shape.props.h,
          isFilled: false
        }),
        new Rectangle2d({
          x,
          y,
          width,
          height,
          isFilled: true,
          isLabel: true,
          excludeFromShapeBounds: true
        })
      ]
    });
  }
  getText(shape) {
    return shape.props.name;
  }
  component(shape) {
    const theme = useDefaultColorTheme();
    const isCreating = useValue(
      "is creating this shape",
      () => {
        const resizingState = this.editor.getStateDescendant("select.resizing");
        if (!resizingState) return false;
        if (!resizingState.getIsActive()) return false;
        const info = resizingState?.info;
        if (!info) return false;
        return info.isCreating && this.editor.getOnlySelectedShapeId() === shape.id;
      },
      [shape.id]
    );
    const showFrameColors = this.options.showColors;
    const colorToUse = showFrameColors ? shape.props.color : "black";
    const frameFill = getColorValue(theme, colorToUse, "frameFill");
    const frameStroke = getColorValue(theme, colorToUse, "frameStroke");
    const frameHeadingStroke = showFrameColors ? getColorValue(theme, colorToUse, "frameHeadingStroke") : theme.background;
    const frameHeadingFill = showFrameColors ? getColorValue(theme, colorToUse, "frameHeadingFill") : theme.background;
    const frameHeadingText = getColorValue(theme, colorToUse, "frameText");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          className: classNames("tl-frame__body", { "tl-frame__creating": isCreating }),
          fill: frameFill,
          stroke: frameStroke,
          style: {
            width: `calc(${shape.props.w}px + 1px / var(--tl-zoom))`,
            height: `calc(${shape.props.h}px + 1px / var(--tl-zoom))`,
            transform: `translate(calc(-0.5px / var(--tl-zoom)), calc(-0.5px / var(--tl-zoom)))`
          }
        }
      ) }),
      isCreating ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
        FrameHeading,
        {
          id: shape.id,
          name: shape.props.name,
          fill: frameHeadingFill,
          stroke: frameHeadingStroke,
          color: frameHeadingText,
          width: shape.props.w,
          height: shape.props.h,
          offsetX: showFrameColors ? -1 : -7,
          showColors: this.options.showColors
        }
      )
    ] });
  }
  toSvg(shape, ctx) {
    const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode });
    const labelSide = getFrameHeadingSide(this.editor, shape);
    const isVertical = labelSide % 2 === 1;
    const rotatedTopEdgeWidth = isVertical ? shape.props.h : shape.props.w;
    const labelTranslate = getFrameHeadingTranslation(shape, labelSide, true);
    const opts = getFrameHeadingOpts(rotatedTopEdgeWidth - 12, true);
    const frameTitle = defaultEmptyAs(shape.props.name, "Frame") + String.fromCharCode(8203);
    const labelBounds = getFrameHeadingSize(this.editor, shape, opts);
    const spans = this.editor.textMeasure.measureTextSpans(frameTitle, opts);
    const text = createTextJsxFromSpans(this.editor, spans, opts);
    const showFrameColors = this.options.showColors;
    const colorToUse = showFrameColors ? shape.props.color : "black";
    const frameFill = getColorValue(theme, colorToUse, "frameFill");
    const frameStroke = getColorValue(theme, colorToUse, "frameStroke");
    const frameHeadingStroke = showFrameColors ? getColorValue(theme, colorToUse, "frameHeadingStroke") : theme.background;
    const frameHeadingFill = showFrameColors ? getColorValue(theme, colorToUse, "frameHeadingFill") : theme.background;
    const frameHeadingText = getColorValue(theme, colorToUse, "frameText");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          width: shape.props.w,
          height: shape.props.h,
          fill: frameFill,
          stroke: frameStroke,
          strokeWidth: 1,
          x: 0,
          rx: 0,
          ry: 0
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: frameHeadingText, transform: labelTranslate, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            x: labelBounds.x - (showFrameColors ? 0 : 6),
            y: labelBounds.y - 6,
            width: Math.min(rotatedTopEdgeWidth, labelBounds.width + 12),
            height: labelBounds.height,
            fill: frameHeadingFill,
            stroke: frameHeadingStroke,
            rx: 4,
            ry: 4
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `translate(${showFrameColors ? 8 : 0}, 4)`, children: text })
      ] })
    ] });
  }
  indicator(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "rect",
      {
        width: toDomPrecision(shape.props.w),
        height: toDomPrecision(shape.props.h),
        className: `tl-frame-indicator`
      }
    );
  }
  providesBackgroundForChildren() {
    return true;
  }
  getClipPath(shape) {
    return this.editor.getShapeGeometry(shape.id).vertices;
  }
  canReceiveNewChildrenOfType(shape) {
    return !shape.isLocked;
  }
  onResize(shape, info) {
    return resizeBox(shape, info);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
  onDoubleClickEdge(shape, info) {
    if (info.target !== "selection") return;
    const { handle } = info;
    if (!handle) return;
    const isHorizontalEdge = handle === "left" || handle === "right";
    const isVerticalEdge = handle === "top" || handle === "bottom";
    const childIds = this.editor.getSortedChildIdsForParent(shape.id);
    const children = compact(childIds.map((id) => this.editor.getShape(id)));
    if (!children.length) return;
    const { dx, dy, w, h: h2 } = getFrameChildrenBounds(children, this.editor, { padding: 10 });
    this.editor.run(() => {
      const changes = childIds.map((childId) => {
        const childShape = this.editor.getShape(childId);
        return {
          id: childShape.id,
          type: childShape.type,
          x: isHorizontalEdge ? childShape.x + dx : childShape.x,
          y: isVerticalEdge ? childShape.y + dy : childShape.y
        };
      });
      this.editor.updateShapes(changes);
    });
    return {
      id: shape.id,
      type: shape.type,
      props: {
        w: isHorizontalEdge ? w : shape.props.w,
        h: isVerticalEdge ? h2 : shape.props.h
      }
    };
  }
  onDoubleClickCorner(shape) {
    fitFrameToContent(this.editor, shape.id, { padding: 10 });
    return {
      id: shape.id,
      type: shape.type
    };
  }
  onDragShapesIn(shape, draggingShapes, { initialParentIds, initialIndices }) {
    const { editor } = this;
    if (draggingShapes.every((s) => s.parentId === shape.id)) return;
    let canRestoreOriginalIndices = false;
    const previousChildren = draggingShapes.filter((s) => shape.id === initialParentIds.get(s.id));
    if (previousChildren.length > 0) {
      const currentChildren = compact(
        editor.getSortedChildIdsForParent(shape).map((id) => editor.getShape(id))
      );
      if (previousChildren.every((s) => !currentChildren.find((c) => c.index === s.index))) {
        canRestoreOriginalIndices = true;
      }
    }
    if (draggingShapes.some((s) => editor.hasAncestor(shape, s.id))) return;
    editor.reparentShapes(draggingShapes, shape.id);
    if (canRestoreOriginalIndices) {
      for (const shape2 of previousChildren) {
        editor.updateShape({
          id: shape2.id,
          type: shape2.type,
          index: initialIndices.get(shape2.id)
        });
      }
    }
  }
  onDragShapesOut(shape, draggingShapes, info) {
    const { editor } = this;
    if (!info.nextDraggingOverShapeId) {
      editor.reparentShapes(
        draggingShapes.filter(
          (s) => s.parentId === shape.id && this.canReceiveNewChildrenOfType(s)
        ),
        editor.getCurrentPageId()
      );
    }
  }
}
const pathCache$1 = new WeakCache();
function getGeoShapePath(shape) {
  return pathCache$1.get(shape, _getGeoPath);
}
function _getGeoPath(shape) {
  const w = Math.max(1, shape.props.w);
  const h2 = Math.max(1, shape.props.h + shape.props.growY);
  const cx = w / 2;
  const cy = h2 / 2;
  const sw = STROKE_SIZES$1[shape.props.size] * shape.props.scale;
  const isFilled = shape.props.fill !== "none";
  switch (shape.props.geo) {
    case "arrow-down": {
      const ox = w * 0.16;
      const oy = Math.min(w, h2) * 0.38;
      return new PathBuilder().moveTo(ox, 0, { geometry: { isFilled } }).lineTo(w - ox, 0).lineTo(w - ox, h2 - oy).lineTo(w, h2 - oy).lineTo(w / 2, h2).lineTo(0, h2 - oy).lineTo(ox, h2 - oy).close();
    }
    case "arrow-left": {
      const ox = Math.min(w, h2) * 0.38;
      const oy = h2 * 0.16;
      return new PathBuilder().moveTo(ox, 0, { geometry: { isFilled } }).lineTo(ox, oy).lineTo(w, oy).lineTo(w, h2 - oy).lineTo(ox, h2 - oy).lineTo(ox, h2).lineTo(0, h2 / 2).close();
    }
    case "arrow-right": {
      const ox = Math.min(w, h2) * 0.38;
      const oy = h2 * 0.16;
      return new PathBuilder().moveTo(0, oy, { geometry: { isFilled } }).lineTo(w - ox, oy).lineTo(w - ox, 0).lineTo(w, h2 / 2).lineTo(w - ox, h2).lineTo(w - ox, h2 - oy).lineTo(0, h2 - oy).close();
    }
    case "arrow-up": {
      const ox = w * 0.16;
      const oy = Math.min(w, h2) * 0.38;
      return new PathBuilder().moveTo(w / 2, 0, { geometry: { isFilled } }).lineTo(w, oy).lineTo(w - ox, oy).lineTo(w - ox, h2).lineTo(ox, h2).lineTo(ox, oy).lineTo(0, oy).close();
    }
    case "check-box": {
      const size2 = Math.min(w, h2) * 0.82;
      const ox = (w - size2) / 2;
      const oy = (h2 - size2) / 2;
      return new PathBuilder().moveTo(0, 0, { geometry: { isFilled } }).lineTo(w, 0).lineTo(w, h2).lineTo(0, h2).close().moveTo(clamp$3(ox + size2 * 0.25, 0, w), clamp$3(oy + size2 * 0.52, 0, h2), {
        geometry: { isInternal: true, isFilled: false },
        offset: 0
      }).lineTo(clamp$3(ox + size2 * 0.45, 0, w), clamp$3(oy + size2 * 0.82, 0, h2)).lineTo(clamp$3(ox + size2 * 0.82, 0, w), clamp$3(oy + size2 * 0.22, 0, h2), { offset: 0 });
    }
    case "diamond":
      return new PathBuilder().moveTo(cx, 0, { geometry: { isFilled } }).lineTo(w, cy).lineTo(cx, h2).lineTo(0, cy).close();
    case "ellipse":
      return new PathBuilder().moveTo(0, cy, { geometry: { isFilled } }).arcTo(cx, cy, false, true, 0, w, cy).arcTo(cx, cy, false, true, 0, 0, cy).close();
    case "heart": {
      const o = w / 4;
      const k = h2 / 4;
      return new PathBuilder().moveTo(cx, h2, { geometry: { isFilled } }).cubicBezierTo(0, k * 1.2, o * 1.5, k * 3, 0, k * 2.5).cubicBezierTo(cx, k * 0.9, 0, -k * 0.32, o * 1.85, -k * 0.32).cubicBezierTo(w, k * 1.2, o * 2.15, -k * 0.32, w, -k * 0.32).cubicBezierTo(cx, h2, w, k * 2.5, o * 2.5, k * 3).close();
    }
    case "hexagon":
      return PathBuilder.lineThroughPoints(getPolygonVertices(w, h2, 6), {
        geometry: { isFilled }
      }).close();
    case "octagon":
      return PathBuilder.lineThroughPoints(getPolygonVertices(w, h2, 8), {
        geometry: { isFilled }
      }).close();
    case "oval":
      return getStadiumPath(w, h2, isFilled);
    case "pentagon":
      return PathBuilder.lineThroughPoints(getPolygonVertices(w, h2, 5), {
        geometry: { isFilled }
      }).close();
    case "rectangle":
      return new PathBuilder().moveTo(0, 0, { geometry: { isFilled } }).lineTo(w, 0).lineTo(w, h2).lineTo(0, h2).close();
    case "rhombus": {
      const offset2 = Math.min(w * 0.38, h2 * 0.38);
      return new PathBuilder().moveTo(offset2, 0, { geometry: { isFilled } }).lineTo(w, 0).lineTo(w - offset2, h2).lineTo(0, h2).close();
    }
    case "rhombus-2": {
      const offset2 = Math.min(w * 0.38, h2 * 0.38);
      return new PathBuilder().moveTo(0, 0, { geometry: { isFilled } }).lineTo(w - offset2, 0).lineTo(w, h2).lineTo(offset2, h2).close();
    }
    case "star":
      return getStarPath(w, h2, isFilled);
    case "trapezoid": {
      const offset2 = Math.min(w * 0.38, h2 * 0.38);
      return new PathBuilder().moveTo(offset2, 0, { geometry: { isFilled } }).lineTo(w - offset2, 0).lineTo(w, h2).lineTo(0, h2).close();
    }
    case "triangle":
      return new PathBuilder().moveTo(cx, 0, { geometry: { isFilled } }).lineTo(w, h2).lineTo(0, h2).close();
    case "x-box":
      return getXBoxPath(w, h2, sw, shape.props.dash, isFilled);
    case "cloud":
      return getCloudPath(w, h2, shape.id, shape.props.size, shape.props.scale, isFilled);
    default:
      exhaustiveSwitchError(shape.props.geo);
  }
}
function getXBoxPath(w, h2, sw, dash, isFilled) {
  const cx = w / 2;
  const cy = h2 / 2;
  const path = new PathBuilder().moveTo(0, 0, { geometry: { isFilled } }).lineTo(w, 0).lineTo(w, h2).lineTo(0, h2).close();
  if (dash === "dashed" || dash === "dotted") {
    return path.moveTo(0, 0, {
      geometry: { isInternal: true, isFilled: false },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(cx, cy).moveTo(w, h2, {
      geometry: { isInternal: true, isFilled: false },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(cx, cy).moveTo(0, h2, {
      geometry: { isInternal: true, isFilled: false },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(cx, cy).moveTo(w, 0, {
      geometry: { isInternal: true, isFilled: false },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(cx, cy);
  }
  const inset = dash === "draw" ? 0.62 : 0;
  path.moveTo(clamp$3(sw * inset, 0, w), clamp$3(sw * inset, 0, h2), {
    geometry: { isInternal: true, isFilled: false }
  }).lineTo(clamp$3(w - sw * inset, 0, w), clamp$3(h2 - sw * inset, 0, h2)).moveTo(clamp$3(w - sw * inset, 0, w), clamp$3(sw * inset, 0, h2)).lineTo(clamp$3(sw * inset, 0, w), clamp$3(h2 - sw * inset, 0, h2));
  return path;
}
function getStadiumPath(w, h2, isFilled) {
  if (h2 > w) {
    const r2 = w / 2;
    return new PathBuilder().moveTo(0, r2, { geometry: { isFilled } }).arcTo(r2, r2, false, true, 0, w, r2).lineTo(w, h2 - r2).arcTo(r2, r2, false, true, 0, 0, h2 - r2).close();
  }
  const r = h2 / 2;
  return new PathBuilder().moveTo(r, h2, { geometry: { isFilled } }).arcTo(r, r, false, true, 0, r, 0).lineTo(w - r, 0).arcTo(r, r, false, true, 0, w - r, h2).close();
}
function getStarPath(w, h2, isFilled) {
  const sides2 = 5;
  const step = PI2 / sides2 / 2;
  const rightMostIndex = Math.floor(sides2 / 4) * 2;
  const leftMostIndex = sides2 * 2 - rightMostIndex;
  const topMostIndex = 0;
  const bottomMostIndex = Math.floor(sides2 / 2) * 2;
  const maxX = Math.cos(-HALF_PI + rightMostIndex * step) * w / 2;
  const minX = Math.cos(-HALF_PI + leftMostIndex * step) * w / 2;
  const minY = Math.sin(-HALF_PI + topMostIndex * step) * h2 / 2;
  const maxY = Math.sin(-HALF_PI + bottomMostIndex * step) * h2 / 2;
  const diffX = w - Math.abs(maxX - minX);
  const diffY = h2 - Math.abs(maxY - minY);
  const offsetX = w / 2 + minX - (w / 2 - maxX);
  const offsetY = h2 / 2 + minY - (h2 / 2 - maxY);
  const ratio = 1;
  const cx = (w - offsetX) / 2;
  const cy = (h2 - offsetY) / 2;
  const ox = (w + diffX) / 2;
  const oy = (h2 + diffY) / 2;
  const ix = ox * ratio / 2;
  const iy = oy * ratio / 2;
  return PathBuilder.lineThroughPoints(
    Array.from(Array(sides2 * 2), (_, i) => {
      const theta = -HALF_PI + i * step;
      return new Vec(
        cx + (i % 2 ? ix : ox) * Math.cos(theta),
        cy + (i % 2 ? iy : oy) * Math.sin(theta)
      );
    }),
    { geometry: { isFilled } }
  ).close();
}
function getOvalPerimeter(h2, w) {
  if (h2 > w) return (PI$1 * (w / 2) + (h2 - w)) * 2;
  else return (PI$1 * (h2 / 2) + (w - h2)) * 2;
}
function getPillPoints(width, height, numPoints) {
  const radius = Math.min(width, height) / 2;
  const longSide = Math.max(width, height) - radius * 2;
  const circumference = Math.PI * (radius * 2) + 2 * longSide;
  const spacing = circumference / numPoints;
  const sections = width > height ? [
    {
      type: "straight",
      start: new Vec(radius, 0),
      delta: new Vec(1, 0)
    },
    {
      type: "arc",
      center: new Vec(width - radius, radius),
      startAngle: -PI$1 / 2
    },
    {
      type: "straight",
      start: new Vec(width - radius, height),
      delta: new Vec(-1, 0)
    },
    {
      type: "arc",
      center: new Vec(radius, radius),
      startAngle: PI$1 / 2
    }
  ] : [
    {
      type: "straight",
      start: new Vec(width, radius),
      delta: new Vec(0, 1)
    },
    {
      type: "arc",
      center: new Vec(radius, height - radius),
      startAngle: 0
    },
    {
      type: "straight",
      start: new Vec(0, height - radius),
      delta: new Vec(0, -1)
    },
    {
      type: "arc",
      center: new Vec(radius, radius),
      startAngle: PI$1
    }
  ];
  let sectionOffset = 0;
  const points = [];
  for (let i = 0; i < numPoints; i++) {
    const section = sections[0];
    if (section.type === "straight") {
      points.push(Vec.Add(section.start, Vec.Mul(section.delta, sectionOffset)));
    } else {
      points.push(
        getPointOnCircle(section.center, radius, section.startAngle + sectionOffset / radius)
      );
    }
    sectionOffset += spacing;
    let sectionLength = section.type === "straight" ? longSide : PI$1 * radius;
    while (sectionOffset > sectionLength) {
      sectionOffset -= sectionLength;
      sections.push(sections.shift());
      sectionLength = sections[0].type === "straight" ? longSide : PI$1 * radius;
    }
  }
  return points;
}
const SIZES = {
  s: 50,
  m: 70,
  l: 100,
  xl: 130
};
const BUMP_PROTRUSION = 0.2;
function getCloudPath(width, height, seed, size2, scale, isFilled) {
  const path = new PathBuilder();
  const getRandom = rng(seed);
  const pillCircumference = getOvalPerimeter(width, height);
  const numBumps = Math.max(
    Math.ceil(pillCircumference / SIZES[size2]),
    6,
    Math.ceil(pillCircumference / Math.min(width, height))
  );
  const targetBumpProtrusion = pillCircumference / numBumps * BUMP_PROTRUSION;
  const innerWidth = Math.max(width - targetBumpProtrusion * 2, 1);
  const innerHeight2 = Math.max(height - targetBumpProtrusion * 2, 1);
  const innerCircumference = getOvalPerimeter(innerWidth, innerHeight2);
  const distanceBetweenPointsOnPerimeter = innerCircumference / numBumps;
  const paddingX = (width - innerWidth) / 2;
  const paddingY = (height - innerHeight2) / 2;
  const bumpPoints = getPillPoints(innerWidth, innerHeight2, numBumps).map((p) => {
    return p.addXY(paddingX, paddingY);
  });
  const maxWiggleX = width < 20 ? 0 : targetBumpProtrusion * 0.3;
  const maxWiggleY = height < 20 ? 0 : targetBumpProtrusion * 0.3;
  const wiggledPoints = bumpPoints.slice(0);
  for (let i = 0; i < Math.floor(numBumps / 2); i++) {
    wiggledPoints[i] = Vec.AddXY(
      wiggledPoints[i],
      getRandom() * maxWiggleX * scale,
      getRandom() * maxWiggleY * scale
    );
    wiggledPoints[numBumps - i - 1] = Vec.AddXY(
      wiggledPoints[numBumps - i - 1],
      getRandom() * maxWiggleX * scale,
      getRandom() * maxWiggleY * scale
    );
  }
  for (let i = 0; i < wiggledPoints.length; i++) {
    const j = i === wiggledPoints.length - 1 ? 0 : i + 1;
    const leftWigglePoint = wiggledPoints[i];
    const rightWigglePoint = wiggledPoints[j];
    const leftPoint = bumpPoints[i];
    const rightPoint = bumpPoints[j];
    const distanceBetweenOriginalPoints = Vec.Dist(leftPoint, rightPoint);
    const curvatureOffset = distanceBetweenPointsOnPerimeter - distanceBetweenOriginalPoints;
    const distanceBetweenWigglePoints = Vec.Dist(leftWigglePoint, rightWigglePoint);
    const relativeSize = distanceBetweenWigglePoints / distanceBetweenOriginalPoints;
    const finalDistance = (Math.max(paddingX, paddingY) + curvatureOffset) * relativeSize;
    const arcPoint = Vec.Lrp(leftPoint, rightPoint, 0.5).add(
      Vec.Sub(rightPoint, leftPoint).uni().per().mul(finalDistance)
    );
    if (arcPoint.x < 0) {
      arcPoint.x = 0;
    } else if (arcPoint.x > width) {
      arcPoint.x = width;
    }
    if (arcPoint.y < 0) {
      arcPoint.y = 0;
    } else if (arcPoint.y > height) {
      arcPoint.y = height;
    }
    const center = centerOfCircleFromThreePoints(leftWigglePoint, rightWigglePoint, arcPoint);
    const radius = Vec.Dist(
      center ? center : Vec.Average([leftWigglePoint, rightWigglePoint]),
      leftWigglePoint
    );
    if (i === 0) {
      path.moveTo(leftWigglePoint.x, leftWigglePoint.y, { geometry: { isFilled } });
    }
    path.circularArcTo(radius, false, true, rightWigglePoint.x, rightWigglePoint.y);
  }
  return path.close();
}
function GeoShapeBody({
  shape,
  shouldScale,
  forceSolid
}) {
  const scaleToUse = shouldScale ? shape.props.scale : 1;
  const theme = useDefaultColorTheme();
  const { props } = shape;
  const { color, fill, dash, size: size2 } = props;
  const strokeWidth = STROKE_SIZES[size2] * scaleToUse;
  const path = getGeoShapePath(shape);
  const fillPath = dash === "draw" && !forceSolid ? path.toDrawD({ strokeWidth, randomSeed: shape.id, passes: 1, offset: 0, onlyFilled: true }) : path.toD({ onlyFilled: true });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d: fillPath, color, fill, scale: scaleToUse }),
    path.toSvg({
      style: dash,
      strokeWidth,
      forceSolid,
      randomSeed: shape.id,
      props: { fill: "none", stroke: getColorValue(theme, color, "solid") }
    })
  ] });
}
const MIN_SIZE_WITH_LABEL = 17 * 3;
class GeoShapeUtil extends BaseBoxShapeUtil {
  static type = "geo";
  static props = geoShapeProps;
  static migrations = geoShapeMigrations;
  canEdit() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      geo: "rectangle",
      dash: "draw",
      growY: 0,
      url: "",
      scale: 1,
      // Text properties
      color: "black",
      labelColor: "black",
      fill: "none",
      size: "m",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      richText: toRichText("")
    };
  }
  getGeometry(shape) {
    const w = Math.max(1, shape.props.w);
    const h2 = Math.max(1, shape.props.h + shape.props.growY);
    const path = getGeoShapePath(shape);
    const unscaledlabelSize = getUnscaledLabelSize(this.editor, shape);
    const unscaledW = w / shape.props.scale;
    const unscaledH = h2 / shape.props.scale;
    const unscaledminWidth = Math.min(100, unscaledW / 2);
    const unscaledMinHeight = Math.min(
      LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2,
      unscaledH / 2
    );
    const unscaledLabelWidth = Math.min(
      unscaledW,
      Math.max(unscaledlabelSize.w, Math.min(unscaledminWidth, Math.max(1, unscaledW - 8)))
    );
    const unscaledLabelHeight = Math.min(
      unscaledH,
      Math.max(unscaledlabelSize.h, Math.min(unscaledMinHeight, Math.max(1, unscaledH - 8)))
    );
    return new Group2d({
      children: [
        path.toGeometry(),
        new Rectangle2d({
          x: shape.props.align === "start" ? 0 : shape.props.align === "end" ? (unscaledW - unscaledLabelWidth) * shape.props.scale : (unscaledW - unscaledLabelWidth) / 2 * shape.props.scale,
          y: shape.props.verticalAlign === "start" ? 0 : shape.props.verticalAlign === "end" ? (unscaledH - unscaledLabelHeight) * shape.props.scale : (unscaledH - unscaledLabelHeight) / 2 * shape.props.scale,
          width: unscaledLabelWidth * shape.props.scale,
          height: unscaledLabelHeight * shape.props.scale,
          isFilled: true,
          isLabel: true,
          excludeFromShapeBounds: true,
          isEmptyLabel: isEmptyRichText(shape.props.richText)
        })
      ]
    });
  }
  getHandleSnapGeometry(shape) {
    const geometry = this.getGeometry(shape);
    const outline = geometry.children[0];
    switch (shape.props.geo) {
      case "arrow-down":
      case "arrow-left":
      case "arrow-right":
      case "arrow-up":
      case "check-box":
      case "diamond":
      case "hexagon":
      case "octagon":
      case "pentagon":
      case "rectangle":
      case "rhombus":
      case "rhombus-2":
      case "star":
      case "trapezoid":
      case "triangle":
      case "x-box":
        return { outline, points: [...outline.vertices, geometry.bounds.center] };
      case "cloud":
      case "ellipse":
      case "heart":
      case "oval":
        return { outline, points: [geometry.bounds.center] };
      default:
        exhaustiveSwitchError(shape.props.geo);
    }
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  getFontFaces(shape) {
    if (isEmptyRichText(shape.props.richText)) {
      return EMPTY_ARRAY;
    }
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  component(shape) {
    const { id, type, props } = shape;
    const { fill, font, align, verticalAlign, size: size2, richText } = props;
    const theme = useDefaultColorTheme();
    const { editor } = this;
    const isOnlySelected = useValue(
      "isGeoOnlySelected",
      () => shape.id === editor.getOnlySelectedShapeId(),
      [editor]
    );
    const isReadyForEditing = useIsReadyForEditing(editor, shape.id);
    const isEmpty = isEmptyRichText(shape.props.richText);
    const showHtmlContainer = isReadyForEditing || !isEmpty;
    const isForceSolid = useValue("force solid", () => editor.getZoomLevel() < 0.2, [editor]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(GeoShapeBody, { shape, shouldScale: true, forceSolid: isForceSolid }) }),
      showHtmlContainer && /* @__PURE__ */ jsxRuntimeExports.jsx(
        HTMLContainer,
        {
          style: {
            overflow: "hidden",
            width: shape.props.w,
            height: shape.props.h + props.growY
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            RichTextLabel,
            {
              shapeId: id,
              type,
              font,
              fontSize: LABEL_FONT_SIZES[size2] * shape.props.scale,
              lineHeight: TEXT_PROPS.lineHeight,
              padding: LABEL_PADDING * shape.props.scale,
              fill,
              align,
              verticalAlign,
              richText,
              isSelected: isOnlySelected,
              labelColor: getColorValue(theme, props.labelColor, "solid"),
              wrap: true
            }
          )
        }
      ),
      shape.props.url && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url: shape.props.url })
    ] });
  }
  indicator(shape) {
    const isZoomedOut = useValue("isZoomedOut", () => this.editor.getZoomLevel() < 0.25, [
      this.editor
    ]);
    const { size: size2, dash, scale } = shape.props;
    const strokeWidth = STROKE_SIZES[size2];
    const path = getGeoShapePath(shape);
    return path.toSvg({
      style: dash === "draw" ? "draw" : "solid",
      strokeWidth: 1,
      passes: 1,
      randomSeed: shape.id,
      offset: 0,
      roundness: strokeWidth * 2 * scale,
      props: { strokeWidth: void 0 },
      forceSolid: isZoomedOut
    });
  }
  toSvg(shape, ctx) {
    const scale = shape.props.scale;
    const newShape = {
      ...shape,
      props: {
        ...shape.props,
        w: shape.props.w / scale,
        h: (shape.props.h + shape.props.growY) / scale,
        growY: 0
        // growY throws off the path calculations, so we set it to 0
      }
    };
    const props = newShape.props;
    ctx.addExportDef(getFillDefForExport(props.fill));
    let textEl;
    if (!isEmptyRichText(props.richText)) {
      const theme = getDefaultColorTheme(ctx);
      const bounds = new Box(0, 0, props.w, (shape.props.h + shape.props.growY) / scale);
      textEl = /* @__PURE__ */ jsxRuntimeExports.jsx(
        RichTextSVG,
        {
          fontSize: LABEL_FONT_SIZES[props.size],
          font: props.font,
          align: props.align,
          verticalAlign: props.verticalAlign,
          richText: props.richText,
          labelColor: getColorValue(theme, props.labelColor, "solid"),
          bounds,
          padding: LABEL_PADDING
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(GeoShapeBody, { shouldScale: false, shape: newShape, forceSolid: false }),
      textEl
    ] });
  }
  getCanvasSvgDefs() {
    return [getFillDefForCanvas()];
  }
  onResize(shape, { handle, newPoint, scaleX, scaleY, initialShape }) {
    const unscaledInitialW = initialShape.props.w / initialShape.props.scale;
    const unscaledInitialH = initialShape.props.h / initialShape.props.scale;
    const unscaledGrowY = initialShape.props.growY / initialShape.props.scale;
    let unscaledW = unscaledInitialW * scaleX;
    let unscaledH = (unscaledInitialH + unscaledGrowY) * scaleY;
    let overShrinkX = 0;
    let overShrinkY = 0;
    const min2 = MIN_SIZE_WITH_LABEL;
    if (!isEmptyRichText(shape.props.richText)) {
      let newW = Math.max(Math.abs(unscaledW), min2);
      let newH = Math.max(Math.abs(unscaledH), min2);
      if (newW < min2 && newH === min2) newW = min2;
      if (newW === min2 && newH < min2) newH = min2;
      const unscaledLabelSize = getUnscaledLabelSize(this.editor, {
        ...shape,
        props: {
          ...shape.props,
          w: newW * shape.props.scale,
          h: newH * shape.props.scale
        }
      });
      const nextW = Math.max(Math.abs(unscaledW), unscaledLabelSize.w) * Math.sign(unscaledW);
      const nextH = Math.max(Math.abs(unscaledH), unscaledLabelSize.h) * Math.sign(unscaledH);
      overShrinkX = Math.abs(nextW) - Math.abs(unscaledW);
      overShrinkY = Math.abs(nextH) - Math.abs(unscaledH);
      unscaledW = nextW;
      unscaledH = nextH;
    }
    const scaledW = unscaledW * shape.props.scale;
    const scaledH = unscaledH * shape.props.scale;
    const offset2 = new Vec(0, 0);
    if (scaleX < 0) {
      offset2.x += scaledW;
    }
    if (handle === "left" || handle === "top_left" || handle === "bottom_left") {
      offset2.x += scaleX < 0 ? overShrinkX : -overShrinkX;
    }
    if (scaleY < 0) {
      offset2.y += scaledH;
    }
    if (handle === "top" || handle === "top_left" || handle === "top_right") {
      offset2.y += scaleY < 0 ? overShrinkY : -overShrinkY;
    }
    const { x, y } = offset2.rot(shape.rotation).add(newPoint);
    return {
      x,
      y,
      props: {
        w: Math.max(Math.abs(scaledW), 1),
        h: Math.max(Math.abs(scaledH), 1),
        growY: 0
      }
    };
  }
  onBeforeCreate(shape) {
    if (isEmptyRichText(shape.props.richText)) {
      if (shape.props.growY) {
        return {
          ...shape,
          props: {
            ...shape.props,
            growY: 0
          }
        };
      } else {
        return;
      }
    }
    const unscaledPrevHeight = shape.props.h / shape.props.scale;
    const unscaledNextHeight = getUnscaledLabelSize(this.editor, shape).h;
    let growY = null;
    if (unscaledNextHeight > unscaledPrevHeight) {
      growY = unscaledNextHeight - unscaledPrevHeight;
    } else {
      if (shape.props.growY) {
        growY = 0;
      }
    }
    if (growY !== null) {
      return {
        ...shape,
        props: {
          ...shape.props,
          // scale the growY
          growY: growY * shape.props.scale
        }
      };
    }
  }
  onBeforeUpdate(prev, next) {
    if (isEqual(prev.props.richText, next.props.richText) && prev.props.font === next.props.font && prev.props.size === next.props.size) {
      return;
    }
    const wasEmpty = isEmptyRichText(prev.props.richText);
    const isEmpty = isEmptyRichText(next.props.richText);
    if (!wasEmpty && isEmpty) {
      return {
        ...next,
        props: {
          ...next.props,
          growY: 0
        }
      };
    }
    const unscaledPrevWidth = prev.props.w / prev.props.scale;
    const unscaledPrevHeight = prev.props.h / prev.props.scale;
    const unscaledPrevGrowY = prev.props.growY / prev.props.scale;
    const unscaledNextLabelSize = getUnscaledLabelSize(this.editor, next);
    if (wasEmpty && !isEmpty && renderPlaintextFromRichText(this.editor, next.props.richText)) {
      let unscaledW = Math.max(unscaledPrevWidth, unscaledNextLabelSize.w);
      let unscaledH = Math.max(unscaledPrevHeight, unscaledNextLabelSize.h);
      const min2 = MIN_SIZE_WITH_LABEL;
      if (unscaledPrevWidth < min2 && unscaledPrevHeight < min2) {
        unscaledW = Math.max(unscaledW, min2);
        unscaledH = Math.max(unscaledH, min2);
        unscaledW = Math.max(unscaledW, unscaledH);
        unscaledH = Math.max(unscaledW, unscaledH);
      }
      return {
        ...next,
        props: {
          ...next.props,
          // Scale the results
          w: unscaledW * next.props.scale,
          h: unscaledH * next.props.scale,
          growY: 0
        }
      };
    }
    let growY = null;
    if (unscaledNextLabelSize.h > unscaledPrevHeight) {
      growY = unscaledNextLabelSize.h - unscaledPrevHeight;
    } else {
      if (unscaledPrevGrowY) {
        growY = 0;
      }
    }
    if (growY !== null) {
      const unscaledNextWidth = next.props.w / next.props.scale;
      return {
        ...next,
        props: {
          ...next.props,
          // Scale the results
          growY: growY * next.props.scale,
          w: Math.max(unscaledNextWidth, unscaledNextLabelSize.w) * next.props.scale
        }
      };
    }
    if (unscaledNextLabelSize.w > unscaledPrevWidth) {
      return {
        ...next,
        props: {
          ...next.props,
          // Scale the results
          w: unscaledNextLabelSize.w * next.props.scale
        }
      };
    }
  }
  onDoubleClick(shape) {
    if (this.editor.inputs.altKey) {
      switch (shape.props.geo) {
        case "rectangle": {
          return {
            ...shape,
            props: {
              geo: "check-box"
            }
          };
        }
        case "check-box": {
          return {
            ...shape,
            props: {
              geo: "rectangle"
            }
          };
        }
      }
    }
    return;
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
}
const minWidths = {
  s: 12,
  m: 14,
  l: 16,
  xl: 20
};
const extraPaddings = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
function getUnscaledLabelSize(editor, shape) {
  const { richText, font, size: size2, w } = shape.props;
  if (!richText || isEmptyRichText(richText)) {
    return { w: 0, h: 0 };
  }
  const minWidth = minWidths[size2];
  const html2 = renderHtmlFromRichTextForMeasurement(editor, richText);
  const textSize = editor.textMeasure.measureHtml(html2, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[font],
    fontSize: LABEL_FONT_SIZES[size2],
    minWidth,
    maxWidth: Math.max(
      // Guard because a DOM nodes can't be less 0
      0,
      // A 'w' width that we're setting as the min-width
      Math.ceil(minWidth + extraPaddings[size2]),
      // The actual text size
      Math.ceil(w / shape.props.scale - LABEL_PADDING * 2)
    )
  });
  return {
    w: textSize.w + LABEL_PADDING * 2,
    h: textSize.h + LABEL_PADDING * 2
  };
}
function useColorSpace() {
  const [supportsP3, setSupportsP3] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const supportsSyntax = CSS.supports("color", "color(display-p3 1 1 1)");
    const query = matchMedia("(color-gamut: p3)");
    setSupportsP3(supportsSyntax && query.matches);
    const onChange = () => setSupportsP3(supportsSyntax && query.matches);
    query.addEventListener("change", onChange);
    return () => query.removeEventListener("change", onChange);
  }, []);
  const forceSrgb = useValue(debugFlags.forceSrgb);
  return forceSrgb || !supportsP3 ? "srgb" : "p3";
}
class HighlightShapeUtil extends ShapeUtil {
  static type = "highlight";
  static props = highlightShapeProps;
  static migrations = highlightShapeMigrations;
  options = {
    maxPointsPerShape: 600,
    underlayOpacity: 0.82,
    overlayOpacity: 0.35
  };
  hideResizeHandles(shape) {
    return getIsDot(shape);
  }
  hideRotateHandle(shape) {
    return getIsDot(shape);
  }
  hideSelectionBoundsFg(shape) {
    return getIsDot(shape);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      size: "m",
      isComplete: false,
      isPen: false,
      scale: 1
    };
  }
  getGeometry(shape) {
    const strokeWidth = getStrokeWidth(shape);
    if (getIsDot(shape)) {
      return new Circle2d({
        x: -strokeWidth / 2,
        y: -strokeWidth / 2,
        radius: strokeWidth / 2,
        isFilled: true
      });
    }
    const { strokePoints, sw } = getHighlightStrokePoints(shape, strokeWidth, true);
    const opts = getHighlightFreehandSettings({ strokeWidth: sw, showAsComplete: true });
    setStrokePointRadii(strokePoints, opts);
    return new Polygon2d({
      points: getStrokeOutlinePoints(strokePoints, opts),
      isFilled: true
    });
  }
  component(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      HighlightRenderer,
      {
        shape,
        forceSolid,
        strokeWidth,
        opacity: this.options.overlayOpacity
      }
    ) });
  }
  backgroundComponent(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      HighlightRenderer,
      {
        shape,
        forceSolid,
        strokeWidth,
        opacity: this.options.underlayOpacity
      }
    ) });
  }
  indicator(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    const { strokePoints, sw } = getHighlightStrokePoints(shape, strokeWidth, forceSolid);
    const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
    let strokePath;
    if (strokePoints.length < 2) {
      strokePath = getIndicatorDot(allPointsFromSegments[0], sw);
    } else {
      strokePath = getSvgPathFromStrokePoints(strokePoints, false);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: strokePath });
  }
  toSvg(shape) {
    const strokeWidth = getStrokeWidth(shape);
    const forceSolid = strokeWidth < 1.5;
    const scaleFactor = 1 / shape.props.scale;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `scale(${scaleFactor})`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      HighlightRenderer,
      {
        forceSolid,
        strokeWidth,
        shape,
        opacity: this.options.overlayOpacity
      }
    ) });
  }
  toBackgroundSvg(shape) {
    const strokeWidth = getStrokeWidth(shape);
    const forceSolid = strokeWidth < 1.5;
    const scaleFactor = 1 / shape.props.scale;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `scale(${scaleFactor})`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      HighlightRenderer,
      {
        forceSolid,
        strokeWidth,
        shape,
        opacity: this.options.underlayOpacity
      }
    ) });
  }
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    const newSegments = [];
    for (const segment of shape.props.segments) {
      newSegments.push({
        ...segment,
        points: segment.points.map(({ x, y, z }) => {
          return {
            x: scaleX * x,
            y: scaleY * y,
            z
          };
        })
      });
    }
    return {
      props: {
        segments: newSegments
      }
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      ...endShape.props,
      segments: interpolateSegments(startShape.props.segments, endShape.props.segments, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
}
function getShapeDot(point) {
  const r = 0.1;
  return `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0`;
}
function getIndicatorDot(point, sw) {
  const r = sw / 2;
  return `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0`;
}
function getHighlightStrokePoints(shape, strokeWidth, forceSolid) {
  const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
  const showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === "straight";
  let sw = strokeWidth;
  if (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (strokeWidth / 6);
  }
  const options = getHighlightFreehandSettings({
    strokeWidth: sw,
    showAsComplete
  });
  const strokePoints = getStrokePoints(allPointsFromSegments, options);
  return { strokePoints, sw };
}
function getStrokeWidth(shape) {
  return FONT_SIZES[shape.props.size] * 1.12 * shape.props.scale;
}
function getIsDot(shape) {
  return shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2;
}
function HighlightRenderer({
  strokeWidth,
  forceSolid,
  shape,
  opacity
}) {
  const theme = useDefaultColorTheme();
  const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
  let sw = strokeWidth;
  if (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (sw / 6);
  }
  const options = getHighlightFreehandSettings({
    strokeWidth: sw,
    showAsComplete: shape.props.isComplete || last(shape.props.segments)?.type === "straight"
  });
  const strokePoints = getStrokePoints(allPointsFromSegments, options);
  const solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, false) : getShapeDot(shape.props.segments[0].points[0]);
  const colorSpace = useColorSpace();
  const color = getColorValue(
    theme,
    shape.props.color,
    colorSpace === "p3" ? "highlightP3" : "highlightSrgb"
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      d: solidStrokePath,
      strokeLinecap: "round",
      fill: "none",
      pointerEvents: "all",
      stroke: color,
      strokeWidth: sw,
      opacity
    }
  );
}
function useHighlightForceSolid(editor, shape) {
  return useValue(
    "forceSolid",
    () => {
      const sw = getStrokeWidth(shape);
      const zoomLevel = editor.getZoomLevel();
      if (sw / zoomLevel < 1.5) {
        return true;
      }
      return false;
    },
    [editor]
  );
}
function BrokenAssetIcon() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      width: "15",
      height: "15",
      viewBox: "0 0 30 30",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3,11 L3,3 11,3", strokeWidth: "2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19,27 L27,27 L27,19", strokeWidth: "2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M27,3 L3,27", strokeWidth: "2" })
      ]
    }
  );
}
function useImageOrVideoAsset({ shapeId, assetId, width }) {
  const editor = useEditor();
  const exportInfo = useSvgExportContext();
  const exportIsReady = useDelaySvgExport();
  const [result, setResult] = reactExports.useState(() => ({
    asset: assetId ? editor.getAsset(assetId) ?? null : null,
    url: null
  }));
  const didAlreadyResolve = reactExports.useRef(false);
  const previousUrl = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!assetId) return;
    let isCancelled = false;
    let cancelDebounceFn;
    const cleanupEffectScheduler = react("update state", () => {
      if (!exportInfo && shapeId && editor.getCulledShapes().has(shapeId)) return;
      const asset = editor.getAsset(assetId);
      if (!asset) {
        setResult((prev) => ({ ...prev, asset: null, url: null }));
        return;
      }
      if (!asset.props.src) {
        const preview = editor.getTemporaryAssetPreview(asset.id);
        if (preview) {
          if (previousUrl.current !== preview) {
            previousUrl.current = preview;
            setResult((prev) => ({ ...prev, isPlaceholder: true, url: preview }));
            exportIsReady();
          }
          return;
        }
      }
      const screenScale = exportInfo ? exportInfo.scale * (width / asset.props.w) : editor.getZoomLevel() * (width / asset.props.w);
      function resolve(asset2, url) {
        if (isCancelled) return;
        if (previousUrl.current === url) return;
        didAlreadyResolve.current = true;
        previousUrl.current = url;
        setResult({ asset: asset2, url });
        exportIsReady();
      }
      if (didAlreadyResolve.current) {
        let tick2 = 0;
        const resolveAssetAfterAWhile = () => {
          tick2++;
          if (tick2 > 500 / 16) {
            resolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url));
            cancelDebounceFn?.();
          }
        };
        cancelDebounceFn?.();
        editor.on("tick", resolveAssetAfterAWhile);
        cancelDebounceFn = () => editor.off("tick", resolveAssetAfterAWhile);
      } else {
        resolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url));
      }
    });
    return () => {
      cleanupEffectScheduler();
      cancelDebounceFn?.();
      isCancelled = true;
    };
  }, [editor, assetId, exportInfo, exportIsReady, shapeId, width]);
  return result;
}
function resolveAssetUrl(editor, assetId, screenScale, exportInfo, callback) {
  editor.resolveAssetUrl(assetId, {
    screenScale,
    shouldResolveToOriginal: exportInfo ? exportInfo.pixelRatio === null : false,
    dpr: exportInfo?.pixelRatio ?? void 0
  }).then((url) => {
    callback(url);
  });
}
async function getDataURIFromURL(url) {
  const response = await fetch$1(url);
  const blob = await response.blob();
  return FileHelpers.blobToDataUrl(blob);
}
const imageSvgExportCache = new WeakCache();
class ImageShapeUtil extends BaseBoxShapeUtil {
  static type = "image";
  static props = imageShapeProps;
  static migrations = imageShapeMigrations;
  isAspectRatioLocked() {
    return true;
  }
  canCrop() {
    return true;
  }
  isExportBoundsContainer() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      playing: true,
      url: "",
      crop: null,
      flipX: false,
      flipY: false,
      altText: ""
    };
  }
  getGeometry(shape) {
    if (shape.props.crop?.isCircle) {
      return new Ellipse2d({
        width: shape.props.w,
        height: shape.props.h,
        isFilled: true
      });
    }
    return new Rectangle2d({
      width: shape.props.w,
      height: shape.props.h,
      isFilled: true
    });
  }
  getAriaDescriptor(shape) {
    return shape.props.altText;
  }
  onResize(shape, info) {
    let resized = resizeBox(shape, info);
    const { flipX, flipY } = info.initialShape.props;
    const { scaleX, scaleY, mode } = info;
    resized = {
      ...resized,
      props: {
        ...resized.props,
        flipX: scaleX < 0 !== flipX,
        flipY: scaleY < 0 !== flipY
      }
    };
    if (!shape.props.crop) return resized;
    const flipCropHorizontally = (
      // We used the flip horizontally feature
      // We resized the shape past it's bounds, so it flipped
      mode === "scale_shape" && scaleX === -1 || mode === "resize_bounds" && flipX !== resized.props.flipX
    );
    const flipCropVertically = (
      // We used the flip vertically feature
      // We resized the shape past it's bounds, so it flipped
      mode === "scale_shape" && scaleY === -1 || mode === "resize_bounds" && flipY !== resized.props.flipY
    );
    const { topLeft, bottomRight } = shape.props.crop;
    resized.props.crop = {
      topLeft: {
        x: flipCropHorizontally ? 1 - bottomRight.x : topLeft.x,
        y: flipCropVertically ? 1 - bottomRight.y : topLeft.y
      },
      bottomRight: {
        x: flipCropHorizontally ? 1 - topLeft.x : bottomRight.x,
        y: flipCropVertically ? 1 - topLeft.y : bottomRight.y
      },
      isCircle: shape.props.crop.isCircle
    };
    return resized;
  }
  component(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageShape, { shape });
  }
  indicator(shape) {
    const isCropping = this.editor.getCroppingShapeId() === shape.id;
    if (isCropping) return null;
    if (shape.props.crop?.isCircle) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "ellipse",
        {
          cx: toDomPrecision(shape.props.w / 2),
          cy: toDomPrecision(shape.props.h / 2),
          rx: toDomPrecision(shape.props.w / 2),
          ry: toDomPrecision(shape.props.h / 2)
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: toDomPrecision(shape.props.w), height: toDomPrecision(shape.props.h) });
  }
  async toSvg(shape, ctx) {
    const props = shape.props;
    if (!props.assetId) return null;
    const asset = this.editor.getAsset(props.assetId);
    if (!asset) return null;
    const { w } = getUncroppedSize(shape.props, props.crop);
    const src = await imageSvgExportCache.get(asset, async () => {
      let src2 = await ctx.resolveAssetUrl(asset.id, w);
      if (!src2) return null;
      if (src2.startsWith("blob:") || src2.startsWith("http") || src2.startsWith("/") || src2.startsWith("./")) {
        src2 = await getDataURIFromURL(src2) || "";
      }
      if (getIsAnimated(this.editor, asset.id)) {
        const { promise } = getFirstFrameOfAnimatedImage(src2);
        src2 = await promise;
      }
      return src2;
    });
    if (!src) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgImage, { shape, src });
  }
  onDoubleClickEdge(shape) {
    const props = shape.props;
    if (!props) return;
    if (this.editor.getCroppingShapeId() !== shape.id) {
      return;
    }
    const crop = structuredClone(props.crop) || {
      topLeft: { x: 0, y: 0 },
      bottomRight: { x: 1, y: 1 }
    };
    const { w, h: h2 } = getUncroppedSize(shape.props, crop);
    const pointDelta = new Vec(crop.topLeft.x * w, crop.topLeft.y * h2).rot(shape.rotation);
    const partial = {
      id: shape.id,
      type: shape.type,
      x: shape.x - pointDelta.x,
      y: shape.y - pointDelta.y,
      props: {
        crop: {
          topLeft: { x: 0, y: 0 },
          bottomRight: { x: 1, y: 1 }
        },
        w,
        h: h2
      }
    };
    this.editor.updateShapes([partial]);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    function interpolateCrop(startShape2, endShape2) {
      if (startShape2.props.crop === null && endShape2.props.crop === null) return null;
      const startTL = startShape2.props.crop?.topLeft || { x: 0, y: 0 };
      const startBR = startShape2.props.crop?.bottomRight || { x: 1, y: 1 };
      const endTL = endShape2.props.crop?.topLeft || { x: 0, y: 0 };
      const endBR = endShape2.props.crop?.bottomRight || { x: 1, y: 1 };
      return {
        topLeft: { x: lerp(startTL.x, endTL.x, t2), y: lerp(startTL.y, endTL.y, t2) },
        bottomRight: { x: lerp(startBR.x, endBR.x, t2), y: lerp(startBR.y, endBR.y, t2) }
      };
    }
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2),
      crop: interpolateCrop(startShape, endShape)
    };
  }
}
const ImageShape = reactExports.memo(function ImageShape2({ shape }) {
  const editor = useEditor();
  const { w } = getUncroppedSize(shape.props, shape.props.crop);
  const { asset, url } = useImageOrVideoAsset({
    shapeId: shape.id,
    assetId: shape.props.assetId,
    width: w
  });
  const prefersReducedMotion = usePrefersReducedMotion();
  const [staticFrameSrc, setStaticFrameSrc] = reactExports.useState("");
  const [loadedUrl, setLoadedUrl] = reactExports.useState(null);
  const isAnimated = asset && getIsAnimated(editor, asset.id);
  reactExports.useEffect(() => {
    if (url && isAnimated) {
      const { promise, cancel } = getFirstFrameOfAnimatedImage(url);
      promise.then((dataUrl) => {
        setStaticFrameSrc(dataUrl);
        setLoadedUrl(url);
      });
      return () => {
        cancel();
      };
    }
  }, [editor, isAnimated, prefersReducedMotion, url]);
  const showCropPreview = useValue(
    "show crop preview",
    () => shape.id === editor.getOnlySelectedShapeId() && editor.getCroppingShapeId() === shape.id && editor.isIn("select.crop"),
    [editor, shape.id]
  );
  const reduceMotion = prefersReducedMotion && (asset?.props.mimeType?.includes("video") || isAnimated);
  const containerStyle = getCroppedContainerStyle(shape);
  const nextSrc = url === loadedUrl ? null : url;
  const loadedSrc = reduceMotion ? staticFrameSrc : loadedUrl;
  if (!url && !asset?.props.src) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      HTMLContainer,
      {
        id: shape.id,
        style: {
          overflow: "hidden",
          width: shape.props.w,
          height: shape.props.h,
          color: "var(--tl-color-text-3)",
          backgroundColor: "var(--tl-color-low)",
          border: "1px solid var(--tl-color-low-border)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: classNames("tl-image-container", asset && "tl-image-container-loading"),
              style: containerStyle,
              children: asset ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(BrokenAssetIcon, {})
            }
          ),
          "url" in shape.props && shape.props.url && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url: shape.props.url })
        ]
      }
    );
  }
  const crossOrigin = isAnimated ? "anonymous" : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    showCropPreview && loadedSrc && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: containerStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        className: "tl-image",
        style: { ...getFlipStyle(shape), opacity: 0.1 },
        crossOrigin,
        src: loadedSrc,
        referrerPolicy: "strict-origin-when-cross-origin",
        draggable: false,
        alt: ""
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      HTMLContainer,
      {
        id: shape.id,
        style: {
          overflow: "hidden",
          width: shape.props.w,
          height: shape.props.h,
          borderRadius: shape.props.crop?.isCircle ? "50%" : void 0
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames("tl-image-container"), style: containerStyle, children: [
            loadedSrc && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                className: "tl-image",
                style: getFlipStyle(shape),
                crossOrigin,
                src: loadedSrc,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: false,
                alt: ""
              },
              loadedSrc
            ),
            nextSrc && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                className: "tl-image",
                style: getFlipStyle(shape),
                crossOrigin,
                src: nextSrc,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: false,
                alt: shape.props.altText,
                onLoad: () => setLoadedUrl(nextSrc)
              },
              nextSrc
            )
          ] }),
          shape.props.url && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url: shape.props.url })
        ]
      }
    )
  ] });
});
function getIsAnimated(editor, assetId) {
  const asset = assetId ? editor.getAsset(assetId) : void 0;
  if (!asset) return false;
  return "mimeType" in asset.props && MediaHelpers.isAnimatedImageType(asset?.props.mimeType) || "isAnimated" in asset.props && asset.props.isAnimated;
}
function getCroppedContainerStyle(shape) {
  const crop = shape.props.crop;
  const topLeft = crop?.topLeft;
  if (!topLeft) {
    return {
      width: shape.props.w,
      height: shape.props.h
    };
  }
  const { w, h: h2 } = getUncroppedSize(shape.props, crop);
  const offsetX = -topLeft.x * w;
  const offsetY = -topLeft.y * h2;
  return {
    transform: `translate(${offsetX}px, ${offsetY}px)`,
    width: w,
    height: h2
  };
}
function getFlipStyle(shape, size2) {
  const { flipX, flipY, crop } = shape.props;
  if (!flipX && !flipY) return void 0;
  let cropOffsetX;
  let cropOffsetY;
  if (crop) {
    const { w, h: h2 } = getUncroppedSize(shape.props, crop);
    const cropWidth = crop.bottomRight.x - crop.topLeft.x;
    const cropHeight = crop.bottomRight.y - crop.topLeft.y;
    cropOffsetX = modulate(crop.topLeft.x, [0, 1 - cropWidth], [0, w - shape.props.w]);
    cropOffsetY = modulate(crop.topLeft.y, [0, 1 - cropHeight], [0, h2 - shape.props.h]);
  }
  const scale = `scale(${flipX ? -1 : 1}, ${flipY ? -1 : 1})`;
  const translate = size2 ? `translate(${(flipX ? size2.width : 0) - (cropOffsetX ? cropOffsetX : 0)}px,
		             ${(flipY ? size2.height : 0) - (cropOffsetY ? cropOffsetY : 0)}px)` : "";
  return {
    transform: `${translate} ${scale}`,
    // in SVG, flipping around the center doesn't work so we use explicit width/height
    transformOrigin: size2 ? "0 0" : "center center"
  };
}
function SvgImage({ shape, src }) {
  const cropClipId = useUniqueSafeId();
  const containerStyle = getCroppedContainerStyle(shape);
  const crop = shape.props.crop;
  if (containerStyle.transform && crop) {
    const { transform: cropTransform, width, height } = containerStyle;
    const croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width;
    const croppedHeight = (crop.bottomRight.y - crop.topLeft.y) * height;
    const points = [
      new Vec(0, 0),
      new Vec(croppedWidth, 0),
      new Vec(croppedWidth, croppedHeight),
      new Vec(0, croppedHeight)
    ];
    const flip2 = getFlipStyle(shape, { width, height });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: cropClipId, children: crop.isCircle ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "ellipse",
        {
          cx: croppedWidth / 2,
          cy: croppedHeight / 2,
          rx: croppedWidth / 2,
          ry: croppedHeight / 2
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: points.map((p) => `${p.x},${p.y}`).join(" ") }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("g", { clipPath: `url(#${cropClipId})`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "image",
        {
          href: src,
          width,
          height,
          "aria-label": shape.props.altText,
          style: flip2 ? { ...flip2 } : { transform: cropTransform }
        }
      ) })
    ] });
  } else {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "image",
      {
        href: src,
        width: shape.props.w,
        height: shape.props.h,
        "aria-label": shape.props.altText,
        style: getFlipStyle(shape, { width: shape.props.w, height: shape.props.h })
      }
    );
  }
}
function getFirstFrameOfAnimatedImage(url) {
  let cancelled = false;
  const promise = new Promise((resolve) => {
    const image = Image();
    image.onload = () => {
      if (cancelled) return;
      const canvas = document.createElement("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.drawImage(image, 0, 0);
      resolve(canvas.toDataURL());
    };
    image.crossOrigin = "anonymous";
    image.src = url;
  });
  return { promise, cancel: () => cancelled = true };
}
const handlesCache = new WeakCache();
class LineShapeUtil extends ShapeUtil {
  static type = "line";
  static props = lineShapeProps;
  static migrations = lineShapeMigrations;
  hideResizeHandles() {
    return true;
  }
  hideRotateHandle() {
    return true;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  hideSelectionBoundsBg() {
    return true;
  }
  hideInMinimap() {
    return true;
  }
  getDefaultProps() {
    const [start, end] = getIndices(2);
    return {
      dash: "draw",
      size: "m",
      color: "black",
      spline: "line",
      points: {
        [start]: { id: start, index: start, x: 0, y: 0 },
        [end]: { id: end, index: end, x: 0.1, y: 0.1 }
      },
      scale: 1
    };
  }
  getGeometry(shape) {
    const geometry = getPathForLineShape(shape).toGeometry();
    assert(geometry instanceof PathBuilderGeometry2d);
    return geometry;
  }
  getHandles(shape) {
    return handlesCache.get(shape.props, () => {
      const spline = this.getGeometry(shape);
      const points = linePointsToArray(shape);
      const results = points.map((point) => ({
        ...point,
        id: point.index,
        type: "vertex",
        canSnap: true
      }));
      for (let i = 0; i < points.length - 1; i++) {
        const index2 = getIndexBetween(points[i].index, points[i + 1].index);
        const segment = spline.getSegments()[i];
        const point = segment.interpolateAlongEdge(0.5);
        results.push({
          id: index2,
          type: "create",
          index: index2,
          x: point.x,
          y: point.y,
          canSnap: true
        });
      }
      return results.sort(sortByIndex);
    });
  }
  //   Events
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    return {
      props: {
        points: mapObjectMapValues(shape.props.points, (_, { id, index: index2, x, y }) => ({
          id,
          index: index2,
          x: x * scaleX,
          y: y * scaleY
        }))
      }
    };
  }
  onBeforeCreate(next) {
    const {
      props: { points }
    } = next;
    const pointKeys = Object.keys(points);
    if (pointKeys.length < 2) {
      return;
    }
    const firstPoint = points[pointKeys[0]];
    const allSame = pointKeys.every((key) => {
      const point = points[key];
      return point.x === firstPoint.x && point.y === firstPoint.y;
    });
    if (allSame) {
      const lastKey = pointKeys[pointKeys.length - 1];
      points[lastKey] = {
        ...points[lastKey],
        x: points[lastKey].x + 0.1,
        y: points[lastKey].y + 0.1
      };
      return next;
    }
    return;
  }
  onHandleDrag(shape, { handle }) {
    const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor);
    return {
      ...shape,
      props: {
        ...shape.props,
        points: {
          ...shape.props.points,
          [handle.id]: { id: handle.id, index: handle.index, x: newPoint.x, y: newPoint.y }
        }
      }
    };
  }
  onHandleDragStart(shape, { handle }) {
    if (handle.type === "create") {
      return {
        ...shape,
        props: {
          ...shape.props,
          points: {
            ...shape.props.points,
            [handle.index]: { id: handle.index, index: handle.index, x: handle.x, y: handle.y }
          }
        }
      };
    }
    return;
  }
  component(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { style: { minWidth: 50, minHeight: 50 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LineShapeSvg, { shape }) });
  }
  indicator(shape) {
    const strokeWidth = STROKE_SIZES$1[shape.props.size] * shape.props.scale;
    const path = getPathForLineShape(shape);
    const { dash } = shape.props;
    return path.toSvg({
      style: dash === "draw" ? "draw" : "solid",
      strokeWidth: 1,
      passes: 1,
      randomSeed: shape.id,
      offset: 0,
      roundness: strokeWidth * 2,
      props: { strokeWidth: void 0 }
    });
  }
  toSvg(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(LineShapeSvg, { shouldScale: true, shape });
  }
  getHandleSnapGeometry(shape) {
    const points = linePointsToArray(shape);
    return {
      points,
      getSelfSnapPoints: (handle) => {
        const index2 = this.getHandles(shape).filter((h2) => h2.type === "vertex").findIndex((h2) => h2.id === handle.id);
        return points.filter((_, i) => Math.abs(i - index2) > 1).map(Vec.From);
      },
      getSelfSnapOutline: (handle) => {
        const index2 = this.getHandles(shape).filter((h2) => h2.type === "vertex").findIndex((h2) => h2.id === handle.id);
        const segments = this.getGeometry(shape).getSegments().filter((_, i) => i !== index2 - 1 && i !== index2);
        if (!segments.length) return null;
        return new Group2d({ children: segments });
      }
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    const startPoints = linePointsToArray(startShape);
    const endPoints = linePointsToArray(endShape);
    const pointsToUseStart = [];
    const pointsToUseEnd = [];
    let index2 = ZERO_INDEX_KEY;
    if (startPoints.length > endPoints.length) {
      for (let i = 0; i < startPoints.length; i++) {
        pointsToUseStart[i] = { ...startPoints[i] };
        if (endPoints[i] === void 0) {
          pointsToUseEnd[i] = { ...endPoints[endPoints.length - 1], id: index2 };
        } else {
          pointsToUseEnd[i] = { ...endPoints[i], id: index2 };
        }
        index2 = getIndexAbove(index2);
      }
    } else if (endPoints.length > startPoints.length) {
      for (let i = 0; i < endPoints.length; i++) {
        pointsToUseEnd[i] = { ...endPoints[i] };
        if (startPoints[i] === void 0) {
          pointsToUseStart[i] = {
            ...startPoints[startPoints.length - 1],
            id: index2
          };
        } else {
          pointsToUseStart[i] = { ...startPoints[i], id: index2 };
        }
        index2 = getIndexAbove(index2);
      }
    } else {
      for (let i = 0; i < endPoints.length; i++) {
        pointsToUseStart[i] = startPoints[i];
        pointsToUseEnd[i] = endPoints[i];
      }
    }
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      points: Object.fromEntries(
        pointsToUseStart.map((point, i) => {
          const endPoint = pointsToUseEnd[i];
          return [
            point.id,
            {
              ...point,
              x: lerp(point.x, endPoint.x, t2),
              y: lerp(point.y, endPoint.y, t2)
            }
          ];
        })
      ),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
}
function linePointsToArray(shape) {
  return Object.values(shape.props.points).sort(sortByIndex);
}
const pathCache = new WeakCache();
function getPathForLineShape(shape) {
  return pathCache.get(shape, () => {
    const points = linePointsToArray(shape).map(Vec.From);
    switch (shape.props.spline) {
      case "cubic": {
        return PathBuilder.cubicSplineThroughPoints(points, { endOffsets: 0 });
      }
      case "line": {
        return PathBuilder.lineThroughPoints(points, { endOffsets: 0 });
      }
    }
  });
}
function LineShapeSvg({
  shape,
  shouldScale = false,
  forceSolid = false
}) {
  const theme = useDefaultColorTheme();
  const path = getPathForLineShape(shape);
  const { dash, color, size: size2 } = shape.props;
  const scaleFactor = 1 / shape.props.scale;
  const scale = shouldScale ? scaleFactor : 1;
  const strokeWidth = STROKE_SIZES$1[size2] * shape.props.scale;
  return path.toSvg({
    style: dash,
    strokeWidth,
    forceSolid,
    randomSeed: shape.id,
    props: {
      transform: `scale(${scale})`,
      stroke: getColorValue(theme, color, "solid"),
      fill: "none"
    }
  });
}
function startEditingShapeWithLabel(editor, shape, selectAll2 = false) {
  editor.select(shape);
  editor.setEditingShape(shape);
  editor.setCurrentTool("select.editing_shape", {
    target: "shape",
    shape
  });
  if (selectAll2) {
    editor.emit("select-all-text", { shapeId: shape.id });
  }
}
class NoteShapeUtil extends ShapeUtil {
  static type = "note";
  static props = noteShapeProps;
  static migrations = noteShapeMigrations;
  options = {
    resizeMode: "none"
  };
  canEdit() {
    return true;
  }
  hideResizeHandles() {
    const { resizeMode } = this.options;
    switch (resizeMode) {
      case "none": {
        return true;
      }
      case "scale": {
        return false;
      }
      default: {
        throw exhaustiveSwitchError(resizeMode);
      }
    }
  }
  isAspectRatioLocked() {
    return this.options.resizeMode === "scale";
  }
  hideSelectionBoundsFg() {
    return false;
  }
  getDefaultProps() {
    return {
      color: "black",
      richText: toRichText(""),
      size: "m",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      labelColor: "black",
      growY: 0,
      fontSizeAdjustment: 0,
      url: "",
      scale: 1
    };
  }
  getGeometry(shape) {
    const { labelHeight, labelWidth } = getLabelSize(this.editor, shape);
    const { scale } = shape.props;
    const lh = labelHeight * scale;
    const lw = labelWidth * scale;
    const nw = NOTE_SIZE * scale;
    const nh = getNoteHeight(shape);
    return new Group2d({
      children: [
        new Rectangle2d({ width: nw, height: nh, isFilled: true }),
        new Rectangle2d({
          x: shape.props.align === "start" ? 0 : shape.props.align === "end" ? nw - lw : (nw - lw) / 2,
          y: shape.props.verticalAlign === "start" ? 0 : shape.props.verticalAlign === "end" ? nh - lh : (nh - lh) / 2,
          width: lw,
          height: lh,
          isFilled: true,
          isLabel: true,
          excludeFromShapeBounds: true
        })
      ]
    });
  }
  getHandles(shape) {
    const { scale } = shape.props;
    const isCoarsePointer = this.editor.getInstanceState().isCoarsePointer;
    if (isCoarsePointer) return [];
    const zoom = this.editor.getZoomLevel();
    if (zoom * scale < 0.25) return [];
    const nh = getNoteHeight(shape);
    const nw = NOTE_SIZE * scale;
    const offset2 = CLONE_HANDLE_MARGIN / zoom * scale;
    if (zoom * scale < 0.5) {
      return [
        {
          id: "bottom",
          index: "a3",
          type: "clone",
          x: nw / 2,
          y: nh + offset2
        }
      ];
    }
    return [
      {
        id: "top",
        index: "a1",
        type: "clone",
        x: nw / 2,
        y: -offset2
      },
      {
        id: "right",
        index: "a2",
        type: "clone",
        x: nw + offset2,
        y: nh / 2
      },
      {
        id: "bottom",
        index: "a3",
        type: "clone",
        x: nw / 2,
        y: nh + offset2
      },
      {
        id: "left",
        index: "a4",
        type: "clone",
        x: -offset2,
        y: nh / 2
      }
    ];
  }
  onResize(shape, info) {
    const { resizeMode } = this.options;
    switch (resizeMode) {
      case "none": {
        return void 0;
      }
      case "scale": {
        return resizeScaled(shape, info);
      }
      default: {
        throw exhaustiveSwitchError(resizeMode);
      }
    }
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  getFontFaces(shape) {
    if (isEmptyRichText(shape.props.richText)) {
      return EMPTY_ARRAY;
    }
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  component(shape) {
    const {
      id,
      type,
      props: {
        labelColor,
        scale,
        color,
        font,
        size: size2,
        align,
        richText,
        verticalAlign,
        fontSizeAdjustment
      }
    } = shape;
    const handleKeyDown2 = useNoteKeydownHandler(id);
    const theme = useDefaultColorTheme();
    const nw = NOTE_SIZE * scale;
    const nh = getNoteHeight(shape);
    const rotation = useValue(
      "shape rotation",
      () => this.editor.getShapePageTransform(id)?.rotation() ?? 0,
      [this.editor]
    );
    const hideShadows = useValue("zoom", () => this.editor.getZoomLevel() < 0.35 / scale, [
      scale,
      this.editor
    ]);
    const isDarkMode = useValue("dark mode", () => this.editor.user.getIsDarkMode(), [this.editor]);
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const isReadyForEditing = useIsReadyForEditing(this.editor, shape.id);
    const isEmpty = isEmptyRichText(richText);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          id,
          className: "tl-note__container",
          style: {
            width: nw,
            height: nh,
            backgroundColor: getColorValue(theme, color, "noteFill"),
            borderBottom: hideShadows ? isDarkMode ? `${2 * scale}px solid rgb(20, 20, 20)` : `${2 * scale}px solid rgb(144, 144, 144)` : "none",
            boxShadow: hideShadows ? "none" : getNoteShadow(shape.id, rotation, scale)
          },
          children: (isSelected || isReadyForEditing || !isEmpty) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            RichTextLabel,
            {
              shapeId: id,
              type,
              font,
              fontSize: (fontSizeAdjustment || LABEL_FONT_SIZES[size2]) * scale,
              lineHeight: TEXT_PROPS.lineHeight,
              align,
              verticalAlign,
              richText,
              isSelected,
              labelColor: labelColor === "black" ? getColorValue(theme, color, "noteText") : getColorValue(theme, labelColor, "fill"),
              wrap: true,
              padding: LABEL_PADDING * scale,
              hasCustomTabBehavior: true,
              onKeyDown: handleKeyDown2
            }
          )
        }
      ),
      "url" in shape.props && shape.props.url && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url: shape.props.url })
    ] });
  }
  indicator(shape) {
    const { scale } = shape.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "rect",
      {
        rx: scale,
        width: toDomPrecision(NOTE_SIZE * scale),
        height: toDomPrecision(getNoteHeight(shape))
      }
    );
  }
  toSvg(shape, ctx) {
    const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode });
    const bounds = getBoundsForSVG(shape);
    const textLabel = /* @__PURE__ */ jsxRuntimeExports.jsx(
      RichTextSVG,
      {
        fontSize: shape.props.fontSizeAdjustment || LABEL_FONT_SIZES[shape.props.size],
        font: shape.props.font,
        align: shape.props.align,
        verticalAlign: shape.props.verticalAlign,
        richText: shape.props.richText,
        labelColor: getColorValue(theme, shape.props.color, "noteText"),
        bounds,
        padding: LABEL_PADDING,
        showTextOutline: false
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: 5, y: 5, rx: 1, width: NOTE_SIZE - 10, height: bounds.h, fill: "rgba(0,0,0,.1)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          rx: 1,
          width: NOTE_SIZE,
          height: bounds.h,
          fill: getColorValue(theme, shape.props.color, "noteFill")
        }
      ),
      textLabel
    ] });
  }
  onBeforeCreate(next) {
    return getNoteSizeAdjustments(this.editor, next);
  }
  onBeforeUpdate(prev, next) {
    if (isEqual(prev.props.richText, next.props.richText) && prev.props.font === next.props.font && prev.props.size === next.props.size) {
      return;
    }
    return getNoteSizeAdjustments(this.editor, next);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
}
function getNoteSizeAdjustments(editor, shape) {
  const { labelHeight, fontSizeAdjustment } = getLabelSize(editor, shape);
  const growY = Math.max(0, labelHeight - NOTE_SIZE);
  if (growY !== shape.props.growY || fontSizeAdjustment !== shape.props.fontSizeAdjustment) {
    return {
      ...shape,
      props: {
        ...shape.props,
        growY,
        fontSizeAdjustment
      }
    };
  }
}
function getNoteLabelSize(editor, shape) {
  const { richText } = shape.props;
  if (isEmptyRichText(richText)) {
    const minHeight = LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2;
    return { labelHeight: minHeight, labelWidth: 100, fontSizeAdjustment: 0 };
  }
  const unadjustedFontSize = LABEL_FONT_SIZES[shape.props.size];
  let fontSizeAdjustment = 0;
  let iterations = 0;
  let labelHeight = NOTE_SIZE;
  let labelWidth = NOTE_SIZE;
  const FUZZ = 1;
  do {
    fontSizeAdjustment = Math.min(unadjustedFontSize, unadjustedFontSize - iterations);
    const html2 = renderHtmlFromRichTextForMeasurement(editor, richText);
    const nextTextSize = editor.textMeasure.measureHtml(html2, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[shape.props.font],
      fontSize: fontSizeAdjustment,
      maxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ,
      disableOverflowWrapBreaking: true,
      measureScrollWidth: true
    });
    labelHeight = nextTextSize.h + LABEL_PADDING * 2;
    labelWidth = nextTextSize.w + LABEL_PADDING * 2;
    if (fontSizeAdjustment <= 14) {
      const html22 = renderHtmlFromRichTextForMeasurement(editor, richText);
      const nextTextSizeWithOverflowBreak = editor.textMeasure.measureHtml(html22, {
        ...TEXT_PROPS,
        fontFamily: FONT_FAMILIES[shape.props.font],
        fontSize: fontSizeAdjustment,
        maxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ
      });
      labelHeight = nextTextSizeWithOverflowBreak.h + LABEL_PADDING * 2;
      labelWidth = nextTextSizeWithOverflowBreak.w + LABEL_PADDING * 2;
      break;
    }
    if (nextTextSize.scrollWidth.toFixed(0) === nextTextSize.w.toFixed(0)) {
      break;
    }
  } while (iterations++ < 50);
  return {
    labelHeight,
    labelWidth,
    fontSizeAdjustment
  };
}
const labelSizesForNote = new WeakCache();
function getLabelSize(editor, shape) {
  return labelSizesForNote.get(shape, () => getNoteLabelSize(editor, shape));
}
function useNoteKeydownHandler(id) {
  const editor = useEditor();
  const translation = reactExports.useContext(TranslationsContext);
  return reactExports.useCallback(
    (e) => {
      const shape = editor.getShape(id);
      if (!shape) return;
      const isTab = e.key === "Tab";
      const isCmdEnter = (e.metaKey || e.ctrlKey) && e.key === "Enter";
      if (isTab || isCmdEnter) {
        e.preventDefault();
        const pageTransform = editor.getShapePageTransform(id);
        const pageRotation = pageTransform.rotation();
        const isRTL2 = !!(translation?.dir === "rtl" || // todo: can we check a partial of the text, so that we don't have to render the whole thing?
        isRightToLeftLanguage(renderPlaintextFromRichText(editor, shape.props.richText)));
        const offsetLength = (NOTE_SIZE + editor.options.adjacentShapeMargin + // If we're growing down, we need to account for the current shape's growY
        (isCmdEnter && !e.shiftKey ? shape.props.growY : 0)) * shape.props.scale;
        const adjacentCenter = new Vec(
          isTab ? e.shiftKey != isRTL2 ? -1 : 1 : 0,
          isCmdEnter ? e.shiftKey ? -1 : 1 : 0
        ).mul(offsetLength).add(NOTE_CENTER_OFFSET.clone().mul(shape.props.scale)).rot(pageRotation).add(pageTransform.point());
        const newNote = getNoteShapeForAdjacentPosition(editor, shape, adjacentCenter, pageRotation);
        if (newNote) {
          startEditingShapeWithLabel(
            editor,
            newNote,
            true
            /* selectAll */
          );
        }
      }
    },
    [id, editor, translation?.dir]
  );
}
function getNoteHeight(shape) {
  return (NOTE_SIZE + shape.props.growY) * shape.props.scale;
}
function getNoteShadow(id, rotation, scale) {
  const random = rng(id);
  const lift2 = Math.abs(random()) + 0.5;
  const oy = Math.cos(rotation);
  const a = 5 * scale;
  const b = 4 * scale;
  const c = 6 * scale;
  const d = 7 * scale;
  return `0px ${a - lift2}px ${a}px -${a}px rgba(15, 23, 31, .6),
	0px ${(b + lift2 * d) * Math.max(0, oy)}px ${c + lift2 * d}px -${b + lift2 * c}px rgba(15, 23, 31, ${(0.3 + lift2 * 0.1).toFixed(2)}), 
	0px ${48 * scale}px ${10 * scale}px -${10 * scale}px inset rgba(15, 23, 44, ${((0.022 + random() * 5e-3) * ((1 + oy) / 2)).toFixed(2)})`;
}
function getBoundsForSVG(shape) {
  return new Box(0, 0, NOTE_SIZE, NOTE_SIZE + shape.props.growY);
}
const sizeCache = createComputedCache(
  "text size",
  (editor, shape) => {
    editor.fonts.trackFontsForShape(shape);
    return getTextSize(editor, shape.props);
  },
  { areRecordsEqual: (a, b) => a.props === b.props }
);
class TextShapeUtil extends ShapeUtil {
  static type = "text";
  static props = textShapeProps;
  static migrations = textShapeMigrations;
  options = {
    extraArrowHorizontalPadding: 10
  };
  getDefaultProps() {
    return {
      color: "black",
      size: "m",
      w: 8,
      font: "draw",
      textAlign: "start",
      autoSize: true,
      scale: 1,
      richText: toRichText("")
    };
  }
  getMinDimensions(shape) {
    return sizeCache.get(this.editor, shape.id);
  }
  getGeometry(shape, opts) {
    const { scale } = shape.props;
    const { width, height } = this.getMinDimensions(shape);
    const context = opts?.context ?? "none";
    return new Rectangle2d({
      x: (context === "@tldraw/arrow-without-arrowhead" ? -this.options.extraArrowHorizontalPadding : 0) * scale,
      width: (width + (context === "@tldraw/arrow-without-arrowhead" ? this.options.extraArrowHorizontalPadding * 2 : 0)) * scale,
      height: height * scale,
      isFilled: true,
      isLabel: true
    });
  }
  getFontFaces(shape) {
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  canEdit() {
    return true;
  }
  isAspectRatioLocked() {
    return true;
  }
  // WAIT NO THIS IS HARD CODED IN THE RESIZE HANDLER
  component(shape) {
    const {
      id,
      props: { font, size: size2, richText, color, scale, textAlign }
    } = shape;
    const { width, height } = this.getMinDimensions(shape);
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const theme = useDefaultColorTheme();
    const handleKeyDown2 = useTextShapeKeydownHandler(id);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RichTextLabel,
      {
        shapeId: id,
        classNamePrefix: "tl-text-shape",
        type: "text",
        font,
        fontSize: FONT_SIZES[size2],
        lineHeight: TEXT_PROPS.lineHeight,
        align: textAlign,
        verticalAlign: "middle",
        richText,
        labelColor: getColorValue(theme, color, "solid"),
        isSelected,
        textWidth: width,
        textHeight: height,
        style: {
          transform: `scale(${scale})`,
          transformOrigin: "top left"
        },
        wrap: true,
        onKeyDown: handleKeyDown2
      }
    );
  }
  indicator(shape) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    const editor = useEditor();
    if (shape.props.autoSize && editor.getEditingShapeId() === shape.id) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: toDomPrecision(bounds.width), height: toDomPrecision(bounds.height) });
  }
  toSvg(shape, ctx) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    const width = bounds.width / (shape.props.scale ?? 1);
    const height = bounds.height / (shape.props.scale ?? 1);
    const theme = getDefaultColorTheme(ctx);
    const exportBounds = new Box(0, 0, width, height);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RichTextSVG,
      {
        fontSize: FONT_SIZES[shape.props.size],
        font: shape.props.font,
        align: shape.props.textAlign,
        verticalAlign: "middle",
        richText: shape.props.richText,
        labelColor: getColorValue(theme, shape.props.color, "solid"),
        bounds: exportBounds,
        padding: 0
      }
    );
  }
  onResize(shape, info) {
    const { newPoint, initialBounds, initialShape, scaleX, handle } = info;
    if (info.mode === "scale_shape" || handle !== "right" && handle !== "left") {
      return {
        id: shape.id,
        type: shape.type,
        ...resizeScaled(shape, info)
      };
    } else {
      const nextWidth = Math.max(1, Math.abs(initialBounds.width * scaleX));
      const { x, y } = scaleX < 0 ? Vec.Sub(newPoint, Vec.FromAngle(shape.rotation).mul(nextWidth)) : newPoint;
      return {
        id: shape.id,
        type: shape.type,
        x,
        y,
        props: {
          w: nextWidth / initialShape.props.scale,
          autoSize: false
        }
      };
    }
  }
  onEditEnd(shape) {
    const trimmedText = renderPlaintextFromRichText(this.editor, shape.props.richText).trimEnd();
    if (trimmedText.length === 0) {
      this.editor.deleteShapes([shape.id]);
    }
  }
  onBeforeUpdate(prev, next) {
    if (!next.props.autoSize) return;
    const styleDidChange = prev.props.size !== next.props.size || prev.props.textAlign !== next.props.textAlign || prev.props.font !== next.props.font || prev.props.scale !== 1 && next.props.scale === 1;
    const textDidChange = !isEqual(prev.props.richText, next.props.richText);
    if (!styleDidChange && !textDidChange) return;
    const boundsA = this.getMinDimensions(prev);
    const boundsB = getTextSize(this.editor, next.props);
    const wA = boundsA.width * prev.props.scale;
    const hA = boundsA.height * prev.props.scale;
    const wB = boundsB.width * next.props.scale;
    const hB = boundsB.height * next.props.scale;
    let delta;
    switch (next.props.textAlign) {
      case "middle": {
        delta = new Vec((wB - wA) / 2, textDidChange ? 0 : (hB - hA) / 2);
        break;
      }
      case "end": {
        delta = new Vec(wB - wA, textDidChange ? 0 : (hB - hA) / 2);
        break;
      }
      default: {
        if (textDidChange) break;
        delta = new Vec(0, (hB - hA) / 2);
        break;
      }
    }
    if (delta) {
      delta.rot(next.rotation);
      const { x, y } = next;
      return {
        ...next,
        x: x - delta.x,
        y: y - delta.y,
        props: { ...next.props, w: wB }
      };
    } else {
      return {
        ...next,
        props: { ...next.props, w: wB }
      };
    }
  }
  // 	todo: The edge doubleclicking feels like a mistake more often than
  //  not, especially on multiline text. Removed June 16 2024
  // override onDoubleClickEdge = (shape: TLTextShape) => {
  // 	// If the shape has a fixed width, set it to autoSize.
  // 	if (!shape.props.autoSize) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				autoSize: true,
  // 			},
  // 		}
  // 	}
  // 	// If the shape is scaled, reset the scale to 1.
  // 	if (shape.props.scale !== 1) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				scale: 1,
  // 			},
  // 		}
  // 	}
  // }
}
function getTextSize(editor, props) {
  const { font, richText, size: size2, w } = props;
  const minWidth = 16;
  const fontSize = FONT_SIZES[size2];
  const maybeFixedWidth = props.autoSize ? null : Math.max(minWidth, Math.floor(w));
  const html2 = renderHtmlFromRichTextForMeasurement(editor, richText);
  const result = editor.textMeasure.measureHtml(html2, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[font],
    fontSize,
    maxWidth: maybeFixedWidth
  });
  return {
    width: maybeFixedWidth ?? Math.max(minWidth, result.w + 1),
    height: Math.max(fontSize, result.h)
  };
}
function useTextShapeKeydownHandler(id) {
  const editor = useEditor();
  return reactExports.useCallback(
    (e) => {
      if (editor.getEditingShapeId() !== id) return;
      switch (e.key) {
        case "Enter": {
          if (e.ctrlKey || e.metaKey) {
            editor.complete();
          }
          break;
        }
      }
    },
    [editor, id]
  );
}
const videoSvgExportCache = new WeakCache();
class VideoShapeUtil extends BaseBoxShapeUtil {
  static type = "video";
  static props = videoShapeProps;
  static migrations = videoShapeMigrations;
  options = {
    autoplay: true
  };
  canEdit() {
    return true;
  }
  isAspectRatioLocked() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      autoplay: this.options.autoplay,
      url: "",
      altText: "",
      // Not used, but once upon a time were used to sync video state between users
      time: 0,
      playing: true
    };
  }
  getAriaDescriptor(shape) {
    return shape.props.altText;
  }
  component(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VideoShape, { shape });
  }
  indicator(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: toDomPrecision(shape.props.w), height: toDomPrecision(shape.props.h) });
  }
  async toSvg(shape, ctx) {
    const props = shape.props;
    if (!props.assetId) return null;
    const asset = this.editor.getAsset(props.assetId);
    if (!asset) return null;
    const src = await videoSvgExportCache.get(asset, async () => {
      const assetUrl = await ctx.resolveAssetUrl(asset.id, props.w);
      if (!assetUrl) return null;
      const video = await MediaHelpers.loadVideo(assetUrl);
      return await MediaHelpers.getVideoFrameAsDataUrl(video, 0);
    });
    if (!src) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("image", { href: src, width: props.w, height: props.h, "aria-label": shape.props.altText });
  }
}
const VideoShape = reactExports.memo(function VideoShape2({ shape }) {
  const editor = useEditor();
  const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110;
  const isEditing = useIsEditing(shape.id);
  const prefersReducedMotion = usePrefersReducedMotion();
  const { Spinner: Spinner2 } = useEditorComponents();
  const { asset, url } = useImageOrVideoAsset({
    shapeId: shape.id,
    assetId: shape.props.assetId,
    width: shape.props.w
  });
  const rVideo = reactExports.useRef(null);
  const [isLoaded, setIsLoaded] = reactExports.useState(false);
  const handleLoadedData = reactExports.useCallback((e) => {
    const video = e.currentTarget;
    if (!video) return;
    setIsLoaded(true);
  }, []);
  const [isFullscreen, setIsFullscreen] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const fullscreenChange = () => setIsFullscreen(document.fullscreenElement === rVideo.current);
    document.addEventListener("fullscreenchange", fullscreenChange);
    return () => document.removeEventListener("fullscreenchange", fullscreenChange);
  });
  reactExports.useEffect(() => {
    const video = rVideo.current;
    if (!video) return;
    if (isEditing) {
      if (document.activeElement !== video) {
        video.focus();
      }
    }
  }, [isEditing, isLoaded]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      HTMLContainer,
      {
        id: shape.id,
        style: {
          color: "var(--tl-color-text-3)",
          backgroundColor: asset ? "transparent" : "var(--tl-color-low)",
          border: asset ? "none" : "1px solid var(--tl-color-low-border)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-counter-scaled", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-video-container", children: !asset ? /* @__PURE__ */ jsxRuntimeExports.jsx(BrokenAssetIcon, {}) : Spinner2 && !asset.props.src ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner2, {}) : url ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "video",
            {
              ref: rVideo,
              style: isEditing ? { pointerEvents: "all" } : !isLoaded ? { display: "none" } : void 0,
              className: classNames("tl-video", `tl-video-shape-${shape.id.split(":")[1]}`, {
                "tl-video-is-fullscreen": isFullscreen
              }),
              width: "100%",
              height: "100%",
              draggable: false,
              playsInline: true,
              autoPlay: shape.props.autoplay && !prefersReducedMotion,
              muted: true,
              loop: true,
              disableRemotePlayback: true,
              disablePictureInPicture: true,
              controls: isEditing && showControls,
              onLoadedData: handleLoadedData,
              hidden: !isLoaded,
              "aria-label": shape.props.altText,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: url })
            },
            url
          ),
          !isLoaded && Spinner2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner2, {})
        ] }) : null }) })
      }
    ),
    "url" in shape.props && shape.props.url && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url: shape.props.url })
  ] });
});
const defaultShapeUtils = [
  TextShapeUtil,
  BookmarkShapeUtil,
  DrawShapeUtil,
  GeoShapeUtil,
  NoteShapeUtil,
  LineShapeUtil,
  FrameShapeUtil,
  ArrowShapeUtil,
  HighlightShapeUtil,
  EmbedShapeUtil,
  ImageShapeUtil,
  VideoShapeUtil
];
function registerDefaultSideEffects(editor) {
  return editor.sideEffects.register({
    instance_page_state: {
      afterChange: (prev, next) => {
        if (prev.croppingShapeId !== next.croppingShapeId) {
          const isInCroppingState = editor.isIn("select.crop");
          if (!prev.croppingShapeId && next.croppingShapeId) {
            if (!isInCroppingState) {
              editor.setCurrentTool("select.crop.idle");
            }
          } else if (prev.croppingShapeId && !next.croppingShapeId) {
            if (isInCroppingState) {
              editor.setCurrentTool("select.idle");
            }
          }
        }
        if (prev.editingShapeId !== next.editingShapeId) {
          if (!prev.editingShapeId && next.editingShapeId) {
            if (!editor.isIn("select.editing_shape")) {
              const shape = editor.getEditingShape();
              if (shape && shape.type === "text" && editor.isInAny("text.pointing", "select.resizing") && editor.getInstanceState().isToolLocked) {
                editor.setCurrentTool("select.editing_shape", {
                  isCreatingTextWhileToolLocked: true
                });
              } else {
                editor.setCurrentTool("select.editing_shape");
              }
            }
          } else if (prev.editingShapeId && !next.editingShapeId) {
            if (editor.isIn("select.editing_shape")) {
              editor.setCurrentTool("select.idle");
            }
          }
        }
      }
    }
  });
}
class Erasing extends StateNode {
  static id = "erasing";
  info = {};
  scribbleId = "id";
  markId = "";
  excludedShapeIds = /* @__PURE__ */ new Set();
  _isHoldingAccelKey = false;
  _firstErasingShapeId = null;
  _erasingShapeIds = [];
  onEnter(info) {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
    this._firstErasingShapeId = this.editor.getErasingShapeIds()[0];
    this._erasingShapeIds = this.editor.getErasingShapeIds();
    this.markId = this.editor.markHistoryStoppingPoint("erase scribble begin");
    this.info = info;
    const { originPagePoint } = this.editor.inputs;
    this.excludedShapeIds = new Set(
      this.editor.getCurrentPageShapes().filter((shape) => {
        if (this.editor.isShapeOrAncestorLocked(shape)) return true;
        if (this.editor.isShapeOfType(shape, "group") || this.editor.isShapeOfType(shape, "frame")) {
          const pointInShapeShape = this.editor.getPointInShapeSpace(shape, originPagePoint);
          const geometry = this.editor.getShapeGeometry(shape);
          return geometry.bounds.containsPoint(pointInShapeShape);
        }
        return false;
      }).map((shape) => shape.id)
    );
    const scribble = this.editor.scribbles.addScribble({
      color: "muted-1",
      size: 12
    });
    this.scribbleId = scribble.id;
    this.update();
  }
  pushPointToScribble() {
    const { x, y } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, x, y);
  }
  onExit() {
    this.editor.setErasingShapes([]);
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onKeyUp() {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
    this.update();
  }
  onKeyDown() {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
    this.update();
  }
  update() {
    const { editor, excludedShapeIds } = this;
    const erasingShapeIds = editor.getErasingShapeIds();
    const zoomLevel = editor.getZoomLevel();
    const currentPageShapes = editor.getCurrentPageRenderingShapesSorted();
    const {
      inputs: { currentPagePoint, previousPagePoint }
    } = editor;
    this.pushPointToScribble();
    const erasing = new Set(erasingShapeIds);
    const minDist = this.editor.options.hitTestMargin / zoomLevel;
    for (const shape of currentPageShapes) {
      if (editor.isShapeOfType(shape, "group")) continue;
      const pageMask = editor.getShapeMask(shape.id);
      if (pageMask && !pointInPolygon(currentPagePoint, pageMask)) {
        continue;
      }
      const geometry = editor.getShapeGeometry(shape);
      const pageTransform = editor.getShapePageTransform(shape);
      if (!geometry || !pageTransform) continue;
      const pt = pageTransform.clone().invert();
      const A = pt.applyToPoint(previousPagePoint);
      const B = pt.applyToPoint(currentPagePoint);
      const { bounds } = geometry;
      if (bounds.minX - minDist > Math.max(A.x, B.x) || bounds.minY - minDist > Math.max(A.y, B.y) || bounds.maxX + minDist < Math.min(A.x, B.x) || bounds.maxY + minDist < Math.min(A.y, B.y)) {
        continue;
      }
      if (geometry.hitTestLineSegment(A, B, minDist)) {
        erasing.add(editor.getOutermostSelectableShape(shape).id);
      }
      this._erasingShapeIds = [...erasing];
    }
    if (this._isHoldingAccelKey && this._firstErasingShapeId) {
      const erasingShapeId = this._firstErasingShapeId;
      if (erasingShapeId && this.editor.getShape(erasingShapeId)) {
        editor.setErasingShapes([erasingShapeId]);
      }
      return;
    }
    this.editor.setErasingShapes(this._erasingShapeIds.filter((id) => !excludedShapeIds.has(id)));
  }
  complete() {
    const { editor } = this;
    editor.deleteShapes(editor.getCurrentPageState().erasingShapeIds);
    this.parent.transition("idle");
    this._erasingShapeIds = [];
    this._firstErasingShapeId = null;
  }
  cancel() {
    const { editor } = this;
    editor.bailToMark(this.markId);
    this.parent.transition("idle", this.info);
  }
}
let Idle$5 = class Idle8 extends StateNode {
  static id = "idle";
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
let Pointing$2 = class Pointing7 extends StateNode {
  static id = "pointing";
  _isHoldingAccelKey = false;
  onEnter() {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
    const zoomLevel = this.editor.getZoomLevel();
    const currentPageShapesSorted = this.editor.getCurrentPageRenderingShapesSorted();
    const {
      inputs: { currentPagePoint }
    } = this.editor;
    const erasing = /* @__PURE__ */ new Set();
    const initialSize = erasing.size;
    for (let n = currentPageShapesSorted.length, i = n - 1; i >= 0; i--) {
      const shape = currentPageShapesSorted[i];
      if (this.editor.isShapeOrAncestorLocked(shape) || this.editor.isShapeOfType(shape, "group")) {
        continue;
      }
      if (this.editor.isPointInShape(shape, currentPagePoint, {
        hitInside: false,
        margin: this.editor.options.hitTestMargin / zoomLevel
      })) {
        const hitShape = this.editor.getOutermostSelectableShape(shape);
        if (this.editor.isShapeOfType(hitShape, "frame") && erasing.size > initialSize) {
          break;
        }
        erasing.add(hitShape.id);
        if (this._isHoldingAccelKey) {
          break;
        }
      }
    }
    this.editor.setErasingShapes([...erasing]);
  }
  onKeyUp() {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
  }
  onKeyDown() {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
  }
  onLongPress(info) {
    this.startErasing(info);
  }
  onExit(_info, to) {
    if (to !== "erasing") {
      this.editor.setErasingShapes([]);
    }
  }
  onPointerMove(info) {
    if (this._isHoldingAccelKey) return;
    if (this.editor.inputs.isDragging) {
      this.startErasing(info);
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  startErasing(info) {
    this.parent.transition("erasing", info);
  }
  complete() {
    const erasingShapeIds = this.editor.getErasingShapeIds();
    if (erasingShapeIds.length) {
      this.editor.markHistoryStoppingPoint("erase end");
      this.editor.deleteShapes(erasingShapeIds);
    }
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
};
class EraserTool extends StateNode {
  static id = "eraser";
  static initial = "idle";
  static isLockable = false;
  static children() {
    return [Idle$5, Pointing$2, Erasing];
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
}
class Dragging2 extends StateNode {
  static id = "dragging";
  initialCamera = new Vec();
  onEnter() {
    this.initialCamera = Vec.From(this.editor.getCamera());
    this.update();
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.parent.transition("idle");
  }
  onComplete() {
    this.complete();
  }
  update() {
    const { initialCamera, editor } = this;
    const { currentScreenPoint, originScreenPoint } = editor.inputs;
    const delta = Vec.Sub(currentScreenPoint, originScreenPoint).div(editor.getZoomLevel());
    if (delta.len2() === 0) return;
    editor.setCamera(initialCamera.clone().add(delta));
  }
  complete() {
    const { editor } = this;
    const { pointerVelocity } = editor.inputs;
    const velocityAtPointerUp = Math.min(pointerVelocity.len(), 2);
    if (velocityAtPointerUp > 0.1) {
      this.editor.slideCamera({ speed: velocityAtPointerUp, direction: pointerVelocity });
    }
    this.parent.transition("idle");
  }
}
let Idle$4 = class Idle9 extends StateNode {
  static id = "idle";
  onEnter() {
    this.editor.setCursor({ type: "grab", rotation: 0 });
  }
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
let Pointing$1 = class Pointing8 extends StateNode {
  static id = "pointing";
  onEnter() {
    this.editor.stopCameraAnimation();
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onLongPress() {
    this.startDragging();
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      this.startDragging();
    }
  }
  startDragging() {
    this.parent.transition("dragging");
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.complete();
  }
  complete() {
    this.parent.transition("idle");
  }
};
class HandTool extends StateNode {
  static id = "hand";
  static initial = "idle";
  static isLockable = false;
  static children() {
    return [Idle$4, Pointing$1, Dragging2];
  }
  onDoubleClick(info) {
    if (info.phase === "settle") {
      const { currentScreenPoint } = this.editor.inputs;
      this.editor.zoomIn(currentScreenPoint, {
        animation: { duration: 220, easing: EASINGS.easeOutQuint }
      });
    }
  }
  onTripleClick(info) {
    if (info.phase === "settle") {
      const { currentScreenPoint } = this.editor.inputs;
      this.editor.zoomOut(currentScreenPoint, {
        animation: { duration: 320, easing: EASINGS.easeOutQuint }
      });
    }
  }
  onQuadrupleClick(info) {
    if (info.phase === "settle") {
      const zoomLevel = this.editor.getZoomLevel();
      const {
        inputs: { currentScreenPoint }
      } = this.editor;
      if (zoomLevel === 1) {
        this.editor.zoomToFit({ animation: { duration: 400, easing: EASINGS.easeOutQuint } });
      } else {
        this.editor.resetZoom(currentScreenPoint, {
          animation: { duration: 320, easing: EASINGS.easeOutQuint }
        });
      }
    }
  }
}
let Idle$3 = class Idle10 extends StateNode {
  static id = "idle";
  onCancel() {
    this.editor.setCurrentTool("select");
  }
  onPointerDown(info) {
    this.parent.transition("lasering", info);
  }
};
class Lasering extends StateNode {
  static id = "lasering";
  scribbleId = "id";
  onEnter() {
    const scribble = this.editor.scribbles.addScribble({
      color: "laser",
      opacity: 0.7,
      size: 4,
      delay: this.editor.options.laserDelayMs,
      shrink: 0.05,
      taper: true
    });
    this.scribbleId = scribble.id;
    this.pushPointToScribble();
  }
  onExit() {
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.pushPointToScribble();
  }
  onPointerUp() {
    this.complete();
  }
  pushPointToScribble() {
    const { x, y } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, x, y);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  complete() {
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
}
class LaserTool extends StateNode {
  static id = "laser";
  static initial = "idle";
  static children() {
    return [Idle$3, Lasering];
  }
  static isLockable = false;
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
}
class Brushing extends StateNode {
  static id = "brushing";
  info = {};
  initialSelectedShapeIds = [];
  excludedShapeIds = /* @__PURE__ */ new Set();
  isWrapMode = false;
  viewportDidChange = false;
  cleanupViewportChangeReactor() {
  }
  // cleanup function for the viewport reactor
  onEnter(info) {
    const { editor } = this;
    const { altKey: altKey2 } = editor.inputs;
    this.isWrapMode = editor.user.getIsWrapMode();
    this.viewportDidChange = false;
    let isInitialCheck = true;
    this.cleanupViewportChangeReactor = react("viewport change while brushing", () => {
      editor.getViewportPageBounds();
      if (!isInitialCheck && !this.viewportDidChange) {
        this.viewportDidChange = true;
      }
    });
    if (altKey2) {
      this.parent.transition("scribble_brushing", info);
      return;
    }
    this.excludedShapeIds = new Set(
      editor.getCurrentPageShapes().filter(
        (shape) => editor.isShapeOfType(shape, "group") || editor.isShapeOrAncestorLocked(shape)
      ).map((shape) => shape.id)
    );
    this.info = info;
    this.initialSelectedShapeIds = editor.getSelectedShapeIds().slice();
    this.hitTestShapes();
    isInitialCheck = false;
  }
  onExit() {
    this.initialSelectedShapeIds = [];
    this.editor.updateInstanceState({ brush: null });
    this.cleanupViewportChangeReactor();
  }
  onTick({ elapsed }) {
    const { editor } = this;
    editor.edgeScrollManager.updateEdgeScrolling(elapsed);
  }
  onPointerMove() {
    this.hitTestShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel(info) {
    this.editor.setSelectedShapes(this.initialSelectedShapeIds);
    this.parent.transition("idle", info);
  }
  onKeyDown(info) {
    if (this.editor.inputs.altKey) {
      this.parent.transition("scribble_brushing", info);
    } else {
      this.hitTestShapes();
    }
  }
  onKeyUp() {
    this.hitTestShapes();
  }
  complete() {
    this.hitTestShapes();
    this.parent.transition("idle");
  }
  hitTestShapes() {
    const { editor, excludedShapeIds, isWrapMode } = this;
    const {
      inputs: { originPagePoint, currentPagePoint, shiftKey, ctrlKey: ctrlKey2 }
    } = editor;
    const results = new Set(shiftKey ? this.initialSelectedShapeIds : []);
    const isWrapping = isWrapMode ? !ctrlKey2 : ctrlKey2;
    const brush = Box.FromPoints([originPagePoint, currentPagePoint]);
    const { corners } = brush;
    let A, B, shape, pageBounds, pageTransform, localCorners;
    const brushBoxIsInsideViewport = editor.getViewportPageBounds().contains(brush);
    const shapesToHitTest = brushBoxIsInsideViewport && !this.viewportDidChange ? editor.getCurrentPageRenderingShapesSorted() : editor.getCurrentPageShapesSorted();
    const currentPageId = editor.getCurrentPageId();
    testAllShapes: for (let i = 0, n = shapesToHitTest.length; i < n; i++) {
      shape = shapesToHitTest[i];
      if (excludedShapeIds.has(shape.id) || results.has(shape.id)) continue testAllShapes;
      pageBounds = editor.getShapePageBounds(shape);
      if (!pageBounds) continue testAllShapes;
      if (brush.contains(pageBounds)) {
        this.handleHit(shape, currentPagePoint, currentPageId, results, corners);
        continue testAllShapes;
      }
      if (isWrapping || editor.isShapeOfType(shape, "frame")) {
        continue testAllShapes;
      }
      if (brush.collides(pageBounds)) {
        pageTransform = editor.getShapePageTransform(shape);
        if (!pageTransform) continue testAllShapes;
        localCorners = pageTransform.clone().invert().applyToPoints(corners);
        const geometry = editor.getShapeGeometry(shape);
        hitTestBrushEdges: for (let i2 = 0; i2 < 4; i2++) {
          A = localCorners[i2];
          B = localCorners[(i2 + 1) % 4];
          if (geometry.hitTestLineSegment(A, B, 0)) {
            this.handleHit(shape, currentPagePoint, currentPageId, results, corners);
            break hitTestBrushEdges;
          }
        }
      }
    }
    const currentBrush = editor.getInstanceState().brush;
    if (!currentBrush || !brush.equals(currentBrush)) {
      editor.updateInstanceState({ brush: { ...brush.toJson() } });
    }
    const current = editor.getSelectedShapeIds();
    if (current.length !== results.size || current.some((id) => !results.has(id))) {
      editor.setSelectedShapes(Array.from(results));
    }
  }
  onInterrupt() {
    this.editor.updateInstanceState({ brush: null });
  }
  handleHit(shape, currentPagePoint, currentPageId, results, corners) {
    if (shape.parentId === currentPageId) {
      results.add(shape.id);
      return;
    }
    const selectedShape = this.editor.getOutermostSelectableShape(shape);
    const pageMask = this.editor.getShapeMask(selectedShape.id);
    if (pageMask && !polygonsIntersect(pageMask, corners) && !pointInPolygon(currentPagePoint, pageMask)) {
      return;
    }
    results.add(selectedShape.id);
  }
}
const CursorTypeMap = {
  bottom: "ns-resize",
  top: "ns-resize",
  left: "ew-resize",
  right: "ew-resize",
  bottom_left: "nesw-resize",
  bottom_right: "nwse-resize",
  top_left: "nwse-resize",
  top_right: "nesw-resize",
  bottom_left_rotate: "swne-rotate",
  bottom_right_rotate: "senw-rotate",
  top_left_rotate: "nwse-rotate",
  top_right_rotate: "nesw-rotate",
  mobile_rotate: "grabbing"
};
class PointingResizeHandle extends StateNode {
  static id = "pointing_resize_handle";
  info = {};
  updateCursor() {
    const selected = this.editor.getSelectedShapes();
    const cursorType = CursorTypeMap[this.info.handle];
    this.editor.setCursor({
      type: cursorType,
      rotation: selected.length === 1 ? this.editor.getSelectionRotation() : 0
    });
  }
  onEnter(info) {
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      this.startResizing();
    }
  }
  onLongPress() {
    this.startResizing();
  }
  startResizing() {
    if (this.editor.getIsReadonly()) return;
    this.parent.transition("resizing", this.info);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
  cancel() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
}
class Cropping extends StateNode {
  static id = "cropping";
  info = {};
  markId = "";
  snapshot = {};
  onEnter(info) {
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.markId = this.editor.markHistoryStoppingPoint("cropping");
    this.snapshot = this.createSnapshot();
    this.updateShapes();
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    this.updateShapes();
  }
  onKeyUp() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
  }
  updateCursor() {
    const selectedShape = this.editor.getSelectedShapes()[0];
    if (!selectedShape) return;
    const cursorType = CursorTypeMap[this.info.handle];
    this.editor.setCursor({ type: cursorType, rotation: this.editor.getSelectionRotation() });
  }
  updateShapes() {
    const { shape, cursorHandleOffset } = this.snapshot;
    if (!shape) return;
    const util = this.editor.getShapeUtil(shape.type);
    if (!util) return;
    const { shiftKey } = this.editor.inputs;
    const currentPagePoint = this.editor.inputs.currentPagePoint.clone().sub(cursorHandleOffset);
    const originPagePoint = this.editor.inputs.originPagePoint.clone().sub(cursorHandleOffset);
    const change = currentPagePoint.clone().sub(originPagePoint).rot(-shape.rotation);
    const crop = shape.props.crop ?? getDefaultCrop();
    const uncroppedSize = getUncroppedSize(shape.props, crop);
    const cropFn = util.onCrop?.bind(util) ?? getCropBox;
    const partial = cropFn(shape, {
      handle: this.info.handle,
      change,
      crop,
      uncroppedSize,
      initialShape: this.snapshot.shape,
      aspectRatioLocked: shiftKey
    });
    if (!partial) return;
    this.editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        ...partial
      }
    ]);
    this.updateCursor();
  }
  complete() {
    this.updateShapes();
    kickoutOccludedShapes(this.editor, [this.snapshot.shape.id]);
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
    } else {
      this.editor.setCroppingShape(null);
      this.editor.setCurrentTool("select.idle");
    }
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
    } else {
      this.editor.setCroppingShape(null);
      this.editor.setCurrentTool("select.idle");
    }
  }
  createSnapshot() {
    const selectionRotation = this.editor.getSelectionRotation();
    const {
      inputs: { originPagePoint }
    } = this.editor;
    const shape = this.editor.getOnlySelectedShape();
    const selectionBounds = this.editor.getSelectionRotatedPageBounds();
    const dragHandlePoint = Vec.RotWith(
      selectionBounds.getHandlePoint(this.info.handle),
      selectionBounds.point,
      selectionRotation
    );
    const cursorHandleOffset = Vec.Sub(originPagePoint, dragHandlePoint);
    return {
      shape,
      cursorHandleOffset
    };
  }
}
function getHitShapeOnCanvasPointerDown(editor, hitLabels = false) {
  const zoomLevel = editor.getZoomLevel();
  const {
    inputs: { currentPagePoint }
  } = editor;
  return (
    // hovered shape at point
    // selected shape at point
    editor.getShapeAtPoint(currentPagePoint, {
      hitInside: false,
      hitLabels,
      margin: editor.options.hitTestMargin / zoomLevel,
      renderingOnly: true
    }) ?? editor.getSelectedShapeAtPoint(currentPagePoint)
  );
}
function getTranslateCroppedImageChange(editor, shape, delta) {
  if (!shape) {
    throw Error("Needs to translate a cropped shape!");
  }
  const { crop: oldCrop } = shape.props;
  if (!oldCrop) {
    return;
  }
  const flatten = editor.inputs.shiftKey ? Math.abs(delta.x) < Math.abs(delta.y) ? "x" : "y" : null;
  if (flatten === "x") {
    delta.x = 0;
  } else if (flatten === "y") {
    delta.y = 0;
  }
  delta.rot(-shape.rotation);
  const { w, h: h2 } = getUncroppedSize(shape.props, oldCrop);
  const xCropSize = oldCrop.bottomRight.x - oldCrop.topLeft.x;
  const yCropSize = oldCrop.bottomRight.y - oldCrop.topLeft.y;
  const newCrop = structuredClone(oldCrop);
  const xMinWithCrop = 1 - xCropSize;
  const yMinWithCrop = 1 - yCropSize;
  newCrop.topLeft.x = clamp$3(newCrop.topLeft.x - delta.x / w, 0, xMinWithCrop);
  newCrop.topLeft.y = clamp$3(newCrop.topLeft.y - delta.y / h2, 0, yMinWithCrop);
  newCrop.bottomRight.x = newCrop.topLeft.x + xCropSize;
  newCrop.bottomRight.y = newCrop.topLeft.y + yCropSize;
  const partial = {
    id: shape.id,
    type: shape.type,
    props: {
      crop: newCrop
    }
  };
  return partial;
}
let Idle$2 = class Idle11 extends StateNode {
  static id = "idle";
  onEnter() {
    this.editor.setCursor({ type: "default", rotation: 0 });
    const onlySelectedShape = this.editor.getOnlySelectedShape();
    if (onlySelectedShape) {
      this.editor.setCroppingShape(onlySelectedShape.id);
    }
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onCancel() {
    this.editor.setCroppingShape(null);
    this.editor.setCurrentTool("select.idle", {});
  }
  onPointerDown(info) {
    if (info.accelKey) {
      this.cancel();
      this.editor.root.handleEvent(info);
      return;
    }
    switch (info.target) {
      case "canvas": {
        const hitShape = getHitShapeOnCanvasPointerDown(this.editor);
        if (hitShape && !this.editor.isShapeOfType(hitShape, "group")) {
          this.onPointerDown({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        this.cancel();
        this.editor.root.handleEvent(info);
        break;
      }
      case "shape": {
        if (info.shape.id === this.editor.getCroppingShapeId()) {
          this.editor.setCurrentTool("select.crop.pointing_crop", info);
          return;
        } else {
          if (this.editor.getShapeUtil(info.shape)?.canCrop(info.shape)) {
            this.editor.setCroppingShape(info.shape.id);
            this.editor.setSelectedShapes([info.shape.id]);
            this.editor.setCurrentTool("select.crop.pointing_crop", info);
          } else {
            this.cancel();
            this.editor.root.handleEvent(info);
          }
        }
        break;
      }
      case "selection": {
        switch (info.handle) {
          case "mobile_rotate":
          case "top_left_rotate":
          case "top_right_rotate":
          case "bottom_left_rotate":
          case "bottom_right_rotate": {
            this.editor.setCurrentTool("select.pointing_rotate_handle", {
              ...info,
              onInteractionEnd: "select.crop.idle"
            });
            break;
          }
          case "top":
          case "right":
          case "bottom":
          case "left":
          case "top_left":
          case "top_right":
          case "bottom_left":
          case "bottom_right": {
            this.editor.setCurrentTool("select.crop.pointing_crop_handle", {
              ...info,
              onInteractionEnd: "select.crop.idle"
            });
            break;
          }
          default: {
            this.cancel();
          }
        }
        break;
      }
    }
  }
  onDoubleClick(info) {
    if (this.editor.inputs.shiftKey || info.phase !== "up") return;
    const croppingShapeId = this.editor.getCroppingShapeId();
    if (!croppingShapeId) return;
    const shape = this.editor.getShape(croppingShapeId);
    if (!shape) return;
    const util = this.editor.getShapeUtil(shape);
    if (!util) return;
    if (info.target === "selection") {
      util.onDoubleClickEdge?.(shape, info);
      return;
    }
    this.cancel();
    this.editor.root.handleEvent(info);
  }
  onKeyDown() {
    this.nudgeCroppingImage(false);
  }
  onKeyRepeat() {
    this.nudgeCroppingImage(true);
  }
  onKeyUp(info) {
    switch (info.key) {
      case "Enter": {
        this.editor.setCroppingShape(null);
        this.editor.setCurrentTool("select.idle", {});
        break;
      }
    }
  }
  cancel() {
    this.editor.setCroppingShape(null);
    this.editor.setCurrentTool("select.idle", {});
  }
  nudgeCroppingImage(ephemeral = false) {
    const {
      editor: {
        inputs: { keys: keys2 }
      }
    } = this;
    const shiftKey = keys2.has("ShiftLeft");
    const delta = new Vec(0, 0);
    if (keys2.has("ArrowLeft")) delta.x += 1;
    if (keys2.has("ArrowRight")) delta.x -= 1;
    if (keys2.has("ArrowUp")) delta.y += 1;
    if (keys2.has("ArrowDown")) delta.y -= 1;
    if (delta.equals(new Vec(0, 0))) return;
    if (shiftKey) delta.mul(10);
    const shape = this.editor.getShape(this.editor.getCroppingShapeId());
    if (!shape) return;
    const partial = getTranslateCroppedImageChange(this.editor, shape, delta);
    if (partial) {
      if (!ephemeral) {
        this.editor.markHistoryStoppingPoint("translate crop");
      }
      this.editor.updateShapes([partial]);
    }
  }
};
class PointingCrop extends StateNode {
  static id = "pointing_crop";
  onCancel() {
    this.editor.setCurrentTool("select.crop.idle", {});
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      this.startDragging(info);
    }
  }
  onLongPress(info) {
    this.startDragging(info);
  }
  onPointerUp(info) {
    this.editor.setCurrentTool("select.crop.idle", info);
  }
  startDragging(info) {
    this.editor.setCurrentTool("select.crop.translating_crop", info);
  }
}
class PointingCropHandle extends StateNode {
  static id = "pointing_crop_handle";
  info = {};
  onEnter(info) {
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    const selectedShape = this.editor.getSelectedShapes()[0];
    if (!selectedShape) return;
    const cursorType = CursorTypeMap[this.info.handle];
    this.editor.setCursor({ type: cursorType, rotation: this.editor.getSelectionRotation() });
    this.editor.setCroppingShape(selectedShape.id);
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.parent.setCurrentToolIdMask(void 0);
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      this.startCropping();
    }
  }
  onLongPress() {
    this.startCropping();
  }
  startCropping() {
    if (this.editor.getIsReadonly()) return;
    this.parent.transition("cropping", {
      ...this.info,
      onInteractionEnd: this.info.onInteractionEnd
    });
  }
  onPointerUp() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.editor.setCroppingShape(null);
    this.editor.setCurrentTool("select.idle");
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.editor.setCroppingShape(null);
    this.editor.setCurrentTool("select.idle");
  }
}
class TranslatingCrop extends StateNode {
  static id = "translating_crop";
  info = {};
  markId = "";
  snapshot = {};
  onEnter(info) {
    this.info = info;
    this.snapshot = this.createSnapshot();
    this.markId = this.editor.markHistoryStoppingPoint("translating_crop");
    this.editor.setCursor({ type: "move", rotation: 0 });
    this.updateShapes();
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onKeyDown(info) {
    switch (info.key) {
      case "Alt":
      case "Shift": {
        this.updateShapes();
        return;
      }
    }
  }
  onKeyUp(info) {
    switch (info.key) {
      case "Enter": {
        this.complete();
        return;
      }
      case "Alt":
      case "Shift": {
        this.updateShapes();
      }
    }
  }
  complete() {
    this.updateShapes();
    this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  createSnapshot() {
    const shape = this.editor.getOnlySelectedShape();
    return { shape };
  }
  updateShapes() {
    const shape = this.snapshot.shape;
    if (!shape) return;
    const { originPagePoint, currentPagePoint } = this.editor.inputs;
    const delta = currentPagePoint.clone().sub(originPagePoint);
    const partial = getTranslateCroppedImageChange(this.editor, shape, delta);
    if (partial) {
      this.editor.updateShapes([partial]);
    }
  }
}
class Crop extends StateNode {
  static id = "crop";
  static initial = "idle";
  static children() {
    return [Idle$2, TranslatingCrop, PointingCrop, PointingCropHandle, Cropping];
  }
  markId = "";
  onEnter() {
    this.didExit = false;
    this.markId = this.editor.markHistoryStoppingPoint("crop");
  }
  didExit = false;
  onExit() {
    if (!this.didExit) {
      this.didExit = true;
      this.editor.squashToMark(this.markId);
    }
  }
  onCancel() {
    if (!this.didExit) {
      this.didExit = true;
      this.editor.bailToMark(this.markId);
    }
  }
}
class DraggingHandle extends StateNode {
  static id = "dragging_handle";
  shapeId;
  initialHandle;
  initialAdjacentHandle;
  initialPagePoint;
  markId;
  initialPageTransform;
  initialPageRotation;
  info;
  isPrecise = false;
  isPreciseId = null;
  pointingId = null;
  onEnter(info) {
    const { shape, isCreating, creatingMarkId, handle } = info;
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.shapeId = shape.id;
    this.markId = "";
    if (isCreating) {
      if (creatingMarkId) {
        this.markId = creatingMarkId;
      } else {
        const markId = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        if (markId) {
          this.markId = markId;
        }
      }
    } else {
      this.markId = this.editor.markHistoryStoppingPoint("dragging handle");
    }
    this.initialHandle = structuredClone(handle);
    this.initialPageTransform = this.editor.getShapePageTransform(shape);
    this.initialPageRotation = this.initialPageTransform.rotation();
    this.initialPagePoint = this.editor.inputs.originPagePoint.clone();
    this.editor.setCursor({ type: isCreating ? "cross" : "grabbing", rotation: 0 });
    const handles = this.editor.getShapeHandles(shape).sort(sortByIndex);
    const index2 = handles.findIndex((h2) => h2.id === info.handle.id);
    this.initialAdjacentHandle = null;
    if (info.handle.snapReferenceHandleId) {
      const customHandle = handles.find((h2) => h2.id === info.handle.snapReferenceHandleId);
      if (customHandle) {
        this.initialAdjacentHandle = customHandle;
      }
    }
    if (!this.initialAdjacentHandle) {
      for (let i = index2 + 1; i < handles.length; i++) {
        const handle2 = handles[i];
        if (handle2.type === "vertex" && handle2.id !== "middle" && handle2.id !== info.handle.id) {
          this.initialAdjacentHandle = handle2;
          break;
        }
      }
      if (!this.initialAdjacentHandle) {
        for (let i = handles.length - 1; i >= 0; i--) {
          const handle2 = handles[i];
          if (handle2.type === "vertex" && handle2.id !== "middle" && handle2.id !== info.handle.id) {
            this.initialAdjacentHandle = handle2;
            break;
          }
        }
      }
    }
    if (this.editor.isShapeOfType(shape, "arrow")) {
      const initialBinding = getArrowBindings(this.editor, shape)[info.handle.id];
      this.isPrecise = false;
      if (initialBinding) {
        this.isPrecise = initialBinding.props.isPrecise;
        if (this.isPrecise) {
          this.isPreciseId = initialBinding.toId;
        } else {
          this.resetExactTimeout();
        }
      }
    }
    const handleDragInfo = {
      handle: this.initialHandle,
      isPrecise: this.isPrecise,
      isCreatingShape: !!this.info.isCreating,
      initial: shape
    };
    const util = this.editor.getShapeUtil(shape);
    const startChanges = util.onHandleDragStart?.(shape, handleDragInfo);
    if (startChanges) {
      this.editor.updateShapes([{ ...startChanges, id: shape.id, type: shape.type }]);
    }
    this.update();
    this.editor.select(this.shapeId);
  }
  // Only relevant to arrows
  exactTimeout = -1;
  // Only relevant to arrows
  resetExactTimeout() {
    const arrowUtil = this.editor.getShapeUtil("arrow");
    const timeoutValue = arrowUtil.options.pointingPreciseTimeout;
    if (this.exactTimeout !== -1) {
      this.clearExactTimeout();
    }
    this.exactTimeout = this.editor.timers.setTimeout(() => {
      if (this.getIsActive() && !this.isPrecise) {
        this.isPrecise = true;
        this.isPreciseId = this.pointingId;
        this.update();
      }
      this.exactTimeout = -1;
    }, timeoutValue);
  }
  // Only relevant to arrows
  clearExactTimeout() {
    if (this.exactTimeout !== -1) {
      clearTimeout(this.exactTimeout);
      this.exactTimeout = -1;
    }
  }
  onPointerMove() {
    this.update();
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.update();
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    clearArrowTargetState(this.editor);
    this.editor.snaps.clearIndicators();
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  complete() {
    this.editor.snaps.clearIndicators();
    kickoutOccludedShapes(this.editor, [this.shapeId]);
    const shape = this.editor.getShape(this.shapeId);
    if (shape) {
      const util = this.editor.getShapeUtil(shape);
      const handleDragInfo = {
        handle: this.initialHandle,
        isPrecise: this.isPrecise,
        isCreatingShape: !!this.info.isCreating,
        initial: this.info.shape
      };
      const endChanges = util.onHandleDragEnd?.(shape, handleDragInfo);
      if (endChanges) {
        this.editor.updateShapes([{ ...endChanges, id: shape.id, type: shape.type }]);
      }
    }
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        if (this.editor.getInstanceState().isToolLocked && onInteractionEnd) {
          this.editor.setCurrentTool(onInteractionEnd, { shapeId: this.shapeId });
          return;
        }
      } else {
        onInteractionEnd?.();
        return;
      }
    }
    this.parent.transition("idle");
  }
  cancel() {
    const shape = this.editor.getShape(this.shapeId);
    if (shape) {
      const util = this.editor.getShapeUtil(shape);
      const handleDragInfo = {
        handle: this.initialHandle,
        isPrecise: this.isPrecise,
        isCreatingShape: !!this.info.isCreating,
        initial: this.info.shape
      };
      util.onHandleDragCancel?.(shape, handleDragInfo);
    }
    this.editor.bailToMark(this.markId);
    this.editor.snaps.clearIndicators();
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, { shapeId: this.shapeId });
      } else {
        onInteractionEnd?.();
      }
      return;
    }
    this.parent.transition("idle");
  }
  update() {
    const { editor, shapeId, initialPagePoint } = this;
    const { initialHandle, initialPageRotation, initialAdjacentHandle } = this;
    const isSnapMode = this.editor.user.getIsSnapMode();
    const {
      snaps,
      inputs: { currentPagePoint, shiftKey, ctrlKey: ctrlKey2, altKey: altKey2, pointerVelocity }
    } = editor;
    const initial = this.info.shape;
    const shape = editor.getShape(shapeId);
    if (!shape) return;
    const util = editor.getShapeUtil(shape);
    const initialBinding = editor.isShapeOfType(shape, "arrow") ? getArrowBindings(editor, shape)[initialHandle.id] : void 0;
    let point = currentPagePoint.clone().sub(initialPagePoint).rot(-initialPageRotation).add(initialHandle);
    if (shiftKey && initialAdjacentHandle && initialHandle.id !== "middle") {
      const angle = Vec.Angle(initialAdjacentHandle, point);
      const snappedAngle = snapAngle(angle, 24);
      const angleDifference = snappedAngle - angle;
      point = Vec.RotWith(point, initialAdjacentHandle, angleDifference);
    }
    editor.snaps.clearIndicators();
    let nextHandle = { ...initialHandle, x: point.x, y: point.y };
    let canSnap = false;
    if (initialHandle.canSnap && initialHandle.snapType) {
      warnOnce(
        "canSnap is deprecated. Cannot use both canSnap and snapType together - snapping disabled. Please use only snapType."
      );
    } else {
      canSnap = initialHandle.canSnap || initialHandle.snapType !== void 0;
    }
    if (canSnap && (isSnapMode ? !ctrlKey2 : ctrlKey2)) {
      const pageTransform = editor.getShapePageTransform(shape.id);
      if (!pageTransform) throw Error("Expected a page transform");
      const snap = snaps.handles.snapHandle({ currentShapeId: shapeId, handle: nextHandle });
      if (snap) {
        snap.nudge.rot(-editor.getShapeParentTransform(shape).rotation());
        point.add(snap.nudge);
        nextHandle = { ...initialHandle, x: point.x, y: point.y };
      }
    }
    const changes = util.onHandleDrag?.(shape, {
      handle: nextHandle,
      isPrecise: this.isPrecise || altKey2,
      isCreatingShape: !!this.info.isCreating,
      initial
    });
    const next = { id: shape.id, type: shape.type, ...changes };
    if (initialHandle.type === "vertex" && this.editor.isShapeOfType(shape, "arrow")) {
      const bindingAfter = getArrowBindings(editor, shape)[initialHandle.id];
      if (bindingAfter) {
        if (initialBinding?.toId !== bindingAfter.toId) {
          this.pointingId = bindingAfter.toId;
          this.isPrecise = pointerVelocity.len() < 0.5 || altKey2;
          this.isPreciseId = this.isPrecise ? bindingAfter.toId : null;
          this.resetExactTimeout();
        }
      } else {
        if (initialBinding) {
          this.pointingId = null;
          this.isPrecise = false;
          this.isPreciseId = null;
          this.resetExactTimeout();
        }
      }
    }
    if (changes) {
      editor.updateShapes([next]);
    }
  }
}
function getTextLabels(geometry) {
  if (geometry.isLabel) {
    return [geometry];
  }
  if (geometry instanceof Group2d) {
    return geometry.children.filter((child) => child.isLabel);
  }
  return [];
}
class EditingShape extends StateNode {
  static id = "editing_shape";
  hitShapeForPointerUp = null;
  info = {};
  onEnter(info) {
    const editingShape = this.editor.getEditingShape();
    if (!editingShape) throw Error("Entered editing state without an editing shape");
    this.hitShapeForPointerUp = null;
    this.info = info;
    if (info.isCreatingTextWhileToolLocked) {
      this.parent.setCurrentToolIdMask("text");
    }
    updateHoveredShapeId(this.editor);
    this.editor.select(editingShape);
  }
  onExit() {
    const { editingShapeId } = this.editor.getCurrentPageState();
    if (!editingShapeId) return;
    this.editor.setEditingShape(null);
    updateHoveredShapeId.cancel();
    if (this.info.isCreatingTextWhileToolLocked) {
      this.parent.setCurrentToolIdMask(void 0);
      this.editor.setCurrentTool("text", {});
    }
  }
  onPointerMove(info) {
    if (this.hitShapeForPointerUp && this.editor.inputs.isDragging) {
      if (this.editor.getIsReadonly()) return;
      if (this.hitShapeForPointerUp.isLocked) return;
      this.editor.select(this.hitShapeForPointerUp);
      this.parent.transition("translating", info);
      this.hitShapeForPointerUp = null;
      return;
    }
    switch (info.target) {
      case "shape":
      case "canvas": {
        updateHoveredShapeId(this.editor);
        return;
      }
    }
  }
  onPointerDown(info) {
    this.hitShapeForPointerUp = null;
    switch (info.target) {
      // N.B. This bit of logic has a bit of history to it.
      // There was a PR that got rid of this logic: https://github.com/tldraw/tldraw/pull/4237
      // But here we bring it back to help support the new rich text world.
      // The original issue which is visible in the video attachments in the PR now seem
      // to have been resolved anyway via some other layer.
      case "canvas": {
        const hitShape = getHitShapeOnCanvasPointerDown(
          this.editor,
          true
          /* hitLabels */
        );
        if (hitShape) {
          this.onPointerDown({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        break;
      }
      case "shape": {
        const { shape: selectingShape } = info;
        const editingShape = this.editor.getEditingShape();
        if (!editingShape) {
          throw Error("Expected an editing shape!");
        }
        const geometry = this.editor.getShapeUtil(selectingShape).getGeometry(selectingShape);
        const textLabels = getTextLabels(geometry);
        const textLabel = textLabels.length === 1 ? textLabels[0] : void 0;
        const isEmptyTextShape = this.editor.isShapeOfType(editingShape, "text") && renderPlaintextFromRichText(this.editor, editingShape.props.richText).trim() === "";
        if (textLabel && !isEmptyTextShape) {
          const pointInShapeSpace = this.editor.getPointInShapeSpace(
            selectingShape,
            this.editor.inputs.currentPagePoint
          );
          if (textLabel.bounds.containsPoint(pointInShapeSpace, 0) && textLabel.hitTestPoint(pointInShapeSpace)) {
            if (selectingShape.id === editingShape.id) {
              return;
            } else {
              this.hitShapeForPointerUp = selectingShape;
              this.editor.markHistoryStoppingPoint("editing on pointer up");
              this.editor.select(selectingShape.id);
              return;
            }
          }
        } else {
          if (selectingShape.id === editingShape.id) {
            if (this.editor.isShapeOfType(selectingShape, "frame")) {
              this.editor.setEditingShape(null);
              this.parent.transition("idle", info);
            }
          } else {
            this.parent.transition("pointing_shape", info);
            return;
          }
          return;
        }
        break;
      }
    }
    this.parent.transition("idle", info);
    this.editor.root.handleEvent(info);
  }
  onPointerUp(info) {
    const hitShape = this.hitShapeForPointerUp;
    if (!hitShape) return;
    this.hitShapeForPointerUp = null;
    const util = this.editor.getShapeUtil(hitShape);
    if (hitShape.isLocked) return;
    if (this.editor.getIsReadonly()) {
      if (!util.canEditInReadonly(hitShape)) {
        this.parent.transition("pointing_shape", info);
        return;
      }
    }
    this.editor.select(hitShape.id);
    const currentEditingShape = this.editor.getEditingShape();
    const isEditToEditAction = currentEditingShape && currentEditingShape.id !== hitShape.id;
    this.editor.setEditingShape(hitShape.id);
    const isMobile = tlenv.isIos || tlenv.isAndroid;
    if (!isMobile || !isEditToEditAction) {
      this.editor.emit("place-caret", { shapeId: hitShape.id, point: info.point });
    } else if (isMobile && isEditToEditAction) {
      this.editor.emit("select-all-text", { shapeId: hitShape.id });
    }
    updateHoveredShapeId(this.editor);
  }
  onComplete(info) {
    this.editor.getContainer().focus();
    this.parent.transition("idle", info);
  }
  onCancel(info) {
    this.editor.getContainer().focus();
    this.parent.transition("idle", info);
  }
}
function getShouldEnterCropMode(editor) {
  const onlySelectedShape = editor.getOnlySelectedShape();
  return !!(onlySelectedShape && !editor.isShapeOrAncestorLocked(onlySelectedShape) && editor.getShapeUtil(onlySelectedShape).canCrop(onlySelectedShape));
}
function selectOnCanvasPointerUp(editor, info) {
  const selectedShapeIds = editor.getSelectedShapeIds();
  const { currentPagePoint } = editor.inputs;
  const { shiftKey, altKey: altKey2, accelKey } = info;
  const additiveSelectionKey = shiftKey || accelKey;
  const hitShape = editor.getShapeAtPoint(currentPagePoint, {
    hitInside: false,
    margin: editor.options.hitTestMargin / editor.getZoomLevel(),
    hitLabels: true,
    renderingOnly: true,
    filter: (shape) => !shape.isLocked
  });
  if (hitShape) {
    const outermostSelectableShape = editor.getOutermostSelectableShape(hitShape);
    if (additiveSelectionKey && !altKey2) {
      editor.cancelDoubleClick();
      if (selectedShapeIds.includes(outermostSelectableShape.id)) {
        editor.markHistoryStoppingPoint("deselecting shape");
        editor.deselect(outermostSelectableShape);
      } else {
        editor.markHistoryStoppingPoint("shift selecting shape");
        editor.setSelectedShapes([...selectedShapeIds, outermostSelectableShape.id]);
      }
    } else {
      let shapeToSelect = void 0;
      if (outermostSelectableShape === hitShape) {
        shapeToSelect = hitShape;
      } else {
        if (outermostSelectableShape.id === editor.getFocusedGroupId() || selectedShapeIds.includes(outermostSelectableShape.id)) {
          shapeToSelect = hitShape;
        } else {
          shapeToSelect = outermostSelectableShape;
        }
      }
      if (shapeToSelect && !selectedShapeIds.includes(shapeToSelect.id)) {
        editor.markHistoryStoppingPoint("selecting shape");
        editor.select(shapeToSelect.id);
      }
    }
  } else {
    if (additiveSelectionKey) {
      return;
    } else {
      if (selectedShapeIds.length > 0) {
        editor.markHistoryStoppingPoint("selecting none");
        editor.selectNone();
      }
      const focusedGroupId = editor.getFocusedGroupId();
      if (isShapeId(focusedGroupId)) {
        const groupShape = editor.getShape(focusedGroupId);
        if (!editor.isPointInShape(groupShape, currentPagePoint, { margin: 0, hitInside: true })) {
          editor.setFocusedGroup(null);
        }
      }
    }
  }
}
const SKIPPED_KEYS_FOR_AUTO_EDITING = [
  "Delete",
  "Backspace",
  "[",
  "]",
  "Enter",
  " ",
  "Shift",
  "Tab"
];
let Idle$1 = class Idle12 extends StateNode {
  static id = "idle";
  selectedShapesOnKeyDown = [];
  onEnter() {
    this.parent.setCurrentToolIdMask(void 0);
    updateHoveredShapeId(this.editor);
    this.selectedShapesOnKeyDown = [];
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onExit() {
    updateHoveredShapeId.cancel();
  }
  onPointerMove() {
    updateHoveredShapeId(this.editor);
  }
  onPointerDown(info) {
    const shouldEnterCropMode = info.ctrlKey && getShouldEnterCropMode(this.editor);
    switch (info.target) {
      case "canvas": {
        const hitShape = getHitShapeOnCanvasPointerDown(this.editor);
        if (hitShape && !hitShape.isLocked) {
          this.onPointerDown({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        const selectedShapeIds = this.editor.getSelectedShapeIds();
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        const {
          inputs: { currentPagePoint }
        } = this.editor;
        if (selectedShapeIds.length > 1 || onlySelectedShape && !this.editor.getShapeUtil(onlySelectedShape).hideSelectionBoundsBg(onlySelectedShape)) {
          if (isPointInRotatedSelectionBounds(this.editor, currentPagePoint)) {
            this.onPointerDown({
              ...info,
              target: "selection"
            });
            return;
          }
        }
        this.parent.transition("pointing_canvas", info);
        break;
      }
      case "shape": {
        const { shape } = info;
        if (this.editor.isShapeOrAncestorLocked(shape)) {
          this.parent.transition("pointing_canvas", info);
          break;
        }
        this.parent.transition("pointing_shape", info);
        break;
      }
      case "handle": {
        if (this.editor.getIsReadonly()) break;
        if (this.editor.inputs.altKey) {
          this.parent.transition("pointing_shape", info);
        } else {
          this.parent.transition("pointing_handle", info);
        }
        break;
      }
      case "selection": {
        switch (info.handle) {
          case "mobile_rotate":
          case "top_left_rotate":
          case "top_right_rotate":
          case "bottom_left_rotate":
          case "bottom_right_rotate": {
            if (info.accelKey) {
              this.parent.transition("brushing", info);
              break;
            }
            this.parent.transition("pointing_rotate_handle", info);
            break;
          }
          case "top":
          case "right":
          case "bottom":
          case "left":
          case "top_left":
          case "top_right":
          case "bottom_left":
          case "bottom_right": {
            if (shouldEnterCropMode) {
              this.parent.transition("crop.pointing_crop_handle", info);
            } else {
              if (info.accelKey) {
                this.parent.transition("brushing", info);
                break;
              }
              this.parent.transition("pointing_resize_handle", info);
            }
            break;
          }
          default: {
            const hoveredShape = this.editor.getHoveredShape();
            if (hoveredShape && !this.editor.getSelectedShapeIds().includes(hoveredShape.id) && !hoveredShape.isLocked) {
              this.onPointerDown({
                ...info,
                shape: hoveredShape,
                target: "shape"
              });
              return;
            }
            this.parent.transition("pointing_selection", info);
          }
        }
        break;
      }
    }
  }
  onDoubleClick(info) {
    if (this.editor.inputs.shiftKey || info.phase !== "up") return;
    if (info.ctrlKey || info.shiftKey) return;
    switch (info.target) {
      case "canvas": {
        const hoveredShape = this.editor.getHoveredShape();
        const hitShape = hoveredShape && !this.editor.isShapeOfType(hoveredShape, "group") ? hoveredShape : this.editor.getSelectedShapeAtPoint(this.editor.inputs.currentPagePoint) ?? this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
          margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
          hitInside: false
        });
        const focusedGroupId = this.editor.getFocusedGroupId();
        if (hitShape) {
          if (this.editor.isShapeOfType(hitShape, "group")) {
            selectOnCanvasPointerUp(this.editor, info);
            return;
          } else {
            const parent = this.editor.getShape(hitShape.parentId);
            if (parent && this.editor.isShapeOfType(parent, "group")) {
              if (focusedGroupId && parent.id === focusedGroupId) ;
              else {
                selectOnCanvasPointerUp(this.editor, info);
                return;
              }
            }
          }
          this.onDoubleClick({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        if (!this.editor.inputs.shiftKey) {
          this.handleDoubleClickOnCanvas(info);
        }
        break;
      }
      case "selection": {
        if (this.editor.getIsReadonly()) break;
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        if (onlySelectedShape) {
          const util = this.editor.getShapeUtil(onlySelectedShape);
          if (!this.canInteractWithShapeInReadOnly(onlySelectedShape)) {
            return;
          }
          if (info.handle === "right" || info.handle === "left" || info.handle === "top" || info.handle === "bottom") {
            const change = util.onDoubleClickEdge?.(onlySelectedShape, info);
            if (change) {
              this.editor.markHistoryStoppingPoint("double click edge");
              this.editor.updateShapes([change]);
              kickoutOccludedShapes(this.editor, [onlySelectedShape.id]);
              return;
            }
          }
          if (info.handle === "top_left" || info.handle === "top_right" || info.handle === "bottom_right" || info.handle === "bottom_left") {
            const change = util.onDoubleClickCorner?.(onlySelectedShape, info);
            if (change) {
              this.editor.markHistoryStoppingPoint("double click corner");
              this.editor.updateShapes([change]);
              kickoutOccludedShapes(this.editor, [onlySelectedShape.id]);
              return;
            }
          }
          if (util.canCrop(onlySelectedShape) && !this.editor.isShapeOrAncestorLocked(onlySelectedShape)) {
            this.parent.transition("crop", info);
            return;
          }
          if (this.shouldStartEditingShape(onlySelectedShape)) {
            this.startEditingShape(
              onlySelectedShape,
              info,
              true
              /* select all */
            );
          }
        }
        break;
      }
      case "shape": {
        const { shape } = info;
        const util = this.editor.getShapeUtil(shape);
        if (shape.type !== "video" && shape.type !== "embed" && this.editor.getIsReadonly()) break;
        if (util.onDoubleClick) {
          const change = util.onDoubleClick?.(shape);
          if (change) {
            this.editor.updateShapes([change]);
            return;
          }
        }
        if (util.canCrop(shape) && !this.editor.isShapeOrAncestorLocked(shape)) {
          this.editor.markHistoryStoppingPoint("select and crop");
          this.editor.select(info.shape?.id);
          this.parent.transition("crop", info);
          return;
        }
        if (this.shouldStartEditingShape(shape)) {
          this.startEditingShape(
            shape,
            info,
            true
            /* select all */
          );
        } else {
          this.handleDoubleClickOnCanvas(info);
        }
        break;
      }
      case "handle": {
        if (this.editor.getIsReadonly()) break;
        const { shape, handle } = info;
        const util = this.editor.getShapeUtil(shape);
        const changes = util.onDoubleClickHandle?.(shape, handle);
        if (changes) {
          this.editor.updateShapes([changes]);
        } else {
          if (this.shouldStartEditingShape(shape)) {
            this.startEditingShape(
              shape,
              info,
              true
              /* select all */
            );
          }
        }
      }
    }
  }
  onRightClick(info) {
    switch (info.target) {
      case "canvas": {
        const hoveredShape = this.editor.getHoveredShape();
        const hitShape = hoveredShape && !this.editor.isShapeOfType(hoveredShape, "group") ? hoveredShape : this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
          margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
          hitInside: false,
          hitLabels: true,
          hitLocked: true,
          hitFrameInside: true,
          renderingOnly: true
        });
        if (hitShape) {
          this.onRightClick({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        const selectedShapeIds = this.editor.getSelectedShapeIds();
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        const {
          inputs: { currentPagePoint }
        } = this.editor;
        if (selectedShapeIds.length > 1 || onlySelectedShape && !this.editor.getShapeUtil(onlySelectedShape).hideSelectionBoundsBg(onlySelectedShape)) {
          if (isPointInRotatedSelectionBounds(this.editor, currentPagePoint)) {
            this.onRightClick({
              ...info,
              target: "selection"
            });
            return;
          }
        }
        this.editor.selectNone();
        break;
      }
      case "shape": {
        const { selectedShapeIds } = this.editor.getCurrentPageState();
        const { shape } = info;
        const targetShape = this.editor.getOutermostSelectableShape(
          shape,
          (parent) => !selectedShapeIds.includes(parent.id)
        );
        if (!selectedShapeIds.includes(targetShape.id) && !this.editor.findShapeAncestor(
          targetShape,
          (shape2) => selectedShapeIds.includes(shape2.id)
        )) {
          this.editor.markHistoryStoppingPoint("selecting shape");
          this.editor.setSelectedShapes([targetShape.id]);
        }
        break;
      }
    }
  }
  onCancel() {
    if (this.editor.getFocusedGroupId() !== this.editor.getCurrentPageId() && this.editor.getSelectedShapeIds().length > 0) {
      this.editor.popFocusedGroupId();
    } else {
      this.editor.markHistoryStoppingPoint("clearing selection");
      this.editor.selectNone();
    }
  }
  onKeyDown(info) {
    this.selectedShapesOnKeyDown = this.editor.getSelectedShapes();
    switch (info.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown": {
        if (info.accelKey) {
          if (info.shiftKey) {
            if (info.code === "ArrowDown") {
              this.editor.selectFirstChildShape();
            } else if (info.code === "ArrowUp") {
              this.editor.selectParentShape();
            }
          } else {
            this.editor.selectAdjacentShape(
              info.code.replace("Arrow", "").toLowerCase()
            );
          }
          return;
        }
        this.nudgeSelectedShapes(false);
        return;
      }
    }
    if (debugFlags["editOnType"].get()) {
      if (!SKIPPED_KEYS_FOR_AUTO_EDITING.includes(info.key) && !info.altKey && !info.ctrlKey) {
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        if (onlySelectedShape && // If it's a note shape, then edit on type
        this.editor.isShapeOfType(onlySelectedShape, "note") && // If it's not locked or anything
        this.shouldStartEditingShape(onlySelectedShape)) {
          this.startEditingShape(
            onlySelectedShape,
            {
              ...info,
              target: "shape",
              shape: onlySelectedShape
            },
            true
            /* select all */
          );
          return;
        }
      }
    }
  }
  onKeyRepeat(info) {
    switch (info.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown": {
        if (info.accelKey) {
          this.editor.selectAdjacentShape(
            info.code.replace("Arrow", "").toLowerCase()
          );
          return;
        }
        this.nudgeSelectedShapes(true);
        break;
      }
      case "Tab": {
        const selectedShapes = this.editor.getSelectedShapes();
        if (selectedShapes.length && !info.altKey) {
          this.editor.selectAdjacentShape(info.shiftKey ? "prev" : "next");
        }
        break;
      }
    }
  }
  onKeyUp(info) {
    switch (info.key) {
      case "Enter": {
        if (!this.selectedShapesOnKeyDown.length) return;
        const selectedShapes = this.editor.getSelectedShapes();
        if (selectedShapes.every((shape) => this.editor.isShapeOfType(shape, "group"))) {
          this.editor.setSelectedShapes(
            selectedShapes.flatMap((shape) => this.editor.getSortedChildIdsForParent(shape.id))
          );
          return;
        }
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        if (onlySelectedShape && this.shouldStartEditingShape(onlySelectedShape)) {
          this.startEditingShape(
            onlySelectedShape,
            {
              ...info,
              target: "shape",
              shape: onlySelectedShape
            },
            true
            /* select all */
          );
          return;
        }
        if (getShouldEnterCropMode(this.editor)) {
          this.parent.transition("crop", info);
        }
        break;
      }
      case "Tab": {
        const selectedShapes = this.editor.getSelectedShapes();
        if (selectedShapes.length && !info.altKey) {
          this.editor.selectAdjacentShape(info.shiftKey ? "prev" : "next");
        }
        break;
      }
    }
  }
  shouldStartEditingShape(shape = this.editor.getOnlySelectedShape()) {
    if (!shape) return false;
    if (this.editor.isShapeOrAncestorLocked(shape) && shape.type !== "embed") return false;
    if (!this.canInteractWithShapeInReadOnly(shape)) return false;
    return this.editor.getShapeUtil(shape).canEdit(shape);
  }
  startEditingShape(shape, info, shouldSelectAll) {
    if (this.editor.isShapeOrAncestorLocked(shape) && shape.type !== "embed") return;
    this.editor.markHistoryStoppingPoint("editing shape");
    startEditingShapeWithLabel(this.editor, shape, shouldSelectAll);
    this.parent.transition("editing_shape", info);
  }
  isOverArrowLabelTest(shape) {
    if (!shape) return false;
    return isOverArrowLabel(this.editor, shape);
  }
  handleDoubleClickOnCanvas(info) {
    if (this.editor.getIsReadonly()) return;
    if (!this.editor.options.createTextOnCanvasDoubleClick) return;
    this.editor.markHistoryStoppingPoint("creating text shape");
    const id = createShapeId();
    const { x, y } = this.editor.inputs.currentPagePoint;
    this.editor.createShapes([
      {
        id,
        type: "text",
        x,
        y,
        props: {
          richText: toRichText(""),
          autoSize: true
        }
      }
    ]);
    const shape = this.editor.getShape(id);
    if (!shape) return;
    const util = this.editor.getShapeUtil(shape);
    if (this.editor.getIsReadonly()) {
      if (!util.canEditInReadonly(shape)) {
        return;
      }
    }
    this.editor.setEditingShape(id);
    this.editor.select(id);
    this.parent.transition("editing_shape", info);
  }
  nudgeSelectedShapes(ephemeral = false) {
    const {
      editor: {
        inputs: { keys: keys2 }
      }
    } = this;
    const shiftKey = keys2.has("ShiftLeft");
    const delta = new Vec(0, 0);
    if (keys2.has("ArrowLeft")) delta.x -= 1;
    if (keys2.has("ArrowRight")) delta.x += 1;
    if (keys2.has("ArrowUp")) delta.y -= 1;
    if (keys2.has("ArrowDown")) delta.y += 1;
    if (delta.equals(new Vec(0, 0))) return;
    if (!ephemeral) this.editor.markHistoryStoppingPoint("nudge shapes");
    const { gridSize } = this.editor.getDocumentSettings();
    const step = this.editor.getInstanceState().isGridMode ? shiftKey ? gridSize * GRID_INCREMENT : gridSize : shiftKey ? MAJOR_NUDGE_FACTOR : MINOR_NUDGE_FACTOR;
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    this.editor.nudgeShapes(selectedShapeIds, delta.mul(step));
    kickoutOccludedShapes(this.editor, selectedShapeIds);
  }
  canInteractWithShapeInReadOnly(shape) {
    if (!this.editor.getIsReadonly()) return true;
    const util = this.editor.getShapeUtil(shape);
    if (util.canEditInReadonly(shape)) return true;
    return false;
  }
};
const MAJOR_NUDGE_FACTOR = 10;
const MINOR_NUDGE_FACTOR = 1;
const GRID_INCREMENT = 5;
function isPointInRotatedSelectionBounds(editor, point) {
  const selectionBounds = editor.getSelectionRotatedPageBounds();
  if (!selectionBounds) return false;
  const selectionRotation = editor.getSelectionRotation();
  if (!selectionRotation) return selectionBounds.containsPoint(point);
  return pointInPolygon(
    point,
    selectionBounds.corners.map((c) => Vec.RotWith(c, selectionBounds.point, selectionRotation))
  );
}
class PointingArrowLabel extends StateNode {
  static id = "pointing_arrow_label";
  shapeId = "";
  markId = "";
  wasAlreadySelected = false;
  didDrag = false;
  didCtrlOnEnter = false;
  info = {};
  updateCursor() {
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onEnter(info) {
    const { shape } = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.info = info;
    this.shapeId = shape.id;
    this.didDrag = false;
    this.didCtrlOnEnter = info.accelKey;
    this.wasAlreadySelected = this.editor.getOnlySelectedShapeId() === shape.id;
    this.updateCursor();
    const geometry = this.editor.getShapeGeometry(shape);
    const labelGeometry = geometry.children[1];
    if (!labelGeometry) {
      throw Error(`Expected to find an arrow label geometry for shape: ${shape.id}`);
    }
    const { currentPagePoint } = this.editor.inputs;
    const pointInShapeSpace = this.editor.getPointInShapeSpace(shape, currentPagePoint);
    this._labelDragOffset = Vec.Sub(labelGeometry.center, pointInShapeSpace);
    this.markId = this.editor.markHistoryStoppingPoint("label-drag start");
    const additiveSelectionKey = info.shiftKey || info.accelKey;
    if (additiveSelectionKey) {
      const selectedShapeIds = this.editor.getSelectedShapeIds();
      this.editor.setSelectedShapes([...selectedShapeIds, this.shapeId]);
      return;
    }
    this.editor.setSelectedShapes([this.shapeId]);
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  _labelDragOffset = new Vec(0, 0);
  onPointerMove() {
    const { isDragging } = this.editor.inputs;
    if (!isDragging) return;
    if (this.didCtrlOnEnter) {
      this.parent.transition("brushing", this.info);
      return;
    }
    const shape = this.editor.getShape(this.shapeId);
    if (!shape) return;
    const options = this.editor.getShapeUtil("arrow").options;
    const geometry = getArrowBodyGeometry(this.editor, shape);
    const transform = this.editor.getShapePageTransform(shape.id);
    const pointInShapeSpace = this.editor.getPointInShapeSpace(shape, this.editor.inputs.currentPagePoint).add(this._labelDragOffset);
    const defaultLabelPosition = getArrowLabelDefaultPosition(this.editor, shape);
    let nextLabelPosition = geometry.uninterpolateAlongEdge(pointInShapeSpace);
    if (isNaN(nextLabelPosition)) {
      nextLabelPosition = defaultLabelPosition;
    }
    const nextLabelPoint = transform.applyToPoint(geometry.interpolateAlongEdge(nextLabelPosition));
    const labelDefaultPoint = transform.applyToPoint(
      geometry.interpolateAlongEdge(defaultLabelPosition)
    );
    if (Vec.DistMin(
      nextLabelPoint,
      labelDefaultPoint,
      options.labelCenterSnapDistance / this.editor.getZoomLevel()
    )) {
      nextLabelPosition = defaultLabelPosition;
    }
    this.didDrag = true;
    this.editor.updateShape({
      id: shape.id,
      type: shape.type,
      props: { labelPosition: nextLabelPosition }
    });
  }
  onPointerUp() {
    const shape = this.editor.getShape(this.shapeId);
    if (!shape) return;
    if (this.didDrag || !this.wasAlreadySelected) {
      this.complete();
    } else if (!this.editor.getIsReadonly()) {
      this.editor.setEditingShape(shape.id);
      this.editor.setCurrentTool("select.editing_shape");
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
}
class PointingCanvas extends StateNode {
  static id = "pointing_canvas";
  onEnter(info) {
    const additiveSelectionKey = info.shiftKey || info.accelKey;
    if (!additiveSelectionKey) {
      if (this.editor.getSelectedShapeIds().length > 0) {
        this.editor.markHistoryStoppingPoint("selecting none");
        this.editor.selectNone();
      }
    }
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      this.parent.transition("brushing", info);
    }
  }
  onPointerUp(info) {
    selectOnCanvasPointerUp(this.editor, info);
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.parent.transition("idle");
  }
  complete() {
    this.parent.transition("idle");
  }
}
class PointingHandle extends StateNode {
  static id = "pointing_handle";
  didCtrlOnEnter = false;
  info = {};
  onEnter(info) {
    this.info = info;
    this.didCtrlOnEnter = info.accelKey;
    const { shape } = info;
    if (this.editor.isShapeOfType(shape, "arrow")) {
      const initialBindings = getArrowBindings(this.editor, shape);
      const currentBinding = initialBindings[info.handle.id];
      const oppositeBinding = initialBindings[info.handle.id === "start" ? "end" : "start"];
      const arrowTransform = this.editor.getShapePageTransform(shape.id);
      if (currentBinding) {
        updateArrowTargetState({
          editor: this.editor,
          pointInPageSpace: arrowTransform.applyToPoint(info.handle),
          arrow: shape,
          isPrecise: currentBinding.props.isPrecise,
          currentBinding,
          oppositeBinding
        });
      }
    }
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onExit() {
    this.editor.setHintingShapes([]);
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerUp() {
    const { shape, handle } = this.info;
    if (this.editor.isShapeOfType(shape, "note")) {
      const { editor } = this;
      const nextNote = getNoteForAdjacentPosition(editor, shape, handle, false);
      if (nextNote) {
        startEditingShapeWithLabel(
          editor,
          nextNote,
          true
          /* selectAll */
        );
        return;
      }
    }
    this.parent.transition("idle", this.info);
  }
  onPointerMove(info) {
    const { editor } = this;
    if (editor.inputs.isDragging) {
      if (this.didCtrlOnEnter) {
        this.parent.transition("brushing", info);
      } else {
        this.startDraggingHandle();
      }
    }
  }
  onLongPress() {
    this.startDraggingHandle();
  }
  startDraggingHandle() {
    const { editor } = this;
    if (editor.getIsReadonly()) return;
    const { shape, handle } = this.info;
    if (editor.isShapeOfType(shape, "note")) {
      const nextNote = getNoteForAdjacentPosition(editor, shape, handle, true);
      if (nextNote) {
        const centeredOnPointer = editor.getPointInParentSpace(nextNote, editor.inputs.originPagePoint).sub(Vec.Rot(NOTE_CENTER_OFFSET.clone().mul(shape.props.scale), nextNote.rotation));
        editor.updateShape({ ...nextNote, x: centeredOnPointer.x, y: centeredOnPointer.y });
        editor.setHoveredShape(nextNote.id).select(nextNote.id).setCurrentTool("select.translating", {
          ...this.info,
          target: "shape",
          shape: editor.getShape(nextNote),
          onInteractionEnd: "note",
          isCreating: true,
          onCreate: () => {
            startEditingShapeWithLabel(
              editor,
              nextNote,
              true
              /* selectAll */
            );
          }
        });
        return;
      }
    }
    this.parent.transition("dragging_handle", this.info);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
}
function getNoteForAdjacentPosition(editor, shape, handle, forceNew) {
  const pageTransform = editor.getShapePageTransform(shape.id);
  const pagePoint = pageTransform.point();
  const pageRotation = pageTransform.rotation();
  const positions = getNoteAdjacentPositions(
    editor,
    pagePoint,
    pageRotation,
    shape.props.growY * shape.props.scale,
    0,
    shape.props.scale
  );
  const position = positions[handle.index];
  if (position) {
    return getNoteShapeForAdjacentPosition(editor, shape, position, pageRotation, forceNew);
  }
}
class PointingRotateHandle extends StateNode {
  static id = "pointing_rotate_handle";
  info = {};
  updateCursor() {
    this.editor.setCursor({
      type: CursorTypeMap[this.info.handle],
      rotation: this.editor.getSelectionRotation()
    });
  }
  onEnter(info) {
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      this.startRotating();
    }
  }
  onLongPress() {
    this.startRotating();
  }
  startRotating() {
    if (this.editor.getIsReadonly()) return;
    this.parent.transition("rotating", this.info);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd?.();
      }
      return;
    }
    this.parent.transition("idle");
  }
  cancel() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
}
class PointingSelection extends StateNode {
  static id = "pointing_selection";
  info = {};
  onEnter(info) {
    this.info = info;
  }
  onPointerUp(info) {
    selectOnCanvasPointerUp(this.editor, info);
    this.parent.transition("idle", info);
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      this.startTranslating(info);
    }
  }
  onLongPress(info) {
    this.startTranslating(info);
  }
  startTranslating(info) {
    if (this.editor.getIsReadonly()) return;
    this.parent.transition("translating", info);
  }
  onDoubleClick(info) {
    const hoveredShape = this.editor.getHoveredShape();
    const hitShape = hoveredShape && !this.editor.isShapeOfType(hoveredShape, "group") ? hoveredShape : this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
      hitInside: true,
      margin: 0,
      renderingOnly: true
    });
    if (hitShape) {
      this.parent.transition("idle");
      this.parent.onDoubleClick?.({
        ...info,
        target: "shape",
        shape: this.editor.getShape(hitShape)
      });
      return;
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
}
class PointingShape extends StateNode {
  static id = "pointing_shape";
  hitShape = {};
  hitShapeForPointerUp = {};
  isDoubleClick = false;
  didCtrlOnEnter = false;
  didSelectOnEnter = false;
  onEnter(info) {
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    const selectionBounds = this.editor.getSelectionRotatedPageBounds();
    const focusedGroupId = this.editor.getFocusedGroupId();
    const {
      inputs: { currentPagePoint }
    } = this.editor;
    const { shiftKey, altKey: altKey2, accelKey } = info;
    this.hitShape = info.shape;
    this.isDoubleClick = false;
    this.didCtrlOnEnter = accelKey;
    const outermostSelectingShape = this.editor.getOutermostSelectableShape(info.shape);
    const selectedAncestor = this.editor.findShapeAncestor(
      outermostSelectingShape,
      (parent) => selectedShapeIds.includes(parent.id)
    );
    if (this.didCtrlOnEnter || // If the shape has an onClick handler
    this.editor.getShapeUtil(info.shape).onClick || // ...or if the shape is the focused layer (e.g. group)
    outermostSelectingShape.id === focusedGroupId || // ...or if the shape is within the selection
    selectedShapeIds.includes(outermostSelectingShape.id) || // ...or if an ancestor of the shape is selected
    selectedAncestor || // ...or if the current point is NOT within the selection bounds
    selectedShapeIds.length > 1 && selectionBounds?.containsPoint(currentPagePoint)) {
      this.didSelectOnEnter = false;
      this.hitShapeForPointerUp = outermostSelectingShape;
      return;
    }
    this.didSelectOnEnter = true;
    if (shiftKey && !altKey2) {
      this.editor.cancelDoubleClick();
      if (!selectedShapeIds.includes(outermostSelectingShape.id)) {
        this.editor.markHistoryStoppingPoint("shift selecting shape");
        this.editor.setSelectedShapes([...selectedShapeIds, outermostSelectingShape.id]);
      }
    } else {
      this.editor.markHistoryStoppingPoint("selecting shape");
      this.editor.setSelectedShapes([outermostSelectingShape.id]);
    }
  }
  onPointerUp(info) {
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    const focusedGroupId = this.editor.getFocusedGroupId();
    const zoomLevel = this.editor.getZoomLevel();
    const {
      inputs: { currentPagePoint }
    } = this.editor;
    const additiveSelectionKey = info.shiftKey || info.accelKey;
    const hitShape = this.editor.getShapeAtPoint(currentPagePoint, {
      margin: this.editor.options.hitTestMargin / zoomLevel,
      hitInside: true,
      renderingOnly: true
    }) ?? this.hitShape;
    const selectingShape = hitShape ? this.editor.getOutermostSelectableShape(hitShape) : this.hitShapeForPointerUp;
    if (selectingShape) {
      const util = this.editor.getShapeUtil(selectingShape);
      if (util.onClick) {
        const change = util.onClick?.(selectingShape);
        if (change) {
          this.editor.markHistoryStoppingPoint("shape on click");
          this.editor.updateShapes([change]);
          this.parent.transition("idle", info);
          return;
        }
      }
      if (selectingShape.id === focusedGroupId) {
        if (selectedShapeIds.length > 0) {
          this.editor.markHistoryStoppingPoint("clearing shape ids");
          this.editor.setSelectedShapes([]);
        } else {
          this.editor.popFocusedGroupId();
        }
        this.parent.transition("idle", info);
        return;
      }
    }
    if (!this.didSelectOnEnter) {
      const outermostSelectableShape = this.editor.getOutermostSelectableShape(
        hitShape,
        // if a group is selected, we want to stop before reaching that group
        // so we can drill down into the group
        (parent) => !selectedShapeIds.includes(parent.id)
      );
      if (selectedShapeIds.includes(outermostSelectableShape.id)) {
        if (additiveSelectionKey) {
          this.editor.markHistoryStoppingPoint("deselecting on pointer up");
          this.editor.deselect(selectingShape);
        } else {
          if (selectedShapeIds.includes(selectingShape.id)) {
            if (selectedShapeIds.length === 1) {
              const geometry = this.editor.getShapeUtil(selectingShape).getGeometry(selectingShape);
              const textLabels = getTextLabels(geometry);
              const textLabel = textLabels.length === 1 ? textLabels[0] : void 0;
              if (textLabel) {
                const pointInShapeSpace = this.editor.getPointInShapeSpace(
                  selectingShape,
                  currentPagePoint
                );
                if (textLabel.bounds.containsPoint(pointInShapeSpace, 0) && textLabel.hitTestPoint(pointInShapeSpace)) {
                  this.editor.run(() => {
                    this.editor.markHistoryStoppingPoint("editing on pointer up");
                    this.editor.select(selectingShape.id);
                    const util = this.editor.getShapeUtil(selectingShape);
                    if (this.editor.getIsReadonly()) {
                      if (!util.canEditInReadonly(selectingShape)) {
                        return;
                      }
                    }
                    this.editor.setEditingShape(selectingShape.id);
                    this.editor.setCurrentTool("select.editing_shape");
                    if (this.isDoubleClick) {
                      this.editor.emit("select-all-text", { shapeId: selectingShape.id });
                    } else {
                      this.editor.emit("place-caret", {
                        shapeId: selectingShape.id,
                        point: info.point
                      });
                    }
                  });
                  return;
                }
              }
            }
            this.editor.markHistoryStoppingPoint("selecting on pointer up");
            this.editor.select(selectingShape.id);
          } else {
            this.editor.markHistoryStoppingPoint("selecting on pointer up");
            this.editor.select(selectingShape);
          }
        }
      } else if (additiveSelectionKey) {
        const ancestors = this.editor.getShapeAncestors(outermostSelectableShape);
        this.editor.markHistoryStoppingPoint("shift deselecting on pointer up");
        this.editor.setSelectedShapes([
          ...this.editor.getSelectedShapeIds().filter((id) => !ancestors.find((a) => a.id === id)),
          outermostSelectableShape.id
        ]);
      } else {
        this.editor.markHistoryStoppingPoint("selecting on pointer up");
        this.editor.setSelectedShapes([outermostSelectableShape.id]);
      }
    }
    this.parent.transition("idle", info);
  }
  onDoubleClick() {
    this.isDoubleClick = true;
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      if (isOverArrowLabel(this.editor, this.hitShape)) {
        this.parent.transition("pointing_arrow_label", { ...info, shape: this.hitShape });
        return;
      }
      if (this.didCtrlOnEnter) {
        this.parent.transition("brushing", info);
      } else {
        this.startTranslating(info);
      }
    }
  }
  onLongPress(info) {
    this.startTranslating(info);
  }
  startTranslating(info) {
    if (this.editor.getIsReadonly()) return;
    this.editor.focus();
    this.parent.transition("translating", info);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
}
class Resizing extends StateNode {
  static id = "resizing";
  info = {};
  markId = "";
  // A switch to detect when the user is holding ctrl
  didHoldCommand = false;
  // we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,
  // so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas
  // so we allow passing a further offset into this state to negate such issues
  creationCursorOffset = { x: 0, y: 0 };
  snapshot = {};
  onEnter(info) {
    const { isCreating = false, creatingMarkId, creationCursorOffset = { x: 0, y: 0 } } = info;
    this.info = info;
    this.didHoldCommand = false;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.creationCursorOffset = creationCursorOffset;
    try {
      this.snapshot = this._createSnapshot();
    } catch (e) {
      console.error(e);
      this.cancel();
      return;
    }
    this.markId = "";
    if (isCreating) {
      if (creatingMarkId) {
        this.markId = creatingMarkId;
      } else {
        const markId = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        if (markId) {
          this.markId = markId;
        }
      }
    } else {
      this.markId = this.editor.markHistoryStoppingPoint("starting resizing");
    }
    if (isCreating) {
      this.editor.setCursor({ type: "cross", rotation: 0 });
    }
    this.handleResizeStart();
    this.updateShapes();
  }
  onTick({ elapsed }) {
    const { editor } = this;
    editor.edgeScrollManager.updateEdgeScrolling(elapsed);
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    this.updateShapes();
  }
  onKeyUp() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  cancel() {
    const { shapeSnapshots } = this.snapshot;
    shapeSnapshots.forEach(({ shape }) => {
      const current = this.editor.getShape(shape.id);
      if (current) {
        const util = this.editor.getShapeUtil(shape);
        util.onResizeCancel?.(shape, current);
      }
    });
    this.editor.bailToMark(this.markId);
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
  complete() {
    kickoutOccludedShapes(this.editor, this.snapshot.selectedShapeIds);
    this.handleResizeEnd();
    if (this.info.isCreating && this.info.onCreate) {
      this.info.onCreate?.(this.editor.getOnlySelectedShape());
      return;
    }
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        if (this.editor.getInstanceState().isToolLocked) {
          this.editor.setCurrentTool(onInteractionEnd, {});
          return;
        }
      } else {
        onInteractionEnd();
        return;
      }
    }
    this.parent.transition("idle");
  }
  handleResizeStart() {
    const { shapeSnapshots } = this.snapshot;
    const changes = [];
    shapeSnapshots.forEach(({ shape }) => {
      const util = this.editor.getShapeUtil(shape);
      const change = util.onResizeStart?.(shape);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  handleResizeEnd() {
    const { shapeSnapshots } = this.snapshot;
    const changes = [];
    shapeSnapshots.forEach(({ shape }) => {
      const current = this.editor.getShape(shape.id);
      const util = this.editor.getShapeUtil(shape);
      const change = util.onResizeEnd?.(shape, current);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  updateShapes() {
    const { altKey: altKey2, shiftKey } = this.editor.inputs;
    const {
      frames,
      shapeSnapshots,
      selectionBounds,
      cursorHandleOffset,
      selectedShapeIds,
      selectionRotation,
      canShapesDeform
    } = this.snapshot;
    let isAspectRatioLocked = shiftKey || !canShapesDeform;
    if (shapeSnapshots.size === 1) {
      const onlySnapshot = [...shapeSnapshots.values()][0];
      if (this.editor.isShapeOfType(onlySnapshot.shape, "text")) {
        isAspectRatioLocked = !(this.info.handle === "left" || this.info.handle === "right");
      }
    }
    const isHoldingAccel = isAccelKey(this.editor.inputs);
    const currentPagePoint = this.editor.inputs.currentPagePoint.clone().sub(cursorHandleOffset).sub(this.creationCursorOffset);
    const originPagePoint = this.editor.inputs.originPagePoint.clone().sub(cursorHandleOffset);
    if (this.editor.getInstanceState().isGridMode && !isHoldingAccel) {
      const { gridSize } = this.editor.getDocumentSettings();
      currentPagePoint.snapToGrid(gridSize);
    }
    const dragHandle = this.info.handle;
    const scaleOriginHandle = rotateSelectionHandle(dragHandle, Math.PI);
    this.editor.snaps.clearIndicators();
    const shouldSnap = this.editor.user.getIsSnapMode() ? !isHoldingAccel : isHoldingAccel;
    if (shouldSnap && selectionRotation % HALF_PI === 0) {
      const { nudge } = this.editor.snaps.shapeBounds.snapResizeShapes({
        dragDelta: Vec.Sub(currentPagePoint, originPagePoint),
        initialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,
        handle: rotateSelectionHandle(dragHandle, selectionRotation),
        isAspectRatioLocked,
        isResizingFromCenter: altKey2
      });
      currentPagePoint.add(nudge);
    }
    const scaleOriginPage = Vec.RotWith(
      altKey2 ? selectionBounds.center : selectionBounds.getHandlePoint(scaleOriginHandle),
      selectionBounds.point,
      selectionRotation
    );
    const distanceFromScaleOriginNow = Vec.Sub(currentPagePoint, scaleOriginPage).rot(
      -selectionRotation
    );
    const distanceFromScaleOriginAtStart = Vec.Sub(originPagePoint, scaleOriginPage).rot(
      -selectionRotation
    );
    const scale = Vec.DivV(distanceFromScaleOriginNow, distanceFromScaleOriginAtStart);
    if (!Number.isFinite(scale.x)) scale.x = 1;
    if (!Number.isFinite(scale.y)) scale.y = 1;
    const isXLocked = dragHandle === "top" || dragHandle === "bottom";
    const isYLocked = dragHandle === "left" || dragHandle === "right";
    if (isAspectRatioLocked) {
      if (isYLocked) {
        scale.y = Math.abs(scale.x);
      } else if (isXLocked) {
        scale.x = Math.abs(scale.y);
      } else if (Math.abs(scale.x) > Math.abs(scale.y)) {
        scale.y = Math.abs(scale.x) * (scale.y < 0 ? -1 : 1);
      } else {
        scale.x = Math.abs(scale.y) * (scale.x < 0 ? -1 : 1);
      }
    } else {
      if (isXLocked) {
        scale.x = 1;
      }
      if (isYLocked) {
        scale.y = 1;
      }
    }
    if (!this.info.isCreating) {
      this.updateCursor({
        dragHandle,
        isFlippedX: scale.x < 0,
        isFlippedY: scale.y < 0,
        rotation: selectionRotation
      });
    }
    for (const id of shapeSnapshots.keys()) {
      const snapshot = shapeSnapshots.get(id);
      this.editor.resizeShape(id, scale, {
        initialShape: snapshot.shape,
        initialBounds: snapshot.bounds,
        initialPageTransform: snapshot.pageTransform,
        dragHandle,
        mode: selectedShapeIds.length === 1 && id === selectedShapeIds[0] ? "resize_bounds" : "scale_shape",
        scaleOrigin: scaleOriginPage,
        isAspectRatioLocked,
        scaleAxisRotation: selectionRotation,
        skipStartAndEndCallbacks: true
      });
    }
    if (isHoldingAccel) {
      this.didHoldCommand = true;
      for (const { id, children } of frames) {
        if (!children.length) continue;
        const initial = shapeSnapshots.get(id).shape;
        const current = this.editor.getShape(id);
        if (!(initial && current)) continue;
        const dx = current.x - initial.x;
        const dy = current.y - initial.y;
        const delta = new Vec(dx, dy).rot(-initial.rotation);
        if (delta.x !== 0 || delta.y !== 0) {
          for (const child of children) {
            this.editor.updateShape({
              id: child.id,
              type: child.type,
              x: child.x - delta.x,
              y: child.y - delta.y
            });
          }
        }
      }
    } else if (this.didHoldCommand) {
      this.didHoldCommand = false;
      for (const { children } of frames) {
        if (!children.length) continue;
        for (const child of children) {
          this.editor.updateShape({
            id: child.id,
            type: child.type,
            x: child.x,
            y: child.y
          });
        }
      }
    }
  }
  // ---
  updateCursor({
    dragHandle,
    isFlippedX,
    isFlippedY,
    rotation
  }) {
    const nextCursor = { ...this.editor.getInstanceState().cursor };
    switch (dragHandle) {
      case "top_left":
      case "bottom_right": {
        nextCursor.type = "nwse-resize";
        if (isFlippedX !== isFlippedY) {
          nextCursor.type = "nesw-resize";
        }
        break;
      }
      case "top_right":
      case "bottom_left": {
        nextCursor.type = "nesw-resize";
        if (isFlippedX !== isFlippedY) {
          nextCursor.type = "nwse-resize";
        }
        break;
      }
    }
    nextCursor.rotation = rotation;
    this.editor.setCursor(nextCursor);
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.editor.snaps.clearIndicators();
  }
  _createSnapshot() {
    const { editor } = this;
    const selectedShapeIds = editor.getSelectedShapeIds();
    const selectionRotation = editor.getSelectionRotation();
    const {
      inputs: { originPagePoint }
    } = editor;
    const selectionBounds = editor.getSelectionRotatedPageBounds();
    if (!selectionBounds) throw Error("Resizing but nothing is selected");
    const dragHandlePoint = Vec.RotWith(
      selectionBounds.getHandlePoint(this.info.handle),
      selectionBounds.point,
      selectionRotation
    );
    const cursorHandleOffset = Vec.Sub(originPagePoint, dragHandlePoint);
    const shapeSnapshots = /* @__PURE__ */ new Map();
    const frames = [];
    const populateResizingShapes = (shapeId) => {
      const shape = editor.getShape(shapeId);
      if (!shape) return false;
      const util = editor.getShapeUtil(shape);
      if (util.canResize(shape)) {
        const pageTransform = editor.getShapePageTransform(shape);
        shapeSnapshots.set(shape.id, {
          shape,
          bounds: editor.getShapeGeometry(shape).bounds,
          pageTransform,
          pageRotation: Mat.Decompose(pageTransform).rotation,
          isAspectRatioLocked: util.isAspectRatioLocked(shape)
        });
      }
      if (editor.isShapeOfType(shape, "frame")) {
        frames.push({
          id: shape.id,
          children: compact(
            editor.getSortedChildIdsForParent(shape).map((id) => editor.getShape(id))
          )
        });
      }
      if (!util.canResizeChildren(shape)) return false;
    };
    selectedShapeIds.forEach((shapeId) => {
      const keepDescending = populateResizingShapes(shapeId);
      if (keepDescending === false) return;
      editor.visitDescendants(shapeId, populateResizingShapes);
    });
    const canShapesDeform = ![...shapeSnapshots.values()].some(
      (shape) => !areAnglesCompatible(shape.pageRotation, selectionRotation) || shape.isAspectRatioLocked
    );
    return {
      shapeSnapshots,
      selectionBounds,
      cursorHandleOffset,
      selectionRotation,
      selectedShapeIds,
      canShapesDeform,
      initialSelectionPageBounds: this.editor.getSelectionPageBounds(),
      frames
    };
  }
}
const ORDERED_SELECTION_HANDLES = [
  "top",
  "top_right",
  "right",
  "bottom_right",
  "bottom",
  "bottom_left",
  "left",
  "top_left"
];
function rotateSelectionHandle(handle, rotation) {
  rotation = rotation % PI2;
  const numSteps = Math.round(rotation / (PI$1 / 4));
  const currentIndex = ORDERED_SELECTION_HANDLES.indexOf(handle);
  return ORDERED_SELECTION_HANDLES[(currentIndex + numSteps) % ORDERED_SELECTION_HANDLES.length];
}
const ONE_DEGREE = Math.PI / 180;
class Rotating extends StateNode {
  static id = "rotating";
  snapshot = {};
  info = {};
  markId = "";
  onEnter(info) {
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.markId = this.editor.markHistoryStoppingPoint("rotate start");
    const snapshot = getRotationSnapshot({
      editor: this.editor,
      ids: this.editor.getSelectedShapeIds()
    });
    if (!snapshot) return this.parent.transition("idle", this.info);
    this.snapshot = snapshot;
    const newSelectionRotation = this._getRotationFromPointerPosition({
      snapToNearestDegree: false
    });
    applyRotationToSnapshotShapes({
      editor: this.editor,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: false }),
      snapshot: this.snapshot,
      stage: "start"
    });
    this.editor.setCursor({
      type: CursorTypeMap[this.info.handle],
      rotation: newSelectionRotation + this.snapshot.initialShapesRotation
    });
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.parent.setCurrentToolIdMask(void 0);
    this.snapshot = {};
  }
  onPointerMove() {
    this.update();
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  // ---
  update() {
    const newSelectionRotation = this._getRotationFromPointerPosition({
      snapToNearestDegree: false
    });
    applyRotationToSnapshotShapes({
      editor: this.editor,
      delta: newSelectionRotation,
      snapshot: this.snapshot,
      stage: "update"
    });
    this.editor.setCursor({
      type: CursorTypeMap[this.info.handle],
      rotation: newSelectionRotation + this.snapshot.initialShapesRotation
    });
  }
  cancel() {
    const { shapeSnapshots } = this.snapshot;
    shapeSnapshots.forEach(({ shape }) => {
      const current = this.editor.getShape(shape.id);
      if (current) {
        const util = this.editor.getShapeUtil(shape);
        util.onRotateCancel?.(shape, current);
      }
    });
    this.editor.bailToMark(this.markId);
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle", this.info);
  }
  complete() {
    applyRotationToSnapshotShapes({
      editor: this.editor,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: true }),
      snapshot: this.snapshot,
      stage: "end"
    });
    kickoutOccludedShapes(
      this.editor,
      this.snapshot.shapeSnapshots.map((s) => s.shape.id)
    );
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle", this.info);
  }
  _getRotationFromPointerPosition({ snapToNearestDegree }) {
    const {
      inputs: { shiftKey, currentPagePoint }
    } = this.editor;
    const { initialCursorAngle, initialShapesRotation, initialPageCenter } = this.snapshot;
    const preSnapRotationDelta = initialPageCenter.angle(currentPagePoint) - initialCursorAngle;
    let newSelectionRotation = initialShapesRotation + preSnapRotationDelta;
    if (shiftKey) {
      newSelectionRotation = snapAngle(newSelectionRotation, 24);
    } else if (snapToNearestDegree) {
      newSelectionRotation = Math.round(newSelectionRotation / ONE_DEGREE) * ONE_DEGREE;
      if (this.editor.getInstanceState().isCoarsePointer) {
        const snappedToRightAngle = snapAngle(newSelectionRotation, 4);
        const angleToRightAngle = shortAngleDist(newSelectionRotation, snappedToRightAngle);
        if (Math.abs(angleToRightAngle) < degreesToRadians(5)) {
          newSelectionRotation = snappedToRightAngle;
        }
      }
    }
    return newSelectionRotation - initialShapesRotation;
  }
}
class ScribbleBrushing extends StateNode {
  static id = "scribble_brushing";
  hits = /* @__PURE__ */ new Set();
  size = 0;
  scribbleId = "id";
  initialSelectedShapeIds = /* @__PURE__ */ new Set();
  newlySelectedShapeIds = /* @__PURE__ */ new Set();
  onEnter() {
    this.initialSelectedShapeIds = new Set(
      this.editor.inputs.shiftKey ? this.editor.getSelectedShapeIds() : []
    );
    this.newlySelectedShapeIds = /* @__PURE__ */ new Set();
    this.size = 0;
    this.hits.clear();
    const scribbleItem = this.editor.scribbles.addScribble({
      color: "selection-stroke",
      opacity: 0.32,
      size: 12
    });
    this.scribbleId = scribbleItem.id;
    this.updateScribbleSelection(true);
    this.editor.updateInstanceState({ brush: null });
  }
  onExit() {
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.updateScribbleSelection(true);
  }
  onPointerUp() {
    this.complete();
  }
  onKeyDown() {
    this.updateScribbleSelection(false);
  }
  onKeyUp() {
    if (!this.editor.inputs.altKey) {
      this.parent.transition("brushing");
    } else {
      this.updateScribbleSelection(false);
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  pushPointToScribble() {
    const { x, y } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, x, y);
  }
  updateScribbleSelection(addPoint) {
    const { editor } = this;
    const currentPageShapes = this.editor.getCurrentPageRenderingShapesSorted();
    const {
      inputs: { shiftKey, originPagePoint, previousPagePoint, currentPagePoint }
    } = this.editor;
    const { newlySelectedShapeIds, initialSelectedShapeIds } = this;
    if (addPoint) {
      this.pushPointToScribble();
    }
    const shapes = currentPageShapes;
    let shape, geometry, A, B;
    const minDist = 0;
    for (let i = 0, n = shapes.length; i < n; i++) {
      shape = shapes[i];
      if (editor.isShapeOfType(shape, "group") || newlySelectedShapeIds.has(shape.id) || editor.isShapeOrAncestorLocked(shape)) {
        continue;
      }
      geometry = editor.getShapeGeometry(shape);
      if (editor.isShapeOfType(shape, "frame") && geometry.bounds.containsPoint(editor.getPointInShapeSpace(shape, originPagePoint))) {
        continue;
      }
      const pageTransform = editor.getShapePageTransform(shape);
      if (!geometry || !pageTransform) continue;
      const pt = pageTransform.clone().invert();
      A = pt.applyToPoint(previousPagePoint);
      B = pt.applyToPoint(currentPagePoint);
      const { bounds } = geometry;
      if (bounds.minX - minDist > Math.max(A.x, B.x) || bounds.minY - minDist > Math.max(A.y, B.y) || bounds.maxX + minDist < Math.min(A.x, B.x) || bounds.maxY + minDist < Math.min(A.y, B.y)) {
        continue;
      }
      if (geometry.hitTestLineSegment(A, B, minDist)) {
        const outermostShape = this.editor.getOutermostSelectableShape(shape);
        const pageMask = this.editor.getShapeMask(outermostShape.id);
        if (pageMask) {
          const intersection = intersectLineSegmentPolygon(
            previousPagePoint,
            currentPagePoint,
            pageMask
          );
          if (intersection !== null) {
            const isInMask = pointInPolygon(currentPagePoint, pageMask);
            if (!isInMask) continue;
          }
        }
        newlySelectedShapeIds.add(outermostShape.id);
      }
    }
    const current = editor.getSelectedShapeIds();
    const next = new Set(
      shiftKey ? [...newlySelectedShapeIds, ...initialSelectedShapeIds] : [...newlySelectedShapeIds]
    );
    if (current.length !== next.size || current.some((id) => !next.has(id))) {
      this.editor.setSelectedShapes(Array.from(next));
    }
  }
  complete() {
    this.updateScribbleSelection(true);
    this.parent.transition("idle");
  }
  cancel() {
    this.editor.setSelectedShapes([...this.initialSelectedShapeIds]);
    this.parent.transition("idle");
  }
}
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __knownSymbol$1 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$1 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$1 = (base2) => [, , , __create$1(null)];
var __decoratorStrings$1 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$1 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$1("Function expected") : fn;
var __decoratorContext$1 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings$1[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError$1("Already initialized") : fns.push(__expectFn$1(fn || null)) });
var __decoratorMetadata$1 = (array2, target) => __defNormalProp$1(target, __knownSymbol$1("metadata"), array2[3]);
var __runInitializers$1 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$1 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings$1[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$1(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$1(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$1(it) && (desc[key] = it);
  }
  return desc && __defProp$1(target, name, desc), target;
};
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
var _dispose_dec, _init$1;
const SLOW_POINTER_LAG_DURATION = 320;
const FAST_POINTER_LAG_DURATION = 60;
_dispose_dec = [bind$1];
class DragAndDropManager {
  constructor(editor) {
    this.editor = editor;
    __runInitializers$1(_init$1, 5, this);
    __publicField$1(this, "shapesToActuallyMove", []);
    __publicField$1(this, "draggedOverShapeIds", /* @__PURE__ */ new Set());
    __publicField$1(this, "initialGroupIds", /* @__PURE__ */ new Map());
    __publicField$1(this, "initialParentIds", /* @__PURE__ */ new Map());
    __publicField$1(this, "initialIndices", /* @__PURE__ */ new Map());
    __publicField$1(this, "initialDraggingOverShape");
    __publicField$1(this, "prevDraggingOverShape");
    __publicField$1(this, "prevPagePoint", new Vec());
    __publicField$1(this, "intervalTimerId", -1);
    editor.disposables.add(this.dispose);
  }
  startDraggingShapes(movingShapes, point, cb) {
    const { editor } = this;
    if (this.intervalTimerId !== -1) return;
    const shapesToActuallyMove = new Set(movingShapes);
    const movingGroups = /* @__PURE__ */ new Set();
    for (const shape of shapesToActuallyMove) {
      const parent = editor.getShapeParent(shape);
      if (parent && editor.isShapeOfType(parent, "group")) {
        if (!movingGroups.has(parent)) {
          movingGroups.add(parent);
        }
      }
    }
    for (const movingGroup of movingGroups) {
      const children = compact(
        editor.getSortedChildIdsForParent(movingGroup).map((id) => editor.getShape(id))
      );
      shapesToActuallyMove.add(movingGroup);
      for (const child of children) {
        shapesToActuallyMove.delete(child);
      }
    }
    this.initialParentIds.clear();
    for (const shape of shapesToActuallyMove) {
      const parent = editor.getShapeParent(shape);
      if (parent) {
        this.initialParentIds.set(shape.id, parent.id);
      }
      this.initialIndices.set(shape.id, shape.index);
      const group = editor.findShapeAncestor(
        shape,
        (s) => editor.isShapeOfType(s, "group")
      );
      if (group) {
        this.initialGroupIds.set(shape.id, group.id);
      }
    }
    const allShapes = editor.getCurrentPageShapesSorted();
    this.shapesToActuallyMove = Array.from(shapesToActuallyMove).filter((s) => !s.isLocked).sort((a, b) => allShapes.indexOf(a) - allShapes.indexOf(b));
    this.initialDraggingOverShape = editor.getDraggingOverShape(point, this.shapesToActuallyMove);
    this.prevDraggingOverShape = this.initialDraggingOverShape;
    this.updateDraggingShapes(point, cb);
    let skip2of3FramesWhileMovingFast = 0;
    this.intervalTimerId = this.editor.timers.setInterval(
      () => {
        skip2of3FramesWhileMovingFast++;
        if (skip2of3FramesWhileMovingFast % 3 && this.editor.inputs.pointerVelocity.len() > 0.5) {
          return;
        }
        this.updateDraggingShapes(editor.inputs.currentPagePoint, cb);
      },
      movingShapes.length > 10 ? SLOW_POINTER_LAG_DURATION : FAST_POINTER_LAG_DURATION
    );
  }
  dropShapes(shapes) {
    const { editor } = this;
    this.updateDraggingShapes(editor.inputs.currentPagePoint);
    const draggingOverShape = editor.getDraggingOverShape(editor.inputs.currentPagePoint, shapes);
    if (draggingOverShape) {
      const util = editor.getShapeUtil(draggingOverShape);
      util.onDropShapesOver?.(draggingOverShape, shapes, {
        initialDraggingOverShapeId: this.initialDraggingOverShape?.id ?? null,
        initialParentIds: this.initialParentIds,
        initialIndices: this.initialIndices
      });
    }
    this.dispose();
  }
  clear() {
    clearInterval(this.intervalTimerId);
    this.intervalTimerId = -1;
    this.initialParentIds.clear();
    this.initialIndices.clear();
    this.shapesToActuallyMove = [];
    this.initialDraggingOverShape = void 0;
    this.prevDraggingOverShape = void 0;
    this.editor.setHintingShapes([]);
  }
  dispose() {
    this.clear();
  }
  updateDraggingShapes(point, cb) {
    const { editor } = this;
    const draggingShapes = compact(this.shapesToActuallyMove.map((s) => editor.getShape(s)));
    if (!draggingShapes.length) return;
    const nextDraggingOverShape = editor.getDraggingOverShape(point, this.shapesToActuallyMove);
    const cursorDidMove = !this.prevPagePoint.equals(editor.inputs.currentPagePoint);
    this.prevPagePoint.setTo(editor.inputs.currentPagePoint);
    editor.run(() => {
      if (this.prevDraggingOverShape?.id === nextDraggingOverShape?.id) {
        if (cursorDidMove && nextDraggingOverShape && isShapeId(nextDraggingOverShape.id) && !editor.inputs.previousPagePoint.equals(editor.inputs.currentPagePoint)) {
          const util = editor.getShapeUtil(nextDraggingOverShape);
          util.onDragShapesOver?.(nextDraggingOverShape, draggingShapes, {
            initialDraggingOverShapeId: this.initialDraggingOverShape?.id ?? null,
            initialParentIds: this.initialParentIds,
            initialIndices: this.initialIndices
          });
        }
        return;
      }
      if (this.prevDraggingOverShape) {
        const util = editor.getShapeUtil(this.prevDraggingOverShape);
        util.onDragShapesOut?.(this.editor.getShape(this.prevDraggingOverShape), draggingShapes, {
          nextDraggingOverShapeId: nextDraggingOverShape?.id ?? null,
          initialDraggingOverShapeId: this.initialDraggingOverShape?.id ?? null,
          initialParentIds: this.initialParentIds,
          initialIndices: this.initialIndices
        });
      }
      if (nextDraggingOverShape) {
        const util = editor.getShapeUtil(nextDraggingOverShape);
        util.onDragShapesIn?.(nextDraggingOverShape, draggingShapes, {
          initialDraggingOverShapeId: this.initialDraggingOverShape?.id ?? null,
          prevDraggingOverShapeId: this.prevDraggingOverShape?.id ?? null,
          initialParentIds: this.initialParentIds,
          initialIndices: this.initialIndices
        });
        editor.setHintingShapes([nextDraggingOverShape.id]);
      } else if (this.prevDraggingOverShape) {
        editor.setHintingShapes([]);
      }
      cb?.();
    });
    this.prevDraggingOverShape = nextDraggingOverShape;
  }
}
_init$1 = __decoratorStart$1();
__decorateElement$1(_init$1, 1, "dispose", _dispose_dec, DragAndDropManager);
__decoratorMetadata$1(_init$1, DragAndDropManager);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart = (base2) => [, , , __create(base2?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array2, target) => __defNormalProp(target, __knownSymbol("metadata"), array2[3]);
var __runInitializers = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self2);
  return value;
};
var __decorateElement = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s = false, p = false;
  var j = 2, key = __decoratorStrings[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn(it) && (desc[key] = it);
  }
  return desc && __defProp(target, name, desc), target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _updateParentTransforms_dec, _a, _init;
class Translating extends (_a = StateNode, _updateParentTransforms_dec = [bind$1], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
    __publicField(this, "info", {});
    __publicField(this, "selectionSnapshot", {});
    __publicField(this, "snapshot", {});
    __publicField(this, "markId", "");
    __publicField(this, "isCloning", false);
    __publicField(this, "isCreating", false);
    __publicField(this, "dragAndDropManager", new DragAndDropManager(this.editor));
  }
  onCreate(_shape) {
    return;
  }
  onEnter(info) {
    const { isCreating = false, creatingMarkId, onCreate = () => void 0 } = info;
    if (!this.editor.getSelectedShapeIds()?.length) {
      this.parent.transition("idle");
      return;
    }
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.isCreating = isCreating;
    this.markId = "";
    if (isCreating) {
      if (creatingMarkId) {
        this.markId = creatingMarkId;
      } else {
        const markId = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        if (markId) {
          this.markId = markId;
        }
      }
    } else {
      this.markId = this.editor.markHistoryStoppingPoint("translating");
    }
    this.onCreate = onCreate;
    this.isCloning = false;
    this.info = info;
    this.editor.setCursor({ type: "move", rotation: 0 });
    this.selectionSnapshot = getTranslatingSnapshot(this.editor);
    if (!this.isCreating) {
      if (this.editor.inputs.altKey) {
        this.startCloning();
        if (this.isCloning) return;
      }
    }
    this.snapshot = this.selectionSnapshot;
    this.handleStart();
    this.updateShapes();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.selectionSnapshot = {};
    this.snapshot = {};
    this.editor.snaps.clearIndicators();
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.dragAndDropManager.clear();
  }
  onTick({ elapsed }) {
    const { editor } = this;
    editor.edgeScrollManager.updateEdgeScrolling(elapsed);
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    if (this.editor.inputs.altKey && !this.isCloning) {
      this.startCloning();
      if (this.isCloning) return;
    }
    this.updateShapes();
  }
  onKeyUp() {
    if (!this.editor.inputs.altKey && this.isCloning) {
      this.stopCloning();
      return;
    }
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  startCloning() {
    if (this.isCreating) return;
    const shapeIds = Array.from(this.editor.getSelectedShapeIds());
    if (!this.editor.canCreateShapes(shapeIds)) return;
    this.isCloning = true;
    this.reset();
    this.markId = this.editor.markHistoryStoppingPoint("translate cloning");
    this.editor.duplicateShapes(Array.from(this.editor.getSelectedShapeIds()));
    this.snapshot = getTranslatingSnapshot(this.editor);
    this.handleStart();
    this.updateShapes();
  }
  stopCloning() {
    this.isCloning = false;
    this.snapshot = this.selectionSnapshot;
    this.reset();
    this.markId = this.editor.markHistoryStoppingPoint("translate");
    this.updateShapes();
  }
  reset() {
    this.editor.bailToMark(this.markId);
  }
  complete() {
    this.updateShapes();
    this.dragAndDropManager.dropShapes(this.snapshot.movingShapes);
    this.handleEnd();
    kickoutOccludedShapes(
      this.editor,
      this.snapshot.movingShapes.map((s) => s.id)
    );
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        if (this.editor.getInstanceState().isToolLocked) {
          this.editor.setCurrentTool(onInteractionEnd);
          return;
        }
      } else {
        onInteractionEnd();
        return;
      }
    }
    if (this.isCreating) {
      this.onCreate?.(this.editor.getOnlySelectedShape());
    } else {
      this.parent.transition("idle");
    }
  }
  cancel() {
    const { movingShapes } = this.snapshot;
    movingShapes.forEach((shape) => {
      const current = this.editor.getShape(shape.id);
      if (current) {
        const util = this.editor.getShapeUtil(shape);
        util.onTranslateCancel?.(shape, current);
      }
    });
    this.reset();
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd);
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle", this.info);
  }
  handleStart() {
    const { movingShapes } = this.snapshot;
    const changes = [];
    movingShapes.forEach((shape) => {
      const util = this.editor.getShapeUtil(shape);
      const change = util.onTranslateStart?.(shape);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
    this.dragAndDropManager.startDraggingShapes(
      // Get fresh shapes from the snapshot, in case onTranslateStart mutates the shape
      compact(this.snapshot.movingShapes.map((s) => this.editor.getShape(s.id))),
      // Start from the place where the user started dragging
      this.editor.inputs.originPagePoint,
      this.updateParentTransforms
    );
    this.editor.setHoveredShape(null);
  }
  handleEnd() {
    const { movingShapes } = this.snapshot;
    if (this.isCloning && movingShapes.length > 0) {
      const currentAveragePagePoint = Vec.Average(
        movingShapes.map((s) => this.editor.getShapePageTransform(s.id).point())
      );
      const offset2 = Vec.Sub(currentAveragePagePoint, this.selectionSnapshot.averagePagePoint);
      if (!Vec.IsNaN(offset2)) {
        this.editor.updateInstanceState({
          duplicateProps: {
            shapeIds: movingShapes.map((s) => s.id),
            offset: { x: offset2.x, y: offset2.y }
          }
        });
      }
    }
    const changes = [];
    movingShapes.forEach((shape) => {
      const current = this.editor.getShape(shape.id);
      const util = this.editor.getShapeUtil(shape);
      const change = util.onTranslateEnd?.(shape, current);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  updateShapes() {
    const { snapshot } = this;
    this.dragAndDropManager.startDraggingShapes(
      snapshot.movingShapes,
      this.editor.inputs.originPagePoint,
      this.updateParentTransforms
    );
    moveShapesToPoint({
      editor: this.editor,
      snapshot
    });
    const { movingShapes } = snapshot;
    const changes = [];
    movingShapes.forEach((shape) => {
      const current = this.editor.getShape(shape.id);
      const util = this.editor.getShapeUtil(shape);
      const change = util.onTranslate?.(shape, current);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  updateParentTransforms() {
    const {
      editor,
      snapshot: { shapeSnapshots }
    } = this;
    shapeSnapshots.forEach((shapeSnapshot) => {
      const shape = editor.getShape(shapeSnapshot.shape.id);
      if (!shape) return null;
      const parentTransform = isPageId(shape.parentId) ? null : Mat.Inverse(editor.getShapePageTransform(shape.parentId));
      shapeSnapshot.parentTransform = parentTransform;
    });
  }
}
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "updateParentTransforms", _updateParentTransforms_dec, Translating);
__decoratorMetadata(_init, Translating);
__publicField(Translating, "id", "translating");
function getTranslatingSnapshot(editor) {
  const movingShapes = [];
  const pagePoints = [];
  const selectedShapeIds = editor.getSelectedShapeIds();
  const shapeSnapshots = compact(
    selectedShapeIds.map((id) => {
      const shape = editor.getShape(id);
      if (!shape) return null;
      movingShapes.push(shape);
      const pageTransform = editor.getShapePageTransform(id);
      const pagePoint = pageTransform.point();
      const pageRotation = pageTransform.rotation();
      pagePoints.push(pagePoint);
      const parentTransform = PageRecordType.isId(shape.parentId) ? null : Mat.Inverse(editor.getShapePageTransform(shape.parentId));
      return {
        shape,
        pagePoint,
        pageRotation,
        parentTransform
      };
    })
  );
  const onlySelectedShape = editor.getOnlySelectedShape();
  let initialSnapPoints = [];
  if (onlySelectedShape) {
    initialSnapPoints = editor.snaps.shapeBounds.getSnapPoints(onlySelectedShape.id);
  } else {
    const selectionPageBounds = editor.getSelectionPageBounds();
    if (selectionPageBounds) {
      initialSnapPoints = selectionPageBounds.cornersAndCenter.map((p, i) => ({
        id: "selection:" + i,
        x: p.x,
        y: p.y
      }));
    }
  }
  let noteAdjacentPositions;
  let noteSnapshot;
  const { originPagePoint } = editor.inputs;
  const allHoveredNotes = shapeSnapshots.filter(
    (s) => editor.isShapeOfType(s.shape, "note") && editor.isPointInShape(s.shape, originPagePoint)
  );
  if (allHoveredNotes.length === 0) ;
  else if (allHoveredNotes.length === 1) {
    noteSnapshot = allHoveredNotes[0];
  } else {
    const allShapesSorted = editor.getCurrentPageShapesSorted();
    noteSnapshot = allHoveredNotes.map((s) => ({
      snapshot: s,
      index: allShapesSorted.findIndex((shape) => shape.id === s.shape.id)
    })).sort((a, b) => b.index - a.index)[0]?.snapshot;
  }
  if (noteSnapshot) {
    noteAdjacentPositions = getAvailableNoteAdjacentPositions(
      editor,
      noteSnapshot.pageRotation,
      noteSnapshot.shape.props.scale,
      noteSnapshot.shape.props.growY ?? 0
    );
  }
  return {
    averagePagePoint: Vec.Average(pagePoints),
    movingShapes,
    shapeSnapshots,
    initialPageBounds: editor.getSelectionPageBounds(),
    initialSnapPoints,
    noteAdjacentPositions,
    noteSnapshot
  };
}
function moveShapesToPoint({
  editor,
  snapshot
}) {
  const { inputs } = editor;
  const {
    noteSnapshot,
    noteAdjacentPositions,
    initialPageBounds,
    initialSnapPoints,
    shapeSnapshots,
    averagePagePoint
  } = snapshot;
  const isGridMode = editor.getInstanceState().isGridMode;
  const gridSize = editor.getDocumentSettings().gridSize;
  const delta = Vec.Sub(inputs.currentPagePoint, inputs.originPagePoint);
  const flatten = editor.inputs.shiftKey ? Math.abs(delta.x) < Math.abs(delta.y) ? "x" : "y" : null;
  if (flatten === "x") {
    delta.x = 0;
  } else if (flatten === "y") {
    delta.y = 0;
  }
  editor.snaps.clearIndicators();
  const isSnapping = editor.user.getIsSnapMode() ? !inputs.ctrlKey : inputs.ctrlKey;
  let snappedToPit = false;
  if (isSnapping && editor.inputs.pointerVelocity.len() < 0.5) {
    const { nudge } = editor.snaps.shapeBounds.snapTranslateShapes({
      dragDelta: delta,
      initialSelectionPageBounds: initialPageBounds,
      lockedAxis: flatten,
      initialSelectionSnapPoints: initialSnapPoints
    });
    delta.add(nudge);
  } else {
    if (noteSnapshot && noteAdjacentPositions) {
      const { scale } = noteSnapshot.shape.props;
      const pageCenter = noteSnapshot.pagePoint.clone().add(delta).add(NOTE_CENTER_OFFSET.clone().mul(scale).rot(noteSnapshot.pageRotation));
      let min2 = NOTE_ADJACENT_POSITION_SNAP_RADIUS / editor.getZoomLevel();
      let offset2 = new Vec(0, 0);
      for (const pit of noteAdjacentPositions) {
        const deltaToPit = Vec.Sub(pageCenter, pit);
        const dist = deltaToPit.len();
        if (dist < min2) {
          snappedToPit = true;
          min2 = dist;
          offset2 = deltaToPit;
        }
      }
      delta.sub(offset2);
    }
  }
  const averageSnappedPoint = Vec.Add(averagePagePoint, delta);
  const snapIndicators = editor.snaps.getIndicators();
  if (isGridMode && !inputs.ctrlKey && !snappedToPit && snapIndicators.length === 0) {
    averageSnappedPoint.snapToGrid(gridSize);
  }
  const averageSnap = Vec.Sub(averageSnappedPoint, averagePagePoint);
  editor.updateShapes(
    compact(
      shapeSnapshots.map(({ shape, pagePoint, parentTransform }) => {
        const newPagePoint = Vec.Add(pagePoint, averageSnap);
        const newLocalPoint = parentTransform ? Mat.applyToPoint(parentTransform, newPagePoint) : newPagePoint;
        return {
          id: shape.id,
          type: shape.type,
          x: newLocalPoint.x,
          y: newLocalPoint.y
        };
      })
    )
  );
}
class SelectTool extends StateNode {
  static id = "select";
  static initial = "idle";
  static isLockable = false;
  reactor = void 0;
  static children() {
    return [
      Crop,
      Cropping,
      Idle$1,
      PointingCanvas,
      PointingShape,
      Translating,
      Brushing,
      ScribbleBrushing,
      PointingCropHandle,
      PointingSelection,
      PointingResizeHandle,
      EditingShape,
      Resizing,
      Rotating,
      PointingRotateHandle,
      PointingArrowLabel,
      PointingHandle,
      DraggingHandle
    ];
  }
  // We want to clean up the duplicate props when the selection changes
  cleanUpDuplicateProps() {
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    const instance = this.editor.getInstanceState();
    if (!instance.duplicateProps) return;
    const duplicatedShapes = new Set(instance.duplicateProps.shapeIds);
    if (selectedShapeIds.length === duplicatedShapes.size && selectedShapeIds.every((shapeId) => duplicatedShapes.has(shapeId))) {
      return;
    }
    this.editor.updateInstanceState({
      duplicateProps: null
    });
  }
  onEnter() {
    this.reactor = react("clean duplicate props", () => {
      try {
        this.cleanUpDuplicateProps();
      } catch (e) {
        {
          console.error(e);
        }
      }
    });
  }
  onExit() {
    this.reactor?.();
    if (this.editor.getCurrentPageState().editingShapeId) {
      this.editor.setEditingShape(null);
    }
  }
}
class Idle13 extends StateNode {
  static id = "idle";
  info = {};
  onEnter(info) {
    this.info = info;
  }
  onPointerDown() {
    this.parent.transition("pointing", this.info);
  }
}
class Pointing9 extends StateNode {
  static id = "pointing";
  info = {};
  onEnter(info) {
    this.info = info;
  }
  onPointerUp() {
    this.complete();
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      this.parent.transition("zoom_brushing", this.info);
    }
  }
  onCancel() {
    this.cancel();
  }
  complete() {
    const { currentScreenPoint } = this.editor.inputs;
    if (this.editor.inputs.altKey) {
      this.editor.zoomOut(currentScreenPoint, { animation: { duration: 220 } });
    } else {
      this.editor.zoomIn(currentScreenPoint, { animation: { duration: 220 } });
    }
    this.parent.transition("idle", this.info);
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
}
class ZoomBrushing extends StateNode {
  static id = "zoom_brushing";
  info = {};
  zoomBrush = new Box();
  onEnter(info) {
    this.info = info;
    this.update();
  }
  onExit() {
    this.editor.updateInstanceState({ zoomBrush: null });
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  update() {
    const {
      inputs: { originPagePoint, currentPagePoint }
    } = this.editor;
    this.zoomBrush.setTo(Box.FromPoints([originPagePoint, currentPagePoint]));
    this.editor.updateInstanceState({ zoomBrush: this.zoomBrush.toJson() });
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
  complete() {
    const { zoomBrush } = this;
    const threshold = 8 / this.editor.getZoomLevel();
    if (zoomBrush.width < threshold && zoomBrush.height < threshold) {
      const point = this.editor.inputs.currentScreenPoint;
      if (this.editor.inputs.altKey) {
        this.editor.zoomOut(point, { animation: { duration: 220 } });
      } else {
        this.editor.zoomIn(point, { animation: { duration: 220 } });
      }
    } else {
      const targetZoom = this.editor.inputs.altKey ? this.editor.getZoomLevel() / 2 : void 0;
      this.editor.zoomToBounds(zoomBrush, { targetZoom, animation: { duration: 220 } });
    }
    this.parent.transition("idle", this.info);
  }
}
class ZoomTool extends StateNode {
  static id = "zoom";
  static initial = "idle";
  static children() {
    return [Idle13, ZoomBrushing, Pointing9];
  }
  static isLockable = false;
  info = {};
  onEnter(info) {
    this.info = info;
    this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.updateInstanceState({ zoomBrush: null, cursor: { type: "default", rotation: 0 } });
    this.parent.setCurrentToolIdMask(void 0);
  }
  onKeyDown() {
    this.updateCursor();
  }
  onKeyUp(info) {
    this.updateCursor();
    if (info.code === "KeyZ") {
      this.complete();
    }
  }
  onInterrupt() {
    this.complete();
  }
  complete() {
    if (this.info.onInteractionEnd && this.info.onInteractionEnd !== "select") {
      this.editor.setCurrentTool(this.info.onInteractionEnd, this.info);
    } else {
      this.parent.transition("select");
    }
  }
  updateCursor() {
    if (this.editor.inputs.altKey) {
      this.editor.setCursor({ type: "zoom-out", rotation: 0 });
    } else {
      this.editor.setCursor({ type: "zoom-in", rotation: 0 });
    }
  }
}
const defaultTools = [EraserTool, HandTool, LaserTool, ZoomTool, SelectTool];
const PlainTextArea = React.forwardRef(function TextArea({
  isEditing,
  text,
  handleFocus,
  handleChange,
  handleKeyDown: handleKeyDown2,
  handlePaste,
  handleBlur,
  handleInputPointerDown,
  handleDoubleClick: handleDoubleClick2
}, ref) {
  const editor = useEditor();
  const onChange = (e) => {
    handleChange({ plaintext: e.target.value });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "textarea",
    {
      ref,
      className: "tl-text tl-text-input",
      name: "text",
      tabIndex: -1,
      disabled: !isEditing,
      readOnly: !isEditing,
      autoComplete: "off",
      autoCapitalize: "off",
      autoCorrect: "off",
      autoSave: "off",
      placeholder: "",
      spellCheck: "true",
      wrap: "off",
      dir: "auto",
      defaultValue: text,
      onFocus: handleFocus,
      onChange,
      onKeyDown: (e) => handleKeyDown2(e.nativeEvent),
      onBlur: handleBlur,
      onTouchEnd: editor.markEventAsHandled,
      onContextMenu: isEditing ? (e) => e.stopPropagation() : void 0,
      onPointerDown: handleInputPointerDown,
      onPaste: handlePaste,
      onDoubleClick: handleDoubleClick2,
      onDragStart: preventDefault
    }
  );
});
React.memo(function PlainTextLabel2({
  shapeId,
  type,
  text: plaintext,
  labelColor,
  font,
  fontSize,
  lineHeight,
  align,
  verticalAlign,
  wrap: wrap2,
  isSelected,
  padding = 0,
  onKeyDown: handleKeyDownCustom,
  classNamePrefix,
  style: style2,
  textWidth,
  textHeight
}) {
  const { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } = useEditablePlainText(shapeId, type, plaintext);
  const finalPlainText = TextHelpers.normalizeTextForDom(plaintext || "");
  const hasText = finalPlainText.length > 0;
  const legacyAlign = isLegacyAlign(align);
  if (!isEditing && !hasText) {
    return null;
  }
  const cssPrefix = classNamePrefix || "tl-text";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `${cssPrefix}-label tl-text-wrapper tl-plain-text-wrapper`,
      "aria-hidden": !isEditing,
      "data-font": font,
      "data-align": align,
      "data-hastext": !isEmpty,
      "data-isediting": isEditing,
      "data-is-ready-for-editing": isReadyForEditing,
      "data-textwrap": !!wrap2,
      "data-isselected": isSelected,
      style: {
        justifyContent: align === "middle" || legacyAlign ? "center" : align,
        alignItems: verticalAlign === "middle" ? "center" : verticalAlign,
        padding,
        ...style2
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `${cssPrefix}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize,
            lineHeight: lineHeight.toString(),
            minHeight: Math.floor(fontSize * lineHeight) + "px",
            minWidth: Math.ceil(textWidth || 0),
            color: labelColor,
            width: textWidth ? Math.ceil(textWidth) : void 0,
            height: textHeight ? Math.ceil(textHeight) : void 0
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${cssPrefix} tl-text tl-text-content`, dir: "auto", children: finalPlainText.split("\n").map((lineOfText, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dir: "auto", children: lineOfText }, index2)) }),
            (isReadyForEditing || isSelected) && /* @__PURE__ */ jsxRuntimeExports.jsx(
              PlainTextArea,
              {
                ref: rInput,
                text: plaintext,
                isEditing,
                shapeId,
                ...editableTextRest,
                handleKeyDown: handleKeyDownCustom ?? editableTextRest.handleKeyDown
              }
            )
          ]
        }
      )
    }
  );
});
let defaultEditorAssetUrls = {
  fonts: {
    tldraw_mono: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-Medium.woff2`,
    tldraw_mono_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-MediumItalic.woff2`,
    tldraw_mono_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-Bold.woff2`,
    tldraw_mono_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-BoldItalic.woff2`,
    tldraw_serif: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-Medium.woff2`,
    tldraw_serif_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-MediumItalic.woff2`,
    tldraw_serif_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-Bold.woff2`,
    tldraw_serif_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-BoldItalic.woff2`,
    tldraw_sans: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-Medium.woff2`,
    tldraw_sans_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-MediumItalic.woff2`,
    tldraw_sans_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-Bold.woff2`,
    tldraw_sans_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-BoldItalic.woff2`,
    tldraw_draw: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Regular.woff2`,
    tldraw_draw_italic: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Regular_Italic.woff2`,
    tldraw_draw_bold: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Bold.woff2`,
    tldraw_draw_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Bold_Italic.woff2`
  }
};
function useDefaultEditorAssetsWithOverrides(overrides) {
  return reactExports.useMemo(() => {
    if (!overrides) return defaultEditorAssetUrls;
    return {
      fonts: { ...defaultEditorAssetUrls.fonts, ...overrides?.fonts }
    };
  }, [overrides]);
}
const iconTypes = [
  "align-bottom",
  "align-center-horizontal",
  "align-center-vertical",
  "align-left",
  "align-right",
  "align-top",
  "alt",
  "arrow-arc",
  "arrow-cycle",
  "arrow-elbow",
  "arrow-left",
  "arrowhead-arrow",
  "arrowhead-bar",
  "arrowhead-diamond",
  "arrowhead-dot",
  "arrowhead-none",
  "arrowhead-square",
  "arrowhead-triangle-inverted",
  "arrowhead-triangle",
  "blob",
  "bold",
  "bookmark",
  "bring-forward",
  "bring-to-front",
  "broken",
  "bulletList",
  "check-circle",
  "check",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-ne",
  "chevrons-sw",
  "clipboard-copied",
  "clipboard-copy",
  "code",
  "color",
  "comment",
  "corners",
  "crop",
  "cross-2",
  "cross-circle",
  "dash-dashed",
  "dash-dotted",
  "dash-draw",
  "dash-solid",
  "disconnected",
  "discord",
  "distribute-horizontal",
  "distribute-vertical",
  "dot",
  "dots-horizontal",
  "dots-vertical",
  "download",
  "drag-handle-dots",
  "duplicate",
  "edit",
  "external-link",
  "fill-fill",
  "fill-none",
  "fill-pattern",
  "fill-semi",
  "fill-solid",
  "follow",
  "following",
  "font-draw",
  "font-mono",
  "font-sans",
  "font-serif",
  "geo-arrow-down",
  "geo-arrow-left",
  "geo-arrow-right",
  "geo-arrow-up",
  "geo-check-box",
  "geo-cloud",
  "geo-diamond",
  "geo-ellipse",
  "geo-heart",
  "geo-hexagon",
  "geo-octagon",
  "geo-oval",
  "geo-pentagon",
  "geo-rectangle",
  "geo-rhombus-2",
  "geo-rhombus",
  "geo-star",
  "geo-trapezoid",
  "geo-triangle",
  "geo-x-box",
  "github",
  "group",
  "heading",
  "help-circle",
  "highlight",
  "horizontal-align-end",
  "horizontal-align-middle",
  "horizontal-align-start",
  "info-circle",
  "italic",
  "leading",
  "link",
  "list",
  "lock",
  "manual",
  "menu",
  "minus",
  "mixed",
  "pack",
  "plus",
  "question-mark-circle",
  "question-mark",
  "redo",
  "reset-zoom",
  "rotate-ccw",
  "rotate-cw",
  "send-backward",
  "send-to-back",
  "share-1",
  "size-extra-large",
  "size-large",
  "size-medium",
  "size-small",
  "spline-cubic",
  "spline-line",
  "stack-horizontal",
  "stack-vertical",
  "status-offline",
  "stretch-horizontal",
  "stretch-vertical",
  "strike",
  "text-align-center",
  "text-align-left",
  "text-align-right",
  "toggle-off",
  "toggle-on",
  "tool-arrow",
  "tool-eraser",
  "tool-frame",
  "tool-hand",
  "tool-highlight",
  "tool-laser",
  "tool-line",
  "tool-media",
  "tool-note",
  "tool-pencil",
  "tool-pointer",
  "tool-screenshot",
  "tool-text",
  "trash",
  "twitter",
  "underline",
  "undo",
  "ungroup",
  "unlock",
  "vertical-align-end",
  "vertical-align-middle",
  "vertical-align-start",
  "warning-triangle",
  "zoom-in",
  "zoom-out"
];
let defaultUiAssetUrls = {
  ...defaultEditorAssetUrls,
  icons: Object.fromEntries(
    iconTypes.map((name) => [name, `${getDefaultCdnBaseUrl()}/icons/icon/0_merged.svg#${name}`])
  ),
  translations: Object.fromEntries(
    LANGUAGES.map((lang) => [
      lang.locale,
      `${getDefaultCdnBaseUrl()}/translations/${lang.locale}.json`
    ])
  ),
  embedIcons: Object.fromEntries(
    DEFAULT_EMBED_DEFINITIONS.map((def) => [
      def.type,
      `${getDefaultCdnBaseUrl()}/embed-icons/${def.type}.png`
    ])
  )
};
function useDefaultUiAssetUrlsWithOverrides(overrides) {
  return reactExports.useMemo(() => {
    if (!overrides) return defaultUiAssetUrls;
    return {
      fonts: Object.assign({ ...defaultUiAssetUrls.fonts }, { ...overrides?.fonts }),
      icons: Object.assign({ ...defaultUiAssetUrls.icons }, { ...overrides?.icons }),
      embedIcons: Object.assign({ ...defaultUiAssetUrls.embedIcons }, { ...overrides?.embedIcons }),
      translations: Object.assign(
        { ...defaultUiAssetUrls.translations },
        { ...overrides?.translations }
      )
    };
  }, [overrides]);
}
const TldrawUiContextProvider = track(function TldrawUiContextProvider2({
  overrides,
  components,
  assetUrls,
  onUiEvent,
  forceMobile,
  mediaMimeTypes,
  children
}) {
  const editor = useMaybeEditor();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MimeTypeContext.Provider, { value: mediaMimeTypes, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiTooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AssetUrlsProvider, { assetUrls: useDefaultUiAssetUrlsWithOverrides(assetUrls), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiTranslationProvider,
    {
      overrides: useMergedTranslationOverrides(overrides),
      locale: editor?.user.getLocale() ?? defaultUserPreferences.locale,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiEventsProvider, { onEvent: onUiEvent, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToastsProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogsProvider, { context: "tla", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiA11yProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BreakPointProvider, { forceMobile, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiComponentsProvider, { overrides: components, children: /* @__PURE__ */ jsxRuntimeExports.jsx(InternalProviders, { overrides, children }) }) }) }) }) }) })
    }
  ) }) }) });
});
function InternalProviders({
  overrides,
  children
}) {
  const mergedOverrides = useMergedOverrides(overrides);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ActionsProvider, { overrides: mergedOverrides.actions, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToolsProvider, { overrides: mergedOverrides.tools, children }) });
}
function useEditorEvents() {
  const editor = useEditor();
  const { addToast } = useToasts();
  reactExports.useEffect(() => {
    function handleMaxShapes({ name, count: count2 }) {
      addToast({
        title: "Maximum shapes reached",
        description: `You've reached the maximum number of shapes allowed on ${name} (${count2}). Please delete some shapes or move to a different page to continue.`,
        severity: "warning"
      });
    }
    editor.addListener("max-shapes", handleMaxShapes);
    return () => {
      editor.removeListener("max-shapes", handleMaxShapes);
    };
  }, [editor, addToast]);
}
const TldrawUi = React.memo(function TldrawUi2({
  renderDebugMenuItems,
  children,
  hideUi,
  components,
  ...rest
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiContextProvider, { ...rest, components, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiInner, { hideUi, renderDebugMenuItems, children }) });
});
const TldrawUiInner = React.memo(function TldrawUiInner2({
  children,
  hideUi,
  ...rest
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    children,
    hideUi ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiContent, { ...rest })
  ] });
});
const TldrawUiContent = React.memo(function TldrawUI() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const isFocusMode = useValue("focus", () => editor.getInstanceState().isFocusMode, [editor]);
  const isDebugMode = useValue("debug", () => editor.getInstanceState().isDebugMode, [editor]);
  const {
    SharePanel,
    TopPanel,
    MenuPanel: MenuPanel2,
    StylePanel,
    Toolbar: Toolbar2,
    HelpMenu,
    NavigationPanel,
    HelperButtons,
    DebugPanel,
    Toasts,
    Dialogs,
    A11y
  } = useTldrawUiComponents();
  useKeyboardShortcuts();
  useNativeClipboardEvents();
  useEditorEvents();
  const rIsEditingAnything = reactExports.useRef(false);
  const rHidingTimeout = reactExports.useRef(-1);
  const [hideToolbarWhileEditing, setHideToolbarWhileEditing] = reactExports.useState(false);
  useReactor(
    "update hide toolbar while delayed",
    () => {
      const isMobileEnvironment = tlenv.isIos || tlenv.isAndroid;
      if (!isMobileEnvironment) return;
      const editingShape = editor.getEditingShapeId();
      if (editingShape === null) {
        if (rIsEditingAnything.current) {
          rIsEditingAnything.current = false;
          clearTimeout(rHidingTimeout.current);
          if (tlenv.isAndroid) {
            rHidingTimeout.current = editor.timers.setTimeout(() => {
              setHideToolbarWhileEditing(false);
            }, 150);
          } else {
            setHideToolbarWhileEditing(false);
          }
        }
        return;
      }
      if (!rIsEditingAnything.current) {
        rIsEditingAnything.current = true;
        clearTimeout(rHidingTimeout.current);
        setHideToolbarWhileEditing(true);
      }
    },
    []
  );
  const { "toggle-focus-mode": toggleFocus } = useActions();
  const { breakpointsAbove, breakpointsBelow } = reactExports.useMemo(() => {
    const breakpointsAbove2 = [];
    const breakpointsBelow2 = [];
    for (let bp = 0; bp < PORTRAIT_BREAKPOINTS.length; bp++) {
      if (bp <= breakpoint) {
        breakpointsAbove2.push(bp);
      } else {
        breakpointsBelow2.push(bp);
      }
    }
    return { breakpointsAbove: breakpointsAbove2, breakpointsBelow: breakpointsBelow2 };
  }, [breakpoint]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classNames("tlui-layout", {
        "tlui-layout__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
      }),
      "data-iseditinganything": hideToolbarWhileEditing,
      "data-breakpoint": breakpoint,
      "data-breakpoints-above": breakpointsAbove.join(" "),
      "data-breakpoints-below": breakpointsBelow.join(" "),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SkipToMainContent, {}),
        isFocusMode ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-layout__top", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButton,
          {
            type: "icon",
            className: "tlui-focus-button",
            title: msg2("focus-mode.toggle-focus-mode"),
            onClick: () => toggleFocus.onSelect("menu"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "dot" })
          }
        ) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-layout__top", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-layout__top__left", children: [
              MenuPanel2 && /* @__PURE__ */ jsxRuntimeExports.jsx(MenuPanel2, {}),
              HelperButtons && /* @__PURE__ */ jsxRuntimeExports.jsx(HelperButtons, {})
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-layout__top__center", children: TopPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(TopPanel, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-layout__top__right", children: [
              SharePanel && /* @__PURE__ */ jsxRuntimeExports.jsx(SharePanel, {}),
              StylePanel && breakpoint >= PORTRAIT_BREAKPOINT.TABLET_SM && !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanel, {})
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-layout__bottom", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-layout__bottom__main", children: [
              NavigationPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationPanel, {}),
              Toolbar2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar2, {}),
              HelpMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(HelpMenu, {})
            ] }),
            isDebugMode && DebugPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(DebugPanel, {}),
            A11y && /* @__PURE__ */ jsxRuntimeExports.jsx(A11y, {})
          ] })
        ] }),
        Toasts && /* @__PURE__ */ jsxRuntimeExports.jsx(Toasts, {}),
        Dialogs && /* @__PURE__ */ jsxRuntimeExports.jsx(Dialogs, {})
      ]
    }
  );
});
function TldrawUiInFrontOfTheCanvas() {
  const { RichTextToolbar, ImageToolbar, VideoToolbar, CursorChatBubble: CursorChatBubble3, FollowingIndicator } = useTldrawUiComponents();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    RichTextToolbar && /* @__PURE__ */ jsxRuntimeExports.jsx(RichTextToolbar, {}),
    ImageToolbar && /* @__PURE__ */ jsxRuntimeExports.jsx(ImageToolbar, {}),
    VideoToolbar && /* @__PURE__ */ jsxRuntimeExports.jsx(VideoToolbar, {}),
    FollowingIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx(FollowingIndicator, {}),
    CursorChatBubble3 && /* @__PURE__ */ jsxRuntimeExports.jsx(CursorChatBubble3, {})
  ] });
}
const LoadingScreen = () => {
  const { Spinner: Spinner2 } = useEditorComponents();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingScreen$1, { children: Spinner2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner2, {}) : null });
};
const allDefaultTools = [...defaultTools, ...defaultShapeTools];
function Tldraw(props) {
  const {
    children,
    maxImageDimension,
    maxAssetSize,
    acceptedImageMimeTypes,
    acceptedVideoMimeTypes,
    onMount,
    components = {},
    shapeUtils = [],
    bindingUtils = [],
    tools = [],
    embeds,
    textOptions,
    ...rest
  } = props;
  const _components = useShallowObjectIdentity(components);
  const CustomInFrontOfTheCanvas = components?.InFrontOfTheCanvas;
  const InFrontOfTheCanvas = reactExports.useMemo(() => {
    if (rest.hideUi) return CustomInFrontOfTheCanvas ?? null;
    if (!CustomInFrontOfTheCanvas) return TldrawUiInFrontOfTheCanvas;
    return () => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiInFrontOfTheCanvas, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CustomInFrontOfTheCanvas, {})
    ] });
  }, [rest.hideUi, CustomInFrontOfTheCanvas]);
  const componentsWithDefault = reactExports.useMemo(
    () => ({
      Scribble: TldrawScribble,
      ShapeIndicators: TldrawShapeIndicators,
      CollaboratorScribble: TldrawScribble,
      SelectionForeground: TldrawSelectionForeground,
      Handles: TldrawHandles,
      Overlays: TldrawOverlays,
      Spinner,
      LoadingScreen,
      ..._components,
      InFrontOfTheCanvas
    }),
    [_components, InFrontOfTheCanvas]
  );
  const _shapeUtils = useShallowArrayIdentity(shapeUtils);
  const shapeUtilsWithDefaults = reactExports.useMemo(
    () => mergeArraysAndReplaceDefaults("type", _shapeUtils, defaultShapeUtils),
    [_shapeUtils]
  );
  const _bindingUtils = useShallowArrayIdentity(bindingUtils);
  const bindingUtilsWithDefaults = reactExports.useMemo(
    () => mergeArraysAndReplaceDefaults("type", _bindingUtils, defaultBindingUtils),
    [_bindingUtils]
  );
  const _tools = useShallowArrayIdentity(tools);
  const toolsWithDefaults = reactExports.useMemo(
    () => mergeArraysAndReplaceDefaults("id", _tools, allDefaultTools),
    [_tools]
  );
  const _imageMimeTypes = useShallowArrayIdentity(
    acceptedImageMimeTypes ?? DEFAULT_SUPPORTED_IMAGE_TYPES
  );
  const _videoMimeTypes = useShallowArrayIdentity(
    acceptedVideoMimeTypes ?? DEFAULT_SUPPORT_VIDEO_TYPES
  );
  const textOptionsWithDefaults = reactExports.useMemo(() => {
    return {
      addFontsFromNode: defaultAddFontsFromNode,
      ...textOptions,
      tipTapConfig: {
        extensions: tipTapDefaultExtensions,
        ...textOptions?.tipTapConfig
      }
    };
  }, [textOptions]);
  const mediaMimeTypes = reactExports.useMemo(
    () => [..._imageMimeTypes, ..._videoMimeTypes],
    [_imageMimeTypes, _videoMimeTypes]
  );
  const assets = useDefaultEditorAssetsWithOverrides(rest.assetUrls);
  const embedShapeUtil = shapeUtilsWithDefaults.find((util) => util.type === "embed");
  if (embedShapeUtil && embeds) {
    EmbedShapeUtil.setEmbedDefinitions(embeds);
  }
  return (
    // We provide an extra higher layer of asset+translations providers here so that
    // loading UI (which is rendered outside of TldrawUi) may be translated.
    // Ideally we would refactor to hoist all the UI context providers we can up here. Maybe later.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AssetUrlsProvider,
      { assetUrls: useDefaultUiAssetUrlsWithOverrides(rest.assetUrls), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiTranslationProvider,
        {
          overrides: useMergedTranslationOverrides(rest.overrides),
          locale: rest.user?.userPreferences.get().locale ?? defaultUserPreferences.locale,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            TldrawEditor,
            {
              initialState: "select",
              ...rest,
              components: componentsWithDefault,
              shapeUtils: shapeUtilsWithDefaults,
              bindingUtils: bindingUtilsWithDefaults,
              tools: toolsWithDefaults,
              textOptions: textOptionsWithDefaults,
              assetUrls: assets,
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUi, { ...rest, components: componentsWithDefault, mediaMimeTypes, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  InsideOfEditorAndUiContext,
                  {
                    maxImageDimension,
                    maxAssetSize,
                    acceptedImageMimeTypes: _imageMimeTypes,
                    acceptedVideoMimeTypes: _videoMimeTypes,
                    onMount
                  }
                ),
                children
              ] })
            }
          )
        }
      ) }
    )
  );
}
function InsideOfEditorAndUiContext({
  maxImageDimension,
  maxAssetSize,
  acceptedImageMimeTypes,
  acceptedVideoMimeTypes,
  onMount
}) {
  const editor = useEditor();
  const toasts = useToasts();
  const msg2 = useTranslation();
  const trackEvent = useUiEvents();
  useOnMount(() => {
    const unsubs = [];
    unsubs.push(registerDefaultSideEffects(editor));
    editor.fonts.requestFonts(allDefaultFontFaces);
    editor.once("edit", () => trackEvent("edit", { source: "unknown" }));
    registerDefaultExternalContentHandlers(editor, {
      maxImageDimension,
      maxAssetSize,
      acceptedImageMimeTypes,
      acceptedVideoMimeTypes,
      toasts,
      msg: msg2
    });
    unsubs.push(editor.store.props.onMount(editor));
    unsubs.push(onMount?.(editor));
    return () => {
      unsubs.forEach((fn) => fn?.());
    };
  });
  const { Canvas } = useEditorComponents();
  const { ContextMenu: ContextMenu2 } = useTldrawUiComponents();
  if (ContextMenu2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ContextMenu2, {});
  }
  if (Canvas) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Canvas, {});
  }
  return null;
}
const defaultTextOptions = {
  tipTapConfig: {
    extensions: tipTapDefaultExtensions
  },
  addFontsFromNode: defaultAddFontsFromNode
};
reactExports.memo(function TldrawImage2(props) {
  const [url, setUrl] = reactExports.useState(null);
  const [container, setContainer] = reactExports.useState(null);
  const _shapeUtils = useShallowArrayIdentity(props.shapeUtils ?? []);
  const shapeUtilsWithDefaults = reactExports.useMemo(
    () => mergeArraysAndReplaceDefaults("type", _shapeUtils, defaultShapeUtils),
    [_shapeUtils]
  );
  const _bindingUtils = useShallowArrayIdentity(props.bindingUtils ?? []);
  const bindingUtilsWithDefaults = reactExports.useMemo(
    () => mergeArraysAndReplaceDefaults("type", _bindingUtils, defaultBindingUtils),
    [_bindingUtils]
  );
  const store = useTLStore({ snapshot: props.snapshot, shapeUtils: shapeUtilsWithDefaults });
  const {
    pageId,
    bounds,
    scale,
    pixelRatio,
    background,
    padding,
    darkMode,
    preserveAspectRatio,
    format: format2 = "svg",
    licenseKey,
    assetUrls,
    textOptions = defaultTextOptions
  } = props;
  const assetUrlsWithOverrides = useDefaultEditorAssetsWithOverrides(assetUrls);
  reactExports.useLayoutEffect(() => {
    if (!container) return;
    if (!store) return;
    let isCancelled = false;
    const tempElm = document.createElement("div");
    container.appendChild(tempElm);
    container.classList.add("tl-container", "tl-theme__light");
    const editor = new Editor$1({
      store,
      shapeUtils: shapeUtilsWithDefaults,
      bindingUtils: bindingUtilsWithDefaults,
      tools: [],
      getContainer: () => tempElm,
      licenseKey,
      fontAssetUrls: assetUrlsWithOverrides.fonts,
      textOptions
    });
    if (pageId) editor.setCurrentPage(pageId);
    const shapeIds = editor.getCurrentPageShapeIds();
    async function setSvg() {
      await editor.fonts.loadRequiredFontsForCurrentPage(editor.options.maxFontsToLoadBeforeRender);
      const imageResult = await editor.toImage([...shapeIds], {
        bounds,
        scale,
        background,
        padding,
        darkMode,
        preserveAspectRatio,
        format: format2
      });
      if (!imageResult || isCancelled) return;
      const url2 = URL.createObjectURL(imageResult.blob);
      setUrl(url2);
      editor.dispose();
    }
    setSvg();
    return () => {
      isCancelled = true;
    };
  }, [
    format2,
    container,
    store,
    shapeUtilsWithDefaults,
    bindingUtilsWithDefaults,
    pageId,
    bounds,
    scale,
    background,
    padding,
    darkMode,
    preserveAspectRatio,
    licenseKey,
    pixelRatio,
    assetUrlsWithOverrides,
    textOptions
  ]);
  reactExports.useEffect(() => {
    return () => {
      if (url) URL.revokeObjectURL(url);
    };
  }, [url]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: setContainer, style: { position: "relative", width: "100%", height: "100%" }, children: url && /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: url,
      referrerPolicy: "strict-origin-when-cross-origin",
      style: { width: "100%", height: "100%" }
    }
  ) });
});
reactExports.memo(function DefaultHelpMenu2({ children }) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultHelpMenuContent, {});
  if (breakpoint < PORTRAIT_BREAKPOINT.MOBILE) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: "tlui-help-menu", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDropdownMenuRoot, { id: "help menu", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "help", title: msg2("help-menu.title"), "data-testid": "help-menu.button", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "question-mark", small: true }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuContent, { side: "top", align: "end", alignOffset: 0, sideOffset: 8, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "menu", sourceId: "help-menu", children: content }) })
  ] }) });
});
const schemaV1 = object({
  schemaVersion: literal(1),
  storeVersion: positiveInteger,
  recordVersions: dict(
    string,
    object({
      version: positiveInteger,
      subTypeVersions: dict(string, positiveInteger).optional(),
      subTypeKey: string.optional()
    })
  )
});
const schemaV2 = object({
  schemaVersion: literal(2),
  sequences: dict(string, positiveInteger)
});
object({
  tldrawFileFormatVersion: nonZeroInteger,
  schema: numberUnion("schemaVersion", {
    1: schemaV1,
    2: schemaV2
  }),
  records: arrayOf(
    object({
      id: string,
      typeName: string
    }).allowUnknownProperties()
  )
});
registerTldrawLibraryVersion(
  "tldraw",
  "4.2.0",
  "esm"
);
export {
  ReactDOM$1 as R,
  Tldraw as T,
  __awaiter as _,
  getDefaultExportFromCjs as a,
  __rest as b,
  React as c,
  getAugmentedNamespace as g,
  jsxRuntimeExports as j,
  reactExports as r,
  tslib_es6$1 as t,
  useEditor as u
};
